// Lightweight jsPDF-compatible implementation used for offline testing
// and basic PDF generation. This is **not** the full jsPDF build but
// provides the minimal subset of the API required by the project.

(function (g) {
  class SimplePDF {
    constructor() {
      this._pageWidth = 612;
      this._pageHeight = 792;
      this._fontSize = 12;
      this._fontName = 'helvetica';
      this.pages = [[]];
      this.currentPage = 0;
      this.internal = {
        pageSize: {
          getWidth: () => this._pageWidth,
          getHeight: () => this._pageHeight,
        },
      };
    }

    _currentLines() {
      return this.pages[this.currentPage];
    }

    setFillColor() {}
    rect() {}
    setDrawColor() {}
    line() {}
    setTextColor() {}
    setFont(fontName = 'helvetica') {
      this._fontName = fontName;
    }
    setFontSize(size = 12) {
      const parsed = Number(size);
      if (!Number.isNaN(parsed) && parsed > 0) {
        this._fontSize = parsed;
      }
    }
    text(content) {
      const value = Array.isArray(content)
        ? content.map((line) => String(line ?? '')).join('\n')
        : String(content ?? '');
      this._currentLines().push(value);
    }
    addPage() {
      this.pages.push([]);
      this.currentPage = this.pages.length - 1;
    }
    splitTextToSize(text, maxWidth) {
      const raw = String(text ?? '');
      const width = Number(maxWidth) || 0;
      const existingLines = raw.replace(/\r\n?/g, '\n').split('\n');
      if (width <= 0) {
        return existingLines;
      }
      const approxCharWidth = Math.max(this._fontSize * 0.5, 1);
      const maxChars = Math.max(Math.floor(width / approxCharWidth), 1);
      const result = [];

      existingLines.forEach((line) => {
        if (!line.length) {
          result.push('');
          return;
        }
        const words = line.split(/\s+/);
        let current = '';
        words.forEach((word) => {
          if (!word.length) {
            return;
          }
          const candidate = current.length ? `${current} ${word}` : word;
          if (candidate.length <= maxChars) {
            current = candidate;
            return;
          }
          if (current.length) {
            result.push(current);
            current = '';
          }
          if (word.length <= maxChars) {
            current = word;
            return;
          }
          for (let i = 0; i < word.length; i += maxChars) {
            const slice = word.slice(i, i + maxChars);
            if (slice.length === maxChars) {
              result.push(slice);
            } else {
              current = slice;
            }
          }
        });
        if (current.length) {
          result.push(current);
        }
      });

      return result.length ? result : [''];
    }

    // Very small PDF generator â€“ supports text output only
    async save(filename = 'document.pdf') {
      const esc = (s) =>
        (s || '').replace(/([\\()\n\r])/g, (r) => ({
          '\\': '\\\\',
          '(': '\\(',
          ')': '\\)',
          '\n': '\\n',
          '\r': '',
        }[r]));

      const header = '%PDF-1.1\n';
      const objects = [];
      const allLines = this.pages
        .map((page) => page.join('\n'))
        .join('\n\n---- Page Break ----\n\n');
      const content = `BT /F1 ${Math.round(this._fontSize)} Tf 72 720 Td (${esc(
        allLines
      )}) Tj ET`;
      const stream = `<< /Length ${content.length} >>\nstream\n${content}\nendstream`;
      objects.push(stream);
      objects.push('<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>');
      objects.push(
        `<< /Type /Page /Parent 2 0 R /MediaBox [0 0 ${this._pageWidth} ${this._pageHeight}] /Resources << /Font << /F1 2 0 R >> >> /Contents 1 0 R >>`
      );
      objects.push('<< /Type /Pages /Kids [3 0 R] /Count 1 >>');
      objects.push('<< /Type /Catalog /Pages 4 0 R >>');

      let body = header;
      const offsets = [0];
      objects.forEach((obj, i) => {
        offsets.push(body.length);
        body += `${i + 1} 0 obj\n${obj}\nendobj\n`;
      });
      const xref = body.length;
      body += `xref\n0 ${objects.length + 1}\n`;
      offsets.forEach((off) => {
        body += off.toString().padStart(10, '0') + ' 00000 n \n';
      });
      body += `trailer\n<< /Size ${objects.length + 1} /Root ${objects.length} 0 R >>\nstartxref\n${xref}\n%%EOF`;

      if (typeof document === 'undefined') {
        const fs = await import('node:fs');
        fs.writeFileSync(filename, body);
        return;
      }

      const blob = new Blob([body], { type: 'application/pdf' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }
  }

  g.jspdf = { jsPDF: SimplePDF };
})(typeof window !== 'undefined' ? window : globalThis);

