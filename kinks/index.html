<!DOCTYPE html>
<html lang="en">
<head>
  <!-- TK: passive listeners shim -->
  <script src="/js/tk_passive.js"></script>
  <!-- TK: early diagnostics -->
  <script src="/js/tk_diag.js"></script>
  <!-- TK: passive event shim -->
  <script src="/js/tk_passive_events.js"></script>
  <!-- TK: hard-block Google Fonts early -->
  <script src="/js/tk_block_fonts.js"></script>
  <!-- TK-LOG-GATE inline -->
  <script>
  (function(){
    try {
      // Opt-in debug: ?tkdebug=1 or localStorage.tkdebug="1"
      var sp = new URL(location.href).searchParams;
      var TK_DEBUG = (sp.get('tkdebug') === '1') || (localStorage.getItem('tkdebug') === '1');
      window.__tk_shouldLog = !!TK_DEBUG;

      var lastUS = 0, THROTTLE = 1200; // throttle UNSQUISH logs to ≤ ~1/s
      function gate(fn){
        return function(){ 
          try {
            for (var i=0;i<arguments.length;i++){
              var a = arguments[i];
              if (typeof a === 'string' && a.indexOf('[KINKS-UNSQUISH]') !== -1){
                if (!window.__tk_shouldLog) return;           // drop entirely unless debug
                var now = Date.now(); if (now - lastUS < THROTTLE) return; // throttle
                lastUS = now; 
                break;
              }
            }
          } catch(e){}
          return fn.apply(this, arguments);
        };
      }
      ['log','info','debug'].forEach(function(k){
        if (typeof console[k] === 'function') {
          var orig = console[k].bind(console);
          // Make hard to undo later
          Object.defineProperty(console, k, { configurable:false, enumerable:true, writable:false, value: gate(orig) });
        }
      });

      // Small badge when debug is ON, so you know logs are flowing
      if (window.__tk_shouldLog) {
        var b = document.createElement('div');
        b.textContent = 'tkdebug=1 (UNSQUISH throttled)';
        b.style.cssText='position:fixed;bottom:10px;left:10px;z-index:2147483647;background:#0b0;color:#000;padding:4px 8px;border-radius:6px;font:12px system-ui';
        (document.readyState==='loading')
          ? document.addEventListener('DOMContentLoaded', function(){ document.body.appendChild(b); setTimeout(()=>b.remove(),1500); }, {once:true})
          : (document.body.appendChild(b), setTimeout(()=>b.remove(),1500));
      }
    } catch(e){}
  })();
  </script>

  <!-- TK: log gate (filters/throttles [KINKS-UNSQUISH]) -->
  <script src="/js/tk_log_gate.js"></script>
  <!-- TK: grouped→flat JSON shim -->
  <script src="/js/kinks_fetch_compat.js"></script>
  <script>
    /*! TK watchdog: fail-open + SW reset flag */
    (function(){
      try{
        if (location.search.includes("tkreset=1")) {
          if ("caches" in window) caches.keys().then(ks=>Promise.all(ks.map(k=>caches.delete(k))).then(()=>{}));
          navigator.serviceWorker&&navigator.serviceWorker.getRegistration&&navigator.serviceWorker.getRegistration().then(r=>r&&r.unregister());
        }
      }catch(e){}
      var fired=false;
      function unstick(){ if(fired) return; fired=true;
        try{
          var d=document, $=d.querySelector.bind(d), $$=(s)=>Array.from(d.querySelectorAll(s));
          d.querySelectorAll('.spinner,[aria-busy=true],[data-loading]').forEach(n=>n.remove());
          var start=$('#start,#startSurvey,#startSurveyBtn'); if(start) start.removeAttribute('disabled');
          var box=d.createElement('div'); box.id='tk-watch'; box.style.cssText='position:fixed;top:10px;right:10px;z-index:2147483647;background:#111;color:#fff;border:1px solid #444;border-radius:8px;padding:8px;max-width:460px;font:12px system-ui';
          box.innerHTML='<b>Recovering…</b><div id=tkw style="opacity:.8;margin-top:4px">Checking /data/kinks.json…</div>'; d.body.appendChild(box);
          var tkw=box.querySelector('#tkw');
          fetch('/data/kinks.json?v='+Date.now(),{cache:'no-store'}).then(r=>r.text()).then(t=>{
            if(/^<!doctype html/i.test(t)||/<html[\s>]/i.test(t)){ if(tkw) tkw.textContent='Server sent HTML instead of JSON (rewrite). Start enabled; proceed.'; return; }
            try{
              var j=JSON.parse(t);
              var arr=[];
              if (Array.isArray(j)) arr=j;
              else if (j && Array.isArray(j.categories)) arr=j.categories;
              else if (j && Array.isArray(j.kinks)) arr=j.kinks;
              if(tkw) tkw.textContent='Data OK ('+arr.length+'). Start enabled; proceed.'
            }
            catch(e){ if(tkw) tkw.textContent='JSON invalid. Start enabled; proceed.' }
          }).catch(()=>{ if(tkw) tkw.textContent='Fetch failed. Start enabled; proceed.' });
        }catch(e){}
      }
      var t=setTimeout(unstick, 2500);
      window.addEventListener('load', function(){ clearTimeout(t); }, {once:true});
    })();
  </script>
  <!-- TK-HOTFIX START -->
  <base href="/" />
  <!-- TK-HOTFIX END -->
  <!-- TK-HOTFIX START -->
  <link rel="stylesheet" href="/css/style.css?v=1730846400000" id="tk-style-root"/>
  <link rel="stylesheet" href="/css/theme.css?v=1730846400000" id="tk-theme-root"/>
  <link rel="stylesheet" href="/css/kinksurvey_overrides.css">
  <!-- readable fallback so black text can't disappear on black bg -->
  <style id="tk-fallback">
    :root{ --tk-fg:#e6f2ff; --tk-accent:#00e6ff; }
    body{ background:#000; color:var(--fg, var(--tk-fg)); }
    .themed-title,.category-panel,.themed-text{ color:var(--fg, var(--tk-fg)); }
    .themed-button{ background:var(--accent, var(--tk-accent)); color:#000; }
  </style>
  <script type="module" id="tk-theme-module" src="/js/theme.js?v=1730846400000"></script>
  <!-- TK-HOTFIX END -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Talk Kink</title>
  <!-- TK: system-font fallback (loads after main CSS) -->
  <link rel="stylesheet" href="/css/font-failopen.css">
  <link rel="stylesheet" href="/css/touch-passive.css">
  <!-- TK: force-visible fallback -->
  <link rel="stylesheet" href="/css/tk_force_visible.css">
  <link rel="stylesheet" href="/css/tk_diag_fallback.css">
  <link rel="stylesheet" href="/css/tk_unblock_clicks.css">
  <link rel="stylesheet" href="/css/tk_panel_passthrough.css">
  <!-- TK: scroll/touch perf tweaks -->
  <link rel="stylesheet" href="/css/perf-tweaks.css">
</head>
<body class="theme-dark has-category-panel">
  <script id="kinks-embedded-data" type="application/json">[]</script>
  <script src="/kinks/embedded-kinks.js" data-fallback="kinks"></script>
  <div class="landing-wrapper">
    <h1 class="themed-title">Talk Kink</h1>
    <select id="themeSelector">
      <option value="dark">Dark</option>
      <option value="lipstick">Lipstick</option>
      <option value="forest">Forest</option>
    </select>
<button id="startSurvey" data-legacy-id="startSurveyBtn" data-tk-start class="themed-button start-survey-btn" disabled>Start Survey</button>

    <div id="warning" class="warning"></div>
  </div>
  <div class="tk-toolbar" id="tkToolbar">
    <button class="tk-btn tk-toolbar-btn primary" id="tkOpenDrawer" aria-haspopup="dialog" aria-controls="tkCategoryDrawer" aria-expanded="false">☰ Categories</button>
    <span class="tk-chip" id="tkSelChip">0 selected</span>
  </div>
  <div id="tkDrawerBackdrop" tabindex="-1" aria-hidden="true"></div>
  <aside id="tkCategoryDrawer" role="dialog" aria-modal="true" aria-label="Select categories" aria-hidden="true">
    <div class="tk-drawer-header">
      <div class="tk-drawer-title">Select categories</div>
      <div class="tk-drawer-actions">
        <span class="tk-chip" id="tkCount">0 selected / 0 total</span>
        <button class="tk-btn tk-toolbar-btn" id="tkCloseDrawer" title="Close">✕</button>
      </div>
    </div>
    <div class="tk-drawer-body">
      <div id="tkDrawerContent"></div>
    </div>
  </aside>
  <button id="panelToggle" class="panel-toggle" aria-label="Toggle category panel" aria-controls="categorySurveyPanel" aria-expanded="true">☰</button>

  <!-- Category selection panel -->
  <div id="categorySurveyPanel" class="category-panel open" role="region" aria-label="Category selection">
    <h2>Select the categories you want to include:</h2>
    <div class="category-buttons top-buttons">
      <button id="selectAll" class="themed-button category-button">Select All</button>
      <button id="deselectAll" class="themed-button category-button">Deselect All</button>
    </div>
    <div class="category-list" role="list">
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Appearance Play"><span>Appearance Play</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Behavioral Play"><span>Behavioral Play</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Body Fluids and Functions"><span>Body Fluids and Functions</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Body Modification"><span>Body Modification</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Body Part / Fetish Play"><span>Body Part / Fetish Play</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Body Part Torture"><span>Body Part Torture</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Bondage and Suspension"><span>Bondage and Suspension</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Breath Play"><span>Breath Play</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Chastity Devices"><span>Chastity Devices</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Communication"><span>Communication</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Cosplay &amp; Identity Play"><span>Cosplay &amp; Identity Play</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Gender Play &amp; Transformation"><span>Gender Play &amp; Transformation</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Headspace &amp; Regression"><span>Headspace &amp; Regression</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="High-Intensity Kinks (SSC-Aware)"><span>High-Intensity Kinks (SSC-Aware)</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Impact Play"><span>Impact Play</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Medical Play"><span>Medical Play</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Mindfuck &amp; Manipulation"><span>Mindfuck &amp; Manipulation</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Mouth Play"><span>Mouth Play</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Orgasm Control &amp; Sexual Manipulation"><span>Orgasm Control &amp; Sexual Manipulation</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Other"><span>Other</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Performance &amp; Internal Struggle"><span>Performance &amp; Internal Struggle</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Pet Play"><span>Pet Play</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Primal &amp; Bratting"><span>Primal &amp; Bratting</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Protocol and Ritual"><span>Protocol and Ritual</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Psychological Primal / Prey"><span>Psychological Primal / Prey</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Relationship Preferences"><span>Relationship Preferences</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Roleplaying"><span>Roleplaying</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Sensation Play"><span>Sensation Play</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Service and Restrictive Behaviour"><span>Service and Restrictive Behaviour</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Sexual Activity"><span>Sexual Activity</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Shibari &amp; Rope Bondage"><span>Shibari &amp; Rope Bondage</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Virtual &amp; Long-Distance Play"><span>Virtual &amp; Long-Distance Play</span></label>
      <label role="listitem"><input class="category-checkbox" type="checkbox" name="category" value="Voyeurism/Exhibitionism"><span>Voyeurism/Exhibitionism</span></label>
    </div>
  </div>

  <!-- Progress and Survey Display -->
  <div id="progressBanner" class="progress-container" style="display:none;">
    <div class="progress-label" id="progressLabel"></div>
    <div class="progress-bar">
      <div class="progress-fill" id="progressFill"></div>
    </div>
    <button id="trackCategoryBtn" class="themed-button category-button">
      Categories Left: <span id="categoriesLeft">0</span>
    </button>
  </div>

  <div id="surveyContainer" style="display:none;">
    <h2 id="categoryTitle"></h2>
    <p id="categoryDescription"></p>
    <div id="kinkList"></div>
    <div class="nav-buttons">
      <button id="skipCategoryBtn" class="themed-button">Skip Category</button>
      <button id="nextCategoryBtn" class="themed-button">Next Category</button>
    </div>
  </div>

  <div
    id="finalScreen"
    class="final-screen"
    style="display:none; align-items:center; justify-content:center; flex-direction:column; gap:1.5rem; text-align:center; margin:40px auto 0;"
  >
    <h2>Survey complete!</h2>
    <p>
      You've reviewed every selected category. Download your answers to compare with a partner or continue to the
      data tools for your next steps.
    </p>
    <div id="exportControls" style="display:none; gap:1rem; justify-content:center; flex-wrap:wrap;">
      <button id="exportAndCompareBtn" class="themed-button">Download & Compare</button>
    </div>
  </div>

  <!-- Panel Container (still hidden until needed) -->
  <div id="panelContainer" class="panel-container" style="display:none;"></div>

  <script>
  (function(){
    const $ = (sel, root = document) => root.querySelector(sel);
    const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));

    const body = document.body;
    const openBtn = $('#tkOpenDrawer');
    const closeBtn = $('#tkCloseDrawer');
    const backdrop = $('#tkDrawerBackdrop');
    const drawer = $('#tkCategoryDrawer');
    const content = $('#tkDrawerContent');
    const chip = $('#tkSelChip');
    const countBadge = $('#tkCount');

    const applyCounts = (selected, total) => {
      if (chip) chip.textContent = `${selected} selected`;
      if (countBadge) countBadge.textContent = `${selected} selected / ${total} total`;
    };

    const allCheckboxes = () => {
      const nodes = $$('input[type="checkbox"]', content);
      return nodes.filter(cb =>
        cb.classList.contains('category-checkbox') ||
        cb.name === 'category' ||
        cb.closest('.category-list')
      );
    };

    const refreshCounts = () => {
      const boxes = allCheckboxes();
      const total = boxes.length;
      const selected = boxes.filter(cb => cb.checked).length;
      applyCounts(selected, total);
    };

    window.tkUpdateCategoryChip = applyCounts;

    const focusableSelector = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';

    function openDrawer(){
      body.classList.add('tk-drawer-open');
      openBtn?.setAttribute('aria-expanded','true');
      drawer?.setAttribute('aria-hidden','false');
      backdrop?.setAttribute('aria-hidden','false');
      setTimeout(() => {
        const focusTarget = drawer?.querySelector(focusableSelector) || drawer;
        focusTarget?.focus?.();
      }, 10);
      refreshCounts();
    }

    function closeDrawer(){
      body.classList.remove('tk-drawer-open');
      openBtn?.setAttribute('aria-expanded','false');
      drawer?.setAttribute('aria-hidden','true');
      backdrop?.setAttribute('aria-hidden','true');
      openBtn?.focus?.();
    }

    const toggleDrawer = () => {
      if (body.classList.contains('tk-drawer-open')){
        closeDrawer();
      } else {
        openDrawer();
      }
    };

    openBtn?.addEventListener('click', toggleDrawer);
    closeBtn?.addEventListener('click', closeDrawer);
    backdrop?.addEventListener('click', closeDrawer);
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && body.classList.contains('tk-drawer-open')){
        closeDrawer();
      }
    });

    const changeHandler = (e) => {
      if (e.target && e.target.matches('input[type="checkbox"]')){
        refreshCounts();
      }
    };
    content?.addEventListener('change', changeHandler);

    const observer = new MutationObserver(() => refreshCounts());
    if (content){
      observer.observe(content, {childList:true, subtree:true, attributes:true, attributeFilter:['checked']});
    }

    const findCategoryRoot = () =>
      document.getElementById('categorySurveyPanel')
      || $('.category-panel')
      || $('.category-list')?.closest('div')
      || null;

    function moveCategoryListOnce(){
      const root = findCategoryRoot();
      if (!root) return false;
      const list = root.querySelector('.category-list');
      if (!list) return false;
      const catbar = root.querySelector('.tk-catbar');
      if (content && catbar && !content.contains(catbar)) {
        content.appendChild(catbar);
      }
      if (content && !content.contains(list)) {
        content.appendChild(list);
      }
      if (root !== list){
        root.classList.add('tk-original-panel-hidden');
      }
      refreshCounts();
      return true;
    }

    function ready(){
      if (!moveCategoryListOnce()){
        let tries = 0;
        const t = setInterval(() => {
          if (moveCategoryListOnce() || ++tries > 25){
            clearInterval(t);
          }
        }, 150);
      }
    }

    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', ready, {once:true});
    } else {
      ready();
    }

    window.tkCategoriesDrawer = {
      open: openDrawer,
      close: closeDrawer,
      refresh: refreshCounts
    };
  })();
  </script>

  <!-- Theme & Survey Logic -->
  <script type="module">
    const getThemeModule = async () => {
      try {
        return await import('/js/theme.js?v=1730846400000');
      } catch (err) {
        console.warn('[survey] Failed to load theme module', err);
        return {};
      }
    };

    const { initTheme = () => {}, applyThemeColors = () => {} } = await getThemeModule();

    initTheme();
    window.applyThemeColors = applyThemeColors;

    const onReady = () => {
      const startButton = document.getElementById('startSurvey') || document.getElementById('startSurveyBtn');
      const warningEl = document.getElementById('warning');
      const diagnosticsEl = document.getElementById('kinksDiagnostics');
      const panelToggleBtn = document.getElementById('panelToggle');
      const getDrawerApi = () => window.tkCategoriesDrawer;
      const categoriesLeftEl = document.getElementById('categoriesLeft');

      const getCheckboxes = () => Array.from(document.querySelectorAll('.category-checkbox'))
        .filter(cb => cb instanceof HTMLInputElement);

      const getSelectedCategories = () => getCheckboxes()
        .filter(cb => cb.checked)
        .map(cb => cb.value)
        .filter(Boolean)
        .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));

      const showWarning = (message = '') => {
        if (warningEl) warningEl.textContent = message;
      };

      const updateStartButtonState = () => {
        if (startButton) {
          startButton.disabled = getSelectedCategories().length === 0;
        }
      };

      const updateCategoriesCounter = () => {
        if (categoriesLeftEl) {
          categoriesLeftEl.textContent = String(getSelectedCategories().length || 0);
        }
      };

      const collapsePanel = () => {
        const drawer = getDrawerApi();
        drawer?.close?.();
        if (panelToggleBtn) {
          panelToggleBtn.setAttribute('aria-expanded', 'false');
        }
      };

      const togglePanel = () => {
        const drawer = getDrawerApi();
        if (!drawer) return;
        const isOpen = document.body.classList.contains('tk-drawer-open');
        if (isOpen) {
          drawer.close?.();
          panelToggleBtn?.setAttribute('aria-expanded', 'false');
        } else {
          drawer.open?.();
          panelToggleBtn?.setAttribute('aria-expanded', 'true');
        }
      };

      const persistSelection = (values) => {
        try {
          localStorage.setItem('selectedKinks', JSON.stringify(values));
        } catch (err) {
          console.warn('[survey] Failed to persist selection', err);
        }
      };

      const bindCheckboxes = () => {
        getCheckboxes().forEach(cb => {
          cb.addEventListener('change', () => {
            showWarning('');
            updateStartButtonState();
            updateCategoriesCounter();
            getDrawerApi()?.refresh?.();
          });
        });
      };

      const SURVEY_ROUTE = '/kinksurvey/';

      const startSurvey = (event) => {
        event?.preventDefault?.();
        const selected = getSelectedCategories();
        if (!selected.length) {
          showWarning('Please select at least one category.');
          return;
        }

        showWarning('');
        persistSelection(selected);
        try {
          sessionStorage.setItem('tkSelectedCategories', JSON.stringify(selected));
        } catch (err) {
          console.warn('[survey] Failed to persist session selection', err);
        }
        collapsePanel();
        window.location.assign(SURVEY_ROUTE);
      };

      if (startButton) {
        startButton.addEventListener('click', startSurvey);
      }

      if (panelToggleBtn) {
        panelToggleBtn.addEventListener('click', togglePanel);
      }

      const selectAllBtn = document.getElementById('selectAll');
      if (selectAllBtn) {
        selectAllBtn.addEventListener('click', () => {
          getCheckboxes().forEach(cb => {
            cb.checked = true;
          });
          showWarning('');
          updateStartButtonState();
          updateCategoriesCounter();
          getDrawerApi()?.refresh?.();
        });
      }

      const deselectAllBtn = document.getElementById('deselectAll');
      if (deselectAllBtn) {
        deselectAllBtn.addEventListener('click', () => {
          getCheckboxes().forEach(cb => {
            cb.checked = false;
          });
          showWarning('');
          updateStartButtonState();
          updateCategoriesCounter();
          getDrawerApi()?.refresh?.();
        });
      }

      window.selectAllCategories = () => {
        getCheckboxes().forEach(cb => {
          cb.checked = true;
        });
        showWarning('');
        updateStartButtonState();
        updateCategoriesCounter();
        getDrawerApi()?.refresh?.();
      };

      window.deselectAllCategories = () => {
        getCheckboxes().forEach(cb => {
          cb.checked = false;
        });
        showWarning('');
        updateStartButtonState();
        updateCategoriesCounter();
        getDrawerApi()?.refresh?.();
      };

      bindCheckboxes();
      updateStartButtonState();
      updateCategoriesCounter();
      getDrawerApi()?.refresh?.();
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', onReady, { once: true });
    } else {
      onReady();
    }
  </script>

<!--
 TALK KINKS — FIX "MISSING CATEGORIES" ON /kinks/
 Copy/paste this whole block near the end of /kinks/index.html (right before </body>).

 STEPS (Codex todo)
 1) Ensure your data file exists at one of:
      /data/kinks.json   (preferred)
      /kinks.json
    If it’s elsewhere, add its URL to DATA_URLS below.

 2) Add (or keep) a render container on the page:
      <div id="surveyRoot"></div>
    This script will create it if missing.

 3) Paste THIS block. It:
    • Fetches the JSON with fallbacks + “no-store” cache to avoid stale data
    • Accepts two shapes:
        A) [ { category, items:[ {id,label,type?} ] }, ... ]
        B) { "Category Name": [ {id,label,type?}, ... ], ... }
    • Skips only truly bad rows (no id/label), never aborts the whole render
    • Shows a Diagnostics panel with counts + any skipped rows
    • Kills CSS clipping that hides long lists

 4) Reload the page with DevTools → Network → “Disable cache” enabled, then click Start Survey.
    If it still looks short, read the diagnostics box and Console table for “skipped”.

 5) Optional: If your Start Survey button doesn’t render anything, ensure it binds:
      document.addEventListener('DOMContentLoaded', () => {
        document.querySelector('#startSurvey,#startSurveyBtn')?.addEventListener('click', KINKS_boot);
      });

 That’s all! If your dataset is valid, ALL categories/items will render or be reported as skipped with reasons.
 -->

<style>
  /* Prevent clipping: show full list */
  #surveyRoot, .kinks-root { max-height: none !important; overflow: visible !important; }

  /* Simple dark styling (tweak to your theme) */
  .kinks-diagnostics{
    font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    color: #e8ffff; background: #071317; border: 1px solid #00d5ff55;
    border-radius: 10px; padding: 10px 12px; margin: 18px auto 8px; max-width: 960px; white-space: pre-wrap;
  }
  .kinks-category{
    border: 1px solid #00e5ff33; border-radius: 12px; padding: 12px 14px;
    margin: 10px auto; max-width: 960px; color: #fff; background: #0a0f14;
  }
  .kinks-category h3{ margin:0 0 6px 0; font-weight:700; color:#7ef9ff; }
  .kinks-item{ display:flex; align-items:center; gap:10px; padding:6px 0; border-top:1px dashed #00e5ff22; }
  .kinks-item:first-of-type{ border-top:0; }
  .kinks-item label{ cursor:pointer; }
  .kinks-empty{ margin:20px auto; padding:16px 18px; max-width:960px; text-align:center; border:1px dashed #00e5ff55; border-radius:12px; color:#e8ffff; background:#071317; }
</style>

<div id="kinksDiagnostics" class="kinks-diagnostics" style="display:none"></div>
<div id="surveyRoot"></div>

<script>
(function(){
  const LOG = (...a)=>console.log("[KINKS]", ...a);

  /* --------------- 1) CONFIG: where to look for data --------------- */
  const DATA_URLS = [
    '/data/kinks.json',
    '/kinksurvey/data/kinks.json',
    '/kinksurvey/kinks.json',
    '/kinks.json',
    '/assets/kinks.json',
    './data/kinks.json',
    './kinks.json',
    './assets/kinks.json'
  ];

  /* --------------- 2) UTILITIES --------------- */
  const tidy = (s)=>String(s??"").replace(/\s+/g," ").trim();
  const normalizeName = (s)=>tidy(s).toLowerCase();
  const isObj = (x)=>x && typeof x==="object" && !Array.isArray(x);

  function ensureRoot(){
    let r = document.querySelector("#surveyRoot") || document.querySelector(".kinks-root");
    if (!r){ r = document.createElement("div"); r.id="surveyRoot"; document.body.prepend(r); }
    return r;
  }

  async function fetchJSONWithFallbacks(){
    const errors = [];
    for (const url of DATA_URLS){
      try{
        const res = await fetch(url, { cache:"no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();
        if (text.trim().startsWith("<")) throw new Error("Got HTML, not JSON");
        const json = JSON.parse(text);
        return { json, source:url, errors };
      }catch(e){ errors.push(`${url}: ${e.message}`); }
    }
    if (window.KINKS_BANK) {
      return { json: window.KINKS_BANK, source:"window.KINKS_BANK (fallback)", errors };
    }
    throw new Error("All fetch attempts failed:\n- " + errors.join("\n- "));
  }

  function normalizeBank(raw){
    if (raw && typeof raw === "object" && !Array.isArray(raw)) {
      if (Array.isArray(raw.categories)) return normalizeBank(raw.categories);
      if (Array.isArray(raw.kinks)) return normalizeBank(raw.kinks);
      if (raw.kinks && typeof raw.kinks === "object") {
        const flat = Object.entries(raw.kinks).map(([id, value]) => {
          if (value && typeof value === "object") {
            return { id: value.id ?? value.code ?? value.key ?? id, ...value };
          }
          return { id, label: String(value ?? id) };
        });
        return normalizeBank(flat);
      }
      if (Array.isArray(raw.data)) return normalizeBank(raw.data);
    }
    // Accepts:
    //  A) [ {category, items:[{id,label,type?}]} ]
    //  B) { \"Category\":[{id,label,type?}], ... }
    const out = [];
    const skipped = [];

    function pushCat(name, items){
      const cat = tidy(name);
      if (!cat){ skipped.push({where:"category-name-missing", item:name}); return; }
      const good = [];
      for (const it of (items||[])){
        const id = tidy(it?.id || it?.key || it?.name || "");
        const label = tidy(it?.label || it?.text || "");
        const type = tidy(it?.type || it?.input || "scale");
        if (!id || !label){ skipped.push({where:`item-missing-id-or-label:${cat}`, item:it}); continue; }
        good.push({ id, label, type });
      }
      if (good.length) out.push({ category: cat, items: good });
      else skipped.push({ where:`empty-category:${cat}`, item:items });
    }

    if (Array.isArray(raw)){
      const grouped = new Map();
      const order = [];
      const ensureBucket = (cat)=>{
        if (!grouped.has(cat)){
          grouped.set(cat, []);
          order.push(cat);
        }
        return grouped.get(cat);
      };

      for (const entry of raw){
        const items = entry?.items;
        if (Array.isArray(items)){
          pushCat(entry?.category ?? entry?.name, items);
          continue;
        }

        const catRaw = entry?.category ?? entry?.name;
        const cat = tidy(catRaw);
        const id = tidy(entry?.id || entry?.key || entry?.name || "");
        const label = tidy(entry?.label || entry?.text || "");
        const type = tidy(entry?.type || entry?.input || "scale");

        if (!cat){
          skipped.push({ where:"category-name-missing", item:entry });
          continue;
        }
        if (!id || !label){
          skipped.push({ where:`item-missing-id-or-label:${cat}`, item:entry });
          continue;
        }

        ensureBucket(cat).push({ id, label, type });
      }

      for (const cat of order){
        const items = grouped.get(cat) || [];
        if (!items.length) continue;
        const existing = out.find(c=>c.category === tidy(cat));
        if (existing){
          existing.items.push(...items);
        } else {
          pushCat(cat, items);
        }
      }
    } else if (isObj(raw)){
      Object.entries(raw).forEach(([k,v])=>{
        if (k === "labels" || k === "kinks" || k === "items") return;
        pushCat(k, v);
      });
    } else {
      throw new Error("Unsupported JSON shape. Use array-of-categories or object map.");
    }

    return { bank: out, skipped };
  }

  function renderSurvey(root, bank){
    root.innerHTML = "";
    if (!Array.isArray(bank) || bank.length === 0){
      const empty = document.createElement("div");
      empty.className = "kinks-empty";
      empty.textContent = "No categories are available for the current selection.";
      root.appendChild(empty);
      return;
    }
    for (const cat of bank){
      const sec = document.createElement("section");
      sec.className = "kinks-category";
      sec.innerHTML = `<h3>${escapeHTML(cat.category)}</h3>`;
      for (const item of cat.items){
        const row = document.createElement("div");
        row.className = "kinks-item";
        const inputId = `k_${item.id}`;
        row.appendChild(renderInput(inputId, item));
        const label = document.createElement("label");
        label.setAttribute("for", inputId);
        label.textContent = item.label;
        row.appendChild(label);
        sec.appendChild(row);
      }
      root.appendChild(sec);
    }
  }

  function renderInput(id, item){
    const wrap = document.createElement("div");
    const type = (item.type || "scale").toLowerCase();
    if (type === "scale"){   // 1–5 selector
      const sel = document.createElement("select"); sel.id=id; sel.name=item.id;
      for (let v=1; v<=5; v++){ const o=document.createElement("option"); o.value=v; o.textContent=v; sel.appendChild(o); }
      wrap.appendChild(sel);
    } else if (type === "bool"){ // checkbox
      const cb = document.createElement("input"); cb.type="checkbox"; cb.id=id; cb.name=item.id; wrap.appendChild(cb);
    } else { // free text fallback
      const t = document.createElement("input"); t.type="text"; t.id=id; t.name=item.id; wrap.appendChild(t);
    }
    return wrap;
  }

  function escapeHTML(s){
    return String(s).replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;','\'':'&#39;'}[c]));
  }

  function showDiagnostics(info){
    const box = document.getElementById("kinksDiagnostics");
    if (!box) return;
    const {
      source,
      countCats,
      countItems,
      skipped,
      fetchErrors,
      requested,
      missing,
      availableCount
    } = info || {};
    const safeCountCats = Number.isFinite(countCats) ? countCats : 0;
    const safeCountItems = Number.isFinite(countItems) ? countItems : 0;
    const safeAvailable = Number.isFinite(availableCount) ? availableCount : safeCountCats;
    const requestedList = Array.isArray(requested) ? requested.filter(Boolean) : [];
    const missingList = Array.isArray(missing) ? missing.filter(Boolean) : [];
    const skippedList = Array.isArray(skipped) ? skipped : [];
    const fetchList = Array.isArray(fetchErrors) ? fetchErrors.filter(Boolean) : [];

    const lines = [];
    if (fetchList.length){
      lines.push("⚠️ Fetch attempts:", ...fetchList.map(e=>"  • "+e));
    }
    lines.push(
      `Source: ${source || "(inline)"}`,
      `Available categories: ${safeAvailable}`,
      `Categories rendered: ${safeCountCats}`,
      `Total items: ${safeCountItems}`
    );
    if (requestedList.length){
      lines.push(`Requested categories: ${requestedList.length}`);
    }
    if (missingList.length){
      lines.push(`Missing categories (${missingList.length}):`);
      missingList.slice(0, 25).forEach(name => {
        lines.push(`  • ${name}`);
      });
      if (missingList.length > 25){
        lines.push(`  … and ${missingList.length - 25} more`);
      }
    }
    if (skippedList.length){
      lines.push(`Skipped (${skippedList.length}):`);
      for (const s of skippedList.slice(0, 25)){
        lines.push(`  • ${s.where} → ${safePreview(s.item)}`);
      }
      if (skippedList.length > 25){
        lines.push(`  … and ${skippedList.length - 25} more`);
      }
    }
    box.textContent = lines.join("\n");
    box.style.display = "block";
  }

  function safePreview(x){ try{ return JSON.stringify(x).slice(0,160); }catch(_){ return String(x); } }

  /* --------------- 3) BOOTSTRAP --------------- */
  async function KINKS_boot(options = {}){
    const root = ensureRoot();
    const rawRequested = Array.isArray(options?.categories) ? options.categories : [];
    const requestedMap = new Map();
    for (const value of rawRequested){
      if (typeof value !== "string") continue;
      const trimmed = tidy(value);
      const normalized = normalizeName(trimmed);
      if (!normalized) continue;
      if (!requestedMap.has(normalized)) {
        requestedMap.set(normalized, trimmed);
      }
    }
    const requestedOrder = Array.from(requestedMap.keys());
    const requestedValues = Array.from(requestedMap.values());

    let json, source, errors=[];
    try{
      const got = await fetchJSONWithFallbacks();
      json = got.json; source = got.source; errors = got.errors || [];
    }catch(e){
      showDiagnostics({
        source:"(none)",
        countCats:0,
        countItems:0,
        skipped:[],
        fetchErrors:[e.message],
        requested: requestedValues,
        missing: requestedValues,
        availableCount: 0
      });
      console.error("[KINKS] Fetch failed:", e);
      return;
    }

    let bank, skipped;
    try{
      const norm = normalizeBank(json);
      bank = norm.bank; skipped = norm.skipped;
    }catch(e){
      showDiagnostics({
        source,
        countCats:0,
        countItems:0,
        skipped:[{where:"normalize-error", item:e.message}],
        fetchErrors:errors,
        requested: requestedValues,
        missing: requestedValues,
        availableCount: Array.isArray(json) ? json.length : (json && typeof json === "object" ? Object.keys(json).length : 0)
      });
      console.error("[KINKS] Normalize failed:", e);
      return;
    }

    const availableCount = bank.length;
    let filteredBank = bank;
    const missing = [];

    if (requestedOrder.length){
      const lookup = new Map();
      for (const cat of bank){
        const key = normalizeName(cat?.category);
        if (key && !lookup.has(key)) lookup.set(key, cat);
      }
      filteredBank = [];
      const seen = new Set();
      for (const key of requestedOrder){
        if (seen.has(key)) continue;
        seen.add(key);
        const found = lookup.get(key);
        if (found){
          filteredBank.push(found);
        } else {
          missing.push(requestedMap.get(key) || key);
        }
      }
    }

    renderSurvey(root, filteredBank);
    const countCats = filteredBank.length;
    const countItems = filteredBank.reduce((n,c)=>n + c.items.length, 0);
    showDiagnostics({
      source,
      countCats,
      countItems,
      skipped,
      fetchErrors:errors,
      requested: requestedValues,
      missing,
      availableCount
    });
    if (missing.length){
      LOG("Missing categories:", missing);
    }
    LOG(`Rendered ${countCats} categories / ${countItems} items from ${source}`);
    return { source, countCats, countItems, skipped, missing, requested: requestedValues, categories: filteredBank };
  }

  // Expose the boot function so Start Survey can call it
  window.KINKS_boot = KINKS_boot;

  // Auto-run if you want immediate render on load (optional):
  // if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", KINKS_boot);
  // else KINKS_boot();
})();
</script>

    <script>
    fetch("/check-session", { credentials: "include" })
      .then(res => {
        if (res.status === 401) {
          console.info("Session check: unauthenticated user", res);
        }
      })
      .catch(err => console.error("Session check failed:", err));
  </script>

<!--
KINKS PAGE — “UNSQUISH + CENTER” HOTFIX
Paste this whole block near the end of /kinks/index.html (right before </body>).

What this does
1) Centers the survey UI and lets it grow to a comfortable width (no more skinny column).
2) Removes any fixed heights/clamps/overflows that were cutting off or squishing the category tracker.
3) Makes long sections scroll naturally (page scroll) instead of being trapped in a short inner scroller.
4) Works without renaming your existing elements; it targets common wrappers and “tracker” panels.

How to use
- Paste this once.
- Hard refresh with DevTools → Network → “Disable cache” (Ctrl/Cmd+Shift+R).
- If you still see a squished panel, keep the DevTools open and watch the console logs
  (the script lists which elements it unclamped).
-->

<style>
  /* 1) Global sanity so widths behave predictably */
  *, *::before, *::after { box-sizing: border-box; }

  /* 2) Center the main survey area and give it breathing room */
  #surveyRoot,
  .kinks-root,
  .kinks-wrapper,
  .survey-wrapper,
  .compat-container,
  main.kinks,
  [data-kinks-root] {
    display: block !important;
    margin-left: auto !important;
    margin-right: auto !important;
    width: min(1100px, 92vw) !important;   /* roomy but responsive */
  }

  /* 3) Make each category section full width inside the centered container */
  .kinks-category,
  .category-section,
  section[data-category],
  .kink-category-card {
    width: 100% !important;
    max-width: 100% !important;
  }

  /* 4) Never clamp height on containers that likely hold lists/tracker */
  #surveyRoot, .kinks-root, .kinks-wrapper,
  .categories, .category-list, .results,
  .tracker, .category-tracker, [class*="tracker"] {
    max-height: none !important;
    height: auto !important;
    overflow: visible !important; /* let the PAGE scroll, not the inner box */
  }

  /* 5) Basic dark-friendly styling (optional, safe) */
  .kinks-category {
    border: 1px solid #00e5ff33;
    border-radius: 12px;
    padding: 12px 14px;
    margin: 12px 0;
    color: #fff;
    background: #0a0f14;
  }
  .kinks-category h3 {
    margin: 0 0 6px 0;
    font-weight: 700;
    color: #7ef9ff;
  }
  .kinks-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 6px 0;
    border-top: 1px dashed #00e5ff22;
  }
  .kinks-item:first-of-type { border-top: 0; }
</style>

<script>
(() => {
  const LOG = (...a) => { try { if (typeof window !== 'undefined' && !window.__tk_shouldLog) return; } catch {} console.log('[KINKS-UNSQUISH]', ...a); };

  // 6) Unclamp anything that forces short/squished tracker panes
  function unclampOnce(root = document) {
    const selectors = [
      '#surveyRoot', '.kinks-root', '.kinks-wrapper', '.survey-wrapper',
      '.categories', '.category-list', '.results', '.tracker', '.category-tracker',
      '[class*="tracker"]', '[data-kinks-root]', 'main.kinks'
    ];

    const seen = new Set();
    selectors.forEach(sel => {
      root.querySelectorAll(sel).forEach(el => {
        if (seen.has(el)) return;
        seen.add(el);

        // Remove inline clamps
        const before = { h: el.style.height, mh: el.style.maxHeight, ov: el.style.overflow };
        if (el.style.height)     el.style.height = "";
        if (el.style.maxHeight)  el.style.maxHeight = "";
        if (el.style.overflow)   el.style.overflow = "";

        // Force our desired behavior
        el.style.setProperty('max-height', 'none', 'important');
        el.style.setProperty('height', 'auto', 'important');
        el.style.setProperty('overflow', 'visible', 'important');

        // Common “clamp” classes used by frameworks
        const clampClasses = [
          'is-clamped','clamped','scroll','scrollable','scroller','overflow',
          'overflow-auto','overflow-y','max-h','h-fixed','panel'
        ];
        clampClasses.forEach(c => { if (el.classList.contains(c)) el.classList.remove(c); });

        LOG('unclamped', el, before);
      });
    });

    // Center primary containers
    const centers = root.querySelectorAll('#surveyRoot, .kinks-root, .kinks-wrapper, .survey-wrapper, main.kinks, [data-kinks-root]');
    centers.forEach(el => {
      el.style.setProperty('margin-left', 'auto', 'important');
      el.style.setProperty('margin-right', 'auto', 'important');
      el.style.setProperty('width', 'min(1100px, 92vw)', 'important');
    });
  }

  // Run once now
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => unclampOnce(document));
  } else {
    unclampOnce(document);
  }

  // 7) Keep fixing if the app re-renders after “Start Survey”
  const mo = new MutationObserver(muts => {
    let touched = false;
    for (const m of muts) {
      if (m.addedNodes && m.addedNodes.length) { touched = true; break; }
      if (m.type === 'attributes' && (m.attributeName === 'style' || m.attributeName === 'class')) { touched = true; break; }
    }
    if (touched) unclampOnce(document);
  });
  mo.observe(document.documentElement, { subtree: true, childList: true, attributes: true });

  // 8) Optional: if you have a Start Survey button, ensure it triggers after DOM
  const startBtn = document.querySelector('#startSurvey');
  if (startBtn && !startBtn.dataset.kinksEnhBound) {
    startBtn.dataset.kinksEnhBound = '1';
    startBtn.addEventListener('click', () => {
      // Give your app a moment to inject DOM, then unclamp again
      setTimeout(() => unclampOnce(document), 120);
    });
    LOG('bound Start Survey for post-render unclamp');
  }
})();
</script>
<script>
// TK-CLICKFIX — make category checkboxes clickable
(() => {
  const d = document;

  // 0) quiet the spammy logger
  const _log = console.log.bind(console);
  const allowUnsquish = () => {
    try { return typeof window !== 'undefined' && window.__tk_shouldLog; }
    catch (_) { return false; }
  };
  console.log = (...a) => {
    if (String(a?.[0] ?? "").includes("[KINKS-UNSQUISH]") && !allowUnsquish()) return;
    _log(...a);
  };

  // 1) kill full-screen overlays that eat clicks
  const overlays = [];
  for (const el of d.querySelectorAll("body *")) {
    const cs = getComputedStyle(el);
    if (cs.position === "fixed") {
      const r = el.getBoundingClientRect();
      const covers =
        r.left <= 0 && r.top <= 0 &&
        r.right >= innerWidth - 1 &&
        r.bottom >= innerHeight - 1 &&
        cs.visibility !== "hidden" && +cs.opacity > 0.001 &&
        cs.pointerEvents !== "none";
      if (covers) {
        el.dataset.tkPrevPE = cs.pointerEvents;
        el.style.pointerEvents = "none";
        el.style.zIndex = "0";
        overlays.push(el);
      }
    }
  }
  _log("[TK] overlays disabled:", overlays.length);

  // 2) ensure panel can receive clicks
  const panel = d.querySelector(".category-panel") || d.body;
  if (panel) {
    panel.style.pointerEvents = "auto";
    panel.style.zIndex = "2147483647";
  }

  // 3) remove generic blockers
  d.querySelectorAll("[inert]").forEach(n => n.removeAttribute("inert"));
  d.querySelectorAll("[aria-busy='true'],[data-loading]").forEach(n => n.remove());

  // 4) re-enable all inputs & ancestors
  const inputs = d.querySelectorAll("input,select,button");
  inputs.forEach(el => { el.disabled = false; el.style.pointerEvents = "auto"; });
  const cbs = Array.from(d.querySelectorAll(".category-panel input[type='checkbox'], input[type='checkbox']"));
  cbs.forEach(cb => { let p = cb; for (let i=0; i<5 && p; i++) { p.style.pointerEvents = "auto"; p = p.parentElement; } });

  // 5) if something still sits on top of a checkbox, detect & neutralize it
  const offenders = new Set();
  for (const cb of cbs.slice(0, 20)) {
    const r = cb.getBoundingClientRect();
    const topEl = d.elementFromPoint(r.left + 8, r.top + r.height/2);
    if (topEl && topEl !== cb && !cb.contains(topEl) && !topEl.contains(cb)) offenders.add(topEl);
  }
  offenders.forEach(el => { el.style.pointerEvents = "none"; el.style.zIndex = "0"; });
  _log("[TK] elementFromPoint offenders disabled:", offenders.size);

  // 6) sanity: toggle a few boxes
  cbs.slice(0, 5).forEach(cb => { cb.click(); cb.click(); });

  _log("[TK] clickfix applied. Try clicking the category checkboxes now.");
})();
</script>
<!-- ✅ 1) Add this *once* near the end of every page that was freezing (before </body>) -->
<script>
/* ---------- TalkKink Safe Bootstrap (drop-in) ---------- */
(function () {
  const LOG = (...a) => console.log("[TK-SAFE]", ...a);

  /* A. QUICK SANITY CHECKS — find & warn about merge markers (these often lock pages) */
  try {
    const html = document.documentElement.innerHTML;
    const HEAD = '<'.repeat(7);
    const SEP = '='.repeat(7);
    const TAIL = '>'.repeat(7);
    if (html.includes(HEAD) && html.includes(SEP) && html.includes(TAIL)) {
      const conflictPattern = new RegExp(`${HEAD}[\s\S]*?${SEP}[\s\S]*?${TAIL}`);
      if (conflictPattern.test(html)) {
        console.warn("[TK-SAFE] Merge conflict markers detected in DOM. Remove them to avoid broken JS/CSS.");
      }
    }
  } catch (_) {}

  /* B. ONE-TIME INIT GUARD (prevents duplicate event bind/render loops) */
  if (window.__TK_INITED__) {
    LOG("Init skipped: already initialized.");
    return;
  }
  window.__TK_INITED__ = true;

  /* C. SAFE-MODE FLAGS (use ?safe=1 or ?nopdf=1 or ?noscore=1 to bypass heavy work) */
  const params = new URLSearchParams(location.search);
  const SAFE_MODE  = params.has("safe");
  const NO_PDF     = SAFE_MODE || params.has("nopdf");
  const NO_SCORE   = SAFE_MODE || params.has("noscore");

  if (SAFE_MODE) LOG("SAFE MODE ON: skipping scoring/render and lazy-loading libraries.");

  /* D. SMALL UTILITIES */
  const byId = (id) => document.getElementById(id);
  function once(el, type, handler, opts) {
    // prevent stacked duplicate listeners after HMR/partials
    el && el.addEventListener(type, function f(e) {
      el.removeEventListener(type, f, opts);
      handler(e);
    }, opts);
  }
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      if (document.querySelector(`script[src="${src}"]`)) return resolve();
      const s = document.createElement("script");
      s.src = src; s.async = true; s.defer = true;
      s.onload = resolve;
      s.onerror = () => reject(new Error("Failed to load " + src));
      document.head.appendChild(s);
    });
  }
  function idle(fn) {
    // yield back to the browser to keep UI responsive
    return (window.requestIdleCallback || ((cb)=>setTimeout(cb,0)))(fn);
  }

  /* E. LAZY LOADERS FOR HEAVY LIBS (loaded only on click) */
  async function ensureJsPDF() {
    if (!(window.jspdf && window.jspdf.jsPDF)) {
      await loadScript("https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js");
    }
  }
  async function ensureAutoTable() {
    // Only after jsPDF UMD maps window.jspdf.jsPDF
    await ensureJsPDF();
    const hasAT = (window.jspdf && window.jspdf.jsPDF && window.jspdf.jsPDF.API && window.jspdf.jsPDF.API.autoTable)
               || (window.jspdf && window.jspdf.autoTable);
    if (!hasAT) {
      await loadScript("https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.3/jspdf.plugin.autotable.min.js");
    }
  }

  /* F. DEFENSIVE BINDINGS (buttons used across pages) */
  idle(() => {
    // PDF buttons (compatibility, IKA, etc.)
    const dl1 = byId("downloadBtn");
    const dl2 = byId("downloadPdfBtn");
    const anyDownload = dl1 || dl2;

    if (anyDownload) {
      const handler = async (e) => {
        e.preventDefault();
        if (NO_PDF) { alert("PDF disabled (safe mode). Add ?safe=0 or remove ?nopdf."); return; }
        try {
          // Lazy load heavy libs only now
          await ensureAutoTable();
          // Yield once more before heavy export:
          await new Promise(r => setTimeout(r, 0));
          // Call your existing exporter (must be defined elsewhere)
          if (typeof window.TKPDF_export === "function") {
            await window.TKPDF_export();
          } else if (typeof window.TKPDF_forceDark === "function") {
            await window.TKPDF_forceDark();
          } else if (typeof window.exportIKAPdf === "function") {
            await window.exportIKAPdf();
          } else {
            alert("Export function not found. Expected TKPDF_export/TKPDF_forceDark/exportIKAPdf.");
          }
        } catch (err) {
          console.error("[TK-SAFE] PDF export failed:", err);
          alert("PDF export failed: " + (err?.message || err));
        }
      };

      // Bind once to whichever exists
      if (dl1) once(dl1, "click", handler);
      if (dl2) once(dl2, "click", handler);
      LOG("Bound PDF button(s).");
    }

    // File upload styled label (IKA)
    const fileInput = byId("ikaFile");
    const fileLabel = document.querySelector('label[for="ikaFile"]');
    if (fileInput && fileLabel) {
      once(fileLabel, "click", () => fileInput.click());
      LOG("Bound Upload Survey label→input.");
    }
  });

  /* G. STOP RUNNING EXPENSIVE WORK ON LOAD (scoring/rendering) */
  // Wrap your page’s auto-render or scoring in this gate:
  window.TK_canRunHeavy = function () {
    if (SAFE_MODE) return false;
    // Avoid running more than once
    if (window.__TK_HEAVY_RAN__) return false;
    window.__TK_HEAVY_RAN__ = true;
    return true;
  };

  // Example usage for your pages (leave here; your code can call it):
  // if (window.TK_canRunHeavy()) {
  //   // run scoring/render here or schedule with idle(...)
  //   idle(() => window.renderResults && window.renderResults());
  // }

  /* H. GLOBAL CATCH FOR ACCIDENTAL LONG TASKS */
  // If something still locks the UI, advise safe mode.
  window.addEventListener("error", (e) => {
    console.warn("[TK-SAFE] Window error:", e.message);
  });
})();
</script>
<!-- ---------- End Safe Bootstrap ---------- -->

<script src="/js/tk_kinksurvey_enhance.js"></script>
<!-- TK-HOTFIX START -->
<script id="tk-diag">
(function(){
  function show(msg){
    var d = document.getElementById('kinksDiagnostics');
    if(!d){ d = document.createElement('div'); d.id='kinksDiagnostics'; document.body.prepend(d); }
    d.hidden = false;
    d.style.cssText = "background:#111;color:#fff;padding:8px;border:1px solid #444;margin:8px 0";
    d.textContent = msg;
  }
  // Try the canonical JSON from root (works under /kinks/)
  (async () => {
    try {
      const r = await fetch('/data/kinks.json?v=1730846400000', { cache:'no-store' });
      if(!r.ok) throw new Error('kinks.json ' + r.status);
      const data = await r.json();
      if (typeof window.KINKS_boot === 'function') { window.KINKS_boot(data); }
    } catch (e) { show('Data bootstrap failed: ' + e.message); }
  })();
})();
</script>
<!-- TK-HOTFIX END -->

  <!-- TK guard: dim missing categories; enable Start when valid -->
  <script type="module" src="/js/kinks_data_guard.js"></script>


<!-- TK fail-open (safe: idle unless boot stalls) -->
  <script type="module" src="/js/tk_failopen.js"></script>
  <!-- TK: reveal fallback -->
  <script src="/js/tk_reveal.js"></script>
  <script src="/js/tk_unblock_clicks.js"></script>
  <script src="/js/tk_click_rerouter.js"></script>
  <!-- TK CLICKFIX: make category panel clickable & keep Start in sync -->
  <link rel="stylesheet" href="/css/tk_clickfix.css">
  <script src="/js/tk_clickfix.js" defer></script>
  <script>
  (function(){
    const text = (el) => (el?.textContent ?? "").trim();
    const normKey = (s) =>
      String(s ?? "")
        .normalize("NFKD")
        .replace(/[\u0300-\u036f]/g, "")
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, " ")
        .trim();

    const AtoZ = (a,b) => a.localeCompare(b, undefined, {
      sensitivity: "base",
      numeric: true,
      ignorePunctuation: true
    });

    function uniqSorted(list){
      const out = [];
      const seen = new Set();
      for (const c of list || []) {
        const t = String(c ?? "").trim();
        const k = normKey(t);
        if (!k || seen.has(k)) continue;
        seen.add(k);
        out.push(t);
      }
      return out.sort(AtoZ);
    }

    function sortCategoryPanel(){
      const list = document.querySelector(".category-list");
      if (!list) return;
      const rows = Array.from(list.querySelectorAll('label[role="listitem"]'));
      if (!rows.length) return;

      rows.sort((ra, rb) => AtoZ(text(ra), text(rb)));
      rows.forEach(r => list.appendChild(r));
    }

    const panelRoot = document.querySelector("#categorySurveyPanel") || document;
    const mo = new MutationObserver(() => sortCategoryPanel());
    mo.observe(panelRoot, { childList: true, subtree: true });

    function wrapBootSorter(){
      const tryWrap = () => {
        const boot = window.KINKS_boot;
        if (!boot || boot.__ksvSortedWrap) return false;

        const wrapped = function(opts){
          const o = Object.assign({}, opts || {});
          let chosen = Array.isArray(o.categories) ? o.categories : null;

          if (!chosen || !chosen.length) {
            const last = Array.isArray(window.__KSV_LAST_SORTED_SELECTION__)
              ? window.__KSV_LAST_SORTED_SELECTION__
              : null;
            if (last && last.length) {
              chosen = last;
            } else {
              const checked = Array.from(document.querySelectorAll(".category-checkbox:checked"));
              if (checked.length) {
                chosen = checked.map(cb => cb.value);
              }
            }
          }

          if (chosen && chosen.length) {
            o.categories = uniqSorted(chosen);
          }
          return boot(o);
        };
        wrapped.__ksvSortedWrap = true;
        window.KINKS_boot = wrapped;
        return true;
      };

      if (!tryWrap()){
        const iv = setInterval(() => { if (tryWrap()) clearInterval(iv); }, 100);
        setTimeout(() => clearInterval(iv), 10000);
      }
    }

    function hookStartButton(){
      const btn = document.querySelector("#startSurvey, #startSurveyBtn");
      if (!btn || btn.__ksvSelHooked) return;
      btn.__ksvSelHooked = true;

      btn.addEventListener("click", () => {
        const checked = Array.from(document.querySelectorAll(".category-checkbox:checked"));
        if (checked.length) {
          const vals = checked.map(cb => cb.value);
          window.__KSV_LAST_SORTED_SELECTION__ = uniqSorted(vals);
        }
      }, { capture: true });
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", () => {
        sortCategoryPanel();
        wrapBootSorter();
        hookStartButton();
      }, { once:true });
    } else {
      sortCategoryPanel();
      wrapBootSorter();
      hookStartButton();
    }
  })();
  </script>
  <script>
  (function () {
    /* Guard: install once */
    if (window.__tkPortalInstalled) return;
    window.__tkPortalInstalled = true;

    const Z = 2147483000; // max-ish z-index so we're always above everything.

    /* 1) Find the existing panel (your drawer) */
    const panel = document.querySelector('#categorySurveyPanel, .category-panel');
    if (!panel) {
      console.warn('[TK] No panel found (#categorySurveyPanel or .category-panel).');
      return;
    }

    /* 2) Create scrim and portal wrapper that sit at the top of the page stack */
    const scrim = Object.assign(document.createElement('div'), { id: 'tkScrim' });
    Object.assign(scrim.style, {
      position: 'fixed', inset: '0', background: 'rgba(0,0,0,.6)',
      display: 'none', opacity: '0', transition: 'opacity .18s ease', zIndex: Z, pointerEvents: 'none'
    });

    const portal = Object.assign(document.createElement('div'), { id: 'tkPortal' });
    Object.assign(portal.style, { position: 'fixed', inset: '0', display: 'none', zIndex: Z + 1, pointerEvents: 'none' });

    const shell = Object.assign(document.createElement('div'), { className: 'tk-shell' });
    Object.assign(shell.style, {
      position: 'fixed', left: '50%', top: '50%', transform: 'translate(-50%, -50%)',
      maxHeight: '85vh', width: 'min(980px, 92vw)',
      background: 'rgba(10,10,10,.97)', border: '1px solid #00f0ff', borderRadius: '12px',
      boxShadow: '0 24px 64px rgba(0,0,0,.55)', overflow: 'auto', pointerEvents: 'auto', padding: '16px'
    });

    document.body.appendChild(scrim);
    document.body.appendChild(portal);
    portal.appendChild(shell);

    /* 3) Remember original location so we can restore on close */
    const origParent = panel.parentNode;
    const origNext = panel.nextSibling;

    /* 4) Neutralize common hiding mechanisms on the panel itself */
    ['hidden', 'inert', 'aria-hidden'].forEach(a => { try { panel.removeAttribute(a); } catch {} });
    try { panel.classList.remove('hidden','is-hidden','closed','tk-hidden','tk-closed'); } catch {}
    Object.assign(panel.style, {
      display: 'block', visibility: 'visible', opacity: '1', filter: 'none', transform: 'none'
    });

    /* 5) Mount/unmount helpers */
    function mountPanel(){
      // Pull into portal and ensure it can't be 0x0
      shell.appendChild(panel);
      if (panel.getBoundingClientRect().height < 40) {
        panel.style.minHeight = '240px';   // safety so you see something
      }
    }
    function unmountPanel(){
      if (!origParent) return;
      if (origNext) origParent.insertBefore(panel, origNext);
      else origParent.appendChild(panel);
    }

    /* 6) Open/close controls */
    function open(){
      mountPanel();
      scrim.style.display = 'block';
      portal.style.display = 'block';
      requestAnimationFrame(() => { scrim.style.opacity = '1'; scrim.style.pointerEvents = 'auto'; });
      document.documentElement.style.overflow = 'hidden';
      console.log('[TK] Panel opened (portal mode).');
    }
    function close(){
      scrim.style.opacity = '0';
      scrim.style.pointerEvents = 'none';
      setTimeout(() => {
        scrim.style.display = 'none';
        portal.style.display = 'none';
        document.documentElement.style.overflow = '';
        unmountPanel();
        console.log('[TK] Panel closed (restored to original DOM).');
      }, 180);
    }
    scrim.addEventListener('click', close, { passive: true });

    /* 7) Public probes (handy in console) */
    window.tkOpenPanel = open;
    window.tkClosePanel = close;
    window.tkProbe = function(){
      const r = panel.getBoundingClientRect();
      console.table([
        { key: 'panel',   present: !!panel,   w: Math.round(r.width), h: Math.round(r.height),
          inPortal: panel.parentNode === shell },
        { key: 'overlay', present: true,      visible: scrim.style.display !== 'none' }
      ]);
      return { rect: r, inPortal: panel.parentNode === shell };
    };

    /* 8) Wire your Start buttons */
    const startSelectors = [
      '#startSurveyBtn', '#startSurvey', '.start-survey-btn',
      'button.themed-button.start-survey-btn', 'a[href="#start"]'
    ].join(',');
    document.querySelectorAll(startSelectors).forEach(btn => {
      btn.addEventListener('click', e => { e.preventDefault(); open(); }, { passive: false });
    });

  console.log('[TK] Portal installed. Click “Start Survey”, or run tkOpenPanel().');
})();
  </script>

  <!-- TK: Gate Start Survey until categories are selected -->
  <style>
    /* visual disabled state that doesn't fight your current button styles */
    .tk-disabled {
      pointer-events: none !important;
      opacity: .45 !important;
      filter: grayscale(.25);
    }
    .tk-pulse {
      animation: tkPulse 1.25s ease-in-out infinite;
    }
    @keyframes tkPulse {
      0%,
      100% {
        box-shadow: 0 0 0 0 rgba(0, 240, 255, .35);
      }
      50% {
        box-shadow: 0 0 0 10px rgba(0, 240, 255, 0);
      }
    }
  </style>

  <script>
  (function(){
    if (window.__tkGateOnce) return; window.__tkGateOnce = true;

    // ------- robust element lookups -------
    function q(sel, root=document){ return root.querySelector(sel); }
    function qa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

    // 1) Find the docked panel host we created earlier, or fall back to the native panel
    const panel =
      q('#tkPortal .tk-shell') || // our extracted/docked panel container (from previous patch)
      q('#categorySurveyPanel')   ||
      q('.category-panel')        ||
      document.body;

    // 2) Find all category checkboxes inside the panel (work with both native and custom roles)
    function getAllBoxes(){
      const inputs = qa('input[type="checkbox"]', panel);
      const roles  = qa('[role="checkbox"]', panel).filter(el => !inputs.includes(el));
      return [...inputs, ...roles];
    }
    function isChecked(el){
      if (!el) return false;
      if (el.matches('[role="checkbox"]')) {
        const v = (el.getAttribute('aria-checked')||'').toLowerCase();
        return v === 'true' || v === 'mixed';
      }
      return !!el.checked;
    }

    // 3) Find the Start Survey button (right-rail OR original spot)
    function findStartBtn(){
      const cands = [
        '#startSurveyBtn', '#startSurvey', '.start-survey-btn',
        '.tk-right-rail button', '.tk-right-rail a',
        'button', 'a[role="button"]'
      ];
      for (const sel of cands) {
        const el = qa(sel).find(b => /start\s*survey/i.test((b.textContent||'').trim()));
        if (el) return el;
      }
      return null;
    }

    const startBtn = findStartBtn();
    if (!startBtn) { console.warn('[TK] Start button not found; gating skipped.'); return; }

    // ------- gating logic -------
    function setDisabled(btn, disabled){
      btn.classList.toggle('tk-disabled', !!disabled);
      btn.classList.toggle('tk-pulse', !disabled);      // tiny affordance when it becomes ready
      btn.setAttribute('aria-disabled', disabled ? 'true' : 'false');
      // keep focusability sane
      if (disabled) { btn._oldTabIndex ??= btn.getAttribute('tabindex'); btn.setAttribute('tabindex', '-1'); }
      else          { if (btn._oldTabIndex != null) btn.setAttribute('tabindex', btn._oldTabIndex); else btn.removeAttribute('tabindex'); }
    }

    function countSelected(){
      const boxes = getAllBoxes();
      return { selected: boxes.filter(isChecked).length, total: boxes.length };
    }

    // DEFAULT RULE: enable Start when the user has **selected at least one** category.
    // If you literally want **all 35 must be checked**, change the line below to:
    //   const ready = n.selected === n.total;
    function computeReady(){
      const n = countSelected();
      const ready = n.selected > 0;    // <-- tweak here if you want "all must be checked"
      return { ready, ...n };
    }

    // Update gate immediately and on every interaction inside the panel
    function refreshGate(){
      const { ready } = computeReady();
      setDisabled(startBtn, !ready);
    }

    // Wire events on the panel to detect selections
    function wireChangeListeners(){
      const root = panel;
      // Native checkboxes
      root.addEventListener('change', refreshGate, true);
      // Custom role=checkbox components often toggle on click/keydown
      root.addEventListener('click',  e => { if (e.target.closest('[role="checkbox"]')) setTimeout(refreshGate, 0); }, true);
      root.addEventListener('keydown',e => { if (e.target.closest('[role="checkbox"]')) setTimeout(refreshGate, 0); }, true);
      // Also catch "Select All" / "Deselect All" style controls
      root.addEventListener('click', e => {
        const t = (e.target.closest('button,[role="button"],a') || {});
        const txt = (t.textContent||'').trim().toLowerCase();
        if (/(select all|deselect all|clear all)/.test(txt)) setTimeout(refreshGate, 0);
      }, true);
    }

    // Stop the old behavior (if any) when disabled, otherwise let it flow to your app start
    function onStartClick(evt){
      const disabled = startBtn.classList.contains('tk-disabled') || startBtn.getAttribute('aria-disabled') === 'true';
      if (disabled) {
        evt.preventDefault(); evt.stopPropagation();
        // bring the left panel into view to nudge the user
        try { (q('#tkPortal .tk-shell') || panel).scrollIntoView({ behavior:'smooth', block:'center' }); } catch {}
        return;
      }

      // When enabled, call your existing "start" entry point (whichever exists)
      if (typeof window.tkGo === 'function')       { try{ window.tkGo(); return; }catch{} }
      if (typeof window.startSurvey === 'function'){ try{ window.startSurvey(); return; }catch{} }
      // Fallback: fire a custom event so your code can listen if desired
      document.dispatchEvent(new CustomEvent('tk:start'));
    }

    // Initial state + listeners
    setDisabled(startBtn, true);
    startBtn.addEventListener('click', onStartClick, true);
    wireChangeListeners();

    // In case the panel contents are hydrated after load, observe and re-evaluate
    const mo = new MutationObserver(() => refreshGate());
    mo.observe(panel, { subtree:true, childList:true, attributes:true, attributeFilter:['checked','aria-checked','class'] });

    // First pass once everything settles
    setTimeout(refreshGate, 0);
  })();
  </script>
</body>
</html>
