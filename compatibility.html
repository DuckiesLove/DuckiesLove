<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>See Our Compatibility</title>
  <!-- Import theme and global layout styles -->
  <link rel="stylesheet" href="/css/theme.css" />
  <link rel="stylesheet" href="/css/global.css" />
  <link rel="stylesheet" href="/css/compat-table.css" />
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet" />
  <script src="js/vendor/html2pdf.bundle.min.js"></script>
  <style>
    .upload-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      margin-top: 3rem;
    }

      .upload-button {
        position: relative;
        display: inline-block;
      }

    .upload-button input[type="file"] {
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .wide-button {
      min-width: 260px;
      max-width: 300px;
      width: 100%;
    }
  </style>
  <style>
    /* Keep rows from splitting in both web and print */
    .compat-section tr { break-inside: avoid; page-break-inside: avoid; }

    /* Make sure tables are fixed-width to avoid right-side cutoff */
    .compat-section table {
      width: 100% !important;
      table-layout: fixed !important;
      border-collapse: collapse !important;
    }

    /* Optional: make header clean (no decorative lines/boxes) */
    .section-title, .category-header, .compat-category {
      border: none !important;
      box-shadow: none !important;
      background: transparent !important;
    }
  </style>
</head>
<body class="theme-dark">
  <div class="main-container themed">
    <h1 class="page-title">See Our Compatibility</h1>
    <div class="upload-container">
      <button class="themed-button wide-button" onclick="window.history.back()">← Back</button>

      <label id="uploadYourSurvey" class="upload-button themed-button wide-button">
        <input type="file" id="uploadUser" onchange="handleFileUpload(this)" />
        Upload Your Survey
      </label>

      <label id="uploadPartnerSurvey" class="upload-button themed-button wide-button">
        <input type="file" id="uploadPartner" onchange="handleFileUpload(this)" />
        Upload Partner’s Survey
      </label>

      <button class="themed-button wide-button" id="downloadBtn">Download PDF</button>
    </div>

    <div id="comparisonResults">
      <div id="loading-spinner" class="loading-overlay"><div class="spinner"></div></div>
      <div id="pdf-container">
        <div id="compatibility-wrapper" class="compatibility-wrapper">
          <div id="comparisonResult"></div>
          <div id="compatibility-report" class="pdf-export-area"></div>
          <div id="print-card-list" class="print-only"></div>
        </div>
      </div>
      <div class="print-footer"></div>
    </div>
  </div>

  <script src="js/template-survey.js"></script>
  <script type="module" src="js/compatibilityPage.js"></script>
  <script type="module">
    import { initTheme, applyThemeColors } from './js/theme.js';
    initTheme();
    window.applyThemeColors = applyThemeColors;
  </script>
  <script>
    fetch("/check-session", { credentials: "include" })
      .then(res => {
        if (res.status === 401) {
          window.location.href = "/token.html";
        }
      });
  </script>

  <!-- =========================
  FIXED BLACK PDF + RELIABLE RENDER
  Drop this whole block near the end of <body> after your app has rendered.
  Requires #pdf-container to exist on the page.
  ========================= -->

  <!-- If html2pdf isn’t already loaded, this ensures it is. Safe to keep even if you load it elsewhere. -->
  <script>
  (function ensureHtml2Pdf() {
    if (window.html2pdf) return;
    const s = document.createElement('script');
    s.src = "https://unpkg.com/html2pdf.js@0.9.3/dist/html2pdf.bundle.min.js";
    s.defer = true;
    document.head.appendChild(s);
  })();
  </script>

  <style>
  /* ----- PDF-only styling applied to the cloned node via .pdf-export ----- */
  .pdf-export {
    background: #000 !important;
    color: #fff !important;
    padding: 24px !important;
    margin: 0 !important;
  }
  /* Tables render at full width with fixed layout so nothing collapses */
  .pdf-export table {
    width: 100% !important;
    table-layout: fixed !important;
    border-collapse: collapse !important;
    background: transparent !important;
    color: #fff !important;
  }
  /* Cells: compact, readable, and non-splitting in PDF */
  .pdf-export th, .pdf-export td {
    border: none !important;
    background: transparent !important;
    color: #fff !important;
    padding: 6px 8px !important;
    line-height: 1.25 !important;
    vertical-align: top !important;
    word-break: break-word !important;
    white-space: normal !important;
    box-sizing: border-box !important;
    page-break-inside: avoid !important;
    break-inside: avoid !important;
  }
  /* Rows must never split across pages */
  .pdf-export tr {
    page-break-inside: avoid !important;
    break-inside: avoid !important;
  }
  /* Clean category headers in both web & PDF (remove decorative boxes/lines) */
  .section-title, .category-header, .compat-category {
    border: none !important;
    box-shadow: none !important;
    background: transparent !important;
    padding: 6px 0 !important;
  }
  /* Hide any dedicated emoji nodes in WEB immediately */
  .category-emoji, .category-header .emoji, .section-title .emoji { display: none !important; }
  /* Keep web tables sane too (helps your on-screen view match PDF) */
  #pdf-container table {
    width: 100%;
    table-layout: fixed;
    border-collapse: collapse;
  }
  </style>

  <script>
  /* ============ Small helpers ============ */

  /** Strip inline emoji out of headers (web + PDF parity). */
  function stripHeaderEmoji(root=document) {
    const emojiRe = /[\p{Extended_Pictographic}\p{Emoji_Presentation}]/gu;
    const nodes = root.querySelectorAll('.section-title, .category-header, .compat-category, th');
    nodes.forEach(n => {
      const txt = (n.textContent || "").replace(emojiRe, '').trim();
      if (txt) n.textContent = txt;
    });
  }

  /** Wait until content is truly rendered:
   * - fonts ready
   * - at least one table with rows
   * - 2 animation frames for layout settle
   */
  async function waitUntilRenderReady(container) {
    // 1) fonts
    if (document.fonts && document.fonts.ready) {
      try { await document.fonts.ready; } catch(_) {}
    }
    // 2) data/tables present
    const t0 = Date.now();
    while (true) {
      const hasRows = Array.from(container.querySelectorAll('table tbody'))
        .some(tb => tb.children && tb.children.length > 0);
      if (hasRows) break;
      if (Date.now() - t0 > 6000) { console.warn('[pdf] Timed out waiting for table rows'); break; }
      await new Promise(r => setTimeout(r, 100));
    }
    // 3) let layout settle for two frames
    await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
  }

  /** Create a black shell, clone #pdf-container, tag it for PDF, and normalize styles. */
  function makePdfClone() {
    const src = document.getElementById('pdf-container');
    if (!src) throw new Error('#pdf-container not found');

    const shell = document.createElement('div');
    Object.assign(shell.style, {
      background: '#000', color: '#fff', margin: '0', padding: '0',
      width: '100%', minHeight: '100vh', overflow: 'visible'
    });

    const clone = src.cloneNode(true);
    clone.classList.add('pdf-export'); // key: activates the CSS above

    // Remove UI-only bits in the clone
    clone.querySelectorAll('[data-hide-in-pdf], .download-btn, .print-btn, nav, header, footer').forEach(el => el.remove());

    // Strip header emoji in the clone
    stripHeaderEmoji(clone);

    shell.appendChild(clone);
    document.body.appendChild(shell);
    return { shell, clone };
  }

  /** Compute a sane capture width so the right edge doesn't get cut. */
  function computeCaptureWidth(el) {
    const r = el.getBoundingClientRect();
    return Math.ceil(Math.max(el.scrollWidth, r.width, document.documentElement.clientWidth));
  }

  /* ============ Main exporter ============ */
  async function downloadCompatibilityPDF() {
    try {
      const src = document.getElementById('pdf-container');
      if (!src) { alert('PDF container not found'); return; }

      // Make sure web headers are clean too (helps what you see = what you get)
      stripHeaderEmoji(document);

      // Ensure your app finished rendering rows etc.
      await waitUntilRenderReady(src);

      // Build black clone
      const { shell, clone } = makePdfClone();

      // One more layout settle on the clone (styles applied)
      await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

      // Ensure tables have fixed layout in the clone as well (belt + suspenders)
      clone.querySelectorAll('table').forEach(t => {
        t.style.width = '100%';
        t.style.tableLayout = 'fixed';
        t.style.borderCollapse = 'collapse';
        t.style.pageBreakInside = 'avoid';
        t.style.breakInside = 'avoid';
      });

      // Prevent row splits
      clone.querySelectorAll('tr').forEach(tr => {
        tr.style.pageBreakInside = 'avoid';
        tr.style.breakInside = 'avoid';
      });

      const captureWidth = computeCaptureWidth(clone);

      // Remove default margins that create white borders in some viewers
      const prevHtmlMargin = document.documentElement.style.margin;
      const prevBodyMargin = document.body.style.margin;
      document.documentElement.style.margin = '0';
      document.body.style.margin = '0';

      // Wait for html2pdf if it’s still loading
      if (!window.html2pdf) {
        await new Promise((res, rej) => {
          let t=0, h=setInterval(() => {
            if (window.html2pdf) { clearInterval(h); res(); }
            else if ((t+=100) > 8000) { clearInterval(h); rej(new Error('html2pdf not loaded')); }
          }, 100);
        });
      }

      const opt = {
        margin: 0,
        filename: 'kink-compatibility.pdf',
        image: { type: 'jpeg', quality: 1 },
        html2canvas: {
          backgroundColor: '#000',       // true black canvas
          scale: 2,
          useCORS: true,
          scrollX: 0, scrollY: 0,
          windowWidth: captureWidth      // ensures right edge is captured
        },
        jsPDF: { unit: 'pt', format: 'letter', orientation: 'portrait' },
        pagebreak: { mode: ['avoid-all', 'css', 'legacy'], before: '.compat-section' }
      };

      await html2pdf().set(opt).from(shell).save();

      // restore margins
      document.documentElement.style.margin = prevHtmlMargin;
      document.body.style.margin = prevBodyMargin;

      // cleanup
      document.body.removeChild(shell);
    } catch (err) {
      console.error('[pdf] generation failed:', err);
      alert('Could not generate PDF. Check console for details.');
    }
  }

  /* ============ Wire the button (supports id or data attribute) ============ */
  (function wireDownloadButton() {
    function getBtn() {
      return document.getElementById('downloadBtn') || document.querySelector('[data-download-pdf]');
    }
    let btn = getBtn();
    if (!btn) return console.warn('[pdf] No download button found. Add id="downloadBtn" or data-download-pdf.');
    // prevent duplicate handlers after hot reloads
    const clone = btn.cloneNode(true);
    btn.replaceWith(clone);
    clone.addEventListener('click', downloadCompatibilityPDF);
  })();

  /* ============ Optional sanity log ============ */
  (function sanity() {
    const c = document.getElementById('pdf-container');
    if (!c) console.error('[pdf] #pdf-container not found.');
  })();
  </script>
  </body>
</html>
