<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Kill-switch for legacy Partner-B bootstrap that caused "freeze after first upload" -->
  <script>
    // Hard disable any code path that auto-fills Partner B from internal JSON.
    // This must be loaded before every other script.
    window.TK_DISABLE_BOOTSTRAP_B = true;
    console.info('[compat] kill-switch enabled');
    // one-time guard so labels/overrides merge only once per load
    window._tkLabelsMerged = false;
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>See Our Compatibility</title>
  <style>
    /* Kill any category dock/panel overlays without layout shift */
    #tkDockCard,
    #categorySurveyPanel,
    aside.category-panel,
    .category-panel,
    [data-testid="select-categories-panel"],
    #tkOverlay,
    .tk-overlay {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }

    /* Ensure body isn't pushed for a removed dock */
    html.tk-dock body {
      margin-left: 0 !important;
    }
  </style>
  <script>
    (function killCategoryPanel() {
      const selectors = [
        '#tkDockCard',
        '#categorySurveyPanel',
        'aside.category-panel',
        '.category-panel',
        '[data-testid="select-categories-panel"]',
        '#tkOverlay',
        '.tk-overlay'
      ];

      window.__TK_DISABLE_PANEL__ = true;
      window.__TK_DISABLE_PORTAL__ = true;

      const purge = () => {
        document.documentElement.classList.remove('tk-dock');
        if (document.body) {
          document.body.style.marginLeft = '';
        }
        selectors.forEach((selector) => {
          document.querySelectorAll(selector).forEach((node) => node.remove());
        });
      };

      purge();

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', purge, { once: true });
      }

      const observer = new MutationObserver(purge);
      observer.observe(document.documentElement, { childList: true, subtree: true });
      setTimeout(() => observer.disconnect(), 4000);
    })();
  </script>
  <!-- COMPAT PAGE: recentre layout + neutralize any dock margin -->
  <style id="compat-centering">
    :root {
      --tk-dock-width: 0px !important;
    }

    html,
    body {
      margin: 0;
    }

    .compat-page,
    .compat-wrapper,
    #compatRoot,
    main,
    .page,
    .container {
      max-width: 960px;
      margin: 0 auto !important;
      padding: 40px 16px;
    }

    .compat-buttons,
    .compat-actions {
      display: flex;
      flex-direction: column;
      gap: 24px;
      align-items: center;
    }

    .compat-buttons .themed-button,
    .compat-actions .themed-button,
    .themed-button.compat {
      width: min(680px, 90vw);
    }
  </style>

  <script>
    (function () {
      try {
        if (document.body) {
          document.body.style.marginLeft = '0px';
        }
        document.documentElement.style.setProperty('--tk-dock-width', '0px');

        const host = document.querySelector(
          '#compatRoot, .compat-page, .compat-wrapper, main, .page, .container'
        );

        if (host) {
          Object.assign(host.style, {
            maxWidth: '960px',
            margin: '0 auto',
            padding: '40px 16px'
          });
        }

        document.querySelectorAll('.themed-button').forEach((btn) => {
          Object.assign(btn.style, {
            width: 'min(680px, 90vw)',
            margin: '0 auto',
            display: 'block'
          });
        });
      } catch (err) {
        console.warn('[compat] unable to apply centering overrides', err);
      }
    })();
  </script>
  <style id="tk-compat-center">
    /* Remove any panel/dock if an older script injected it */
    #tkDockCard,
    #categorySurveyPanel,
    .category-panel,
    .tk-overlay {
      display: none !important;
    }

    html,
    body {
      margin: 0;
    }

    body[style*="margin-left"] {
      margin-left: 0 !important;
    }

    /* Center the content column */
    .compat-wrap,
    .compat-container,
    .container,
    main,
    #app {
      box-sizing: border-box;
      max-width: 960px;
      width: min(960px, 92vw);
      margin-inline: auto;
      padding-inline: 16px;
    }

    .compat-wrap > *,
    .compat-container > *,
    .container > *,
    main > * {
      max-width: 100%;
    }
  </style>
  <script>
    (function () {
      // Nuke any leftover dock/overlay/panel on this page
      for (const sel of ['#tkDockCard', '.tk-overlay', '#categorySurveyPanel', '.category-panel']) {
        const n = document.querySelector(sel);
        if (n) n.remove();
      }

      document.body.style.marginLeft = '';
      const _dock = document.querySelector('#compat-dock');
      if (_dock) {
        _dock.style.removeProperty('margin-bottom');
      }
    })();
  </script>
  <!-- Import theme and global layout styles -->
  <link rel="stylesheet" href="/css/theme.css" />
  <link rel="stylesheet" href="/css/global.css" />
  <link rel="stylesheet" href="/css/compat-table.css" />
  <link rel="stylesheet" href="/css/font-failopen.css">
  <link rel="stylesheet" href="/css/compatibility.css" />
  <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg" />

  <style>
    /* --- Percent bar (Match %) --- */
    .pct {
      position: relative;
      width: 100%;
      height: 22px;
      border: 1px solid #3ddbf3;
      border-radius: 6px;
      background: rgba(61,219,243,0.08);
      overflow: hidden;
    }
    .pct-fill {
      position: absolute;
      inset: 0;
      width: 0%;
      background: linear-gradient(90deg, #18a0fb, #3df3c3);
      transition: width .35s ease;
    }
    .pct-text {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-variant-numeric: tabular-nums;
      font-weight: 600;
    }
    /* Friendly label text in first column (wrap nicely on small screens) */
    .tk-cat {
      white-space: normal;
      line-height: 1.2;
    }
    .tk-code {
      opacity: .5;
      font-size: .85em;
      margin-left: .4rem;
    }
  </style>
  <style>
    td.pct-cell .pct { position: relative; height: 1.1em; line-height: 1.1em; }
    td.pct-cell .pct .bar { position:absolute; left:0; top:0; bottom:0; width:0%;
                            background:rgba(0,255,255,0.25); border-radius:2px; }
    td.pct-cell .pct .txt { position:relative; display:block; text-align:center; }
    td.pct-cell { min-width:5rem; }
  </style>
  <style>
  #pdf-container {
    width: 100%;
    max-width: 100%;
  }
  table {
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    text-align: center;
    vertical-align: middle;
    padding: 6px;
  }
  th:first-child, td:first-child {
    text-align: left;
    padding-left: 10px;
  }
  </style>
  <style>
    .upload-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      margin-top: 3rem;
    }

    .upload-button {
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
    }

    .upload-button input[type="file"] {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .upload-button .upload-trigger {
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .upload-button .upload-trigger:focus-visible {
      outline: 2px solid rgba(61, 219, 243, 0.9);
      outline-offset: 2px;
    }

    .wide-button {
      min-width: 260px;
      max-width: 300px;
      width: 100%;
    }
    .export-tip {
      font-size: 0.9rem;
      margin: 0;
    }
  </style>
  <style>
    /* Keep rows from splitting in both web and print */
    .compat-section tr { break-inside: avoid; page-break-inside: avoid; }

    /* Make sure tables are fixed-width to avoid right-side cutoff */
    .compat-section table {
      width: 100% !important;
      table-layout: fixed !important;
      border-collapse: collapse !important;
    }

    /* Optional: make header clean (no decorative lines/boxes) */
    .section-title, .category-header, .compat-category {
      border: none !important;
      box-shadow: none !important;
      background: transparent !important;
    }
  </style>
  <style>
    /* Force LIGHT pdf colors by default; override via body[style] if you want dark */
    :root { --pdf-bg:#fff; --pdf-text:#000; }
    .pdf-export, #pdfWrapper, .pdf-container {
      background: var(--pdf-bg) !important;
      color: var(--pdf-text) !important;
    }
  </style>
  <style>
    /* optional polish to match your theme */
    .tk-compat th, .tk-compat td{
      border-bottom:1px solid #00e6ff33;
      padding:.55rem .8rem;
      vertical-align:middle;
    }
    .tk-compat td.ta-c{ text-align:center; }
  </style>
  <style>
  /* Small, unobtrusive subtitle under the category code */
  .tk-catwrap { display:flex; flex-direction:column; gap:2px; }
  .tk-catwrap .tk-code { font-weight:600; letter-spacing:0.02em; }
  .tk-catwrap .tk-sub  {
    font-weight:500; opacity:.78;
    font-size: clamp(11px,.9vw,13px);
    line-height:1.2;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    max-width: min(48vw, 780px);  /* fits your wide first column */
  }

  /* Match % meter (tuned for your dark theme) */
  .tk-meter {
    position: relative;
    height: 10px; min-width: 110px;
    background: rgba(0, 230, 255, .12);
    border-radius: 999px;
    outline: 1px solid rgba(0,230,255,.20);
    overflow: hidden;
  }
  .tk-meter > .tk-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg,
      rgba(0,230,255,.88), rgba(120,255,250,.95));
    box-shadow: 0 0 10px rgba(0,230,255,.35) inset;
    border-radius: inherit;
    transition: width .35s ease;
  }
  .tk-meter + .tk-pct {
    display:inline-block; min-width: 42px;
    font-weight:800; letter-spacing:.02em;
    margin-left:.5rem; opacity:.9;
  }

  /* Keep row height stable on narrow screens */
  @media (max-width: 720px){
    .tk-catwrap .tk-sub { max-width: 70vw; }
    .tk-meter { min-width: 80px; }
  }
  </style>
  <style>
  /* ====== Match % chip (compact, no layout shift) ====== */
  .tk-match-chip{
    display:inline-flex; flex-direction:column; align-items:center; gap:6px;
    min-width:70px; line-height:1; vertical-align:middle;
  }
  .tk-match-num{ font-weight:800; letter-spacing:.02em; }
  .tk-match-bar{
    position:relative; width:90px; height:7px; border-radius:999px;
    outline:1px solid rgba(0,230,255,.35);
    background:rgba(0,230,255,.10); overflow:hidden;
  }
  .tk-match-fill{
    display:block; height:100%; width:var(--w,0%);
    background:linear-gradient(90deg,#00e6ff,#3bffc4);
    border-radius:inherit; transition:width .25s ease;
  }
  /* Dim the bar if the value is “missing” on that row */
  .tk-match-chip[data-missing="1"] .tk-match-bar{ opacity:.38; }

  /* ====== Category main + tiny subline (summary) ====== */
  .tk-cat-wrap{ display:flex; flex-direction:column; gap:3px; }
  .tk-cat-main{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .tk-cat-sub{
    font-size:.82em; color:#9beff7; opacity:.78;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    max-width:48ch;  /* keep it subtle; doesn’t stretch your layout */
  }
  /* On narrow screens you can hide the subline if you want */
  @media (max-width: 680px){
    .tk-cat-sub{ display:none; }
  }
  </style>
  <style>
  /* Compatibility table progressive enhancement (fallback match bar + labels) */
  td.ksv-match { white-space: nowrap; }

  .ksv-matchwrap{
    display:flex; flex-direction:column; align-items:center; gap:.4rem;
    min-width:8rem;
  }
  .ksv-pct{
    font: 800 0.95rem/1.1 system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    letter-spacing:.02em; color:#d9ffff;
  }
  .ksv-bar{
    width:100%; height:6px; border-radius:999px;
    background: rgba(0,230,255,.12);
    outline: 1px solid rgba(0,230,255,.35);
    overflow:hidden;
  }
  .ksv-bar > i{
    display:block; height:100%; width:var(--w,0%);
    background: linear-gradient(90deg,#00e6ff 0%, #5fffd6 100%);
    box-shadow: 0 0 6px #00e6ff66 inset;
  }

  td.ksv-cat{
    word-break: break-word;
  }
  .ksv-cat .ksv-cat-text{
    display:inline;
  }
  </style>

  <link rel="stylesheet" href="/assets/css/comparison.css" />
</head>
<body data-page="compat">
  <main class="tk-landing">
    <h1 class="tk-title">TalkKink Compatibility</h1>

    <div class="tk-menu">
      <label for="fileA" class="tk-btn">Upload Your Survey</label>
      <label for="fileB" class="tk-btn">Upload Partner’s Survey</label>
      <button id="btnDownloadPdf" class="tk-btn" disabled>Download PDF</button>
    </div>

        <a href="https://talkkink.org/KinkSurveyPage/index.html" class="tk-btn back">← Back</a>

    <input id="fileA" type="file" accept=".json" hidden />
    <input id="fileB" type="file" accept=".json" hidden />
  </main>

  <script>
    function ksvParseSurveyJsonText(jsonText, partner = 'A') {
      const fail = (reason) => ({ ok: false, reason, cells: [], survey: null });
      if (typeof jsonText !== 'string') return fail('No JSON payload provided');

      let payload;
      try {
        payload = JSON.parse(jsonText);
      } catch (err) {
        return fail('Invalid JSON');
      }

      const answers = {};
      const answersByKey = {};
      let maxIndex = 0;

      const clamp = (value) => {
        const n = Number(value);
        if (!Number.isFinite(n)) return 0;
        if (n < 0) return 0;
        if (n > 5) return 5;
        return Math.round(n);
      };

      const toRating = (value) => {
        if (value == null || value === '') return 0;
        if (typeof value === 'number' && Number.isFinite(value)) return clamp(value);
        if (typeof value === 'string') {
          const trimmed = value.trim();
          if (!trimmed) return 0;
          const match = trimmed.match(/-?\d+(?:\.\d+)?/);
          if (match) return clamp(Number(match[0]));
        }
        return 0;
      };

      const applyRating = (index, value) => {
        const idx = Number(index);
        if (!Number.isFinite(idx) || idx <= 0) return;
        const normalized = toRating(value);
        const key = String(idx);
        answersByKey[key] = normalized;
        if (idx > maxIndex) maxIndex = idx;
      };

      const absorbArray = (arr) => {
        if (!Array.isArray(arr)) return;
        arr.forEach((value, i) => applyRating(i + 1, value));
      };

      const absorbObject = (obj) => {
        if (!obj || typeof obj !== 'object') return;
        Object.keys(obj)
          .sort((a, b) => Number(a) - Number(b))
          .forEach((key) => applyRating(key, obj[key]));
      };

      if (Array.isArray(payload)) {
        absorbArray(payload);
      } else if (payload && typeof payload === 'object') {
        absorbArray(payload.cells);
        absorbArray(payload.answers);
        absorbObject(payload.answersByKey);
        absorbObject(payload.answersById);
        absorbObject(payload.ratings);
      } else {
        return fail('Unsupported survey payload');
      }

      if (!maxIndex) {
        return fail('No survey answers found');
      }

      for (let i = 1; i <= maxIndex; i += 1) {
        const key = String(i);
        const rating = Object.prototype.hasOwnProperty.call(answersByKey, key)
          ? answersByKey[key]
          : 0;
        answers[key] = rating;
        answersByKey[key] = rating;
      }

      const cells = Array.from({ length: maxIndex }, (_, i) => answersByKey[String(i + 1)] ?? 0);
      return { ok:true, cells, survey: { answers, answersByKey } };
}

    window.ksvParseSurveyJsonText = ksvParseSurveyJsonText;
  </script>

  <script defer src="/assets/js/comparison.js"></script>
  <!-- ===== TalkKink: inline PDF + upload logic (standalone) ===== -->
  <script>
/* ---- 1) Remove the two problematic scripts if they’re on the page ---- */
(function killBadIncludes(){
  const sel = 'script[src*="theme-globals.js"],script[src*="pdfDownload.js"]';
  document.querySelectorAll(sel).forEach(node => {
    try {
      node.parentNode?.removeChild(node);
    } catch (_) {
      /* ignore */
    }
  });
})();

/* ---- 2) Null-guard for the “dock margin” style error ---- */
try {
  const dock = document.querySelector('[data-dock-margin]') ||
               document.getElementById('dock-margin') ||
               document.querySelector('.dock-margin');
  if (dock && dock.style) dock.style.margin = '';
} catch (_) {}

/* ---- 3) Minimal standalone PDF exporter (jsPDF via CDN) ---- */
(function () {
  const PAGE = { w: 612, h: 792 };
  const MARGIN = { t: 48, r: 40, b: 54, l: 40 };
  const LINE = 16;
  const COL_GAP = 18;
  const SELF_KEYS = ['talkkink:survey', 'talkkink:mine', 'tk_compat.self'];
  const PARTNER_KEYS = ['talkkink:partner', 'tk_compat.partner'];

  const nowStamp = () => {
    const d = new Date();
    const pad = (n) => String(n).padStart(2, '0');
    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
  };

  async function loadJsPDF() {
    if (window.jspdf?.jsPDF) return window.jspdf.jsPDF;
    await new Promise((res, rej) => {
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js';
      s.async = true;
      s.onload = res;
      s.onerror = () => rej(new Error('jsPDF load failed'));
      document.head.appendChild(s);
    });
    if (!(window.jspdf?.jsPDF)) throw new Error('jsPDF init failed');
    return window.jspdf.jsPDF;
  }

  function normalizeRating(value) {
    const num = Number(value);
    if (!Number.isFinite(num)) return 0;
    return Math.max(0, Math.min(5, Math.round(num)));
  }

  function normalizeRows(survey) {
    const rows = Array.isArray(survey?.responses) ? survey.responses : [];
    return rows.map((row, idx) => ({
      id: row.id ?? row.prompt ?? row.text ?? row.title ?? `item-${idx}`,
      prompt: row.prompt ?? row.text ?? row.title ?? row.label ?? row.question ?? row.id ?? '',
      category: row.category ?? row.categoryId ?? row.cat ?? row.section ?? 'Other',
      rating: normalizeRating(row.rating ?? row.score ?? row.value ?? row.answer ?? 0),
      index: row.index ?? row.order ?? row.position ?? idx
    }));
  }

  const groupByCategory = (survey) => {
    const grouped = new Map();
    normalizeRows(survey).forEach(row => {
      if (!grouped.has(row.category)) grouped.set(row.category, []);
      grouped.get(row.category).push(row);
    });
    for (const list of grouped.values()) {
      list.sort((a, b) => (a.index ?? 0) - (b.index ?? 0));
    }
    return grouped;
  };

  const summarize = (survey) => {
    const counts = [0, 0, 0, 0, 0, 0];
    normalizeRows(survey).forEach(row => {
      counts[row.rating] += 1;
    });
    return counts;
  };

  function addWrapText(doc, text, x, y, maxW, lh) {
    const words = String(text || '').split(/\s+/);
    let line = '';
    let cy = y;
    const width = (t) => doc.getTextWidth(t);
    words.forEach(word => {
      const test = line ? `${line} ${word}` : word;
      if (width(test) > maxW) {
        if (line) {
          doc.text(line, x, cy);
          cy += lh;
        }
        line = word;
      } else {
        line = test;
      }
    });
    if (line) {
      doc.text(line, x, cy);
      cy += lh;
    }
    return cy;
  }

  function header(doc, title, subtitle) {
    doc.setFillColor(0, 0, 0);
    doc.rect(0, 0, PAGE.w, PAGE.h, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(32);
    doc.text(title, PAGE.w / 2, MARGIN.t, { align: 'center', baseline: 'top' });
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(12);
    doc.text(subtitle, PAGE.w / 2, MARGIN.t + 28, { align: 'center', baseline: 'top' });
    return MARGIN.t + 42;
  }

  function addFooter(doc, page, total) {
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(9);
    doc.setTextColor(180, 180, 180);
    doc.text(`TalkKink • ${nowStamp()} • Page ${page}/${total}`, PAGE.w / 2, PAGE.h - MARGIN.b + 24, { align: 'center', baseline: 'bottom' });
  }

  function block(doc, cat, items, startY) {
    let cy = startY + 6;
    const x = MARGIN.l;
    const maxW = PAGE.w - MARGIN.l - MARGIN.r;
    if (cat) {
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(16);
      doc.setTextColor(255, 255, 255);
      cy = addWrapText(doc, cat, x, cy, maxW, LINE);
    }
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(11);
    doc.setTextColor(220, 220, 220);
    for (const row of items) {
      const chip = ` [${row.rating}] `;
      const bullet = '• ';
      const headW = doc.getTextWidth(bullet + chip);
      doc.text(bullet, x, cy);
      doc.setTextColor(140, 230, 255);
      doc.text(chip, x + doc.getTextWidth(bullet), cy);
      doc.setTextColor(220, 220, 220);
      const px = x + headW + 2;
      cy = addWrapText(doc, row.prompt || row.id, px, cy, maxW - headW - 4, LINE - 2) - 4;
      cy += 4;
      if (cy > PAGE.h - MARGIN.b - 40) {
        doc.addPage('letter', 'portrait');
        doc.setFillColor(0, 0, 0);
        doc.rect(0, 0, PAGE.w, PAGE.h, 'F');
        cy = MARGIN.t;
      }
    }
    doc.setDrawColor(60, 120, 140);
    doc.line(MARGIN.l, cy, PAGE.w - MARGIN.r, cy);
    return cy + 10;
  }

  function summary(doc, survey, label, startY) {
    const counts = summarize(survey);
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(14);
    doc.setTextColor(255, 255, 255);
    doc.text(`${label} — Rating Summary`, MARGIN.l, startY);
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(11);
    doc.setTextColor(200, 200, 200);
    doc.text(counts.map((count, rating) => `${rating}: ${count}`).join('    '), MARGIN.l, startY + LINE);
    return startY + LINE * 2;
  }

  function pickSources(opts = {}) {
    const out = { mine: opts.mine ?? null, partner: opts.partner ?? null };
    if (!out.mine) out.mine = window.talkkinkMine || window.talkkinkSurvey;
    if (!out.partner) out.partner = window.talkkinkPartner;
    try {
      if (!out.mine) {
        for (const key of SELF_KEYS) {
          const value = localStorage.getItem(key);
          if (value) { out.mine = JSON.parse(value); break; }
        }
      }
      if (!out.partner) {
        for (const key of PARTNER_KEYS) {
          const value = localStorage.getItem(key);
          if (value) { out.partner = JSON.parse(value); break; }
        }
      }
    } catch (_) {}
    return out;
  }

  async function buildPdf({ mine, partner, filename }) {
    const jsPDF = await loadJsPDF();
    const doc = new jsPDF({ unit: 'pt', format: 'letter', compress: true });
    const title = partner ? 'TalkKink Compatibility Report' : 'TalkKink Survey Export';
    const mineCats = mine?.meta?.selectedCategories?.join(', ') || 'All Categories';
    const partnerCats = partner?.meta?.selectedCategories?.join(', ') || 'All Categories';
    const subtitle = partner
      ? `Exported ${nowStamp()} • Mine: ${mineCats} • Partner: ${partnerCats}`
      : `Exported ${nowStamp()} • Selected: ${mineCats}`;

    let y = header(doc, title, subtitle);
    if (partner) {
      y = summary(doc, mine, 'Mine', y);
      y = summary(doc, partner, 'Partner', y) + 6;
    } else {
      y = summary(doc, mine, 'Summary', y) + 6;
    }

    const mineMap = groupByCategory(mine);
    const partnerMap = partner ? groupByCategory(partner) : null;

    for (const [cat, items] of mineMap.entries()) {
      if (y > PAGE.h - MARGIN.b - 120) {
        doc.addPage('letter', 'portrait');
        doc.setFillColor(0, 0, 0);
        doc.rect(0, 0, PAGE.w, PAGE.h, 'F');
        y = MARGIN.t;
      }

      if (partner && partnerMap) {
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(18);
        doc.setTextColor(255, 255, 255);
        y = addWrapText(doc, cat, MARGIN.l, y, PAGE.w - MARGIN.l - MARGIN.r, LINE) + 2;

        const colW = (PAGE.w - MARGIN.l - MARGIN.r - COL_GAP) / 2;
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(12);
        doc.text('Mine', MARGIN.l, y);
        const yL = block(doc, '', items, y + LINE - LINE);

        let yR = y;
        let xR = MARGIN.l + colW + COL_GAP;
        if (yR + 40 > PAGE.h - MARGIN.b) {
          doc.addPage('letter', 'portrait');
          doc.setFillColor(0, 0, 0);
          doc.rect(0, 0, PAGE.w, PAGE.h, 'F');
          yR = MARGIN.t;
        }
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(12);
        doc.text('Partner', xR, yR);
        yR += LINE;

        (function drawRight() {
          let cy = yR + 6;
          const maxW = colW;
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(11);
          doc.setTextColor(220, 220, 220);
          for (const row of partnerMap.get(cat) || []) {
            const chip = ` [${row.rating}] `;
            const bullet = '• ';
            const headW = doc.getTextWidth(bullet + chip);
            doc.text(bullet, xR, cy);
            doc.setTextColor(140, 230, 255);
            doc.text(chip, xR + doc.getTextWidth(bullet), cy);
            doc.setTextColor(220, 220, 220);
            const px = xR + headW + 2;
            cy = addWrapText(doc, row.prompt || row.id, px, cy, maxW - headW - 4, LINE - 2) - 4;
            cy += 4;
            if (cy > PAGE.h - MARGIN.b - 40) {
              doc.addPage('letter', 'portrait');
              doc.setFillColor(0, 0, 0);
              doc.rect(0, 0, PAGE.w, PAGE.h, 'F');
              cy = MARGIN.t;
            }
          }
          doc.setDrawColor(60, 120, 140);
          doc.line(xR, cy, xR + maxW, cy);
          yR = cy + 12;
        })();

        y = Math.max(yL, yR) + 10;
      } else {
        y = block(doc, cat, items, y);
      }
    }

    const total = doc.internal.getNumberOfPages();
    for (let i = 1; i <= total; i += 1) {
      doc.setPage(i);
      addFooter(doc, i, total);
    }
    doc.save(filename || (partner ? 'talkkink-compatibility-results.pdf' : 'talkkink-survey-results.pdf'));
  }

  window.TKPDF = window.TKPDF || {};
  window.TKPDF.download = (opts = {}) => {
    const { mine, partner } = pickSources(opts);
    if (!mine) {
      alert('Export unavailable: no survey data found.');
      return;
    }
    buildPdf({ mine, partner, filename: opts.filename }).catch(err => {
      console.error(err);
      alert('Export failed.');
    });
  };

  function attachUpload(btn, key, input) {
    if (!btn && !input) return;
    let fileInput = input || null;
    const created = !fileInput;
    if (!fileInput) {
      fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = 'application/json';
      fileInput.style.display = 'none';
      document.body.appendChild(fileInput);
    } else if (!fileInput.accept) {
      fileInput.accept = 'application/json';
    }

    const isLabelForInput = Boolean(btn && fileInput && btn.tagName === 'LABEL' && btn.htmlFor && fileInput.id && btn.htmlFor === fileInput.id);
    if (btn && !isLabelForInput && btn !== fileInput) {
      btn.addEventListener('click', () => fileInput.click());
    }

    fileInput.addEventListener('change', async () => {
      const file = fileInput.files?.[0];
      if (!file) return;
      try {
        const text = await file.text();
        const json = JSON.parse(text);
        localStorage.setItem(key, text);
        if (key === 'talkkink:mine') {
          window.talkkinkMine = json;
          window.talkkinkSurvey = json;
        }
        if (key === 'talkkink:partner') {
          window.talkkinkPartner = json;
        }
        alert('Uploaded ✓');
      } catch (err) {
        console.error(err);
        alert('Invalid file — expected TalkKink JSON export.');
      }
      if (created) {
        fileInput.value = '';
      }
    });
  }

  function findBtn(txt) {
    const needle = (txt || '').toLowerCase();
    return Array.from(document.querySelectorAll('button,a,[role="button"]')).find(el => (el.textContent || '').toLowerCase().includes(needle));
  }

  function bindUI() {
    const mineBtn = document.getElementById('uploadMineBtn') || findBtn('upload your survey');
    const partnerBtn = document.getElementById('uploadPartnerBtn') || findBtn('upload partner');
    const dlBtn = document.getElementById('downloadPdfBtn') || document.getElementById('btnDownloadPdf') || findBtn('download pdf');
    const mineInput = document.getElementById('fileA') || document.querySelector('[data-upload-input="mine"]');
    const partnerInput = document.getElementById('fileB') || document.querySelector('[data-upload-input="partner"]');
    attachUpload(mineBtn, 'talkkink:mine', mineInput);
    attachUpload(partnerBtn, 'talkkink:partner', partnerInput);
    if (dlBtn) {
      dlBtn.addEventListener('click', () => window.TKPDF.download());
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bindUI);
  } else {
    bindUI();
  }
})();
  </script>
  <script defer>
    /**
     * Safely clear margin on the dock *only if it exists on this page*.
     * This replaces any previous null-unsafe code around lines ~188–192.
     */
    (function () {
      const SELECTOR = '#compat-dock, .compat-dock, [data-compat-dock]';

      function clearDockMarginSafe() {
        const el = document.querySelector(SELECTOR);
        if (!el) return;                  // No-op if the dock isn't present
        el.style.removeProperty('margin');
        el.style.removeProperty('margin-bottom');
      }

      // Run after DOM is parsed; also handle late mounts briefly
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', clearDockMarginSafe, { once: true });
      } else {
        queueMicrotask(clearDockMarginSafe);
      }
      const mo = new MutationObserver(() => {
        const el = document.querySelector(SELECTOR);
        if (el) { clearDockMarginSafe(); mo.disconnect(); }
      });
      mo.observe(document.documentElement, { childList: true, subtree: true });
      setTimeout(() => mo.disconnect(), 3000);
    })();
  </script>
</body>

</html>
