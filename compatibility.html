<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>See Our Compatibility</title>
  <!-- Import theme and global layout styles -->
  <link rel="stylesheet" href="/css/theme.css" />
  <link rel="stylesheet" href="/css/global.css" />
  <link rel="stylesheet" href="/css/compat-table.css" />
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet" />
  <style>
  #pdf-container {
    width: 100%;
    max-width: 100%;
  }
  table {
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    text-align: center;
    vertical-align: middle;
    padding: 6px;
  }
  th:first-child, td:first-child {
    text-align: left;
    padding-left: 10px;
  }
  </style>
  <style>
    .upload-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      margin-top: 3rem;
    }

      .upload-button {
        position: relative;
        display: inline-block;
      }

    .upload-button input[type="file"] {
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .wide-button {
      min-width: 260px;
      max-width: 300px;
      width: 100%;
    }
    .export-tip {
      font-size: 0.9rem;
      margin: 0;
    }
  </style>
  <style>
    /* Keep rows from splitting in both web and print */
    .compat-section tr { break-inside: avoid; page-break-inside: avoid; }

    /* Make sure tables are fixed-width to avoid right-side cutoff */
    .compat-section table {
      width: 100% !important;
      table-layout: fixed !important;
      border-collapse: collapse !important;
    }

    /* Optional: make header clean (no decorative lines/boxes) */
    .section-title, .category-header, .compat-category {
      border: none !important;
      box-shadow: none !important;
      background: transparent !important;
    }
  </style>
  <style>
    /* Force LIGHT pdf colors by default; override via body[style] if you want dark */
    :root { --pdf-bg:#fff; --pdf-text:#000; }
    .pdf-export, #pdfWrapper, .pdf-container {
      background: var(--pdf-bg) !important;
      color: var(--pdf-text) !important;
    }
  </style>
</head>
<body class="theme-dark">
  <div class="main-container themed">
    <h1 class="page-title">See Our Compatibility</h1>
    <div class="upload-container">
      <button class="themed-button wide-button" onclick="window.history.back()">← Back</button>

      <label id="uploadYourSurvey" class="upload-button themed-button wide-button">
        <input id="uploadSurveyA" type="file" accept="application/json" />
        Upload Your Survey
      </label>

      <label id="uploadPartnerSurvey" class="upload-button themed-button wide-button">
        <input id="uploadSurveyB" type="file" accept="application/json" />
        Upload Partner’s Survey
      </label>

      <button class="themed-button wide-button" id="downloadBtn">Download PDF</button>
      <p id="exportTip" class="export-tip">Upload both surveys before exporting.</p>
    </div>

    <div id="comparisonResults">
      <p id="comparisonResult"></p>
      <div id="loading-spinner" class="loading-overlay"><div class="spinner"></div></div>
      <div id="pdf-container" class="compat-root" data-compat-root></div>
      <div class="print-footer"></div>
    </div>
  </div>

  <script src="js/template-survey.js"></script>
  <script type="module" src="js/compatibilityPage.js"></script>
  <script type="module">
    import { initTheme, applyThemeColors } from './js/theme.js';
    initTheme();
    window.applyThemeColors = applyThemeColors;
  </script>
  <!-- Safe session check script -->
  <script>
  /**
   * Safe session check:
   * - Silently ignores 404 / network errors (useful on static hosting & local previews)
   * - Only redirects on 401 Unauthorized
   * - Won’t throw or spam the console
   *
   * How to use:
   * 1) Paste this block.
   * 2) Delete the old:
   *      fetch("/check-session", { credentials: "include" })
   *        .then(res => { if (res.status === 401) window.location.href = "/token.html"; });
   * 3) Call safeCheckSession(); (or skip entirely if you don’t need auth)
   */

  (function(){
    function safeCheckSession(opts){
      const cfg = Object.assign({
        url: '/check-session',          // change if your API path differs
        redirectTo: '/token.html',      // where to send on 401
        credentials: 'include',         // send cookies if present
        log: false,                     // set true to log non-401 statuses
        skipHosts: undefined,           // overrideable allow list of static hosts
        skipHostSuffixes: undefined,    // overrideable suffix allow list (e.g. github.io)
        skipOnFileProtocol: true,       // skip when opened via file:// by default
        force: false                    // set true to bypass the skip guards
      }, (opts || {}));

      const host = (window.location && window.location.hostname || '').toLowerCase();
      const proto = (window.location && window.location.protocol) || '';

      const defaultHosts = ['talkkink.org', 'www.talkkink.org'];
      const defaultSuffixes = ['github.io'];
      const skipHosts = Array.isArray(cfg.skipHosts) && cfg.skipHosts.length ? cfg.skipHosts : defaultHosts;
      const skipSuffixes = Array.isArray(cfg.skipHostSuffixes) && cfg.skipHostSuffixes.length ? cfg.skipHostSuffixes : defaultSuffixes;

      const matchesHost = !!host && skipHosts.some(h => h && host === String(h).toLowerCase());
      const matchesSuffix = !!host && skipSuffixes.some(s => s && host.endsWith(String(s).toLowerCase()));
      const isFile = cfg.skipOnFileProtocol !== false && proto === 'file:';

      if (!cfg.force && (isFile || matchesHost || matchesSuffix)) {
        if (cfg.log) {
          console.info('[session] skipped check-session fetch for host:', host || '(unknown host)');
        }
        return;
      }

      try {
        fetch(cfg.url, { credentials: cfg.credentials })
          .then(res => {
            if (res.status === 401) {
              // Only redirect on explicit 401
              window.location.href = cfg.redirectTo;
              return;
            }
            // Silence 404s and other statuses unless logging is enabled
            if (cfg.log && res.status !== 204 && res.status !== 200) {
              console.info('[session] status:', res.status);
            }
          })
          .catch(() => {
            // Network error / CORS / offline — ignore quietly
          });
      } catch (_) {
        // Older browsers / unexpected errors — ignore
      }
    }

    // OPTIONAL: run automatically on load (safe even if endpoint doesn’t exist)
    document.addEventListener('DOMContentLoaded', function(){
      safeCheckSession();
    });

    // Expose if you want to call manually later
    window.safeCheckSession = safeCheckSession;
  })();
  </script>

<script>
/* ==== COMPAT: Robust A/B Fill (markup-agnostic) ==== *
 * Supports three table shapes:
 *  1) Cells with data-partner-a / data-partner-b attributes             (preferred)
 *  2) Cells with .pa / .pb classes                                      (legacy)
 *  3) No markers, but THEAD headers literally "Partner A" / "Partner B" (auto-tag)
 *
 * Also:
 *  - Annotates rows with data-full (full visible label) and data-id (normalized key)
 *  - Matches JSON -> rows by data-id -> data-full -> visible text -> fuzzy overlap
 *  - Bootstraps a simple table if your container has 0 rows
 *  - Recomputes a Match % (assumes 1–5 scale)
 *
 * Requirements:
 *  - Your wrapper has data-compat-root OR you use #pdf-container
 *  - First column is the label cell (visible text)
 *  - Keep THEAD headers: Category | Partner A | Match | Partner B (lets us auto-tag A/B)
 */

(function(){
  /* ---------- normalizers ---------- */
  function norm(s){
    return String(s||'')
      .replace(/[\u2018\u2019\u2032]/g,"'")
      .replace(/[\u201C\u201D\u2033]/g,'"')
      .replace(/[\u2013\u2014]/g,'-')
      .replace(/\u2026/g,'')
      .replace(/[^\w\s'-]/g,' ')
      .replace(/\s+/g,' ')
      .trim().toLowerCase();
  }
  const toks = s => norm(s).split(' ').filter(Boolean);

  /* ---------- JSON → lookup ---------- */
  function toLookup(json){
    const map = new Map();
    if (!json || typeof json !== 'object') return map;

    // flat {key:value}
    if (!Array.isArray(json) && !json.items && !json.survey){
      for (const [k,v] of Object.entries(json)){
        const n = Number(v); if (Number.isFinite(n)) map.set(norm(k), n);
      }
      return map;
    }

    // items array
    if (Array.isArray(json.items)){
      for (const it of json.items){
        const k = norm(it?.name ?? it?.label ?? it?.key ?? it?.id ?? '');
        const n = Number(it?.rating ?? it?.score ?? it?.value);
        if (k && Number.isFinite(n)) map.set(k, n);
      }
      return map;
    }

    // nested survey export
    if (json.survey && typeof json.survey === 'object'){
      Object.values(json.survey).forEach(section=>{
        ['Giving','Receiving','General'].forEach(bucket=>{
          (Array.isArray(section?.[bucket])?section[bucket]:[]).forEach(it=>{
            const k = norm(it?.name ?? it?.label ?? it?.id ?? '');
            const n = Number(it?.rating ?? it?.score ?? it?.value);
            if (k && Number.isFinite(n)) map.set(k, Math.max(map.get(k)??-Infinity, n));
          });
        });
      });
    }
    return map;
  }

  /* ---------- DOM helpers ---------- */
  function getRoot(){
    return document.querySelector('[data-compat-root]') || document.querySelector('#pdf-container') || document.body;
  }

  // If no rows exist, create a simple "All" table from the union of JSON keys
  function bootstrapIfEmpty(root){
    const hasRows = root.querySelectorAll('tbody tr').length > 0;
    if (hasRows) return false;

    const aMap = toLookup(window.partnerASurvey || window.surveyA || {});
    const bMap = toLookup(window.partnerBSurvey || window.surveyB || {});
    const keys = new Set([...aMap.keys(), ...bMap.keys()]);
    if (!keys.size) return false;

    const section = document.createElement('section'); section.className = 'compat-section';
    const h2 = document.createElement('h2'); h2.className = 'section-title'; h2.textContent = 'All'; section.appendChild(h2);

    const table = document.createElement('table'); table.className = 'compat-table';
    const thead = document.createElement('thead'); const thr = document.createElement('tr');
    ['Category','Partner A','Match','Partner B'].forEach(t=>{ const th=document.createElement('th'); th.textContent=t; thr.appendChild(th); });
    thead.appendChild(thr);
    const tbody = document.createElement('tbody');

    keys.forEach(k=>{
      const tr = document.createElement('tr');
      tr.setAttribute('data-id', k);
      tr.setAttribute('data-full', k);
      const td0 = document.createElement('td'); td0.textContent = k;
      const tda = document.createElement('td'); tda.className = 'pa'; tda.setAttribute('data-partner-a',''); tda.textContent = aMap.has(k) ? aMap.get(k) : '-';
      const tdm = document.createElement('td'); tdm.className = 'match';
      const tdb = document.createElement('td'); tdb.className = 'pb'; tdb.setAttribute('data-partner-b',''); tdb.textContent = bMap.has(k) ? bMap.get(k) : '-';
      tr.append(td0, tda, tdm, tdb); tbody.appendChild(tr);
    });

    table.append(thead, tbody); section.appendChild(table);
    root.innerHTML = ''; root.appendChild(section);
    console.log(`[compat] bootstrapped ${keys.size} rows from JSON union.`);
    return true;
  }

  // Ensure each row has data-full and data-id
  function annotateRows(root){
    root.querySelectorAll('table tbody tr').forEach(tr=>{
      const first = tr.querySelector('td:first-child, th:first-child');
      const vis = first ? (first.textContent || '') : '';
      if (!tr.hasAttribute('data-full') && vis) tr.setAttribute('data-full', vis);
      if (!tr.hasAttribute('data-id')){
        const canon = norm(tr.getAttribute('data-full') || vis);
        if (canon) tr.setAttribute('data-id', canon);
      }
    });
  }

  // If there are no .pa/.pb markers, use THEAD headers to tag the columns
  function ensurePartnerMarkers(root){
    root.querySelectorAll('table').forEach(table=>{
      const thead = table.querySelector('thead tr'); if (!thead) return;
      const ths = Array.from(thead.children).map(th => norm(th.textContent));
      const idxA = ths.indexOf('partner a');
      const idxB = ths.indexOf('partner b');

      const tbody = table.querySelector('tbody'); if (!tbody) return;
      if (idxA >= 0 && !tbody.querySelector('td.pa, td[data-partner-a]')){
        tbody.querySelectorAll('tr').forEach(tr=>{ const td = tr.children[idxA]; if (td){ td.classList.add('pa'); td.setAttribute('data-partner-a',''); }});
      }
      if (idxB >= 0 && !tbody.querySelector('td.pb, td[data-partner-b]')){
        tbody.querySelectorAll('tr').forEach(tr=>{ const td = tr.children[idxB]; if (td){ td.classList.add('pb'); td.setAttribute('data-partner-b',''); }});
      }
    });
  }

  /* ---------- matching ---------- */
  function rowKeyBundle(tr){
    const id   = tr.getAttribute('data-id')   || '';
    const full = tr.getAttribute('data-full') || '';
    const vis  = tr.querySelector('td:first-child, th:first-child')?.textContent || '';
    return { kId: norm(id), kFull: norm(full), kVis: norm(vis) };
  }

  function pickValue(keys, lookup){
    // 1) exact id
    if (keys.kId && lookup.has(keys.kId)) return lookup.get(keys.kId);
    // 2) exact full
    if (keys.kFull && lookup.has(keys.kFull)) return lookup.get(keys.kFull);
    // 3) exact visible
    if (keys.kVis && lookup.has(keys.kVis)) return lookup.get(keys.kVis);
    // 4) contains (either direction)
    for (const [lk, val] of lookup.entries()){
      if (lk.includes(keys.kFull) || keys.kFull.includes(lk)) return val;
      if (lk.includes(keys.kVis)  || keys.kVis.includes(lk))  return val;
    }
    // 5) token overlap ≥60% or ≥4 shared tokens
    const tryKeys = [keys.kFull, keys.kVis].filter(Boolean);
    for (const rk of tryKeys){
      const rt = toks(rk); if (!rt.length) continue;
      for (const [lk, val] of lookup.entries()){
        const lt = toks(lk); if (!lt.length) continue;
        const set = new Set(lt);
        const shared = rt.filter(t=>set.has(t)).length;
        const overlap = Math.min(shared/rt.length, shared/lt.length);
        if (shared >= 4 || overlap >= 0.6) return val;
      }
    }
    return undefined;
  }

  /* ---------- fill + match ---------- */
  function fillColumn(root, selectorList, lookup){
    if (!lookup || !lookup.size) return 0;
    const rows = root.querySelectorAll('table tbody tr');
    let wrote = 0;
    rows.forEach(tr=>{
      const td = tr.querySelector(selectorList);
      if (!td) return;
      const current = (td.textContent || '').trim();
      if (current && !/^[-–—]$/.test(current)) return; // don't overwrite real values
      const val = pickValue(rowKeyBundle(tr), lookup);
      if (val == null) return;
      td.textContent = String(val);
      wrote++;
    });
    return wrote;
  }

  function computeMatch(a, b){
    const na = Number(a), nb = Number(b);
    if (!Number.isFinite(na) || !Number.isFinite(nb)) return '';
    const diff = Math.abs(na - nb);                      // 0..4
    return Math.round((1 - diff/4) * 100) + '%';         // 100..0
  }

  function recomputeMatches(root){
    root.querySelectorAll('table tbody tr').forEach(tr=>{
      const a = tr.querySelector('td[data-partner-a], td.pa')?.textContent;
      const b = tr.querySelector('td[data-partner-b], td.pb')?.textContent;
      const m = tr.querySelector('td[data-match]') || tr.children[2]; // assume 3rd col if standard
      if (m && m.tagName === 'TD') m.textContent = computeMatch(a, b);
    });
  }

  /* ---------- main entry ---------- */
  function runFill(){
    const root = getRoot();
    if (!root) return;

    // If empty, create a minimal table so we can fill something
    bootstrapIfEmpty(root);

    // Make keys discoverable & cells targetable
    annotateRows(root);
    ensurePartnerMarkers(root);

    const aMap = toLookup(window.partnerASurvey || window.surveyA || {});
    const bMap = toLookup(window.partnerBSurvey || window.surveyB || {});

    const wroteA = fillColumn(root, 'td[data-partner-a], td.pa', aMap);
    const wroteB = fillColumn(root, 'td[data-partner-b], td.pb', bMap);

    if (wroteA || wroteB) recomputeMatches(root);
    if (typeof window.populateFlags === 'function') window.populateFlags();

    console.log(`[compat] filled Partner A cells: ${wroteA}; Partner B cells: ${wroteB}`);
  }

  // Wire uploads (Partner A / Partner B)
  document.addEventListener('change', async e=>{
    if (!e.target) return;
    if (e.target.matches('#uploadSurveyA,[data-upload-a],#uploadSurveyB,[data-upload-b]')){
      // If your upload handlers already parse JSON and set window.partnerASurvey/window.partnerBSurvey,
      // runFill will use them. If not, attempt quick inline parsing:
      const f = e.target.files && e.target.files[0];
      if (f && (
        (e.target.matches('#uploadSurveyA,[data-upload-a]') && !window.partnerASurvey) ||
        (e.target.matches('#uploadSurveyB,[data-upload-b]') && !window.partnerBSurvey)
      )){
        try {
          const json = JSON.parse(await f.text());
          if (e.target.matches('#uploadSurveyA,[data-upload-a]')) window.partnerASurvey = json;
          else window.partnerBSurvey = json;
        } catch {}
      }
      setTimeout(runFill, 150);
    }
  });

  // Expose manual trigger + run once
  window.__compatRunFill = runFill;
document.addEventListener('DOMContentLoaded', () => setTimeout(runFill, 250));
})();
</script>
<!--
Talk Kink • Compatibility Report — Dark-Mode PDF (all-black cells)
WHAT THIS DOES
• Loads jsPDF + AutoTable from CDN only if missing
• Finds your results table (#compatibilityTable, .results-table.compat, or first <table>)
• Uses the FIRST section header on the page (e.g., “Appearance Play”) as the left column label
• Exports a landscape A4 PDF with black background, white text, THICK white grid lines
• Ensures the on-screen scores transfer exactly (including 0). 0/blank are also listed at the end as “Unanswered”.
• Binds to #downloadBtn automatically, or call TKPDF_forceDark() from the console

HOW TO USE (Codex-ready steps)
1) Open compatibility.html
2) Paste this entire <script> block just before </body>
3) Ensure your results table is rendered in the DOM when the user clicks “Download PDF”
4) Click the button with id="downloadBtn" (or run TKPDF_forceDark() in the console)

RESULT
• A file named compatibility-dark.pdf is downloaded with:
  – main results table in dark theme
  – a second table “Unanswered (0 or blank)” listing any category Partner A or B didn’t answer
-->

<script>
(function () {
  const LOG = (...a) => console.log('[TK-PDF]', ...a);

  /* -------------------- loader -------------------- */
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      if (document.querySelector(`script[src="${src}"]`)) return resolve();
      const s = document.createElement('script');
      s.src = src;
      s.onload = resolve;
      s.onerror = () => reject(new Error('Failed to load ' + src));
      document.head.appendChild(s);
    });
  }
  async function ensureLibs() {
    if (!(window.jspdf && window.jspdf.jsPDF)) {
      await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js');
    }
    const hasAT =
      (window.jspdf && window.jspdf.jsPDF && window.jspdf.jsPDF.API && window.jspdf.jsPDF.API.autoTable);
    if (!hasAT) {
      await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.3/jspdf.plugin.autotable.min.js');
    }
  }

  /* -------------------- DOM helpers -------------------- */
  function findTable() {
    return (
      document.querySelector('#compatibilityTable') ||
      document.querySelector('.results-table.compat') ||
      document.querySelector('table')
    );
  }
  const tidy = (s) => (s || '').replace(/\s+/g, ' ').trim();

  // Extract first integer-like token (supports 0..5)
  function rawInt(v) {
    const m = String(v ?? '').match(/-?\d+/);
    if (!m) return null;
    const n = parseInt(m[0], 10);
    return Number.isFinite(n) ? n : null;
  }
  const isValidScore = (n) => n != null && Number.isInteger(n) && n >= 1 && n <= 5;
  const isZeroOrBlank = (raw) => raw == null || raw === 0;

  // Label cleanup: dedupe words, tiny fixes, rename "Cum" -> "Cum Play"
  function cleanLabel(s) {
    let t = tidy(s);
    t = t.replace(/\b([A-Za-z/’'-]+)\s*\1\b/g, '$1'); // e.g., "Blood Blood" -> "Blood"
    t = t.replace(/\bCum\b/g, 'Cum Play');
    return t;
  }

  /* -------------------- table parsing -------------------- */
  function extractRows(table) {
    const trs = [...table.querySelectorAll('tr')];
    const rows = [];     // main table rows
    const missing = [];  // [Category, missA, missB] for 0/blank
    let firstSectionHeader = 'Category';

    for (const tr of trs) {
      const tds = [...tr.querySelectorAll('td')];
      if (!tds.length) continue;

      const texts = tds.map(td => cleanLabel(td.textContent));

      // Section header detection: one <td> that spans the row (or others empty)
      if (tds.length === 1 || (texts[0] && texts.slice(1).every(x => !x))) {
        if (firstSectionHeader === 'Category') firstSectionHeader = texts[0];
        rows.push([{
          content: texts[0],
          colSpan: 4,
          styles: { fontStyle: 'bold', halign: 'left', fillColor: [0,0,0], textColor: [255,255,255] }
        }]);
        continue;
      }

      // Category text is first cell
      const category = cleanLabel(texts[0] || '—');

      // Pick Partner A = first numeric, Partner B = last numeric (from the row)
      const raws = texts.map(rawInt);
      const numIdx = raws.map((n, i) => (n !== null ? i : -1)).filter(i => i >= 0);
      const aRaw = numIdx.length ? raws[numIdx[0]] : null;
      const bRaw = numIdx.length ? raws[numIdx[numIdx.length - 1]] : null;

      // What to SHOW in the PDF:
      // - If it's 0, show "0" (to match the on-screen table)
      // - If 1..5, show the number
      // - Otherwise "—"
      const aShow = (aRaw === 0) ? '0' : (isValidScore(aRaw) ? String(aRaw) : '—');
      const bShow = (bRaw === 0) ? '0' : (isValidScore(bRaw) ? String(bRaw) : '—');

      // Match %: use present % cell if any; else compute only when both scores are valid (1..5)
      let matchCell = texts.find(c => /%$/.test(c)) || '—';
      if (matchCell === '—' && isValidScore(aRaw) && isValidScore(bRaw)) {
        const pct = Math.round(100 - (Math.abs(aRaw - bRaw) / 5) * 100);
        matchCell = `${Math.max(0, Math.min(100, pct))}%`;
      }

      // Missing (0 or blank) tracker
      const missA = isZeroOrBlank(aRaw);
      const missB = isZeroOrBlank(bRaw);
      if (missA || missB) {
        missing.push([category, missA ? '✖' : '—', missB ? '✖' : '—']);
      }

      // Push row (ALL BLACK cells w/ white text)
      rows.push([
        { content: category,  styles: { fillColor: [0,0,0], textColor: [255,255,255] } },
        { content: aShow,     styles: { fillColor: [0,0,0], textColor: [255,255,255] } },
        { content: matchCell, styles: { fillColor: [0,0,0], textColor: [255,255,255] } },
        { content: bShow,     styles: { fillColor: [0,0,0], textColor: [255,255,255] } },
      ]);
    }
    return { rows, missing, firstSectionHeader };
  }

  /* -------------------- PDF export -------------------- */
  async function TKPDF_export() {
    try {
      await ensureLibs();
      const { jsPDF } = window.jspdf;

      const table = findTable();
      if (!table) return alert('No table found on the page.');

      const { rows, missing, firstSectionHeader } = extractRows(table);

      const doc = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });
      const pageW = doc.internal.pageSize.getWidth();
      const pageH = doc.internal.pageSize.getHeight();
      const marginLR = 30;
      const usable = pageW - marginLR * 2;

      // Dark page painter (fixes "white boxes")
      const paintBg = () => { doc.setFillColor(0,0,0); doc.rect(0,0,pageW,pageH,'F'); doc.setTextColor(255,255,255); };

      paintBg();
      doc.setFontSize(24);
      doc.text('Talk Kink • Compatibility Report', pageW/2, 42, { align: 'center' });

      // Column widths (kept constant to avoid overflow warnings)
      const Awidth = 90, Mwidth = 110, Bwidth = 90;
      const CatWidth = usable - (Awidth + Mwidth + Bwidth);

      doc.autoTable({
        head: [[firstSectionHeader, 'Partner A', 'Match %', 'Partner B']],
        body: rows,
        startY: 64,
        margin: { left: marginLR, right: marginLR },
        styles: {
          fontSize: 11,
          cellPadding: 6,
          textColor: [255,255,255],
          fillColor: [0,0,0],
          lineColor: [255,255,255],
          lineWidth: 1.2,
          halign: 'center',
          valign: 'middle',
          overflow: 'linebreak'
        },
        headStyles: {
          fillColor: [0,0,0],
          textColor: [255,255,255],
          fontStyle: 'bold',
          lineColor: [255,255,255],
          lineWidth: 1.4
        },
        columnStyles: {
          0: { cellWidth: CatWidth, halign: 'left' },
          1: { cellWidth: Awidth },
          2: { cellWidth: Mwidth },
          3: { cellWidth: Bwidth }
        },
        willDrawPage: paintBg
      });

      if (missing.length) {
        doc.autoTable({
          head: [['Unanswered Categories (0 or blank)', 'Partner A', 'Partner B']],
          body: missing.map(r => r.map(c => ({ content: c, styles: { fillColor: [0,0,0], textColor: [255,255,255] } }))),
          startY: (doc.lastAutoTable && doc.lastAutoTable.finalY ? doc.lastAutoTable.finalY : 64) + 20,
          margin: { left: marginLR, right: marginLR },
          styles: {
            fontSize: 11,
            cellPadding: 6,
            textColor: [255,255,255],
            fillColor: [0,0,0],
            lineColor: [255,255,255],
            lineWidth: 1.2
          },
          headStyles: { fillColor: [0,0,0], textColor: [255,255,255], fontStyle: 'bold' },
          columnStyles: { 0: { cellWidth: usable - 180 }, 1: { cellWidth: 90 }, 2: { cellWidth: 90 } },
          willDrawPage: paintBg
        });
      }

      doc.save('compatibility-dark.pdf');
      LOG('Export complete');
    } catch (err) {
      console.error('[TK-PDF] Export failed:', err);
      alert('PDF export failed: ' + (err?.message || err));
    }
  }

  // Public + button binding
  window.TKPDF_forceDark = TKPDF_export;
  const btn = document.querySelector('#downloadBtn');
  if (btn) btn.addEventListener('click', (e) => { e.preventDefault(); TKPDF_export(); });
  LOG('Bound Download PDF');
})();
</script>


<!-- ✅ 1) Add this *once* near the end of every page that was freezing (before </body>) -->
<script>
/* ---------- TalkKink Safe Bootstrap (drop-in) ---------- */
(function () {
  const LOG = (...a) => console.log("[TK-SAFE]", ...a);

  /* A. QUICK SANITY CHECKS — find & warn about merge markers (these often lock pages) */
  try {
    const html = document.documentElement.innerHTML;
    const HEAD = '<'.repeat(7);
    const SEP = '='.repeat(7);
    const TAIL = '>'.repeat(7);
    if (html.includes(HEAD) && html.includes(SEP) && html.includes(TAIL)) {
      const conflictPattern = new RegExp(`${HEAD}[\s\S]*?${SEP}[\s\S]*?${TAIL}`);
      if (conflictPattern.test(html)) {
        console.warn("[TK-SAFE] Merge conflict markers detected in DOM. Remove them to avoid broken JS/CSS.");
      }
    }
  } catch (_) {}

  /* B. ONE-TIME INIT GUARD (prevents duplicate event bind/render loops) */
  if (window.__TK_INITED__) {
    LOG("Init skipped: already initialized.");
    return;
  }
  window.__TK_INITED__ = true;

  /* C. SAFE-MODE FLAGS (use ?safe=1 or ?nopdf=1 or ?noscore=1 to bypass heavy work) */
  const params = new URLSearchParams(location.search);
  const SAFE_MODE  = params.has("safe");
  const NO_PDF     = SAFE_MODE || params.has("nopdf");
  const NO_SCORE   = SAFE_MODE || params.has("noscore");

  if (SAFE_MODE) LOG("SAFE MODE ON: skipping scoring/render and lazy-loading libraries.");

  /* D. SMALL UTILITIES */
  const byId = (id) => document.getElementById(id);
  function once(el, type, handler, opts) {
    // prevent stacked duplicate listeners after HMR/partials
    el && el.addEventListener(type, function f(e) {
      el.removeEventListener(type, f, opts);
      handler(e);
    }, opts);
  }
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      if (document.querySelector(`script[src="${src}"]`)) return resolve();
      const s = document.createElement("script");
      s.src = src; s.async = true; s.defer = true;
      s.onload = resolve;
      s.onerror = () => reject(new Error("Failed to load " + src));
      document.head.appendChild(s);
    });
  }
  function idle(fn) {
    // yield back to the browser to keep UI responsive
    return (window.requestIdleCallback || ((cb)=>setTimeout(cb,0)))(fn);
  }

  /* E. LAZY LOADERS FOR HEAVY LIBS (loaded only on click) */
  async function ensureJsPDF() {
    if (!(window.jspdf && window.jspdf.jsPDF)) {
      await loadScript("https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js");
    }
  }
  async function ensureAutoTable() {
    // Only after jsPDF UMD maps window.jspdf.jsPDF
    await ensureJsPDF();
    const hasAT = (window.jspdf && window.jspdf.jsPDF && window.jspdf.jsPDF.API && window.jspdf.jsPDF.API.autoTable)
               || (window.jspdf && window.jspdf.autoTable);
    if (!hasAT) {
      await loadScript("https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.3/jspdf.plugin.autotable.min.js");
    }
  }

  /* F. DEFENSIVE BINDINGS (buttons used across pages) */
  idle(() => {
    // PDF buttons (compatibility, IKA, etc.)
    const dl1 = byId("downloadBtn");
    const dl2 = byId("downloadPdfBtn");
    const anyDownload = dl1 || dl2;

    if (anyDownload) {
      const handler = async (e) => {
        e.preventDefault();
        if (NO_PDF) { alert("PDF disabled (safe mode). Add ?safe=0 or remove ?nopdf."); return; }
        try {
          // Lazy load heavy libs only now
          await ensureAutoTable();
          // Yield once more before heavy export:
          await new Promise(r => setTimeout(r, 0));
          // Call your existing exporter (must be defined elsewhere)
          if (typeof window.TKPDF_export === "function") {
            await window.TKPDF_export();
          } else if (typeof window.TKPDF_forceDark === "function") {
            await window.TKPDF_forceDark();
          } else if (typeof window.exportIKAPdf === "function") {
            await window.exportIKAPdf();
          } else {
            alert("Export function not found. Expected TKPDF_export/TKPDF_forceDark/exportIKAPdf.");
          }
        } catch (err) {
          console.error("[TK-SAFE] PDF export failed:", err);
          alert("PDF export failed: " + (err?.message || err));
        }
      };

      // Bind once to whichever exists
      if (dl1) once(dl1, "click", handler);
      if (dl2) once(dl2, "click", handler);
      LOG("Bound PDF button(s).");
    }

    // File upload styled label (IKA)
    const fileInput = byId("ikaFile");
    const fileLabel = document.querySelector('label[for="ikaFile"]');
    if (fileInput && fileLabel) {
      once(fileLabel, "click", () => fileInput.click());
      LOG("Bound Upload Survey label→input.");
    }
  });

  /* G. STOP RUNNING EXPENSIVE WORK ON LOAD (scoring/rendering) */
  // Wrap your page’s auto-render or scoring in this gate:
  window.TK_canRunHeavy = function () {
    if (SAFE_MODE) return false;
    // Avoid running more than once
    if (window.__TK_HEAVY_RAN__) return false;
    window.__TK_HEAVY_RAN__ = true;
    return true;
  };

  // Example usage for your pages (leave here; your code can call it):
  // if (window.TK_canRunHeavy()) {
  //   // run scoring/render here or schedule with idle(...)
  //   idle(() => window.renderResults && window.renderResults());
  // }

  /* H. GLOBAL CATCH FOR ACCIDENTAL LONG TASKS */
  // If something still locks the UI, advise safe mode.
  window.addEventListener("error", (e) => {
    console.warn("[TK-SAFE] Window error:", e.message);
  });
})();
</script>
<!-- ---------- End Safe Bootstrap ---------- -->
</body>
</html>
