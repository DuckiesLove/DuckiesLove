<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Kill-switch for legacy Partner-B bootstrap that caused "freeze after first upload" -->
  <script>
    // Hard disable any code path that auto-fills Partner B from internal JSON.
    // This must be loaded before every other script.
    window.TK_DISABLE_BOOTSTRAP_B = true;
    console.info('[compat] kill-switch enabled');
    // one-time guard so labels/overrides merge only once per load
    window._tkLabelsMerged = false;
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>See Our Compatibility</title>
  <style>
    /* Kill any category dock/panel overlays without layout shift */
    #tkDockCard,
    #categorySurveyPanel,
    aside.category-panel,
    .category-panel,
    [data-testid="select-categories-panel"],
    #tkOverlay,
    .tk-overlay {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }

    /* Ensure body isn't pushed for a removed dock */
    html.tk-dock body {
      margin-left: 0 !important;
    }
  </style>
  <script>
    (function killCategoryPanel() {
      const selectors = [
        '#tkDockCard',
        '#categorySurveyPanel',
        'aside.category-panel',
        '.category-panel',
        '[data-testid="select-categories-panel"]',
        '#tkOverlay',
        '.tk-overlay'
      ];

      window.__TK_DISABLE_PANEL__ = true;
      window.__TK_DISABLE_PORTAL__ = true;

      const purge = () => {
        document.documentElement.classList.remove('tk-dock');
        if (document.body) {
          document.body.style.marginLeft = '';
        }
        selectors.forEach((selector) => {
          document.querySelectorAll(selector).forEach((node) => node.remove());
        });
      };

      purge();

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', purge, { once: true });
      }

      const observer = new MutationObserver(purge);
      observer.observe(document.documentElement, { childList: true, subtree: true });
      setTimeout(() => observer.disconnect(), 4000);
    })();
  </script>

  <script>
    (function () {
      /* 0) stop stale data from re-injecting a broken table */
      try {
        localStorage.removeItem('talkkink:compatRows');
      } catch (e) {}
      window.talkkinkCompatRows = [];

      /* 1) find a single compatibility table; delete extras */
      const all = Array.from(document.querySelectorAll('table.compat-table, table#compatibility, table[data-compat]'));
      const tbl = all[0];
      all.slice(1).forEach(n => n.remove());
      if (!tbl) return;

      /* 2) enforce ONE thead with 5 headers */
      const theads = tbl.querySelectorAll('thead');
      theads.forEach((t, i) => { if (i) t.remove(); });
      let thead = tbl.querySelector('thead');
      if (!thead) {
        thead = document.createElement('thead');
        tbl.prepend(thead);
      }
      const want = ['Item','Partner A','Match','Flag','Partner B'];
      // build/normalize the header row
      thead.innerHTML = `<tr>${want.map(() => '<th></th>').join('')}</tr>`;
      thead.querySelectorAll('th').forEach((th, i) => th.textContent = want[i]);

      /* 3) trim each body row to exactly 5 tds in correct order */
      const rows = tbl.tBodies.length ? Array.from(tbl.tBodies[0].rows) : [];
      rows.forEach(tr => {
        const cells = Array.from(tr.children).filter(el => el.tagName === 'TD');
        // if there are more than 5 tds, keep the first 5 only
        if (cells.length > 5) cells.slice(5).forEach(td => td.remove());
        // if fewer, pad with empty cells
        while (tr.querySelectorAll('td').length < 5) tr.appendChild(document.createElement('td'));
      });

      /* 4) fix FLAG column content to a real glyph and center it */
      const FLAG_GLYPH = '▶';
      rows.forEach(tr => {
        const tds = tr.querySelectorAll('td');
        if (tds[3]) {
          const raw = (tds[3].textContent || '').trim();
          if (!raw || /&|†|gt;|lt;/.test(raw) || raw.length > 2) tds[3].textContent = FLAG_GLYPH;
          tds[3].classList.add('tk-flag');
        }
        // center numeric cols
        if (tds[1]) tds[1].classList.add('tk-center');
        if (tds[2]) tds[2].classList.add('tk-center');
        if (tds[4]) tds[4].classList.add('tk-center');
      });

      /* 5) install a clean colgroup so headers don’t wrap/smash */
      let cg = tbl.querySelector('colgroup');
      if (cg) cg.remove();
      cg = document.createElement('colgroup');
      // widths: item 56%, A 12%, match 16%, flag 4%, B 12%
      [56,12,16,4,12].forEach(w => {
        const c = document.createElement('col');
        c.style.width = w + '%';
        cg.appendChild(c);
      });
      tbl.prepend(cg);

      /* 6) styling: remove white strips, outline headers, center where needed */
      const ACCENT = '#30E7E7';
      const css = `
        body{ background:#0b0b0c; }
        table{ width:100%; table-layout:fixed; border-collapse:collapse; background:transparent; }
        thead th{
          color:${ACCENT}; font-weight:700; padding:12px 10px; text-align:left;
          text-shadow:0 1px 0 #000, 0 -1px 0 #000, 1px 0 0 #000, -1px 0 0 #000;
          border-bottom:2px solid rgba(255,255,255,.14);
          white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
          background:transparent;
        }
        tbody td{
          color:#e9eef0; padding:12px 10px; border-bottom:1px solid rgba(255,255,255,.06);
          white-space:normal; overflow:hidden; text-overflow:ellipsis; background:transparent;
        }
        tbody tr:nth-child(even) td{ background:rgba(255,255,255,.03); }
        .tk-center{ text-align:center; }
        .tk-flag{ text-align:center; }
      `;
      let style = document.getElementById('tk-compat-fix-css');
      if (!style) {
        style = document.createElement('style');
        style.id = 'tk-compat-fix-css';
        style.textContent = css;
        document.head.appendChild(style);
      }
    })();
  </script>
  <!-- COMPAT PAGE: recentre layout + neutralize any dock margin -->
  <style id="compat-centering">
    :root {
      --tk-dock-width: 0px !important;
    }

    html,
    body {
      margin: 0;
    }

    .compat-page,
    .compat-wrapper,
    #compatRoot,
    main,
    .page,
    .container {
      max-width: 960px;
      margin: 0 auto !important;
      padding: 40px 16px;
    }

    .compat-buttons,
    .compat-actions {
      display: flex;
      flex-direction: column;
      gap: 24px;
      align-items: center;
    }

    .compat-buttons .themed-button,
    .compat-actions .themed-button,
    .themed-button.compat {
      width: min(680px, 90vw);
    }
  </style>
  <style id="compat-print-full-bleed">
    @page {
      size: auto;
      margin: 0;
    }

    @media print {
      html,
      body {
        margin: 0 !important;
        background: #000;
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
      }

      body {
        min-height: 100vh;
      }

      .compat-page,
      .compat-wrapper,
      #compatRoot,
      main,
      .page,
      .container {
        max-width: none !important;
        width: 100vw !important;
        padding: 24px 32px !important;
        box-sizing: border-box;
        margin: 0 auto !important;
      }

      table.compat {
        width: 100%;
      }
    }
  </style>

  <script>
    (function () {
      try {
        if (document.body) {
          document.body.style.marginLeft = '0px';
        }
        document.documentElement.style.setProperty('--tk-dock-width', '0px');

        const host = document.querySelector(
          '#compatRoot, .compat-page, .compat-wrapper, main, .page, .container'
        );

        if (host) {
          Object.assign(host.style, {
            maxWidth: '960px',
            margin: '0 auto',
            padding: '40px 16px'
          });
        }

        document.querySelectorAll('.themed-button').forEach((btn) => {
          Object.assign(btn.style, {
            width: 'min(680px, 90vw)',
            margin: '0 auto',
            display: 'block'
          });
        });
      } catch (err) {
        console.warn('[compat] unable to apply centering overrides', err);
      }
    })();
  </script>

  <script>
    window.TK_COMPAT_UPLOAD_CFG = {
      btnSelf: '#yourBtn, #uploadYourSurvey',
      btnPartner: '#partnerBtn, #uploadPartnerSurvey',
      btnPdf: '#downloadBtn, #downloadPdfBtn',
      selfInput: '#yourFile',
      partnerInput: '#partnerFile',
      guardPdf: false,
      autoInit: false
    };
  </script>
  <script defer src="/js/tk-compat-upload-glue.js"></script>
  <style id="tk-compat-center">
    /* Remove any panel/dock if an older script injected it */
    #tkDockCard,
    #categorySurveyPanel,
    .category-panel,
    .tk-overlay {
      display: none !important;
    }

    html,
    body {
      margin: 0;
    }

    body[style*="margin-left"] {
      margin-left: 0 !important;
    }

    /* Center the content column */
    .compat-wrap,
    .compat-container,
    .container,
    main,
    #app {
      box-sizing: border-box;
      max-width: 960px;
      width: min(960px, 92vw);
      margin-inline: auto;
      padding-inline: 16px;
    }

    .compat-wrap > *,
    .compat-container > *,
    .container > *,
    main > * {
      max-width: 100%;
    }
  </style>
  <script>
    (function () {
      const clearDock = () => {
        // Nuke any leftover dock/overlay/panel on this page
        for (const sel of ['#tkDockCard', '.tk-overlay', '#categorySurveyPanel', '.category-panel']) {
          const n = document.querySelector(sel);
          if (n) n.remove();
        }

        const body = document.body;
        if (body) {
          body.style.marginLeft = '';
        }

        const dock = document.querySelector('#compat-dock');
        if (dock) {
          dock.style.removeProperty('margin-bottom');
        }
      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', clearDock, { once: true });
      } else {
        clearDock();
      }
    })();
  </script>
  <!-- Import theme and global layout styles -->
  <link rel="stylesheet" href="/css/theme.css" />
  <link rel="stylesheet" href="/css/global.css" />
  <link rel="stylesheet" href="/css/compat-table.css" />
  <link rel="stylesheet" href="/css/font-failopen.css">
  <link rel="stylesheet" href="/css/compatibility.css" />
  <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg" />

  <style>
    /* --- Percent bar (Match %) --- */
    .pct {
      position: relative;
      width: 100%;
      height: 22px;
      border: 1px solid #3ddbf3;
      border-radius: 6px;
      background: rgba(61,219,243,0.08);
      overflow: hidden;
    }
    .pct-fill {
      position: absolute;
      inset: 0;
      width: 0%;
      background: linear-gradient(90deg, #18a0fb, #3df3c3);
      transition: width .35s ease;
    }
    .pct-text {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-variant-numeric: tabular-nums;
      font-weight: 600;
    }
    /* Friendly label text in first column (wrap nicely on small screens) */
    .tk-cat {
      white-space: normal;
      line-height: 1.2;
    }
    .tk-code {
      opacity: .5;
      font-size: .85em;
      margin-left: .4rem;
    }
  </style>
  <style>
    td.pct-cell .pct { position: relative; height: 1.1em; line-height: 1.1em; }
    td.pct-cell .pct .bar { position:absolute; left:0; top:0; bottom:0; width:0%;
                            background:rgba(0,255,255,0.25); border-radius:2px; }
    td.pct-cell .pct .txt { position:relative; display:block; text-align:center; }
    td.pct-cell { min-width:5rem; }
  </style>
  <style>
  #pdf-container {
    width: 100%;
    max-width: 100%;
  }
  table {
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    text-align: center;
    vertical-align: middle;
    padding: 6px;
  }
  th:first-child, td:first-child {
    text-align: left;
    padding-left: 10px;
  }
  </style>
  <style>
    .upload-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      margin-top: 3rem;
    }

    .upload-button {
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
    }

    .upload-button input[type="file"] {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .upload-button .upload-trigger {
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .upload-button .upload-trigger:focus-visible {
      outline: 2px solid rgba(61, 219, 243, 0.9);
      outline-offset: 2px;
    }

    .wide-button {
      min-width: 260px;
      max-width: 300px;
      width: 100%;
    }
    .export-tip {
      font-size: 0.9rem;
      margin: 0;
    }
  </style>
  <style>
    /* Keep rows from splitting in both web and print */
    .compat-section tr { break-inside: avoid; page-break-inside: avoid; }

    /* Make sure tables are fixed-width to avoid right-side cutoff */
    .compat-section table {
      width: 100% !important;
      table-layout: fixed !important;
      border-collapse: collapse !important;
    }

    /* Optional: make header clean (no decorative lines/boxes) */
    .section-title, .category-header, .compat-category {
      border: none !important;
      box-shadow: none !important;
      background: transparent !important;
    }
  </style>
  <style>
    /* Force LIGHT pdf colors by default; override via body[style] if you want dark */
    :root { --pdf-bg:#fff; --pdf-text:#000; }
    .pdf-export, #pdfWrapper, .pdf-container {
      background: var(--pdf-bg) !important;
      color: var(--pdf-text) !important;
    }
  </style>
  <style>
    /* optional polish to match your theme */
    .tk-compat th, .tk-compat td{
      border-bottom:1px solid #00e6ff33;
      padding:.55rem .8rem;
      vertical-align:middle;
    }
    .tk-compat td.ta-c{ text-align:center; }
  </style>
  <style>
  /* Small, unobtrusive subtitle under the category code */
  .tk-catwrap { display:flex; flex-direction:column; gap:2px; }
  .tk-catwrap .tk-code { font-weight:600; letter-spacing:0.02em; }
  .tk-catwrap .tk-sub  {
    font-weight:500; opacity:.78;
    font-size: clamp(11px,.9vw,13px);
    line-height:1.2;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    max-width: min(48vw, 780px);  /* fits your wide first column */
  }

  /* Match % meter (tuned for your dark theme) */
  .tk-meter {
    position: relative;
    height: 10px; min-width: 110px;
    background: rgba(0, 230, 255, .12);
    border-radius: 999px;
    outline: 1px solid rgba(0,230,255,.20);
    overflow: hidden;
  }
  .tk-meter > .tk-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg,
      rgba(0,230,255,.88), rgba(120,255,250,.95));
    box-shadow: 0 0 10px rgba(0,230,255,.35) inset;
    border-radius: inherit;
    transition: width .35s ease;
  }
  .tk-meter + .tk-pct {
    display:inline-block; min-width: 42px;
    font-weight:800; letter-spacing:.02em;
    margin-left:.5rem; opacity:.9;
  }

  /* Keep row height stable on narrow screens */
  @media (max-width: 720px){
    .tk-catwrap .tk-sub { max-width: 70vw; }
    .tk-meter { min-width: 80px; }
  }
  </style>
  <style>
  /* ====== Match % chip (compact, no layout shift) ====== */
  .tk-match-chip{
    display:inline-flex; flex-direction:column; align-items:center; gap:6px;
    min-width:70px; line-height:1; vertical-align:middle;
  }
  .tk-match-num{ font-weight:800; letter-spacing:.02em; }
  .tk-match-bar{
    position:relative; width:90px; height:7px; border-radius:999px;
    outline:1px solid rgba(0,230,255,.35);
    background:rgba(0,230,255,.10); overflow:hidden;
  }
  .tk-match-fill{
    display:block; height:100%; width:var(--w,0%);
    background:linear-gradient(90deg,#00e6ff,#3bffc4);
    border-radius:inherit; transition:width .25s ease;
  }
  /* Dim the bar if the value is “missing” on that row */
  .tk-match-chip[data-missing="1"] .tk-match-bar{ opacity:.38; }

  /* ====== Category main + tiny subline (summary) ====== */
  .tk-cat-wrap{ display:flex; flex-direction:column; gap:3px; }
  .tk-cat-main{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .tk-cat-sub{
    font-size:.82em; color:#9beff7; opacity:.78;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    max-width:48ch;  /* keep it subtle; doesn’t stretch your layout */
  }
  /* On narrow screens you can hide the subline if you want */
  @media (max-width: 680px){
    .tk-cat-sub{ display:none; }
  }
  </style>
  <style>
  /* Compatibility table progressive enhancement (fallback match bar + labels) */
  td.ksv-match { white-space: nowrap; }

  .ksv-matchwrap{
    display:flex; flex-direction:column; align-items:center; gap:.4rem;
    min-width:8rem;
  }
  .ksv-pct{
    font: 800 0.95rem/1.1 system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    letter-spacing:.02em; color:#d9ffff;
  }
  .ksv-bar{
    width:100%; height:6px; border-radius:999px;
    background: rgba(0,230,255,.12);
    outline: 1px solid rgba(0,230,255,.35);
    overflow:hidden;
  }
  .ksv-bar > i{
    display:block; height:100%; width:var(--w,0%);
    background: linear-gradient(90deg,#00e6ff 0%, #5fffd6 100%);
    box-shadow: 0 0 6px #00e6ff66 inset;
  }

  .tk-upload-messages {
    display: grid;
    gap: 0.35rem;
    margin: 0.75rem auto 0;
    max-width: 32rem;
  }

  .tk-upload-status {
    font: 500 0.92rem/1.35 "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    color: #c9f4ff;
    text-align: center;
    padding: 0.45rem 0.75rem;
    background: rgba(0, 230, 255, 0.08);
    border: 1px solid rgba(0, 230, 255, 0.18);
    border-radius: 0.75rem;
    margin: 0;
  }

  .tk-upload-status[data-state="info"] {
    color: #c9f4ff;
  }

  .tk-upload-status[data-state="success"] {
    color: #9fffd6;
    background: rgba(53, 255, 197, 0.08);
    border-color: rgba(105, 255, 213, 0.25);
  }

  .tk-upload-status[data-state="error"] {
    color: #ffc1ce;
    background: rgba(255, 70, 102, 0.07);
    border-color: rgba(255, 102, 133, 0.2);
  }

  .tk-consent-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(4, 16, 28, 0.82);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    padding: 1.5rem;
  }

  .tk-consent-card {
    background: #04111c;
    border: 1px solid rgba(0, 230, 255, 0.25);
    box-shadow: 0 24px 60px rgba(0, 0, 0, 0.45);
    border-radius: 1rem;
    padding: 1.65rem;
    max-width: min(34rem, 100%);
    color: #f2fbff;
  }

  .tk-consent-card h2 {
    font: 700 1.2rem/1.3 "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    margin: 0 0 0.75rem;
  }

  .tk-consent-card p {
    margin: 0 0 1.25rem;
    font: 500 0.98rem/1.6 "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    color: #c8e9ff;
  }

  .tk-consent-actions {
    display: flex;
    justify-content: flex-end;
    gap: 0.75rem;
  }

  .tk-btn.tk-btn-secondary {
    background: rgba(0, 230, 255, 0.08);
  }

  .tk-btn.tk-btn-secondary:hover {
    background: rgba(0, 230, 255, 0.14);
  }

  .tk-consent-backdrop[hidden] {
    display: none;
  }

  td.ksv-cat{
    word-break: break-word;
  }
  .ksv-cat .ksv-cat-text{
    display:inline;
  }
  </style>

  <link rel="stylesheet" href="/assets/css/comparison.css" />
</head>
<body data-page="compat">
  <main class="tk-landing">
    <h1 class="tk-title">TalkKink Compatibility</h1>

    <div class="tk-menu">
      <label id="yourBtn" for="yourFile" class="tk-btn">Upload Your Survey</label>
      <label id="partnerBtn" for="partnerFile" class="tk-btn">Upload Partner’s Survey</label>
      <button id="downloadBtn" class="glow-cta compat-download-btn">Download PDF</button>
    </div>

    <div class="tk-upload-messages" aria-live="polite" aria-atomic="true">
      <p id="yourStatus" class="tk-upload-status" role="status" hidden></p>
      <p id="partnerStatus" class="tk-upload-status" role="status" hidden></p>
    </div>

        <a href="https://talkkink.org/KinkSurveyPage/index.html" class="tk-btn back">← Back</a>

    <input id="yourFile" type="file" accept="application/json" hidden />
    <input id="partnerFile" type="file" accept="application/json" hidden />

  </main>

  <!-- TK: Page-centered header helper -->
  <script>
  (() => {
    const FS = { title: 26, stamp: 9, section: 18 };
    const Y = { title: 64, stamp: 82, rule: 92, section: 118, tableTop: 136 };
    const CYAN = [0, 255, 255];
    const RULE_W = 1;
    const PAGE_RULE_MARGIN = { left: 72, right: 72 };
    const TIMESTAMP = new Date().toLocaleString();

    const NULL_FN = () => {};
    ['paint', 'cat', 'drawHeader', 'centerHeader', 'drawHeaderCenteredToPage', 'tkHeaderOverTable', 'tkCenteredHeaderAndTable', 'tkPageCenteredHeaderAndTable']
      .forEach((name) => {
        if (typeof window[name] === 'function') window[name] = NULL_FN;
      });

    function pageWidth(doc) {
      const size = doc.internal.pageSize;
      return typeof size.getWidth === 'function' ? size.getWidth() : size.width;
    }

    function pageHeight(doc) {
      const size = doc.internal.pageSize;
      return typeof size.getHeight === 'function' ? size.getHeight() : size.height;
    }

    function pageCenter(doc) {
      return pageWidth(doc) / 2;
    }

    function tableBox(doc, tableOpts = {}) {
      const width = pageWidth(doc);
      const margin = tableOpts.margin || {};
      const ml = Number.isFinite(margin.left) ? margin.left : 72;
      const mr = Number.isFinite(margin.right) ? margin.right : 72;

      let tw = tableOpts.tableWidth;
      if (!Number.isFinite(tw)) {
        tw = Math.min(680, width - (ml + mr));
      }

      return { width, ml, mr, tw, cx: ml + tw / 2 };
    }

    function resolveHeaderCenters(doc, alignTarget, tableOpts = {}, tableData) {
      const cx = pageCenter(doc);
      const width = pageWidth(doc);
      const ruleMarginL = Number.isFinite(PAGE_RULE_MARGIN.left) ? PAGE_RULE_MARGIN.left : 72;
      const ruleMarginR = Number.isFinite(PAGE_RULE_MARGIN.right) ? PAGE_RULE_MARGIN.right : 72;
      const base = {
        cx,
        ruleL: Math.max(0, ruleMarginL),
        ruleR: Math.max(Math.max(0, ruleMarginL), width - ruleMarginR)
      };

      if (alignTarget === 'table') {
        const table = tableData?.table;
        const startX = Number.isFinite(table?.startX)
          ? table.startX
          : Number.isFinite(table?.x)
            ? table.x
            : null;
        const tw = Number.isFinite(table?.width)
          ? table.width
          : Number.isFinite(table?.finalWidth)
            ? table.finalWidth
            : null;
        if (startX != null && tw != null) {
          base.tableCx = startX + tw / 2;
        } else {
          const box = tableBox(doc, tableOpts);
          base.tableCx = box.cx;
        }
      }

      return base;
    }

    function drawPageHeader(doc, centers, sectionTitle, sectionBaseline, options = {}) {
      const {
        drawBackground = true,
        drawText = true,
        drawRule = true,
        drawSection = true
      } = options;

      const PW = pageWidth(doc);
      const PH = pageHeight(doc);
      if (drawBackground) {
        doc.setFillColor(10, 10, 12);
        doc.rect(0, 0, PW, PH, 'F');
      }

      if (drawText) {
        doc.setTextColor(255, 255, 255);
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(FS.title);
        doc.text('TalkKink — Partner Survey (Clean Report)', centers.cx, Y.title, { align: 'center' });

        doc.setFont('helvetica', 'normal');
        doc.setFontSize(FS.stamp);
        doc.setTextColor(170, 210, 255);
        doc.text('Generated: ' + TIMESTAMP, centers.cx, Y.stamp, { align: 'center' });
      }

      if (drawRule) {
        doc.setDrawColor(...CYAN);
        if (typeof doc.setLineWidth === 'function') doc.setLineWidth(RULE_W);
        doc.line(centers.ruleL, Y.rule, centers.ruleR, Y.rule);
      }

      if (drawSection) {
        const sectionY = Number.isFinite(sectionBaseline) ? sectionBaseline : Y.section;
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(FS.section);
        doc.setTextColor(255, 255, 255);
        const sectionLabel = sectionTitle != null ? String(sectionTitle) : 'Partner Upload Snapshot';
        doc.text(sectionLabel, centers.cx, sectionY, { align: 'center' });
      }
    }

    function isPlainObject(value) {
      return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
    }

    window.tkHeaderAndTable = function tkHeaderAndTable(doc, sectionOrOpts, maybeTableOpts) {
      if (!doc || typeof doc.autoTable !== 'function') {
        throw new Error('autoTable is required before calling tkHeaderAndTable');
      }

      const legacySignature = maybeTableOpts === undefined && isPlainObject(sectionOrOpts);

      let sectionTitle = legacySignature ? sectionOrOpts.sectionTitle : sectionOrOpts;
      let alignTarget = legacySignature ? sectionOrOpts.alignTarget : undefined;
      let sectionBaseline = legacySignature ? sectionOrOpts.startY : undefined;
      let tableOpts = legacySignature ? sectionOrOpts.table || {} : maybeTableOpts || {};

      tableOpts = { ...tableOpts };

      if (sectionTitle == null && legacySignature) sectionTitle = sectionOrOpts.section;
      if (alignTarget == null && typeof tableOpts.alignTarget === 'string') {
        alignTarget = tableOpts.alignTarget;
      }
      if (sectionBaseline == null && Number.isFinite(tableOpts.sectionY)) {
        sectionBaseline = tableOpts.sectionY;
      }

      const rawAlignTarget = alignTarget || tableOpts.headerAlignTarget || 'page';
      const providedWillDrawPage = tableOpts.willDrawPage;
      const providedDidDrawPage = tableOpts.didDrawPage;
      const explicitStartY = tableOpts.startY;

      const headerBaseline = Number.isFinite(sectionBaseline)
        ? sectionBaseline
        : Number.isFinite(tableOpts.sectionY)
          ? tableOpts.sectionY
          : Y.section;

      const resolvedStartY = Number.isFinite(explicitStartY) ? explicitStartY : Y.tableTop;

      delete tableOpts.alignTarget;
      delete tableOpts.headerAlignTarget;
      delete tableOpts.sectionY;
      delete tableOpts.willDrawPage;
      delete tableOpts.didDrawPage;

      const paintHeader = (data, options = {}) => {
        const centers = resolveHeaderCenters(doc, rawAlignTarget, tableOpts, data);
        drawPageHeader(doc, centers, sectionTitle, headerBaseline, options);
      };

      doc.autoTable({
        ...tableOpts,
        startY: resolvedStartY,
        willDrawPage: (data) => {
          paintHeader(rawAlignTarget === 'table' ? data : null, {
            drawText: false,
            drawRule: false,
            drawSection: false
          });
          if (typeof providedWillDrawPage === 'function') providedWillDrawPage(data);
        },
        didDrawPage: (data) => {
          paintHeader(data, { drawBackground: false });
          if (typeof providedDidDrawPage === 'function') providedDidDrawPage(data);
        }
      });

      return doc.lastAutoTable?.finalY ?? resolvedStartY;
    };

    window.tkPageCenteredHeaderAndTable = window.tkCenteredHeaderAndTable = window.tkHeaderAndTable;
    window.drawHeaderCenteredToPage = function drawHeaderCenteredToPage(doc, sectionTitle = 'Behavioral Play') {
      if (!doc) return;
      const centers = resolveHeaderCenters(doc, 'page');
      drawPageHeader(doc, centers, sectionTitle, undefined, { drawBackground: false });
    };
  })();
  </script>

  <script>
    function ksvParseSurveyJsonText(jsonText, partner = 'A') {
      const fail = (reason) => ({ ok: false, reason, cells: [], survey: null });
      if (typeof jsonText !== 'string') return fail('No JSON payload provided');

      let payload;
      try {
        payload = JSON.parse(jsonText);
      } catch (err) {
        return fail('Invalid JSON');
      }

      const answers = {};
      const answersByKey = {};
      let maxIndex = 0;

      const clamp = (value) => {
        const n = Number(value);
        if (!Number.isFinite(n)) return 0;
        if (n < 0) return 0;
        if (n > 5) return 5;
        return Math.round(n);
      };

      const toRating = (value) => {
        if (value == null || value === '') return 0;
        if (typeof value === 'number' && Number.isFinite(value)) return clamp(value);
        if (typeof value === 'string') {
          const trimmed = value.trim();
          if (!trimmed) return 0;
          const match = trimmed.match(/-?\d+(?:\.\d+)?/);
          if (match) return clamp(Number(match[0]));
        }
        return 0;
      };

      const applyRating = (index, value) => {
        const idx = Number(index);
        if (!Number.isFinite(idx) || idx <= 0) return;
        const normalized = toRating(value);
        const key = String(idx);
        answersByKey[key] = normalized;
        if (idx > maxIndex) maxIndex = idx;
      };

      const absorbArray = (arr) => {
        if (!Array.isArray(arr)) return;
        arr.forEach((value, i) => applyRating(i + 1, value));
      };

      const absorbObject = (obj) => {
        if (!obj || typeof obj !== 'object') return;
        Object.keys(obj)
          .sort((a, b) => Number(a) - Number(b))
          .forEach((key) => applyRating(key, obj[key]));
      };

      if (Array.isArray(payload)) {
        absorbArray(payload);
      } else if (payload && typeof payload === 'object') {
        absorbArray(payload.cells);
        absorbArray(payload.answers);
        absorbObject(payload.answersByKey);
        absorbObject(payload.answersById);
        absorbObject(payload.ratings);
      } else {
        return fail('Unsupported survey payload');
      }

      if (!maxIndex) {
        return fail('No survey answers found');
      }

      for (let i = 1; i <= maxIndex; i += 1) {
        const key = String(i);
        const rating = Object.prototype.hasOwnProperty.call(answersByKey, key)
          ? answersByKey[key]
          : 0;
        answers[key] = rating;
        answersByKey[key] = rating;
      }

      const cells = Array.from({ length: maxIndex }, (_, i) => answersByKey[String(i + 1)] ?? 0);
      return { ok:true, cells, survey: { answers, answersByKey } };
}

    window.ksvParseSurveyJsonText = ksvParseSurveyJsonText;
  </script>

  <!-- LOCAL-ONLY jsPDF + autoTable loader (no CDN fallbacks) -->
  <script>
  // LOCAL-ONLY loader to avoid Edge "Tracking Prevention" warnings.
  // Place files at /vendor/jspdf.umd.min.js and /vendor/jspdf.plugin.autotable.min.js
  // (or the fallback /js/vendor/ copies used in local development)
  async function tkLoadPdfLibs() {
    const hasPdf = () =>
      Boolean(
        window.jspdf?.jsPDF?.API?.autoTable ||
        window.jsPDF?.API?.autoTable ||
        (window.jspdf?.jsPDF && window.jspdf?.jsPDF?.API?.autoTable)
      );

    if (!hasPdf()) {
      const inject = (src) =>
        new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = src;
          s.async = true;
          s.onload = () => resolve(src);
          s.onerror = () => reject(new Error(src));
          document.head.appendChild(s);
        });

      const tryInject = async (candidates) => {
        let lastError = null;
        for (const path of candidates) {
          try {
            return await inject(path);
          } catch (error) {
            lastError = error;
          }
        }
        if (lastError) throw lastError;
        throw new Error('No script sources provided');
      };

      await tryInject(['/vendor/jspdf.umd.min.js', '/js/vendor/jspdf.umd.min.js', '/assets/js/vendor/jspdf.umd.min.js']);

      if (!window.jsPDF && window.jspdf?.jsPDF) {
        window.jsPDF = window.jspdf.jsPDF;
      }

      await tryInject([
        '/vendor/jspdf.plugin.autotable.min.js',
        '/js/vendor/jspdf.plugin.autotable.min.js',
        '/assets/js/vendor/jspdf.plugin.autotable.min.js'
      ]);
    }

    const ctor = window.jspdf?.jsPDF || window.jsPDF;
    if (!ctor) {
      throw new Error('Local jsPDF/AutoTable not found. Make sure the files exist in /vendor/ or /js/vendor/.');
    }

    if (!ctor.API?.autoTable && typeof window.jspdf_autotable === 'function') {
      try {
        window.jspdf_autotable(ctor);
      } catch (err) {
        console.warn('[compat] Unable to bind autoTable API', err);
      }
    }

    const testDoc = new ctor({ unit: 'pt', format: 'letter' });
    if (typeof testDoc.autoTable !== 'function' && typeof window.jspdf_autotable === 'function') {
      try {
        window.jspdf_autotable(testDoc);
      } catch (err) {
        console.warn('[compat] Unable to attach autoTable during preload', err);
      }
    }

    if (typeof testDoc.autoTable !== 'function') {
      throw new Error('Local jsPDF/AutoTable not found. Make sure the files exist in /vendor/ or /js/vendor/.');
    }

    window.tkGetJsPDF = () => ctor;
    window.tkMakeDoc = () => {
      const doc = new ctor({ unit: 'pt', format: 'letter' });
      if (typeof doc.setLineWidth !== 'function') {
        doc.setLineWidth = function () {};
      }
      if (typeof doc.autoTable !== 'function' && typeof window.jspdf_autotable === 'function') {
        try {
          window.jspdf_autotable(doc);
        } catch (err) {
          console.warn('[compat] Unable to bind autoTable to doc', err);
        }
      }
      return doc;
    };

    if (typeof window.jsPDF !== 'function' && typeof ctor === 'function') {
      window.jsPDF = ctor;
    }
  }

  window.tkLoadPdfLibs = tkLoadPdfLibs;
  </script>

  <!-- CODEX: Resilient dark PDF exporter (dual-CDN, guarded parsing, consent, diagnostics) -->
  <script>
(function () {
  const $ = (selector, root = document) => root.querySelector(selector);
  const dispatch = (name, detail) => document.dispatchEvent(new CustomEvent(name, { detail }));

  let yourBtn = null;
  let partnerBtn = null;
  let downloadBtn = null;
  let yourInput = null;
  let partnerInput = null;
  let yourStatus = null;
  let partnerStatus = null;

  const statusEls = { self: null, partner: null };

  const STATUS_SELECTORS = {
    self: '#yourStatus, [data-compat-status="self"]',
    partner: '#partnerStatus, [data-compat-status="partner"]'
  };

  function resolveStatusEl(which) {
    const key = which === 'partner' ? 'partner' : 'self';
    let el = statusEls[key];
    if (el && el.isConnected) return el;

    const selector = STATUS_SELECTORS[key];
    if (selector) {
      el = document.querySelector(selector);
      if (el) {
        statusEls[key] = el;
        return el;
      }
    }

    statusEls[key] = null;
    return null;
  }

  window.__TK_FAST_UPLOADS__ = true;
  window.__TK_ALLOW_SINGLE_PDF__ = true;

  const LS_SELF_KEY = 'tk_compat.mine';
  const LS_PARTNER_KEY = 'tk_compat.partner';

  // ---------- STATE ----------
  let yourBlob = null;
  let partnerBlob = null;
  let yourJSON = null;
  let partnerJSON = null;
  const parseTimers = new Map();

  // ---------- HELPERS ----------
  function setStatus(which, message, state = 'info') {
    const el = resolveStatusEl(which);
    if (!el) return;
    if (!message) {
      el.hidden = true;
      el.textContent = '';
      el.removeAttribute('data-state');
      return;
    }
    el.hidden = false;
    el.textContent = message;
    el.dataset.state = state;
  }

  function resetSelection(which, { resetStatus = true } = {}) {
    if (which === 'self') {
      yourBlob = null;
      yourJSON = null;
      window.talkkinkMine = null;
      window.talkkinkSurvey = null;
      try {
        localStorage.removeItem(LS_SELF_KEY);
      } catch (err) {
        console.warn('[compat] unable to clear self cache', err);
      }
    } else {
      partnerBlob = null;
      partnerJSON = null;
      window.talkkinkPartner = null;
      try {
        localStorage.removeItem(LS_PARTNER_KEY);
      } catch (err) {
        console.warn('[compat] unable to clear partner cache', err);
      }
    }
    if (resetStatus) setStatus(which, '', '');
  }

  // ---------- ASSET LOADING ----------
  async function ensurePdfLibs() {
    if (typeof window.tkLoadPdfLibs === 'function') {
      await window.tkLoadPdfLibs();
      return;
    }
    throw new Error('PDF loader unavailable');
  }

  function createPdfDoc() {
    if (typeof window.tkMakeDoc === 'function') {
      return window.tkMakeDoc();
    }
    const ctor = window.jspdf?.jsPDF || window.jsPDF;
    if (!ctor) {
      throw new Error('jsPDF not loaded');
    }
    const doc = new ctor({ unit: 'pt', format: 'letter' });
    if (typeof doc.setLineWidth !== 'function') {
      doc.setLineWidth = function () {};
    }
    return doc;
  }

  function tkEnsureAutoTable(doc) {
    if (typeof doc.autoTable !== 'function' && typeof window.jspdf_autotable === 'function') {
      try {
        window.jspdf_autotable(doc);
      } catch (error) {
        console.warn('[compat] Unable to attach autoTable to doc', error);
      }
    }
    if (typeof doc.autoTable !== 'function') {
      const api = window.jspdf?.jsPDF?.API || window.jsPDF?.API;
      if (api && typeof api.autoTable === 'function') {
        doc.autoTable = function (...args) {
          return api.autoTable.apply(this, args);
        };
      }
    }
    if (typeof doc.autoTable !== 'function') {
      throw new Error('autoTable plugin not attached');
    }
  }

  const allowSingle = () => Boolean(window.__TK_ALLOW_SINGLE_PDF__ || document.body?.dataset?.allowSinglePdf === 'true');

  function setDownloadButton(btn) {
    if (btn === downloadBtn) return;

    if (downloadBtn) {
      downloadBtn.removeEventListener('click', handleDownloadClick, true);
    }

    downloadBtn = btn || null;

    if (downloadBtn) {
      downloadBtn.addEventListener('click', handleDownloadClick, true);
    }

    updateDownloadState();
  }

  function updateDownloadState() {
    if (!downloadBtn) return;
    const ready = allowSingle() ? Boolean(yourJSON || partnerJSON) : Boolean(yourJSON && partnerJSON);
    downloadBtn.disabled = !ready;
  }

  function openPicker(input) {
    if (!input) return;
    input.value = '';
    input.click();
  }

  const CONSENT_KEY = 'tk.partnerConsent.v1';

  function getConsentFlag() {
    try {
      return sessionStorage.getItem(CONSENT_KEY) === '1';
    } catch (err) {
      console.warn('[compat] unable to access consent flag', err);
      return false;
    }
  }

  function setConsentFlag() {
    try {
      sessionStorage.setItem(CONSENT_KEY, '1');
    } catch (err) {
      console.warn('[compat] unable to persist consent flag', err);
    }
  }

  function scheduleParse(which) {
    if (parseTimers.has(which)) {
      clearTimeout(parseTimers.get(which));
    }
    const timer = setTimeout(async () => {
      parseTimers.delete(which);
      try {
        await parseAndCache(which);
      } catch (error) {
        console.error('[compat] Unable to parse survey', error);
        const id = error?.which || which;
        resetSelection(id, { resetStatus: false });
        let message = 'Upload failed. Please try again.';
        if (error instanceof SyntaxError) {
          message = 'Invalid file — expected a TalkKink JSON export.';
        } else if (error?.message === 'No survey answers found') {
          message = 'Upload failed — no survey answers detected.';
        }
        setStatus(id, message, 'error');
        updateDownloadState();
        dispatch('compat:file-selected', { which: id, file: null });
      }
    }, 0);
    parseTimers.set(which, timer);
  }

  function handleFileSelection(event) {
    const target = event.target;
    if (!(target instanceof HTMLInputElement)) return;
    if (target !== yourInput && target !== partnerInput) return;

    event.stopImmediatePropagation();
    event.stopPropagation();

    const which = target === partnerInput ? 'partner' : 'self';
    const file = target.files?.[0];

    const run = async () => {
      if (!file) {
        target.value = '';
        resetSelection(which);
        updateDownloadState();
        dispatch('compat:file-selected', { which, file: null });
        return;
      }

      if (which === 'partner' && !getConsentFlag()) {
        const ok = confirm(
          'Before importing a partner’s survey, confirm you have their explicit consent to upload and compare their responses here.\n\n' +
            'Click “OK” to confirm consent and continue, or “Cancel” to stop.'
        );
        if (!ok) {
          target.value = '';
          resetSelection('partner');
          setStatus('partner', 'Upload canceled — partner consent required.', 'info');
          updateDownloadState();
          dispatch('compat:file-selected', { which: 'partner', file: null });
          return;
        }
        setConsentFlag();
      }

      if (which === 'self') {
        yourBlob = file;
        yourJSON = null;
        setStatus('self', 'Processing your survey…', 'info');
      } else {
        partnerBlob = file;
        partnerJSON = null;
        setStatus('partner', 'Processing partner survey…', 'info');
      }

      dispatch('compat:file-selected', { which, file });
      updateDownloadState();
      target.value = '';
      scheduleParse(which);
    };

    run().catch((error) => {
      console.error('[compat] File selection failed', error);
      resetSelection(which);
      updateDownloadState();
      dispatch('compat:file-selected', { which, file: null });
    });
  }

  function clampScore(value) {
    const num = Number(value);
    if (!Number.isFinite(num)) return 0;
    if (num <= 0) return 0;
    if (num >= 5) return 5;
    return Math.round(num);
  }

  const ROLE_ALIASES = {
    giving: 'Giving',
    giver: 'Giving',
    dom: 'Dominant',
    dominant: 'Dominant',
    top: 'Dominant',
    receiving: 'Receiving',
    receiver: 'Receiving',
    sub: 'Submissive',
    submissive: 'Submissive',
    bottom: 'Submissive',
    switch: 'Switch',
    general: 'General',
    neutral: 'General'
  };

  function normalizeRole(value) {
    if (!value) return 'General';
    const key = String(value).trim().toLowerCase();
    return ROLE_ALIASES[key] || (key ? key[0].toUpperCase() + key.slice(1) : 'General');
  }

  function tidyLabel(value, fallback = '') {
    const str = String(value || '').replace(/\s+/g, ' ').trim();
    return str || fallback;
  }

  function normalizeCompatPayload(raw, which) {
    if (!raw) return raw;

    if (Array.isArray(raw)) {
      const answers = raw.map((score, idx) => ({
        kinkId: `item-${idx + 1}`,
        side: 'general',
        score
      }));
      return normalizeCompatPayload({ answers }, which);
    }

    if (typeof raw !== 'object') return raw;

    const normalized = { ...raw };

    const responses = Array.isArray(normalized.responses)
      ? normalized.responses
          .map((entry, idx) => {
            if (!entry || typeof entry !== 'object') return null;
            const baseId = String(entry.id || `${which || 'A'}-${idx + 1}`);
            const role = normalizeRole(entry.role || entry.side || entry.channel);
            const rating = clampScore(entry.rating ?? entry.score ?? entry.value ?? 0);
            const prompt = tidyLabel(entry.prompt || entry.label || entry.title || entry.name || entry.question, baseId);
            const category = tidyLabel(
              entry.category || entry.categoryName || entry.group || entry.section,
              normalized.meta?.surveyTitle || ''
            );
            return {
              ...entry,
              id: baseId,
              role,
              rating,
              prompt,
              category
            };
          })
          .filter(Boolean)
      : [];

    normalized.responses = responses;

    const seenIds = new Set(responses.map((entry) => entry.id));
    const ensureAnswersArray = () => {
      const sources = [];
      if (Array.isArray(normalized.answers)) sources.push(normalized.answers);
      if (Array.isArray(normalized.survey?.answers)) sources.push(normalized.survey.answers);
      if (Array.isArray(normalized.survey?.responses)) sources.push(normalized.survey.responses);
      return sources.flat();
    };

    const candidates = ensureAnswersArray();

    candidates.forEach((answer, idx) => {
      if (!answer || typeof answer !== 'object') return;
      const kinkId = tidyLabel(answer.kinkId || answer.id || answer.key || answer.name || answer.questionId, `item-${idx + 1}`);
      const sideRaw = String(answer.side || answer.role || answer.channel || 'general');
      const role = normalizeRole(sideRaw);
      const score = clampScore(answer.score ?? answer.rating ?? answer.value ?? answer.answer ?? 0);
      const category = tidyLabel(
        answer.category || answer.categoryName || answer.group || answer.section || answer.categoryId,
        normalized.meta?.surveyTitle || ''
      );
      const prompt = tidyLabel(answer.title || answer.label || answer.prompt || answer.name || kinkId, kinkId);
      const idHint = tidyLabel(answer.id || '', kinkId);
      const baseId = idHint && idHint !== kinkId ? idHint : kinkId;
      const sideKey = sideRaw.trim().toLowerCase() || 'general';
      const composedId = baseId.toLowerCase().endsWith(`-${sideKey}`) ? baseId : `${baseId}-${sideKey}`;
      if (!seenIds.has(composedId)) {
        responses.push({
          id: composedId,
          kinkId,
          role,
          rating: score,
          category,
          prompt
        });
        seenIds.add(composedId);
      }
    });

    if (!normalized.answersById || typeof normalized.answersById !== 'object') {
      normalized.answersById = {};
    }

    responses.forEach((entry, idx) => {
      if (!entry || typeof entry !== 'object') return;
      const id = tidyLabel(entry.id, `${which || 'A'}-${idx + 1}`);
      const score = clampScore(entry.rating ?? entry.score ?? entry.value ?? 0);
      normalized.answersById[id] = score;
    });

    if (!normalized.answersByKey || typeof normalized.answersByKey !== 'object') {
      const map = {};
      responses.forEach((entry, idx) => {
        map[String(idx + 1)] = clampScore(entry.rating ?? entry.score ?? entry.value ?? 0);
      });
      if (Object.keys(map).length) normalized.answersByKey = map;
    }

    return normalized;
  }

  function rowsFromTalkKink(json) {
    if (!json) return [];

    const rows = [];
    const pushRow = (source, idx = 0) => {
      if (!source || typeof source !== 'object') return;
      const score = clampScore(source.score ?? source.rating ?? source.value ?? source.answer ?? 0);
      const label = tidyLabel(source.item || source.prompt || source.title || source.label || source.name || source.id, `Item ${idx + 1}`);
      const role = normalizeRole(source.role || source.side || source.channel || source.position);
      const category = tidyLabel(source.category || source.categoryName || source.group || source.section, 'Other');
      const kinkKey = tidyLabel(source.kinkId || source.id || label, label);
      rows.push({
        Category: category || 'Other',
        Item: label ? label.charAt(0).toUpperCase() + label.slice(1) : 'Item',
        Role: role,
        Score: score,
        _key: `${kinkKey}|${role}`.toLowerCase()
      });
    };

    if (Array.isArray(json.responses) && json.responses.length) {
      json.responses.forEach((resp, idx) => pushRow(resp, idx));
    } else if (Array.isArray(json.answers) && json.answers.length) {
      json.answers.forEach((answer, idx) => pushRow(answer, idx));
    } else if (json.answersById && typeof json.answersById === 'object') {
      Object.entries(json.answersById).forEach(([id, score], idx) => {
        if (!id) return;
        const parts = String(id).split('-');
        const role = normalizeRole(parts.at(-1));
        const base = parts.slice(0, -1).join('-');
        const label = tidyLabel(
          parts
            .slice(2, -1)
            .join(' ')
            .replace(/\bTv\b/gi, 'TV'),
          `Item ${idx + 1}`
        );
        const category = tidyLabel(parts.slice(0, 2).join(' '), 'Other');
        rows.push({
          Category: category || 'Other',
          Item: label ? label.charAt(0).toUpperCase() + label.slice(1) : 'Item',
          Role: role,
          Score: clampScore(score),
          _key: `${base}|${role}`.toLowerCase()
        });
      });
    }

    const deduped = Array.from(
      rows.reduce((map, row) => {
        if (!map.has(row._key)) map.set(row._key, row);
        return map;
      }, new Map()).values()
    );

    deduped.sort(
      (a, b) =>
        a.Category.localeCompare(b.Category) ||
        a.Role.localeCompare(b.Role) ||
        a.Item.localeCompare(b.Item)
    );

    return deduped;
  }

  function buildComparisonBody(rowsA, rowsB) {
    const key = (r) => (r._key || `${r.Role}|${r.Item}`).toLowerCase();
    const mapA = Object.fromEntries(rowsA.map((r) => [key(r), r]));
    const mapB = Object.fromEntries(rowsB.map((r) => [key(r), r]));
    const keys = [...new Set([...Object.keys(mapA), ...Object.keys(mapB)])].sort();
    const body = [];
    for (const k of keys) {
      const a = mapA[k];
      const b = mapB[k];
      const item = a?.Item || b?.Item || '';
      const aScore = Number.isFinite(a?.Score) ? a.Score : '';
      const bScore = Number.isFinite(b?.Score) ? b.Score : '';

      let matchText = '';
      let flagColor = null;
      if (a && b) {
        const diff = Math.abs(a.Score - b.Score);
        const pct = Math.max(0, Math.min(100, Math.round((1 - diff / 5) * 100)));
        matchText = `${pct}%`;
        if (pct > 85) flagColor = FLAG_GREEN;
        else if (pct >= 50) flagColor = FLAG_YELLOW;
        else flagColor = FLAG_RED;
      }
      body.push({
        item,
        aScore: String(aScore),
        matchText,
        flagColor,
        bScore: String(bScore)
      });
    }
    return body;
  }

  async function parseAndCache(which) {
    const isSelf = which === 'self';
    const blob = isSelf ? yourBlob : partnerBlob;
    if (!blob) return null;

    if (isSelf ? yourJSON : partnerJSON) {
      return isSelf ? yourJSON : partnerJSON;
    }

    const text = await blob.text();
    let json;
    try {
      json = JSON.parse(text);
    } catch (err) {
      err.which = which;
      throw err;
    }

    json = normalizeCompatPayload(json, which);

    if (!json || !json.answersById || !Object.keys(json.answersById).length) {
      const error = new Error('No survey answers found');
      error.which = which;
      throw error;
    }

    if (isSelf) {
      yourJSON = json;
      window.talkkinkMine = json;
      window.talkkinkSurvey = json;
      try {
        localStorage.setItem(LS_SELF_KEY, JSON.stringify(json));
      } catch (err) {
        console.warn('[compat] unable to persist self survey', err);
      }
    } else {
      partnerJSON = json;
      window.talkkinkPartner = json;
      try {
        localStorage.setItem(LS_PARTNER_KEY, JSON.stringify(json));
      } catch (err) {
        console.warn('[compat] unable to persist partner survey', err);
      }
    }

    dispatch('compat:json-ready', {
      which,
      json,
      fileName: blob.name || ''
    });

    if (which === 'partner') {
      setStatus(which, 'Partner survey ready ✓ — consent recorded.', 'success');
    } else {
      setStatus(which, 'Your survey ready ✓', 'success');
    }

    updateDownloadState();
    return json;
  }

  class MiniPDF {
    constructor({ width = 612, height = 792 } = {}) {
      this.width = width;
      this.height = height;
      this.pages = [];
      this.fontSize = 12;
      this.currentFont = 'F1';
      this.textColor = [0, 0, 0];
      this.fillColor = [0, 0, 0];
      this.strokeColor = [0, 0, 0];
      this.lineWidth = 1;
      this.addPage();
    }

    addPage() {
      this.pages.push({ commands: [] });
      this.pageIndex = this.pages.length - 1;
    }

    _cmd(cmd) {
      this.pages[this.pageIndex].commands.push(cmd);
    }

    _formatColor(color) {
      return color
        .map((value) => {
          const num = Math.max(0, Math.min(255, Number(value) || 0)) / 255;
          return num.toFixed(3).replace(/\.0+$/, '').replace(/0+$/, '').replace(/\.$/, '') || '0';
        })
        .join(' ');
    }

    setFillColor(r = 0, g = 0, b = 0) {
      this.fillColor = [r, g, b];
    }

    setDrawColor(r = 0, g = 0, b = 0) {
      this.strokeColor = [r, g, b];
    }

    setTextColor(r = 0, g = 0, b = 0) {
      this.textColor = [r, g, b];
    }

    setLineWidth(width = 1) {
      const num = Number(width);
      this.lineWidth = Number.isFinite(num) && num > 0 ? num : 1;
    }

    setFont(_font = 'helvetica', style = 'normal') {
      const s = String(style || '').toLowerCase();
      this.currentFont = s.includes('bold') ? 'F2' : 'F1';
    }

    setFontSize(size = 12) {
      const num = Number(size);
      if (Number.isFinite(num) && num > 0) {
        this.fontSize = num;
      }
    }

    measureText(text, fontSize = this.fontSize) {
      const str = String(text ?? '');
      return str.length * (fontSize * 0.55);
    }

    _escape(text) {
      return String(text ?? '')
        .replace(/\\/g, '\\\\')
        .replace(/\(/g, '\\(')
        .replace(/\)/g, '\\)')
        .replace(/\r?\n/g, '\\n');
    }

    text(text, x, y, opts = {}) {
      const lines = String(text ?? '').split(/\r?\n/);
      const align = String(opts.align || '').toLowerCase();
      const lineHeight = opts.lineHeight || this.fontSize * 1.2;
      lines.forEach((line, idx) => {
        const width = this.measureText(line, this.fontSize);
        let drawX = x;
        if (align === 'center') drawX = x - width / 2;
        else if (align === 'right') drawX = x - width;
        const drawY = y + idx * lineHeight;
        const pdfY = this.height - drawY;
        const color = this._formatColor(this.textColor);
        const escaped = this._escape(line);
        const cmd = [
          `${color} rg`,
          `BT /${this.currentFont} ${this.fontSize.toFixed(2)} Tf`,
          `${drawX.toFixed(2)} ${pdfY.toFixed(2)} Td (${escaped}) Tj`,
          'ET'
        ].join('\n');
        this._cmd(cmd);
      });
    }

    rect(x, y, w, h, mode = 'S') {
      const pdfY = this.height - y - h;
      const fill = this._formatColor(this.fillColor);
      const stroke = this._formatColor(this.strokeColor);
      const lw = this.lineWidth.toFixed(2).replace(/\.0+$/, '').replace(/0+$/, '').replace(/\.$/, '') || '1';
      let op = 'S';
      if (mode === 'F') op = 'f';
      else if (mode === 'FD' || mode === 'DF') op = 'B';
      const cmds = [];
      if (op === 'f' || op === 'B') cmds.push(`${fill} rg`);
      if (op === 'S' || op === 'B') {
        cmds.push(`${stroke} RG`);
        cmds.push(`${lw} w`);
      }
      cmds.push(`${x.toFixed(2)} ${pdfY.toFixed(2)} ${w.toFixed(2)} ${h.toFixed(2)} re`);
      cmds.push(op);
      this._cmd(cmds.join('\n'));
    }

    line(x1, y1, x2, y2) {
      const pdfY1 = this.height - y1;
      const pdfY2 = this.height - y2;
      const stroke = this._formatColor(this.strokeColor);
      const lw = this.lineWidth.toFixed(2).replace(/\.0+$/, '').replace(/0+$/, '').replace(/\.$/, '') || '1';
      const cmd = [
        `${stroke} RG`,
        `${lw} w`,
        `${x1.toFixed(2)} ${pdfY1.toFixed(2)} m`,
        `${x2.toFixed(2)} ${pdfY2.toFixed(2)} l`,
        'S'
      ].join('\n');
      this._cmd(cmd);
    }

    circle(cx, cy, radius, mode = 'S') {
      const r = Number(radius);
      if (!Number.isFinite(r) || r <= 0) return;
      const fmt = (value) =>
        value.toFixed(2).replace(/\.0+$/, '').replace(/0+$/, '').replace(/\.$/, '') || '0';
      const toPdfY = (value) => this.height - value;
      const c = r * 0.5522847498;
      const segments = [
        [cx + c, cy - r, cx + r, cy - c, cx + r, cy],
        [cx + r, cy + c, cx + c, cy + r, cx, cy + r],
        [cx - c, cy + r, cx - r, cy + c, cx - r, cy],
        [cx - r, cy - c, cx - c, cy - r, cx, cy - r]
      ];
      const path = [`${fmt(cx)} ${fmt(toPdfY(cy - r))} m`];
      segments.forEach(([cp1x, cp1y, cp2x, cp2y, x, y]) => {
        path.push(
          `${fmt(cp1x)} ${fmt(toPdfY(cp1y))} ${fmt(cp2x)} ${fmt(toPdfY(cp2y))} ${fmt(x)} ${fmt(toPdfY(y))} c`
        );
      });
      path.push('h');
      let op = 'S';
      if (mode === 'F') op = 'f';
      else if (mode === 'FD' || mode === 'DF') op = 'B';
      const cmds = [];
      if (op === 'f' || op === 'B') cmds.push(`${this._formatColor(this.fillColor)} rg`);
      if (op === 'S' || op === 'B') {
        cmds.push(`${this._formatColor(this.strokeColor)} RG`);
        const lw = this.lineWidth.toFixed(2).replace(/\.0+$/, '').replace(/0+$/, '').replace(/\.$/, '') || '1';
        cmds.push(`${lw} w`);
      }
      cmds.push(path.join('\n'));
      cmds.push(op);
      this._cmd(cmds.join('\n'));
    }

    save(filename = 'document.pdf') {
      const objects = [];
      const pageRefs = [];

      objects.push({ name: 'font_regular', body: '<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>' });
      objects.push({ name: 'font_bold', body: '<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica-Bold >>' });

      this.pages.forEach((page, idx) => {
        const stream = page.commands.join('\n');
        const contentName = `content_${idx}`;
        const pageName = `page_${idx}`;
        objects.push({
          name: contentName,
          body: `<< /Length ${stream.length} >>\nstream\n${stream}\nendstream`
        });
        objects.push({
          name: pageName,
          body: `<< /Type /Page /Parent {{pages}} 0 R /MediaBox [0 0 ${this.width} ${this.height}] /Resources << /Font << /F1 {{font_regular}} 0 R /F2 {{font_bold}} 0 R >> >> /Contents {{${contentName}}} 0 R >>`
        });
        pageRefs.push(`{{${pageName}}} 0 R`);
      });

      objects.push({
        name: 'pages',
        body: `<< /Type /Pages /Kids [ ${pageRefs.join(' ')} ] /Count ${this.pages.length} >>`
      });

      objects.push({ name: 'catalog', body: '<< /Type /Catalog /Pages {{pages}} 0 R >>' });

      const refMap = new Map();
      objects.forEach((obj, idx) => {
        refMap.set(obj.name, idx + 1);
      });

      const resolveRefs = (body) =>
        body.replace(/\{\{([^}]+)\}\}/g, (_, name) => {
          const ref = refMap.get(name);
          if (!ref) throw new Error(`Unknown PDF reference: ${name}`);
          return String(ref);
        });

      let pdf = '%PDF-1.4\n';
      const offsets = [0];
      objects.forEach((obj, idx) => {
        offsets.push(pdf.length);
        pdf += `${idx + 1} 0 obj\n${resolveRefs(obj.body)}\nendobj\n`;
      });

      const xref = pdf.length;
      pdf += `xref\n0 ${objects.length + 1}\n`;
      pdf += '0000000000 65535 f \n';
      for (let i = 1; i <= objects.length; i += 1) {
        pdf += offsets[i].toString().padStart(10, '0') + ' 00000 n \n';
      }
      const rootRef = refMap.get('catalog');
      pdf += `trailer\n<< /Size ${objects.length + 1} /Root ${rootRef} 0 R >>\nstartxref\n${xref}\n%%EOF`;

      const blob = new Blob([pdf], { type: 'application/pdf' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = filename;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      setTimeout(() => {
        URL.revokeObjectURL(link.href);
        link.remove();
      }, 0);
    }
  }

  const FLAG_GREEN = [0, 200, 140];
  const FLAG_YELLOW = [255, 210, 70];
  const FLAG_RED = [255, 86, 86];

  const FLAG_ICON_BY_COLOR = new Map([
    [FLAG_GREEN.join(','), '▲'],
    [FLAG_YELLOW.join(','), '▶'],
    [FLAG_RED.join(','), '▼']
  ]);

  function buildTkpdfSections(selfJson, partnerJson) {
    const rowsA = rowsFromTalkKink(selfJson);
    const rowsB = rowsFromTalkKink(partnerJson);

    const categories = Array.from(
      new Set([...rowsA, ...rowsB].map((row) => row.Category || 'Survey'))
    ).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));

    const sections = [];

    const exportedRows = [];

    categories.forEach((category) => {
      const body = buildComparisonBody(
        rowsA.filter((row) => row.Category === category),
        rowsB.filter((row) => row.Category === category)
      );

      if (!body.length) return;

      const rows = body.map((entry) => {
        const matchText = entry.matchText;
        let matchValue = '';
        if (typeof matchText === 'number' && Number.isFinite(matchText)) {
          matchValue = matchText;
        } else if (typeof matchText === 'string') {
          const numeric = parseInt(matchText.replace(/[^0-9-]/g, ''), 10);
          matchValue = Number.isFinite(numeric) ? numeric : matchText.trim();
        }

        const colorKey = Array.isArray(entry.flagColor) ? entry.flagColor.join(',') : null;
        const flagIcon = colorKey ? FLAG_ICON_BY_COLOR.get(colorKey) || '▶' : '';

        return {
          label: entry.item || '',
          a: entry.aScore ?? '',
          matchPct: matchValue,
          flagIcon,
          b: entry.bScore ?? ''
        };
      });

      if (rows.length) {
        sections.push({ category, rows });
        rows.forEach((row) => {
          exportedRows.push([
            row.label,
            row.a,
            row.matchPct,
            row.flagIcon,
            row.b,
          ]);
        });
      }
    });

    if (exportedRows.length) {
      window.talkkinkCompatRows = exportedRows;
      try {
        localStorage.setItem('talkkink:compatRows', JSON.stringify(exportedRows));
      } catch (error) {
        console.warn('[comparison] Failed to write compat rows to localStorage', error);
      }
      console.info('[comparison] Saved compatibility rows for PDF:', exportedRows.length);
    } else {
      window.talkkinkCompatRows = [];
      try {
        localStorage.removeItem('talkkink:compatRows');
      } catch (error) {
        console.warn('[comparison] Failed to clear compat rows from localStorage', error);
      }
    }

    return sections;
  }

  function wrapText(text, maxWidth, fontSize = 10) {
    const raw = String(text ?? '').trim();
    if (!raw) return [''];
    const approxCharWidth = fontSize * 0.55;
    const maxChars = Math.max(Math.floor(maxWidth / approxCharWidth), 1);
    const words = raw.split(/\s+/);
    const lines = [];
    let current = '';
    const flush = () => {
      if (current) {
        lines.push(current);
        current = '';
      }
    };
    words.forEach((word) => {
      if (!word) return;
      if (!current.length) {
        if (word.length <= maxChars) {
          current = word;
        } else {
          for (let i = 0; i < word.length; i += maxChars) {
            const chunk = word.slice(i, i + maxChars);
            if (chunk.length === maxChars) lines.push(chunk);
            else current = chunk;
          }
        }
        return;
      }
      if (current.length + 1 + word.length <= maxChars) {
        current += ` ${word}`;
        return;
      }
      flush();
      if (word.length <= maxChars) {
        current = word;
      } else {
        for (let i = 0; i < word.length; i += maxChars) {
          const chunk = word.slice(i, i + maxChars);
          if (chunk.length === maxChars) lines.push(chunk);
          else current = chunk;
        }
      }
    });
    flush();
    return lines.length ? lines : [''];
  }

  function drawTextBlock(doc, lines, x, y, width, height, { align = 'left', fontSize = 10, fontStyle = 'normal' } = {}) {
    const cleanLines = lines.length ? lines : [''];
    const lineHeight = fontSize * 1.2;
    const totalHeight = cleanLines.length * lineHeight;
    const offsetY = y + Math.max((height - totalHeight) / 2, 0) + lineHeight - 2;
    doc.setFont('helvetica', fontStyle);
    doc.setFontSize(fontSize);
    cleanLines.forEach((line, idx) => {
      let drawX = x;
      if (align === 'center') drawX = x + width / 2;
      else if (align === 'right') drawX = x + width;
      doc.text(line, drawX, offsetY + idx * lineHeight, { align });
    });
  }

  async function generateDarkPDF(yourJSON, partnerJSON) {
    await ensurePdfLibs();

    const doc = createPdfDoc();
    tkEnsureAutoTable(doc);

    const pageSize = doc.internal.pageSize;
    const W = typeof pageSize.getWidth === 'function' ? pageSize.getWidth() : pageSize.width;
    const CONTENT_W = Math.min(680, W - 96);
    const SECTION_TITLE_START = 108;
    const SECTION_GAP = 18;
    const TABLE_OFFSET = 22;

    const CYAN = [0, 255, 255];
    const BODY1 = [8, 8, 10];
    const BODY2 = [13, 13, 17];
    const GRID = [30, 30, 38];
    const WHITE = [255, 255, 255];
    const GREEN = [0, 200, 140];
    const YELLOW = [255, 210, 70];
    const RED = [255, 86, 86];

    const renderSection =
      window.tkHeaderAndTable || window.tkPageCenteredHeaderAndTable || window.tkCenteredHeaderAndTable;
    if (typeof renderSection !== 'function') {
      throw new Error('tkHeaderAndTable helper unavailable');
    }

    const base = {
      theme: 'grid',
      styles: {
        font: 'helvetica',
        fontSize: 10,
        cellPadding: 4,
        textColor: WHITE,
        fillColor: BODY1,
        lineColor: GRID,
        lineWidth: 0.25
      },
      alternateRowStyles: { fillColor: BODY2 },
      headStyles: {
        fillColor: [0, 0, 0],
        textColor: CYAN,
        lineColor: GRID,
        lineWidth: 0.25,
        fontStyle: 'bold'
      }
    };

    let nextSectionStart = SECTION_TITLE_START;
    const addSection = (title, tableOverrides = {}) => {
      const { startY: tableStartOverride, ...restOverrides } = tableOverrides;
      const tableStart =
        tableStartOverride == null ? nextSectionStart + TABLE_OFFSET : tableStartOverride;
      const finalY = renderSection(doc, title, {
        ...base,
        ...restOverrides,
        startY: tableStart,
        sectionY: nextSectionStart
      });
      nextSectionStart = (finalY ?? tableStart) + SECTION_GAP;
      return finalY;
    };

    const rowsFrom = (json) => {
      if (!json) return [];
      const map = json.answersById || {};
      const out = [];
      for (const [id, score] of Object.entries(map)) {
        const parts = id.split('-');
        const role = parts.at(-1);
        const category = (parts[0] + ' ' + parts[1]).replace(/\b\w/g, (m) => m.toUpperCase());
        const item = parts
          .slice(2, -1)
          .join(' ')
          .replace(/\bTv\b/gi, 'TV')
          .replace(/\s+/g, ' ')
          .trim();
        out.push({
          Category: category,
          Item: item.charAt(0).toUpperCase() + item.slice(1),
          Role: role.charAt(0).toUpperCase() + role.slice(1),
          Score: Number(score)
        });
      }
      out.sort(
        (a, b) =>
          a.Category.localeCompare(b.Category) ||
          a.Role.localeCompare(b.Role) ||
          a.Item.localeCompare(b.Item)
      );
      return out;
    };

    const A = rowsFrom(window.yourJSON || yourJSON);
    const B = rowsFrom(window.partnerJSON || partnerJSON);
    const hasA = A.length > 0;
    const hasB = B.length > 0;

    function buildAB(Arows, Brows) {
      const key = (r) => `${r.Role}|${r.Item}`.toLowerCase();
      const aMap = Object.fromEntries(Arows.map((r) => [key(r), r]));
      const bMap = Object.fromEntries(Brows.map((r) => [key(r), r]));
      const keys = [...new Set([...Object.keys(aMap), ...Object.keys(bMap)])].sort();
      return keys.map((k) => {
        const a = aMap[k];
        const b = bMap[k];
        const item = a?.Item || b?.Item || '';
        const aS = Number.isFinite(a?.Score) ? a.Score : null;
        const bS = Number.isFinite(b?.Score) ? b.Score : null;

        let pct = null;
        let color = null;
        if (aS != null && bS != null) {
          pct = Math.round((1 - Math.abs(aS - bS) / 5) * 100);
          if (pct > 85) color = GREEN;
          else if (pct >= 50) color = YELLOW;
          else color = RED;
        }
        return {
          item,
          a: aS == null ? '' : String(aS),
          match: pct == null ? '' : pct + '%',
          flag: '',
          _flagColor: color,
          b: bS == null ? '' : String(bS)
        };
      });
    }

    function flagShapeHook(flagKey){
      return {
        didDrawCell(data){
          if (data.section !== 'body' || data.column.dataKey !== flagKey) return;

          const color = data.row?.raw?._flagColor;
          if (!color) return;

          const { x, y, height } = data.cell;
          const poleX = x + 10;
          const poleTop = y + 6;
          const poleBottom = y + height - 6;

          // Pennant geometry
          const px = poleX + 1;     // pennant start (slightly right of pole)
          const h  = 10;            // pennant height
          const w  = 14;            // pennant width
          const py = (poleTop + poleBottom)/2 - h/2;

          // Draw pole (subtle gray)
          const prevStroke = doc.getDrawColor();
          doc.setDrawColor(180,180,190);
          if (typeof doc.setLineWidth === 'function') doc.setLineWidth(1);
          doc.line(poleX, poleTop, poleX, poleBottom);

          // Try to draw a FILLED triangular pennant using jsPDF.lines (stable across builds)
          const prevFill = doc.getFillColor();
          try {
            doc.setFillColor(color[0], color[1], color[2]);
            doc.setDrawColor(color[0], color[1], color[2]);
            // Path: (px,py) -> (px+w, py+h/2) -> (px, py+h) -> close
            // Signature: lines(segments, startX, startY, scale=1, style='F', closed=true)
            doc.lines(
              [
                [ w,   h/2],   // to (px+w, py+h/2)
                [-w,   h/2]    // to (px,   py+h)
              ],
              px, py,
              1,              // scale (NUMBER, not array) — prevents crash
              'F',            // fill
              true            // closed path
            );
          } catch (e) {
            // Fallback: draw a colored dot so PDF still generates
            const cx = px + 6, cy = py + h/2, r = 4;
            doc.setFillColor(color[0], color[1], color[2]);
            doc.circle(cx, cy, r, 'F');
          } finally {
            doc.setFillColor(prevFill);
            doc.setDrawColor(prevStroke);
          }
        }
      };
    }

    if (hasA && hasB) {
      const cats = [...new Set([...A, ...B].map((r) => r.Category))];
      for (const c of cats) {
        const body = buildAB(
          A.filter((r) => r.Category === c),
          B.filter((r) => r.Category === c)
        );

        const itemWidth = CONTENT_W - (70 + 60 + 50 + 70);

        addSection(c, {
          ...flagShapeHook('flag'),
          columns: [
            { header: 'Item', dataKey: 'item' },
            { header: 'Partner A', dataKey: 'a' },
            { header: 'Match', dataKey: 'match' },
            { header: 'Flag', dataKey: 'flag' },
            { header: 'Partner B', dataKey: 'b' }
          ],
          body,
          columnStyles: {
            item: { cellWidth: itemWidth },
            a: { cellWidth: 70, halign: 'center' },
            match: { cellWidth: 60, halign: 'center' },
            flag: { cellWidth: 50, halign: 'left' },
            b: { cellWidth: 70, halign: 'center' }
          }
        });
      }
    } else {
      const rows = hasA ? A : B;
      const who = hasA ? 'Partner A' : 'Partner';
      const cats = [...new Set(rows.map((r) => r.Category))];
      for (const c of cats) {
        addSection(`${c} — ${who}`, {
          head: [['Item', 'Score']],
          body: rows
            .filter((r) => r.Category === c)
            .map((r) => [r.Item, String(r.Score)]),
          columnStyles: {
            0: { cellWidth: CONTENT_W - 70 },
            1: { cellWidth: 70, halign: 'center' }
          }
        });
      }
    }

    const name = hasA && hasB ? 'compatibility-pretty-dark.pdf' : 'partner-survey-pretty-dark.pdf';
    doc.save(name);
  }


  window.generateDarkPDF = generateDarkPDF;

  async function handleDownloadClick(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    event.stopPropagation();
    try {
      await Promise.all([parseAndCache('self'), parseAndCache('partner')]);

      if (!yourJSON && !partnerJSON) {
        alert('Load at least one survey first (yours or partner).');
        console.warn('[compat] No survey loaded; aborting PDF.');
        return;
      }

      if (window.TKPDF && typeof window.TKPDF.download === 'function') {
        const sections = buildTkpdfSections(yourJSON, partnerJSON);
        if (!sections.length) {
          alert('Sorry—could not find any survey rows to export.');
          return;
        }
        await window.TKPDF.download({ mine: sections });
        return;
      }

      await generateDarkPDF(yourJSON, partnerJSON);
    } catch (error) {
      console.error('[compat] PDF generation failed:', error);
      alert('Sorry—could not generate the PDF.');
    }
  }

  function bindDomOnce() {
    if (bindDomOnce.bound) return;

    yourBtn = $('#yourBtn');
    partnerBtn = $('#partnerBtn');
    yourInput = $('#yourFile');
    partnerInput = $('#partnerFile');
    yourStatus = $('#yourStatus');
    partnerStatus = $('#partnerStatus');

    statusEls.self = yourStatus;
    statusEls.partner = partnerStatus;

    setDownloadButton($('#downloadBtn'));

    if (!yourInput || !partnerInput) {
      console.error('[compat] Required elements missing (#yourFile, #partnerFile).');
      return;
    }

    if (!downloadBtn) {
      console.warn('[compat] Download button missing (#downloadBtn) — PDF export disabled.');
    }

    if (yourBtn) {
      yourBtn.addEventListener('click', (event) => {
        event.preventDefault();
        openPicker(yourInput);
      });
    }

    if (partnerBtn) {
      partnerBtn.addEventListener('click', (event) => {
        event.preventDefault();
        openPicker(partnerInput);
      });
    }

    document.addEventListener('change', handleFileSelection, true);

    if (document.body) {
      const watchDownload = new MutationObserver(() => {
        const btn = $('#downloadBtn');
        if (btn !== downloadBtn) setDownloadButton(btn);
      });
      watchDownload.observe(document.body, { childList: true, subtree: true });
      setTimeout(() => watchDownload.disconnect(), 4000);
    }

    bindDomOnce.bound = true;
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bindDomOnce, { once: true });
  } else {
    bindDomOnce();
  }

  window.tkResetPartnerConsent = () => {
    try {
      sessionStorage.removeItem(CONSENT_KEY);
    } catch (err) {
      console.warn('[compat] unable to reset consent flag', err);
    }
    console.info('[compat] Partner consent reset for this tab.');
  };
})();
  </script>


    <script defer src="/assets/js/comparison.js"></script>
  <script defer>
    /**
     * Safely clear margin on the dock *only if it exists on this page*.
     * This replaces any previous null-unsafe code around lines ~188–192.
     */
    (function () {
      const SELECTOR = '#compat-dock, .compat-dock, [data-compat-dock]';

      function clearDockMarginSafe() {
        const el = document.querySelector(SELECTOR);
        if (!el) return;                  // No-op if the dock isn't present
        el.style.removeProperty('margin');
        el.style.removeProperty('margin-bottom');
      }

      // Run after DOM is parsed; also handle late mounts briefly
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', clearDockMarginSafe, { once: true });
      } else {
        queueMicrotask(clearDockMarginSafe);
      }
      const mo = new MutationObserver(() => {
        const el = document.querySelector(SELECTOR);
        if (el) { clearDockMarginSafe(); mo.disconnect(); }
      });
      mo.observe(document.documentElement, { childList: true, subtree: true });
      setTimeout(() => mo.disconnect(), 3000);
    })();
  </script>
<!-- Load jsPDF v2 UMD (exposes window.jspdf.jsPDF) -->
<script
  src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
  crossorigin="anonymous"
  referrerpolicy="no-referrer"
  data-lib="jspdf"
></script>

<!-- Your code that uses jsPDF should come AFTER -->
<script src="assets/js/compatPdf.js?v=clean-reset-1" defer></script>
</body>

</html>
