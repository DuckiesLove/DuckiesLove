<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>See Our Compatibility</title>
  <!-- Import theme and global layout styles -->
  <link rel="stylesheet" href="/css/theme.css" />
  <link rel="stylesheet" href="/css/global.css" />
  <link rel="stylesheet" href="/css/compat-table.css" />
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
/**
 * Kink Compatibility — drop-in renderer for your existing data shape.
 *
 * INPUT SHAPE (what you already have):
 * const rowsByCategory = {
 *   "Appearance Play": [
 *     { id: "appearance_outfit",   label: "Choosing my partner's outfit for the day or a scene" },
 *     { id: "appearance_underwear",label: "Selecting their underwear, lingerie, or base layers" },
 *     ...
 *   ],
 *   "Bondage": [
 *     { id: "bondage_rope", label: "Rope (tying, harnesses, decorative)" },
 *     ...
 *   ]
 * };
 *
 * Uploads must set:
 *   window.partnerASurvey (or window.surveyA)
 *   window.partnerBSurvey (or window.surveyB)
 *
 * Then call:
 *   window.updateComparison(rowsByCategory)
 */

(function(){
  // ---------- Normalization + Survey -> Lookup ----------
  function norm(s){
    return String(s||'')
      .replace(/[\u2018\u2019\u2032]/g,"'")
      .replace(/[\u201C\u201D\u2033]/g,'"')
      .replace(/[\u2013\u2014]/g,'-')
      .replace(/\u2026/g,'')
      .replace(/\s*\.\.\.\s*$/,'')
      .replace(/\s+/g,' ')
      .trim().toLowerCase();
  }

  // Supports flat objects, {items:[...]}, or nested {survey:{...}}
  function toLookup(json){
    const map = new Map();
    if (!json || typeof json !== 'object') return map;

    // Flat object: { "Choosing my partner's outfit ...": 4, ... }
    if (!Array.isArray(json) && !json.items && !json.survey){
      for (const [k,v] of Object.entries(json)){
        const n = Number(v);
        if (Number.isFinite(n)) map.set(norm(k), n);
      }
      return map;
    }

    // Items list: { items: [{ name|label|key|id, rating|score|value }, ...] }
    if (Array.isArray(json.items)){
      for (const it of json.items){
        const k = norm(it?.name ?? it?.label ?? it?.key ?? it?.id ?? '');
        const n = Number(it?.rating ?? it?.score ?? it?.value);
        if (k && Number.isFinite(n)) map.set(k, n);
      }
      return map;
    }

    // Nested survey export: { survey: { Category: { Giving/Receiving/General: [...] } } }
    if (json.survey && typeof json.survey === 'object'){
      Object.values(json.survey).forEach(section=>{
        ['Giving','Receiving','General'].forEach(bucket=>{
          (Array.isArray(section?.[bucket]) ? section[bucket] : []).forEach(item=>{
            const k = norm(item?.name ?? item?.label ?? item?.id ?? '');
            const n = Number(item?.rating ?? item?.score ?? item?.value);
            if (k && Number.isFinite(n)){
              // prefer max if duplicates occur
              map.set(k, Math.max(map.get(k) ?? -Infinity, n));
            }
          });
        });
      });
    }

    return map;
  }

  // ---------- Fill + Match ----------
  function fillPartnerCells(tbody, cls, lookup){
    if (!lookup || !lookup.size) return 0;
    let wrote = 0;
    tbody.querySelectorAll('tr').forEach(tr=>{
      const td = tr.querySelector('td.'+cls);
      if (!td) return;
      const cur = (td.textContent||'').trim();
      if (cur && !/^[-–—]$/.test(cur)) return; // don't overwrite real values
      const key = norm(tr.getAttribute('data-full') || tr.getAttribute('data-id') || '');
      if (!key) return;
      const val = lookup.get(key);
      if (val == null) return;
      td.textContent = String(val);
      wrote++;
    });
    return wrote;
  }

  function computeMatch(a, b){
    const na = Number(a), nb = Number(b);
    if (!Number.isFinite(na) || !Number.isFinite(nb)) return '';
    const diff = Math.abs(na - nb);            // assuming 1..5 scale
    const pct  = Math.round((1 - diff/4) * 100); // 100..0
    return pct + '%';
  }

  function recomputeMatches(tbody){
    tbody.querySelectorAll('tr').forEach(tr=>{
      const a = tr.querySelector('td.pa')?.textContent;
      const b = tr.querySelector('td.pb')?.textContent;
      const m = tr.querySelector('td.match');
      if (m) m.textContent = computeMatch(a, b);
    });
  }

  // ---------- Category Table Renderer ----------
  function renderCategoryTable(category, items, mount){
    const section = document.createElement('section');
    section.className = 'compat-section';

    const title = document.createElement('h2');
    title.className = 'section-title';
    title.textContent = category;
    section.appendChild(title);

    const table = document.createElement('table');
    table.className = 'compat-table';

    const thead = document.createElement('thead');
    const thr = document.createElement('tr');
    const hCat   = document.createElement('th'); hCat.textContent   = 'Category';
    const hA     = document.createElement('th'); hA.textContent     = 'Partner A';
    const hMatch = document.createElement('th'); hMatch.textContent = 'Match';
    const hB     = document.createElement('th'); hB.textContent     = 'Partner B';
    thr.append(hCat, hA, hMatch, hB);
    thead.appendChild(thr);

    const tbody = document.createElement('tbody');

    items.forEach(row=>{
      const tr = document.createElement('tr');
      if (row.id)    tr.setAttribute('data-id', row.id);
      if (row.label) tr.setAttribute('data-full', row.label); // full key for matching

      const tdLabel = document.createElement('td');
      tdLabel.textContent = row.label || '';

      const tdA = document.createElement('td');
      tdA.className = 'pa';
      tdA.textContent = '-';

      const tdMatch = document.createElement('td');
      tdMatch.className = 'match';
      tdMatch.textContent = '';

      const tdB = document.createElement('td');
      tdB.className = 'pb';
      tdB.textContent = '-';

      tr.append(tdLabel, tdA, tdMatch, tdB);
      tbody.appendChild(tr);
    });

    table.append(thead, tbody);
    section.appendChild(table);
    mount.appendChild(section);

    // Initial fill from globals, if present
    const aLookup = toLookup(window.partnerASurvey || window.surveyA || null);
    const bLookup = toLookup(window.partnerBSurvey || window.surveyB || null);
    const wroteA  = fillPartnerCells(tbody, 'pa', aLookup);
    const wroteB  = fillPartnerCells(tbody, 'pb', bLookup);
    if (wroteA || wroteB) recomputeMatches(tbody);
  }

  // ---------- Public API ----------
  window.updateComparison = function(rowsByCategory){
    const root = document.querySelector('[data-compat-root]') || document.querySelector('#compat-container') || document.querySelector('#compat-container');
    if (!root) { console.error('[compat] Missing container. Add data-compat-root to the wrapper.'); return; }

    root.innerHTML = ''; // rebuild fresh

    if (Array.isArray(rowsByCategory)) {
      // If a flat array was passed, render as a single category
      renderCategoryTable('All', rowsByCategory, root);
    } else {
      Object.entries(rowsByCategory || {}).forEach(([cat, items])=>{
        renderCategoryTable(cat, Array.isArray(items) ? items : [], root);
      });
    }
  };

  // Re-fill when a new JSON is uploaded (uses your existing upload inputs)
  document.addEventListener('change', (e)=>{
    const isA = e.target && e.target.matches('#uploadSurveyA,[data-upload-a]');
    const isB = e.target && e.target.matches('#uploadSurveyB,[data-upload-b]');
    if (!(isA || isB)) return;

    setTimeout(()=>{
      const aLookup = toLookup(window.partnerASurvey || window.surveyA || null);
      const bLookup = toLookup(window.partnerBSurvey || window.surveyB || null);
      document.querySelectorAll('[data-compat-root] table').forEach(table=>{
        const tbody = table.querySelector('tbody');
        const wroteA = isA ? fillPartnerCells(tbody, 'pa', aLookup) : 0;
        const wroteB = isB ? fillPartnerCells(tbody, 'pb', bLookup) : 0;
        if (wroteA || wroteB) recomputeMatches(tbody);
      });
      if (typeof window.populateFlags === 'function') window.populateFlags();
    }, 120);
  });
})();
  </script>
  <style>
  #compat-container {
    width: 100%;
    max-width: 100%;
  }
  table {
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    text-align: center;
    vertical-align: middle;
    padding: 6px;
  }
  th:first-child, td:first-child {
    text-align: left;
    padding-left: 10px;
  }
  </style>
  <style>
    .upload-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      margin-top: 3rem;
    }

      .upload-button {
        position: relative;
        display: inline-block;
      }

    .upload-button input[type="file"] {
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .wide-button {
      min-width: 260px;
      max-width: 300px;
      width: 100%;
    }
  </style>
  <style>
    /* Keep rows from splitting in both web and print */
    .compat-section tr { break-inside: avoid; page-break-inside: avoid; }

    /* Make sure tables are fixed-width to avoid right-side cutoff */
    .compat-section table {
      width: 100% !important;
      table-layout: fixed !important;
      border-collapse: collapse !important;
    }

    /* Optional: make header clean (no decorative lines/boxes) */
    .section-title, .category-header, .compat-category {
      border: none !important;
      box-shadow: none !important;
      background: transparent !important;
    }
  </style>
</head>
<body class="theme-dark">
  <div class="main-container themed">
    <h1 class="page-title">See Our Compatibility</h1>
    <div class="upload-container">
      <button class="themed-button wide-button" onclick="window.history.back()">← Back</button>

      <label id="uploadYourSurvey" class="upload-button themed-button wide-button">
        <input id="uploadSurveyA" type="file" accept="application/json" />
        Upload Your Survey
      </label>

      <label id="uploadPartnerSurvey" class="upload-button themed-button wide-button">
        <input id="uploadSurveyB" type="file" accept="application/json" />
        Upload Partner’s Survey
      </label>

      <button class="themed-button wide-button" id="downloadBtn">Download PDF</button>
    </div>

    <div id="comparisonResults">
      <div id="loading-spinner" class="loading-overlay"><div class="spinner"></div></div>
      <div id="compat-container" data-compat-root></div>
      <div class="print-footer"></div>
    </div>
  </div>

  <script src="js/template-survey.js"></script>
  <script type="module" src="js/compatibilityPage.js"></script>
  <script type="module">
    import { initTheme, applyThemeColors } from './js/theme.js';
    initTheme();
    window.applyThemeColors = applyThemeColors;
  </script>
  <script>
    fetch("/check-session", { credentials: "include" })
      .then(res => {
        if (res.status === 401) {
          window.location.href = "/token.html";
        }
      });
  </script>

  <script type="module">
    import { downloadCompatibilityPDF } from '/js/pdfDownload.js';
    // auto-wire is built into the module, but this exposes it if you need to call it manually:
    window.downloadCompatibilityPDF = downloadCompatibilityPDF;
  </script>
</body>
</html>
