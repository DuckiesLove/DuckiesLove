<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>See Our Compatibility</title>
  <!-- Import theme and global layout styles -->
  <link rel="stylesheet" href="/css/theme.css" />
  <link rel="stylesheet" href="/css/global.css" />
  <link rel="stylesheet" href="/css/compat-table.css" />
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
  #pdf-container {
    width: 100%;
    max-width: 100%;
  }
  table {
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    text-align: center;
    vertical-align: middle;
    padding: 6px;
  }
  th:first-child, td:first-child {
    text-align: left;
    padding-left: 10px;
  }
  </style>
  <style>
    .upload-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      margin-top: 3rem;
    }

      .upload-button {
        position: relative;
        display: inline-block;
      }

    .upload-button input[type="file"] {
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .wide-button {
      min-width: 260px;
      max-width: 300px;
      width: 100%;
    }
  </style>
  <style>
    /* Keep rows from splitting in both web and print */
    .compat-section tr { break-inside: avoid; page-break-inside: avoid; }

    /* Make sure tables are fixed-width to avoid right-side cutoff */
    .compat-section table {
      width: 100% !important;
      table-layout: fixed !important;
      border-collapse: collapse !important;
    }

    /* Optional: make header clean (no decorative lines/boxes) */
    .section-title, .category-header, .compat-category {
      border: none !important;
      box-shadow: none !important;
      background: transparent !important;
    }
  </style>
</head>
<body class="theme-dark">
  <div class="main-container themed">
    <h1 class="page-title">See Our Compatibility</h1>
    <div class="upload-container">
      <button class="themed-button wide-button" onclick="window.history.back()">‚Üê Back</button>

      <label id="uploadYourSurvey" class="upload-button themed-button wide-button">
        <input id="uploadSurveyA" type="file" accept="application/json" />
        Upload Your Survey
      </label>

      <label id="uploadPartnerSurvey" class="upload-button themed-button wide-button">
        <input id="uploadSurveyB" type="file" accept="application/json" />
        Upload Partner‚Äôs Survey
      </label>

      <button class="themed-button wide-button" id="downloadBtn">Download PDF</button>
    </div>

    <div id="comparisonResults">
      <div id="loading-spinner" class="loading-overlay"><div class="spinner"></div></div>
      <div id="pdf-container">
        <div id="compatibility-wrapper" class="compatibility-wrapper">
          <div id="comparisonResult"></div>
          <div id="compatibility-report" class="pdf-export-area"></div>
          <div id="print-card-list" class="print-only"></div>
        </div>
      </div>
      <div class="print-footer"></div>
    </div>
  </div>

  <script src="js/template-survey.js"></script>
  <script type="module" src="js/compatibilityPage.js"></script>
  <script type="module">
    import { initTheme, applyThemeColors } from './js/theme.js';
    initTheme();
    window.applyThemeColors = applyThemeColors;
  </script>
  <script>
    fetch("/check-session", { credentials: "include" })
      .then(res => {
        if (res.status === 401) {
          window.location.href = "/token.html";
        }
      });
  </script>

  <script type="module">
    import { downloadCompatibilityPDF } from '/js/pdfDownload.js';
    // auto-wire is built into the module, but this exposes it if you need to call it manually:
    window.downloadCompatibilityPDF = downloadCompatibilityPDF;
  </script>

<script>
/**
 * Partner A loader + Flag column + guarded PDF ‚Äî ALL CATEGORIES
 * - Loads Partner A JSON and fills Column A across every table in #pdf-container
 * - auto-creates ‚ÄúPartner A‚Äù column if missing OR writes into existing one
 * - adds ‚ÄúFlag‚Äù column after ‚ÄúMatch‚Äù (‚≠ê >=90, üö© <=50 or 4/5 vs no-answer)
 * - re-fills after async renders (MutationObserver)
 * - blocks PDF download until Partner A has values
 */

const CFG = {
  container: '#pdf-container',
  uploadA:   '#uploadSurveyA, [data-upload-a]',
  download:  '#downloadBtn, [data-download-pdf]',
  partnerACellSelector: null,         // e.g. 'td.pa' if you already have a class-based Partner A cell; leave null to auto-create column
  createMissingPartnerACol: true,     // true = auto insert ‚ÄúPartner A‚Äù column if missing
  partnerAHeaderText: 'Partner A',
  matchHeaderRegex: /\bmatch\b/i,     // header used to place ‚ÄúFlag‚Äù after
  starMin: 90,                        // ‚≠ê rule
  redFlagMax: 50                      // üö© rule
};

const $1 = (s,r=document)=>r.querySelector(s);
const $$ = (s,r=document)=>Array.from(r.querySelectorAll(s));
const wait = ms=>new Promise(r=>setTimeout(r,ms));
function norm(s){return (s||'').replace(/[\u2018\u2019\u2032]/g,"'").replace(/[\u201C\u201D\u2033]/g,'"').replace(/[\u2013\u2014]/g,'-').replace(/\u2026/g,'...').replace(/\s+/g,' ').trim().toLowerCase();}

/* JSON ‚Üí lookup */
function buildLookup(json){
  const map=new Map();
  if (json && typeof json==='object' && !Array.isArray(json)){
    for (const [k,v] of Object.entries(json)) map.set(norm(k), Number(v));
    return map;
  }
  const items = Array.isArray(json?.items) ? json.items : [];
  for (const it of items){
    const k = norm(it.key ?? it.id ?? it.label ?? it.name ?? '');
    if (k) map.set(k, Number(it.rating ?? it.score ?? it.value ?? 0));
  }
  return map;
}

/* header/column helpers */
function findHeaderIndex(table, testFn){
  const tr = $1('thead tr', table) || $1('tr', table);
  if (!tr) return -1;
  return [...tr.children].findIndex(th => testFn((th.textContent||'').trim()));
}
function partnerAIndex(table){ return findHeaderIndex(table, t => norm(t) === norm(CFG.partnerAHeaderText)); }
function matchIndex(table){ return findHeaderIndex(table, t => CFG.matchHeaderRegex.test(t)); }

function ensurePartnerAColumn(table){
  if (CFG.partnerACellSelector) return;                       // writing to class-based cells
  let idx = partnerAIndex(table);
  if (idx >= 0) return;                                       // already present
  if (!CFG.createMissingPartnerACol) return;

  let head = $1('thead tr', table);
  if (!head){
    table.createTHead();
    head = table.tHead.insertRow();
    const firstBodyRow = $1('tbody tr', table);
    const cols = firstBodyRow ? firstBodyRow.children.length : 1;
    for (let i=0;i<cols;i++) head.appendChild(document.createElement('th'));
    head.children[0].textContent = 'Category';
  }
  const th = document.createElement('th'); th.textContent = CFG.partnerAHeaderText;
  head.insertBefore(th, head.children[1] || null);
  $$('tbody tr', table).forEach(tr=>{
    const td = document.createElement('td'); td.textContent='-';
    tr.insertBefore(td, tr.children[1] || null);
  });
}

function ensureFlagColumn(table){
  const headRow = $1('thead tr', table) || $1('tr', table);
  if (!headRow) return -1;
  let m = matchIndex(table);
  if (m === -1) return -1;

  // remove existing "Flag" columns to avoid duplicates
  [...headRow.children].forEach((th,i)=>{
    const t=(th.textContent||'').trim().toLowerCase();
    if (/^flag(\/star)?$/.test(t)){ headRow.children[i].remove(); $$('tbody tr', table).forEach(tr=> tr.children[i]?.remove()); }
  });

  m = matchIndex(table);
  if (m === -1) return -1;

  const th = document.createElement('th'); th.textContent='Flag';
  headRow.insertBefore(th, headRow.children[m+1] || null);
  $$('tbody tr', table).forEach(tr=>{
    const td=document.createElement('td'); td.className='flag-cell'; td.textContent='';
    tr.insertBefore(td, tr.children[m+1] || null);
  });
  return m+1;
}

/* row identity */
function rowKey(tr){
  const dk = tr.getAttribute('data-key') || tr.getAttribute('data-id');
  if (dk) return norm(dk);
  const labelCell = $1('td:first-child, th:first-child', tr);
  return norm(labelCell?.textContent || '');
}

/* access Partner A cell */
function makeACellAccessors(table){
  if (CFG.partnerACellSelector){
    return {
      get: tr => $1(CFG.partnerACellSelector, tr),
      set: (tr,val)=>{ const td=$1(CFG.partnerACellSelector,tr); if(td) td.textContent=String(val); }
    };
  }
  const idx = partnerAIndex(table);
  return {
    get: tr => (idx>=0 ? tr.children[idx] : null),
    set: (tr,val)=>{ if (idx>=0 && tr.children[idx]) tr.children[idx].textContent=String(val); }
  };
}

/* fill Partner A across ALL categories/tables */
function fillPartnerAAll(json){
  const lookup = buildLookup(json);
  const tables = $$(`${CFG.container} table`);
  let wrote=0;

  for (const table of tables){
    ensurePartnerAColumn(table);
    const acc = makeACellAccessors(table);

    for (const tr of $$('tbody tr', table)){
      if (!tr.children || tr.children.length===0) continue;

      const cur = (acc.get(tr)?.textContent||'').trim();
      if (cur && !/^[-‚Äì]$/.test(cur)) continue;

      const k = rowKey(tr);
      if (!k) continue;

      if (lookup.has(k)){ acc.set(tr, lookup.get(k)); wrote++; continue; }

      // forgiving substring fallback both ways
      let hit=null;
      for (const key of lookup.keys()){
        if (k.includes(key) || key.includes(k)){ hit=key; break; }
      }
      if (hit){ acc.set(tr, lookup.get(hit)); wrote++; }
    }
  }
  return wrote;
}

/* Flags (after A/B + Match exist) */
function populateFlags(){
  const tables = $$(`${CFG.container} table`);
  for (const table of tables){
    const mIdx = matchIndex(table);
    if (mIdx === -1) continue;
    const fIdx = ensureFlagColumn(table);
    if (fIdx === -1) continue;

    const aIdx = partnerAIndex(table);
    const bIdx = findHeaderIndex(table, t => /partner\s*b/i.test(t));

    $$('tbody tr', table).forEach(tr=>{
      const getNum = idx => {
        if (idx<0) return null;
        const t=(tr.children[idx]?.textContent||'').trim();
        if (t==='' || /^[-‚Äì]$/.test(t)) return null;
        const n=Number(String(t).replace('%','')); return Number.isFinite(n)?n:null;
      };
      const pct  = getNum(mIdx);
      const aVal = getNum(aIdx);
      const bVal = getNum(bIdx);

      let icon = '';
      if (pct!=null && pct >= CFG.starMin) icon='‚≠ê';
      const high = v => v!=null && v>=4;
      const noAns = v => v==null;
      if ((pct!=null && pct <= CFG.redFlagMax) || (high(aVal)&&noAns(bVal)) || (high(bVal)&&noAns(aVal))) icon='üö©';

      const cell = tr.children[fIdx];
      if (cell) cell.textContent = icon;
    });
  }
}

/* detect any Partner A in DOM */
function partnerAHasAnyData(){
  const tables = $$(`${CFG.container} table`);
  for (const table of tables){
    const acc = makeACellAccessors(table);
    for (const tr of $$('tbody tr', table)){
      const t=(acc.get(tr)?.textContent||'').trim();
      if (t && !/^[-‚Äì]$/.test(t)) return true;
    }
  }
  return false;
}

/* watch async renders and re-fill */
let compatObserver;
function watchAndFillAfterRender(){
  const root = $1(CFG.container);
  if (!root) return;
  if (compatObserver) compatObserver.disconnect();
  compatObserver = new MutationObserver(()=>{
    if (window.partnerASurvey){
      const wrote = fillPartnerAAll(window.partnerASurvey);
      if (wrote) populateFlags();
    }
  });
  compatObserver.observe(root, {childList:true, subtree:true});
  if (window.partnerASurvey){
    const wrote = fillPartnerAAll(window.partnerASurvey);
    if (wrote) populateFlags();
  }
}

/* upload + download wiring */
async function handleUploadA(file){
  try{
    const text = await file.text();
    const json = JSON.parse(text);
    window.partnerASurvey = window.surveyA = json;

    if (typeof window.updateComparison === 'function'){
      await Promise.resolve(window.updateComparison());
    }
    watchAndFillAfterRender();
    await wait(120);
    const wrote = fillPartnerAAll(window.partnerASurvey);
    if (wrote) populateFlags();

    if (!partnerAHasAnyData()){
      alert('Partner A looks empty. Ensure row text or data-key matches your JSON keys.');
    }
  }catch(e){
    console.error('[Partner A] JSON error:', e);
    alert('Invalid JSON file.');
  }
}

(function boot(){
  const up = $1(CFG.uploadA);
  if (up){
    up.addEventListener('change', e=>{
      const f = e?.target?.files?.[0];
      if (f) handleUploadA(f);
    });
  } else {
    console.warn('[Partner A] upload input not found (#uploadSurveyA or [data-upload-a]).');
  }

  const btn = $1(CFG.download);
  if (btn){
    const fresh = btn.cloneNode(true); btn.replaceWith(fresh);
    fresh.addEventListener('click', async ev=>{
      if (!partnerAHasAnyData()){
        ev.preventDefault();
        alert('Partner A looks empty. Upload your survey and wait for the table to refresh.');
        return;
      }
      if (typeof window.downloadCompatibilityPDF === 'function'){
        ev.preventDefault();
        await window.downloadCompatibilityPDF();
      }
    });
  }
})();

/* console diagnostics */
window.__compatDump = () => {
  const out = [];
  const tables = $$(`${CFG.container} table`);
  for (const [i,t] of tables.entries()){
    const head = $$('thead tr th', t).map(th=>th.textContent.trim());
    const idx = partnerAIndex(t);
    const rows = $$('tbody tr', t).slice(0,10).map(tr=>{
      const label = $1('td:first-child, th:first-child', tr)?.textContent?.trim() || '';
      const dk = tr.getAttribute('data-key') || tr.getAttribute('data-id') || '';
      return {label, dataKey: dk};
    });
    out.push({table:i, headers: head, partnerAIndex: idx, sampleRows: rows});
  }
  console.log('[__compatDump]', out);
  return out;
};
</script>
<script>
/**
 * CODEX: DO THIS EXACTLY
 * 1) Ensure the page has:
 *      <div id="pdf-container"> ‚Ä¶ your comparison tables ‚Ä¶ </div>
 *      <input id="uploadSurveyB" type="file" accept="application/json">   <!-- "Upload Partner's Survey" -->
 *   (You can also use any element with [data-upload-b] instead of the id.)
 *
 * 2) Paste THIS script at the very end of compatibility.html (right before </body>).
 *    It is SAFE with the Partner A loader already added.
 *
 * 3) Do NOT change layout. This script:
 *    - Fills "Partner B" across ALL tables inside #pdf-container
 *    - Writes to existing <td class="pb"> if present, OR inserts a ‚ÄúPartner B‚Äù column if missing
 *    - Recomputes the Flag column (‚≠ê ‚â• 90% match; üö© ‚â§ 50% match OR 4/5 vs no-answer)
 *
 * 4) After adding:
 *    - Reload ‚Üí Click ‚ÄúUpload Partner‚Äôs Survey‚Äù ‚Üí pick JSON ‚Üí Partner B column fills everywhere
 *    - The existing ‚ÄúDownload PDF‚Äù flow can remain as-is
 */

(function(){
  // ----------------------- CONFIG -----------------------
  const CFG_B = {
    container: '#pdf-container',
    uploadB:   '#uploadSurveyB, [data-upload-b]',
    partnerBHeaderText: 'Partner B',
    partnerBCellSelector: null,     // e.g. 'td.pb' if you ALREADY render a dedicated Partner B cell; leave null to auto-create a column
    createMissingPartnerBCol: true, // true => insert "Partner B" column if missing
    matchHeaderRegex: /\bmatch\b/i, // used to locate the Match column (for Flag recompute)
    starMin: 90,
    redFlagMax: 50
  };

  // Share tiny helpers with A-script if present:
  const $1 = window.__compat$1 || ((s,r=document)=>r.querySelector(s));
  const $$ = window.__compat$$ || ((s,r=document)=>Array.from(r.querySelectorAll(s)));

  function norm(s){
    return (s||'')
      .replace(/[\u2018\u2019\u2032]/g,"'")
      .replace(/[\u201C\u201D\u2033]/g,'"')
      .replace(/[\u2013\u2014]/g,'-')
      .replace(/\u2026/g,'...')
      .replace(/\s+/g,' ')
      .trim().toLowerCase();
  }

  // ----------------------- JSON ‚Üí lookup -----------------------
  function buildLookup(json){
    const map = new Map();
    if (json && typeof json==='object' && !Array.isArray(json)) {
      for (const [k,v] of Object.entries(json)) map.set(norm(k), Number(v));
      return map;
    }
    const items = Array.isArray(json?.items) ? json.items : [];
    for (const it of items){
      const k = norm(it.key ?? it.id ?? it.label ?? it.name ?? '');
      if (k) map.set(k, Number(it.rating ?? it.score ?? it.value ?? 0));
    }
    return map;
  }

  // ----------------------- table helpers -----------------------
  function findHeaderIndex(table, testFn){
    const tr = $1('thead tr', table) || $1('tr', table);
    if (!tr) return -1;
    const cells = [...tr.children];
    return cells.findIndex(th => testFn((th.textContent||'').trim()));
  }
  function partnerBIndex(table){ return findHeaderIndex(table, t => norm(t) === norm(CFG_B.partnerBHeaderText)); }
  function partnerAIndex(table){ return findHeaderIndex(table, t => /\bpartner\s*a\b/i.test(t)); }
  function partnerMatchIndex(table){ return findHeaderIndex(table, t => CFG_B.matchHeaderRegex.test(t)); }

  function ensurePartnerBColumn(table){
    if (CFG_B.partnerBCellSelector) return;                 // writing to class-based cells
    let idx = partnerBIndex(table);
    if (idx >= 0) return;                                   // already present
    if (!CFG_B.createMissingPartnerBCol) return;

    // Insert Partner B as the LAST column (stable default that won't disrupt ‚ÄúFlag‚Äù)
    let head = $1('thead tr', table);
    if (!head){
      table.createTHead();
      head = table.tHead.insertRow();
      const firstBodyRow = $1('tbody tr', table);
      const cols = firstBodyRow ? firstBodyRow.children.length : 1;
      for (let i=0;i<cols;i++) head.appendChild(document.createElement('th'));
      head.children[0].textContent = 'Category';
    }
    const th = document.createElement('th'); th.textContent = CFG_B.partnerBHeaderText;
    head.appendChild(th);

    $$('tbody tr', table).forEach(tr=>{
      const td = document.createElement('td'); td.textContent='-';
      tr.appendChild(td);
    });
  }

  function makeBCellAccessors(table){
    if (CFG_B.partnerBCellSelector){
      return {
        get: tr => $1(CFG_B.partnerBCellSelector, tr),
        set: (tr,val)=>{ const td=$1(CFG_B.partnerBCellSelector,tr); if(td) td.textContent=String(val); }
      };
    }
    const idx = partnerBIndex(table);
    return {
      get: tr => (idx>=0 ? tr.children[idx] : null),
      set: (tr,val)=>{ if (idx>=0 && tr.children[idx]) tr.children[idx].textContent=String(val); }
    };
  }

  function rowKey(tr){
    const dk = tr.getAttribute('data-key') || tr.getAttribute('data-id');
    if (dk) return norm(dk);
    const labelCell = $1('td:first-child, th:first-child', tr);
    return norm(labelCell?.textContent || '');
  }

  // ----------------------- fill Partner B everywhere -----------------------
  function fillPartnerBAll(json){
    const lookup = buildLookup(json);
    const tables = $$(`${CFG_B.container} table`);
    let wrote=0;

    for (const table of tables){
      ensurePartnerBColumn(table);
      const acc = makeBCellAccessors(table);

      for (const tr of $$('tbody tr', table)){
        if (!tr.children || tr.children.length===0) continue;

        const cur = (acc.get(tr)?.textContent||'').trim();
        if (cur && !/^[-‚Äì]$/.test(cur)) continue; // already filled

        const k = rowKey(tr);
        if (!k) continue;

        if (lookup.has(k)){ acc.set(tr, lookup.get(k)); wrote++; continue; }

        // forgiving substring fallback (both ways)
        let hit=null;
        for (const key of lookup.keys()){
          if (k.includes(key) || key.includes(k)){ hit=key; break; }
        }
        if (hit){ acc.set(tr, lookup.get(hit)); wrote++; }
      }
    }
    return wrote;
  }

  // ----------------------- Flag recompute -----------------------
  // If the Partner A script already defined populateFlags, use it.
  // Otherwise define a minimal local version so B upload still updates flags.
  const populateFlags = window.populateFlags || (function(){
    return function localPopulateFlags(){
      const tables = $$(`${CFG_B.container} table`);
      for (const table of tables){
        const mIdx = partnerMatchIndex(table);
        if (mIdx === -1) continue;

        // ensure a Flag column right after Match (remove duplicates)
        const headRow = $1('thead tr', table) || $1('tr', table);
        if (!headRow) continue;
        [...headRow.children].forEach((th,i)=>{
          const t=(th.textContent||'').trim().toLowerCase();
          if (/^flag(\/star)?$/.test(t)){ headRow.children[i].remove(); $$('tbody tr', table).forEach(r=> r.children[i]?.remove()); }
        });
        const th = document.createElement('th'); th.textContent='Flag';
        headRow.insertBefore(th, headRow.children[mIdx+1] || null);
        const fIdx = mIdx+1;

        const aIdx = partnerAIndex(table);
        const bIdx = partnerBIndex(table);

        $$('tbody tr', table).forEach(tr=>{
          const getNum = idx => {
            if (idx<0) return null;
            const t=(tr.children[idx]?.textContent||'').trim();
            if (t==='' || /^[-‚Äì]$/.test(t)) return null;
            const n=Number(String(t).replace('%',''));
            return Number.isFinite(n)?n:null;
          };
          const pct  = getNum(mIdx);
          const aVal = getNum(aIdx);
          const bVal = getNum(bIdx);

          let icon = '';
          if (pct!=null && pct >= CFG_B.starMin) icon = '‚≠ê';
          const high = v => v!=null && v>=4;
          const noAns = v => v==null;
          if ((pct!=null && pct <= CFG_B.redFlagMax) || (high(aVal)&&noAns(bVal)) || (high(bVal)&&noAns(aVal))) {
            icon = 'üö©';
          }
          const cell = tr.children[fIdx];
          if (cell) cell.textContent = icon;
        });
      }
    };
  })();

  // ----------------------- async render support -----------------------
  let observerB;
  function watchAndFillB(){
    const root = $1(CFG_B.container);
    if (!root) return;
    if (observerB) observerB.disconnect();
    observerB = new MutationObserver(()=>{
      if (window.partnerBSurvey){
        const wrote = fillPartnerBAll(window.partnerBSurvey);
        if (wrote) populateFlags();
      }
    });
    observerB.observe(root, {childList:true, subtree:true});
    // initial pass
    if (window.partnerBSurvey){
      const wrote = fillPartnerBAll(window.partnerBSurvey);
      if (wrote) populateFlags();
    }
  }

  // ----------------------- upload wiring -----------------------
  async function handleUploadB(file){
    try{
      const text = await file.text();
      const json = JSON.parse(text);
      window.partnerBSurvey = window.surveyB = json;

      if (typeof window.updateComparison === 'function'){
        await Promise.resolve(window.updateComparison());
      }
      watchAndFillB();
      // small extra delay to catch late layout/fonts
      setTimeout(()=>{
        const wrote = fillPartnerBAll(window.partnerBSurvey);
        if (wrote) populateFlags();
      }, 120);
    }catch(e){
      console.error('[Partner B] JSON error:', e);
      alert('Invalid JSON file for Partner B.');
    }
  }

  // boot
  document.addEventListener('DOMContentLoaded', ()=>{
    const inp = $1(CFG_B.uploadB);
    if (inp){
      inp.addEventListener('change', e=>{
        const f = e?.target?.files?.[0];
        if (f) handleUploadB(f);
      });
    } else {
      console.warn('[Partner B] upload input not found (#uploadSurveyB or [data-upload-b]).');
    }
  });
})();
  </script>

  <!-- PATCH: accept nested survey export on the compatibility page -->
  <script>
  /**
   * What this does
   * - Detects the nested survey export shape and flattens it to { "Row label": rating, ... }
   * - Hooks into BOTH Partner A & Partner B upload handlers by overriding their JSON->lookup step
   * - Leaves your UI, columns, and PDF code untouched
   *
   * How to use
   * 1) Paste this block after your existing Partner A/B loader scripts (near </body>).
   * 2) Reload the page.
   * 3) Upload the JSON you downloaded from the survey page ‚Äî values will now populate.
   */

  /* ---------- Normalization used across the site ---------- */
  function __compatNormKey(s){
    return String(s||'')
      .replace(/[\u2018\u2019\u2032]/g,"'")
      .replace(/[\u201C\u201D\u2033]/g,'"')
      .replace(/[\u2013\u2014]/g,'-')
      .replace(/\u2026/g,'')           // remove single char ellipsis
      .replace(/\s*\.\.\.\s*$/,'')     // remove trailing "..."
      .replace(/\s+/g,' ')
      .trim()
      .toLowerCase();
  }

  /* ---------- Flatten the nested survey export to a plain object ---------- */

  function __compatFlattenSurveyJSON(json, merge = 'max'){
    // If it already looks flat, just return it
    if (json && typeof json === 'object' && !Array.isArray(json) && !json.survey) return json;
    if (!json || typeof json !== 'object' || !json.survey) return json; // unsupported

    const out = Object.create(null);

    const take = (name, rating) => {
      if (name == null) return;
      const key = name; // leave original label; matching code already normalizes
      const val = Number(rating);
      if (!Number.isFinite(val)) return;

      if (out[key] == null) out[key] = val;
      else {
        switch (merge) {
          case 'max':   out[key] = Math.max(out[key], val); break;
          case 'min':   out[key] = Math.min(out[key], val); break;
          case 'avg':   out[key] = (out[key] + val) / 2;     break;
          case 'last':  out[key] = val;                      break;
          default:      out[key] = Math.max(out[key], val);
        }
      }
    };

    const cats = json.survey || {};
    Object.values(cats).forEach(section=>{
      if (!section || typeof section !== 'object') return;
      ['Giving','Receiving','General'].forEach(bucket=>{
        const arr = Array.isArray(section[bucket]) ? section[bucket] : [];
        arr.forEach(item => take(item?.name ?? item?.label ?? item?.id, item?.rating ?? item?.score ?? item?.value));
      });
    });

    return out;
  }

  /* ---------- Universal buildLookup that supports all inputs ---------- */
  function __compatBuildLookupUniversal(json){
    const flat = __compatFlattenSurveyJSON(json) || json;

    const map = new Map();

    // Case 1: already-flat object
    if (flat && typeof flat === 'object' && !Array.isArray(flat) && !flat.items && !flat.survey){
      for (const [k,v] of Object.entries(flat)){
        map.set(__compatNormKey(k), Number(v));
      }
      return map;
    }

    // Case 2: items array
    const items = Array.isArray(flat?.items) ? flat.items : [];
    for (const it of items){
      const k = __compatNormKey(it?.name ?? it?.label ?? it?.key ?? it?.id ?? '');
      if (!k) continue;
      const n = Number(it?.rating ?? it?.score ?? it?.value);
      if (Number.isFinite(n)) map.set(k, n);
    }

    return map;
  }

  /* ---------- Patch the loaders to use the universal builder ---------- */
  (function patchLoaders(){
    // If the A/B loader exposed buildLookup globally, overwrite it.
    if (typeof window.buildLookup === 'function'){
      window.buildLookup = __compatBuildLookupUniversal;
    }

    // Provide a well-known builder the site scripts can prefer.
    window.__compatBuildLookup = __compatBuildLookupUniversal;

    // If the A/B filler functions exist and internally call a non-global buildLookup,
    // we still succeed because both Partner A and Partner B upload handlers store
    // the parsed object on window.partnerASurvey / window.partnerBSurvey.
    // We can proactively re-fill after an upload using our map:

    function refillFromStored(){
      try {
        if (window.partnerASurvey && typeof window.fillPartnerAAll === 'function'){
          // Make a Map now so row-matching is quick
          const _ = __compatBuildLookupUniversal(window.partnerASurvey);
          // The existing fill function expects the raw JSON; it re-builds internally.
          window.fillPartnerAAll(window.partnerASurvey);
        }
        if (window.partnerBSurvey && typeof window.fillPartnerBAll === 'function'){
          const _ = __compatBuildLookupUniversal(window.partnerBSurvey);
          window.fillPartnerBAll(window.partnerBSurvey);
        }
        if (typeof window.populateFlags === 'function') window.populateFlags();
      } catch (e) { console.warn('[compat] refill after patch failed', e); }
    }

    // Refill once now (in case JSON was already loaded), and whenever uploads happen
    document.addEventListener('change', (e)=>{
      if (e.target && (e.target.matches('#uploadSurveyA, [data-upload-a]') ||
                       e.target.matches('#uploadSurveyB, [data-upload-b]'))){
        setTimeout(refillFromStored, 150);
      }
    });
    // Initial attempt
    setTimeout(refillFromStored, 200);
  })();
  </script>

  <script>
/* ROW KEY ANNOTATOR + AUTO REFILL + DIAGNOSTICS (works with truncated labels) */
(function(){
  const ROOT = document.querySelector('#pdf-container');
  if (!ROOT) return;

  function norm(s){
    return String(s||'')
      .replace(/[\u2018\u2019\u2032]/g,"'")
      .replace(/[\u201C\u201D\u2033]/g,'"')
      .replace(/[\u2013\u2014]/g,'-')
      .replace(/\u2026/g,'')
      .replace(/\s*\.\.\.\s*$/,'')
      .replace(/\s+/g,' ')
      .trim()
      .toLowerCase();
  }

  function deriveLabel(tr){
    const first = tr.querySelector('td:first-child, th:first-child');
    // Prefer attributes first
    const fromAttr =
      tr.getAttribute('data-full') || tr.getAttribute('data-label') ||
      (first && (first.getAttribute('data-full') || first.getAttribute('data-label'))) ||
      tr.getAttribute('title') || tr.getAttribute('aria-label') ||
      (first && (first.getAttribute('title') || first.getAttribute('aria-label')));
    if (fromAttr) return fromAttr;
    // Hidden full label node
    const hidden = tr.querySelector('.full-label') || (first && first.querySelector('.full-label'));
    if (hidden && hidden.textContent) return hidden.textContent;
    // Fallback to visible text (may be ellipsized)
    return first ? first.textContent : '';
  }

  function annotate(){
    ROOT.querySelectorAll('table tbody tr').forEach(tr=>{
      if ((tr.getAttribute('data-key') || tr.getAttribute('data-id') || '').trim()) return;
      const key = norm(deriveLabel(tr));
      if (key) tr.setAttribute('data-key', key);
    });
  }

  // Call Partner A/B fillers if available (from your existing loader scripts)
  function tryRefill(){
    try {
      if (window.partnerASurvey && typeof window.fillPartnerAAll === 'function') {
        window.fillPartnerAAll(window.partnerASurvey);
      }
      if (window.partnerBSurvey && typeof window.fillPartnerBAll === 'function') {
        window.fillPartnerBAll(window.partnerBSurvey);
      }
      if (typeof window.populateFlags === 'function') window.populateFlags();
    } catch(e) { console.warn('[compat] refill error', e); }
  }

  // Diagnostics to help if something still doesn‚Äôt match
  function toMap(obj){
    const m=new Map();
    if (obj && typeof obj==='object') for (const [k,v] of Object.entries(obj)) m.set(norm(k), v);
    return m;
  }
  function mismatch(){
    const A = toMap(window.partnerASurvey);
    const B = toMap(window.partnerBSurvey);
    const keysInDom = [];
    ROOT.querySelectorAll('table tbody tr').forEach(tr=>{
      const k = (tr.getAttribute('data-key')||'').trim();
      if (k) keysInDom.push(k);
    });
    const jsonNotFound = (M) => [...M.keys()].filter(k => !keysInDom.includes(k));
    console.group('[compat] mismatch report');
    if (A.size) console.log('Partner A JSON keys not found in DOM:', jsonNotFound(A).slice(0,60));
    if (B.size) console.log('Partner B JSON keys not found in DOM:', jsonNotFound(B).slice(0,60));
    console.groupEnd();
  }
  window.__compatMismatch = mismatch;
  window.__compatAnnotate = annotate;

  // Run now and on future DOM updates
  annotate();
  tryRefill();
  const mo = new MutationObserver(()=>{ annotate(); tryRefill(); });
  mo.observe(ROOT, {childList:true, subtree:true});
})();
  </script>
</body>
</html>
