<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>See Our Compatibility</title>
  <!-- Import theme and global layout styles -->
  <link rel="stylesheet" href="/css/theme.css" />
  <link rel="stylesheet" href="/css/global.css" />
  <link rel="stylesheet" href="/css/compat-table.css" />
  <link rel="stylesheet" href="/css/font-failopen.css">
  <link rel="stylesheet" href="/css/compatibility.css" />

  <style>
    /* --- Percent bar (Match %) --- */
    .pct {
      position: relative;
      width: 100%;
      height: 22px;
      border: 1px solid #3ddbf3;
      border-radius: 6px;
      background: rgba(61,219,243,0.08);
      overflow: hidden;
    }
    .pct-fill {
      position: absolute;
      inset: 0;
      width: 0%;
      background: linear-gradient(90deg, #18a0fb, #3df3c3);
      transition: width .35s ease;
    }
    .pct-text {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-variant-numeric: tabular-nums;
      font-weight: 600;
    }
    /* Friendly label text in first column (wrap nicely on small screens) */
    .tk-cat {
      white-space: normal;
      line-height: 1.2;
    }
    .tk-code {
      opacity: .5;
      font-size: .85em;
      margin-left: .4rem;
    }
  </style>
  <style>
    td.pct-cell .pct { position: relative; height: 1.1em; line-height: 1.1em; }
    td.pct-cell .pct .bar { position:absolute; left:0; top:0; bottom:0; width:0%;
                            background:rgba(0,255,255,0.25); border-radius:2px; }
    td.pct-cell .pct .txt { position:relative; display:block; text-align:center; }
    td.pct-cell { min-width:5rem; }
  </style>
  <script defer src="/js/tk-labels.js"></script>
  <style>
  #pdf-container {
    width: 100%;
    max-width: 100%;
  }
  table {
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    text-align: center;
    vertical-align: middle;
    padding: 6px;
  }
  th:first-child, td:first-child {
    text-align: left;
    padding-left: 10px;
  }
  </style>
  <style>
    .upload-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      margin-top: 3rem;
    }

      .upload-button {
        position: relative;
        display: inline-block;
      }

    .upload-button input[type="file"] {
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .wide-button {
      min-width: 260px;
      max-width: 300px;
      width: 100%;
    }
    .export-tip {
      font-size: 0.9rem;
      margin: 0;
    }
  </style>
  <style>
    /* Keep rows from splitting in both web and print */
    .compat-section tr { break-inside: avoid; page-break-inside: avoid; }

    /* Make sure tables are fixed-width to avoid right-side cutoff */
    .compat-section table {
      width: 100% !important;
      table-layout: fixed !important;
      border-collapse: collapse !important;
    }

    /* Optional: make header clean (no decorative lines/boxes) */
    .section-title, .category-header, .compat-category {
      border: none !important;
      box-shadow: none !important;
      background: transparent !important;
    }
  </style>
  <style>
    /* Force LIGHT pdf colors by default; override via body[style] if you want dark */
    :root { --pdf-bg:#fff; --pdf-text:#000; }
    .pdf-export, #pdfWrapper, .pdf-container {
      background: var(--pdf-bg) !important;
      color: var(--pdf-text) !important;
    }
  </style>
  <style>
    /* optional polish to match your theme */
    .tk-compat th, .tk-compat td{
      border-bottom:1px solid #00e6ff33;
      padding:.55rem .8rem;
      vertical-align:middle;
    }
    .tk-compat td.ta-c{ text-align:center; }
  </style>
  <style>
  /* Small, unobtrusive subtitle under the category code */
  .tk-catwrap { display:flex; flex-direction:column; gap:2px; }
  .tk-catwrap .tk-code { font-weight:600; letter-spacing:0.02em; }
  .tk-catwrap .tk-sub  {
    font-weight:500; opacity:.78;
    font-size: clamp(11px,.9vw,13px);
    line-height:1.2;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    max-width: min(48vw, 780px);  /* fits your wide first column */
  }

  /* Match % meter (tuned for your dark theme) */
  .tk-meter {
    position: relative;
    height: 10px; min-width: 110px;
    background: rgba(0, 230, 255, .12);
    border-radius: 999px;
    outline: 1px solid rgba(0,230,255,.20);
    overflow: hidden;
  }
  .tk-meter > .tk-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg,
      rgba(0,230,255,.88), rgba(120,255,250,.95));
    box-shadow: 0 0 10px rgba(0,230,255,.35) inset;
    border-radius: inherit;
    transition: width .35s ease;
  }
  .tk-meter + .tk-pct {
    display:inline-block; min-width: 42px;
    font-weight:800; letter-spacing:.02em;
    margin-left:.5rem; opacity:.9;
  }

  /* Keep row height stable on narrow screens */
  @media (max-width: 720px){
    .tk-catwrap .tk-sub { max-width: 70vw; }
    .tk-meter { min-width: 80px; }
  }
  </style>
  <style>
  /* ====== Match % chip (compact, no layout shift) ====== */
  .tk-match-chip{
    display:inline-flex; flex-direction:column; align-items:center; gap:6px;
    min-width:70px; line-height:1; vertical-align:middle;
  }
  .tk-match-num{ font-weight:800; letter-spacing:.02em; }
  .tk-match-bar{
    position:relative; width:90px; height:7px; border-radius:999px;
    outline:1px solid rgba(0,230,255,.35);
    background:rgba(0,230,255,.10); overflow:hidden;
  }
  .tk-match-fill{
    display:block; height:100%; width:var(--w,0%);
    background:linear-gradient(90deg,#00e6ff,#3bffc4);
    border-radius:inherit; transition:width .25s ease;
  }
  /* Dim the bar if the value is “missing” on that row */
  .tk-match-chip[data-missing="1"] .tk-match-bar{ opacity:.38; }

  /* ====== Category main + tiny subline (summary) ====== */
  .tk-cat-wrap{ display:flex; flex-direction:column; gap:3px; }
  .tk-cat-main{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .tk-cat-sub{
    font-size:.82em; color:#9beff7; opacity:.78;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    max-width:48ch;  /* keep it subtle; doesn’t stretch your layout */
  }
  /* On narrow screens you can hide the subline if you want */
  @media (max-width: 680px){
    .tk-cat-sub{ display:none; }
  }
  </style>
  <style>
  /* Compatibility table progressive enhancement (fallback match bar + labels) */
  td.ksv-match { white-space: nowrap; }

  .ksv-matchwrap{
    display:flex; flex-direction:column; align-items:center; gap:.4rem;
    min-width:8rem;
  }
  .ksv-pct{
    font: 800 0.95rem/1.1 system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    letter-spacing:.02em; color:#d9ffff;
  }
  .ksv-bar{
    width:100%; height:6px; border-radius:999px;
    background: rgba(0,230,255,.12);
    outline: 1px solid rgba(0,230,255,.35);
    overflow:hidden;
  }
  .ksv-bar > i{
    display:block; height:100%; width:var(--w,0%);
    background: linear-gradient(90deg,#00e6ff 0%, #5fffd6 100%);
    box-shadow: 0 0 6px #00e6ff66 inset;
  }

  td.ksv-cat{
    word-break: break-word;
  }
  .ksv-cat .ksv-cat-text{
    display:inline;
  }
  </style>
</head>
<body class="theme-dark">
  <div class="main-container themed">
    <h1 class="page-title">See Our Compatibility</h1>
    <div class="upload-container">
      <button class="themed-button wide-button" onclick="window.history.back()">← Back</button>

      <label id="uploadYourSurvey" class="upload-button themed-button wide-button">
        <input id="uploadSurveyA" type="file" accept="application/json" />
        Upload Your Survey
      </label>

      <label id="uploadPartnerSurvey" class="upload-button themed-button wide-button">
        <input id="uploadSurveyB" type="file" accept="application/json" />
        Upload Partner’s Survey
      </label>

      <button class="themed-button wide-button" id="downloadBtn">Download PDF</button>
      <p id="exportTip" class="export-tip">Upload both surveys before exporting.</p>
    </div>

    <div id="comparisonResults">
      <p id="comparisonResult"></p>
      <div id="loading-spinner" class="loading-overlay"><div class="spinner"></div></div>
      <div id="pdf-container" class="compat-root" data-compat-root></div>
      <!-- === Compatibility results mount (add this to compatibility.html) === -->
      <section id="compatResults" style="margin-top:24px">
        <table id="compatTable" class="tk-compat compatTbl" style="width:100%; border-collapse:collapse">
          <thead>
            <tr>
              <th style="text-align:left; padding:.6rem .8rem; border-bottom:2px solid #00e6ff55">Category</th>
              <th style="text-align:center; padding:.6rem .8rem; border-bottom:2px solid #00e6ff55">Partner A</th>
              <th style="text-align:center; padding:.6rem .8rem; border-bottom:2px solid #00e6ff55">Match %</th>
              <th style="text-align:center; padding:.6rem .8rem; border-bottom:2px solid #00e6ff55">Partner B</th>
            </tr>
          </thead>
          <tbody id="tk-compat-body"></tbody>
        </table>
      </section>
      <table id="tk-unanswered" class="compatTable" style="margin-top:24px; width:100%; border-collapse:collapse">
        <thead>
          <tr>
            <th>Unanswered Categories (0 or blank)</th>
            <th>Partner A</th>
            <th>Partner B</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div class="print-footer"></div>
    </div>
  </div>

  <script src="js/template-survey.js"></script>
  <!-- Label loader must be before the page script -->
  <script src="/js/tk-labels.js" defer></script>
  <script src="/js/compatibilityPage.js" defer></script>
  <script type="module">
    import { initTheme, applyThemeColors } from './js/theme.js';
    initTheme();
    window.applyThemeColors = applyThemeColors;
  </script>
  <!-- Safe session check script -->
  <script>
  /**
   * Safe session check:
   * - Silently ignores 404 / network errors (useful on static hosting & local previews)
   * - Only redirects on 401 Unauthorized
   * - Won’t throw or spam the console
   *
   * How to use:
   * 1) Paste this block.
   * 2) Delete the old:
   *      fetch("/check-session", { credentials: "include" })
   *        .then(res => { if (res.status === 401) window.location.href = "/token.html"; });
   * 3) Call safeCheckSession(); (or skip entirely if you don’t need auth)
   */

  (function(){
    function safeCheckSession(opts){
      const cfg = Object.assign({
        url: '/check-session',          // change if your API path differs
        redirectTo: '/token.html',      // where to send on 401
        credentials: 'include',         // send cookies if present
        log: false,                     // set true to log non-401 statuses
        skipHosts: undefined,           // overrideable allow list of static hosts
        skipHostSuffixes: undefined,    // overrideable suffix allow list (e.g. github.io)
        skipOnFileProtocol: true,       // skip when opened via file:// by default
        force: false                    // set true to bypass the skip guards
      }, (opts || {}));

      const host = (window.location && window.location.hostname || '').toLowerCase();
      const proto = (window.location && window.location.protocol) || '';

      const defaultHosts = ['talkkink.org', 'www.talkkink.org'];
      const defaultSuffixes = ['github.io'];
      const skipHosts = Array.isArray(cfg.skipHosts) && cfg.skipHosts.length ? cfg.skipHosts : defaultHosts;
      const skipSuffixes = Array.isArray(cfg.skipHostSuffixes) && cfg.skipHostSuffixes.length ? cfg.skipHostSuffixes : defaultSuffixes;

      const matchesHost = !!host && skipHosts.some(h => h && host === String(h).toLowerCase());
      const matchesSuffix = !!host && skipSuffixes.some(s => s && host.endsWith(String(s).toLowerCase()));
      const isFile = cfg.skipOnFileProtocol !== false && proto === 'file:';

      if (!cfg.force && (isFile || matchesHost || matchesSuffix)) {
        if (cfg.log) {
          console.info('[session] skipped check-session fetch for host:', host || '(unknown host)');
        }
        return;
      }

      try {
        fetch(cfg.url, { credentials: cfg.credentials })
          .then(res => {
            if (res.status === 401) {
              // Only redirect on explicit 401
              window.location.href = cfg.redirectTo;
              return;
            }
            // Silence 404s and other statuses unless logging is enabled
            if (cfg.log && res.status !== 204 && res.status !== 200) {
              console.info('[session] status:', res.status);
            }
          })
          .catch(() => {
            // Network error / CORS / offline — ignore quietly
          });
      } catch (_) {
        // Older browsers / unexpected errors — ignore
      }
    }

    // OPTIONAL: run automatically on load (safe even if endpoint doesn’t exist)
    document.addEventListener('DOMContentLoaded', function(){
      safeCheckSession();
    });

    // Expose if you want to call manually later
    window.safeCheckSession = safeCheckSession;
  })();
  </script>

  <script>
  // Progressive enhancement for fallback compatibility tables
  /* ========================================================================== */
  /*  Compatibility page helpers: progress bar + category summary (tooltip)     */
  /* ========================================================================== */

  /** Holds 1-line summaries for each category id. */
  let TK_CATEGORY_SUMMARY = Object.create(null);

  /**
   * Build summaries from your survey schema. We prefer:
   *   cat.short  >  cat.title  >  first question text  >  id
   * Call this once right after you’ve loaded kinks.json (same object you already
   * use to label things).
   */
  function tkBuildCategorySummaries(kinks) {
    try {
      const cats = kinks?.categories || kinks || {};
      Object.keys(cats).forEach(id => {
        const c = cats[id] || {};
        const firstQ = (c.questions && c.questions[0] && (c.questions[0].short || c.questions[0].title || c.questions[0].text)) || '';
        const raw = c.short || c.title || c.name || firstQ || id;
        TK_CATEGORY_SUMMARY[id] = String(raw).replace(/\s+/g,' ').trim();
      });
    } catch (e) {
      console.warn('[compat] Could not build category summaries:', e);
    }
  }

  /**
   * Create the Match % cell content. We keep your number and, when it’s numeric,
   * layer a subtle bar behind it (no layout change).
   */
  function tkMakePctCell(pct) {
    const td = document.createElement('td');
    td.className = 'tk-pct';
    const isNum = Number.isFinite(pct);
    const pctSafe = isNum ? Math.max(0, Math.min(100, Math.round(pct))) : null;

    const bar = document.createElement('div');
    bar.className = 'tk-pct__bar';
    bar.style.width = `${pctSafe ?? 0}%`;
    td.appendChild(bar);

    const span = document.createElement('span');
    span.textContent = pctSafe != null ? `${pctSafe}%` : '—';
    td.appendChild(span);
    return td;
  }

  /**
   * Make a Category cell that shows a zero-layout native tooltip on hover.
   * (No visible subtitle is inserted; your table stays exactly the same.)
   */
  function tkMakeCategoryCell(catId) {
    const td = document.createElement('td');
    td.className = 'cat';
    td.textContent = catId;
    if (TK_CATEGORY_SUMMARY[catId]) {
      td.title = TK_CATEGORY_SUMMARY[catId];
    }
    return td;
  }

  function tkAppendComparisonRow(tbody, catId, aVal, pct, bVal) {
    if (!tbody) return null;
    const tr = document.createElement('tr');

    const cTD = tkMakeCategoryCell(catId);

    const aTD = document.createElement('td');
    aTD.className = 'ta-c pa';
    aTD.setAttribute('data-partner-a', '');
    aTD.textContent = (Number.isFinite(aVal) ? aVal : '—');

    const pTD = tkMakePctCell(pct);
    pTD.classList.add('ta-c', 'match');

    const bTD = document.createElement('td');
    bTD.className = 'ta-c pb';
    bTD.setAttribute('data-partner-b', '');
    bTD.textContent = (Number.isFinite(bVal) ? bVal : '—');

    tr.append(cTD, aTD, pTD, bTD);
    tbody.appendChild(tr);
    return tr;
  }

  if (typeof window !== 'undefined') {
    window.tkBuildCategorySummaries = tkBuildCategorySummaries;
    window.tkMakePctCell = tkMakePctCell;
    window.tkMakeCategoryCell = tkMakeCategoryCell;
    window.tkAppendComparisonRow = tkAppendComparisonRow;
  }

  (function(){
    const META_URLS = [
      '/data/kinks.json',
      '/kinksurvey/data/kinks.json',
      '/kinksurvey/kinks.json',
      '/kinks.json',
      '/assets/kinks.json'
    ];

    let labelPromise = null;

    const norm = str => String(str || '').trim().toLowerCase();

    async function fetchFirst(urls){
      for (const url of urls){
        try {
          const res = await fetch(url, { cache: 'no-store' });
          if (!res || !res.ok) continue;
          const data = await res.json();
          if (data) {
            tkBuildCategorySummaries(data);
            return data;
          }
        } catch (_) {
          // ignore individual fetch failures
        }
      }
      return null;
    }

    function toLabelMap(meta){
      const map = new Map();
      const store = (key, label) => {
        if (!key) return;
        const cleanKey = String(key).trim();
        if (!cleanKey) return;
        const val = label || cleanKey;
        map.set(cleanKey, val);
        map.set(norm(cleanKey), val);
      };

      const cells = Array.isArray(meta?.cells) ? meta.cells : Array.isArray(meta) ? meta : [];
      cells.forEach(cell => {
        if (!cell || typeof cell !== 'object') return;
        const id = cell.id || cell.key || cell.slug;
        const label = cell.prompt || cell.label || cell.name || cell.title;
        store(id, label);
        if (Array.isArray(cell.aliases)) cell.aliases.forEach(alias => store(alias, label));
      });
      return map;
    }

    function loadLabels(){
      if (!labelPromise){
        labelPromise = fetchFirst(META_URLS).then(toLabelMap).catch(() => new Map());
      }
      return labelPromise;
    }

    function findIndexes(table){
      const headRow = table.tHead && table.tHead.rows && table.tHead.rows[0];
      if (!headRow) return { catIdx: 0, matchIdx: 2 };
      const cells = Array.from(headRow.cells || []);
      const texts = cells.map(th => norm(th.textContent));
      const catIdx = texts.findIndex(t => t && (t.startsWith('category') || t.includes('category')));
      const matchIdx = texts.findIndex(t => t && t.includes('match'));
      return {
        catIdx: catIdx >= 0 ? catIdx : 0,
        matchIdx: matchIdx >= 0 ? matchIdx : 2
      };
    }

    function summarizeLabel(label){
      if (!label) return '';
      let text = String(label).replace(/\s+/g, ' ');
      text = text.replace(/\s*\([^)]*\)\s*/g, ' ');
      text = text.replace(/^((do|does|did|would|could|are|is|i(?:'| a)m)\s+)/i, '');
      text = text.trim();
      if (text.length > 72) text = text.slice(0, 69).trimEnd() + '…';
      return text;
    }

    function applyMatchBars(table, matchIdx){
      if (matchIdx < 0) return;
      const bodies = table.tBodies ? Array.from(table.tBodies) : [];
      bodies.forEach(tbody => {
        Array.from(tbody.rows).forEach(row => {
          const td = row.cells && row.cells[matchIdx];
          if (!td || td.querySelector('.ksv-matchwrap')) return;
          const raw = (td.textContent || '').trim();
          const n = Number(raw.replace(/[^\d.]+/g, ''));
          const pct = Number.isFinite(n) ? Math.max(0, Math.min(100, n)) : null;

          td.classList.add('ksv-match');
          td.textContent = '';
          const wrap = document.createElement('div');
          wrap.className = 'ksv-matchwrap';

          const pctSpan = document.createElement('div');
          pctSpan.className = 'ksv-pct';
          pctSpan.textContent = pct === null ? '—' : `${pct}%`;

          const bar = document.createElement('div');
          bar.className = 'ksv-bar';
          const fill = document.createElement('i');
          if (pct !== null) fill.style.setProperty('--w', `${pct}%`);
          bar.appendChild(fill);

          wrap.appendChild(pctSpan);
          wrap.appendChild(bar);
          td.appendChild(wrap);
        });
      });
    }

    function lookupLabel(map, key, fallback){
      if (!key) return fallback;
      const clean = String(key).trim();
      if (!clean) return fallback;
      return map.get(clean) || map.get(norm(clean)) || fallback;
    }

    function collectRowKeys(row){
      const attrs = ['data-id', 'data-key', 'data-full', 'data-label'];
      for (const attr of attrs){
        const val = row.getAttribute && row.getAttribute(attr);
        if (val) return val;
      }
      return null;
    }

    function applyLabels(table, map, catIdx){
      if (catIdx < 0) return;
      const bodies = table.tBodies ? Array.from(table.tBodies) : [];
      bodies.forEach(tbody => {
        Array.from(tbody.rows).forEach(row => {
          const td = row.cells && row.cells[catIdx];
          if (!td || td.children.length) return;
          const raw = (td.textContent || '').trim();
          if (!raw) return;
          const key = collectRowKeys(row) || raw;
          const nice = lookupLabel(map, key, lookupLabel(map, raw, raw));
          if (!nice || nice === raw) return;
          td.classList.add('ksv-cat');
          td.textContent = '';
          const span = document.createElement('span');
          span.className = 'ksv-cat-text';
          span.textContent = summarizeLabel(nice);
          span.title = nice;
          td.appendChild(span);
        });
      });
    }

    function enhanceTable(table){
      if (!table || table.dataset.ksvEnhanced === 'done' || table.dataset.ksvEnhanced === 'skip') return;
      if (table.querySelector('.tk-match-chip') || table.querySelector('.tk-cat-wrap')) {
        table.dataset.ksvEnhanced = 'skip';
        return;
      }

      const { catIdx, matchIdx } = findIndexes(table);
      applyMatchBars(table, matchIdx);

      loadLabels().then(map => {
        if (!(map instanceof Map) || map.size === 0) return;
        applyLabels(table, map, catIdx);
      });

      table.dataset.ksvEnhanced = 'done';
    }

    window.tkEnhanceCompatTable = function(table){
      if (!table) table = document.querySelector('#pdf-container table, #compatResults table, table');
      if (!table) return;
      enhanceTable(table);
    };

    function init(){
      window.tkEnhanceCompatTable();
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init, { once: true });
    } else {
      init();
    }
  })();
  </script>

<script>
/* ==== COMPAT: Robust A/B Fill (markup-agnostic) ==== *
 * Supports three table shapes:
 *  1) Cells with data-partner-a / data-partner-b attributes             (preferred)
 *  2) Cells with .pa / .pb classes                                      (legacy)
 *  3) No markers, but THEAD headers literally "Partner A" / "Partner B" (auto-tag)
 *
 * Also:
 *  - Annotates rows with data-full (full visible label) and data-id (normalized key)
 *  - Matches JSON -> rows by data-id -> data-full -> visible text -> fuzzy overlap
 *  - Bootstraps a simple table if your container has 0 rows
 *  - Recomputes a Match % (assumes 1–5 scale)
 *
 * Requirements:
 *  - Your wrapper has data-compat-root OR you use #pdf-container
 *  - First column is the label cell (visible text)
 *  - Keep THEAD headers: Category | Partner A | Match | Partner B (lets us auto-tag A/B)
 */

(function(){
  /* ---------- normalizers ---------- */
  function norm(s){
    return String(s||'')
      .replace(/[\u2018\u2019\u2032]/g,"'")
      .replace(/[\u201C\u201D\u2033]/g,'"')
      .replace(/[\u2013\u2014]/g,'-')
      .replace(/\u2026/g,'')
      .replace(/[^\w\s'-]/g,' ')
      .replace(/\s+/g,' ')
      .trim().toLowerCase();
  }
  const toks = s => norm(s).split(' ').filter(Boolean);

  /* ---------- JSON → lookup ---------- */
  function toLookup(json){
    const map = new Map();
    if (!json || typeof json !== 'object') return map;

    // flat {key:value}
    if (!Array.isArray(json) && !json.items && !json.survey){
      for (const [k,v] of Object.entries(json)){
        const n = Number(v); if (Number.isFinite(n)) map.set(norm(k), n);
      }
      return map;
    }

    // items array
    if (Array.isArray(json.items)){
      for (const it of json.items){
        const k = norm(it?.name ?? it?.label ?? it?.key ?? it?.id ?? '');
        const n = Number(it?.rating ?? it?.score ?? it?.value);
        if (k && Number.isFinite(n)) map.set(k, n);
      }
      return map;
    }

    // nested survey export
    if (json.survey && typeof json.survey === 'object'){
      Object.values(json.survey).forEach(section=>{
        ['Giving','Receiving','General'].forEach(bucket=>{
          (Array.isArray(section?.[bucket])?section[bucket]:[]).forEach(it=>{
            const k = norm(it?.name ?? it?.label ?? it?.id ?? '');
            const n = Number(it?.rating ?? it?.score ?? it?.value);
            if (k && Number.isFinite(n)) map.set(k, Math.max(map.get(k)??-Infinity, n));
          });
        });
      });
    }
    return map;
  }

  /* ---------- DOM helpers ---------- */
  function getRoot(){
    return document.querySelector('[data-compat-root]') || document.querySelector('#pdf-container') || document.body;
  }

  // If no rows exist, create a simple "All" table from the union of JSON keys
  function bootstrapIfEmpty(root){
    const hasRows = root.querySelectorAll('tbody tr').length > 0;
    if (hasRows) return false;

    const aMap = toLookup(window.partnerASurvey || window.surveyA || {});
    const bMap = toLookup(window.partnerBSurvey || window.surveyB || {});
    const keys = new Set([...aMap.keys(), ...bMap.keys()]);
    if (!keys.size) return false;

    const section = document.createElement('section'); section.className = 'compat-section';
    const h2 = document.createElement('h2'); h2.className = 'section-title'; h2.textContent = 'All'; section.appendChild(h2);

    const table = document.createElement('table'); table.className = 'compat-table compatTbl';
    const thead = document.createElement('thead'); const thr = document.createElement('tr');
    ['Category','Partner A','Match','Partner B'].forEach(t=>{ const th=document.createElement('th'); th.textContent=t; thr.appendChild(th); });
    thead.appendChild(thr);
    const tbody = document.createElement('tbody');

    keys.forEach(k=>{
      const aVal = aMap.has(k) ? aMap.get(k) : null;
      const bVal = bMap.has(k) ? bMap.get(k) : null;
      const pct = (Number.isFinite(aVal) && Number.isFinite(bVal))
        ? Math.round((1 - Math.abs(aVal - bVal) / 5) * 100)
        : null;
      const tr = tkAppendComparisonRow(tbody, k, aVal, pct, bVal);
      if (tr) {
        tr.setAttribute('data-id', k);
        tr.setAttribute('data-full', k);
      }
    });

    table.append(thead, tbody); section.appendChild(table);
    root.innerHTML = ''; root.appendChild(section);
    console.log(`[compat] bootstrapped ${keys.size} rows from JSON union.`);
    return true;
  }

  // Ensure each row has data-full and data-id
  function annotateRows(root){
    root.querySelectorAll('table tbody tr').forEach(tr=>{
      const first = tr.querySelector('td:first-child, th:first-child');
      const vis = first ? (first.textContent || '') : '';
      if (!tr.hasAttribute('data-full') && vis) tr.setAttribute('data-full', vis);
      if (!tr.hasAttribute('data-id')){
        const canon = norm(tr.getAttribute('data-full') || vis);
        if (canon) tr.setAttribute('data-id', canon);
      }
    });
  }

  // If there are no .pa/.pb markers, use THEAD headers to tag the columns
  function ensurePartnerMarkers(root){
    root.querySelectorAll('table').forEach(table=>{
      const thead = table.querySelector('thead tr'); if (!thead) return;
      const ths = Array.from(thead.children).map(th => norm(th.textContent));
      const idxA = ths.indexOf('partner a');
      const idxB = ths.indexOf('partner b');

      const tbody = table.querySelector('tbody'); if (!tbody) return;
      if (idxA >= 0 && !tbody.querySelector('td.pa, td[data-partner-a]')){
        tbody.querySelectorAll('tr').forEach(tr=>{ const td = tr.children[idxA]; if (td){ td.classList.add('pa'); td.setAttribute('data-partner-a',''); }});
      }
      if (idxB >= 0 && !tbody.querySelector('td.pb, td[data-partner-b]')){
        tbody.querySelectorAll('tr').forEach(tr=>{ const td = tr.children[idxB]; if (td){ td.classList.add('pb'); td.setAttribute('data-partner-b',''); }});
      }
    });
  }

  /* ---------- matching ---------- */
  function rowKeyBundle(tr){
    const id   = tr.getAttribute('data-id')   || '';
    const full = tr.getAttribute('data-full') || '';
    const vis  = tr.querySelector('td:first-child, th:first-child')?.textContent || '';
    return { kId: norm(id), kFull: norm(full), kVis: norm(vis) };
  }

  function pickValue(keys, lookup){
    // 1) exact id
    if (keys.kId && lookup.has(keys.kId)) return lookup.get(keys.kId);
    // 2) exact full
    if (keys.kFull && lookup.has(keys.kFull)) return lookup.get(keys.kFull);
    // 3) exact visible
    if (keys.kVis && lookup.has(keys.kVis)) return lookup.get(keys.kVis);
    // 4) contains (either direction)
    for (const [lk, val] of lookup.entries()){
      if (lk.includes(keys.kFull) || keys.kFull.includes(lk)) return val;
      if (lk.includes(keys.kVis)  || keys.kVis.includes(lk))  return val;
    }
    // 5) token overlap ≥60% or ≥4 shared tokens
    const tryKeys = [keys.kFull, keys.kVis].filter(Boolean);
    for (const rk of tryKeys){
      const rt = toks(rk); if (!rt.length) continue;
      for (const [lk, val] of lookup.entries()){
        const lt = toks(lk); if (!lt.length) continue;
        const set = new Set(lt);
        const shared = rt.filter(t=>set.has(t)).length;
        const overlap = Math.min(shared/rt.length, shared/lt.length);
        if (shared >= 4 || overlap >= 0.6) return val;
      }
    }
    return undefined;
  }

  /* ---------- fill + match ---------- */
  function fillColumn(root, selectorList, lookup){
    if (!lookup || !lookup.size) return 0;
    const rows = root.querySelectorAll('table tbody tr');
    let wrote = 0;
    rows.forEach(tr=>{
      const td = tr.querySelector(selectorList);
      if (!td) return;
      const current = (td.textContent || '').trim();
      if (current && !/^[-–—]$/.test(current)) return; // don't overwrite real values
      const val = pickValue(rowKeyBundle(tr), lookup);
      if (val == null) return;
      const renderScore = typeof window.tkRenderScoreCell === 'function'
        ? window.tkRenderScoreCell
        : v => (v === null || v === undefined || v === '' ? '—' : String(v));
      td.textContent = renderScore(val);
      wrote++;
    });
    return wrote;
  }

  function computeMatch(a, b){
    if (typeof window.tkRenderMatchCell === 'function') {
      return window.tkRenderMatchCell(a, b);
    }
    const calc = typeof window.tkMatchPercent === 'function'
      ? window.tkMatchPercent
      : (va, vb) => {
          const na = Number(va);
          const nb = Number(vb);
          if (!Number.isFinite(na) || !Number.isFinite(nb)) return null;
          if (na === 0 || nb === 0) return 0;
          const diff = Math.abs(na - nb);
          return Math.round((1 - diff / 5) * 100);
        };
    const pct = calc(a, b);
    if (pct === null) {
      return '<div class="tk-match-chip" data-missing="1" aria-label="No match data">—</div>';
    }
    return `
      <div class="tk-match-chip" role="img" aria-label="Match ${pct}%">
        <div class="tk-match-num">${pct}%</div>
        <div class="tk-match-bar" aria-hidden="true">
          <i class="tk-match-fill" style="--w:${pct}%"></i>
        </div>
      </div>
    `;
  }

  function recomputeMatches(root){
    root.querySelectorAll('table tbody tr').forEach(tr=>{
      const a = tr.querySelector('td[data-partner-a], td.pa')?.textContent;
      const b = tr.querySelector('td[data-partner-b], td.pb')?.textContent;
      const m = tr.querySelector('td[data-match]') || tr.children[2]; // assume 3rd col if standard
      if (m && m.tagName === 'TD') m.innerHTML = computeMatch(a, b);
    });
  }

  /* ---------- main entry ---------- */
  function runFill(){
    const root = getRoot();
    if (!root) return;

    // If empty, create a minimal table so we can fill something
    bootstrapIfEmpty(root);

    // Make keys discoverable & cells targetable
    annotateRows(root);
    ensurePartnerMarkers(root);

    const aMap = toLookup(window.partnerASurvey || window.surveyA || {});
    const bMap = toLookup(window.partnerBSurvey || window.surveyB || {});

    const wroteA = fillColumn(root, 'td[data-partner-a], td.pa', aMap);
    const wroteB = fillColumn(root, 'td[data-partner-b], td.pb', bMap);

    if (wroteA || wroteB) recomputeMatches(root);
    if (typeof window.populateFlags === 'function') window.populateFlags();

    console.log(`[compat] filled Partner A cells: ${wroteA}; Partner B cells: ${wroteB}`);
  }

  // Wire uploads (Partner A / Partner B)
  document.addEventListener('change', async e=>{
    if (!e.target) return;
    if (e.target.matches('#uploadSurveyA,[data-upload-a],#uploadSurveyB,[data-upload-b]')){
      // If your upload handlers already parse JSON and set window.partnerASurvey/window.partnerBSurvey,
      // runFill will use them. If not, attempt quick inline parsing:
      const f = e.target.files && e.target.files[0];
      if (f && (
        (e.target.matches('#uploadSurveyA,[data-upload-a]') && !window.partnerASurvey) ||
        (e.target.matches('#uploadSurveyB,[data-upload-b]') && !window.partnerBSurvey)
      )){
        try {
          const jsonText = await f.text();
          const parser = window.TK_LABELS?.parseSurveyJSON;
          const json = parser ? parser(jsonText) : JSON.parse(jsonText);
          if (e.target.matches('#uploadSurveyA,[data-upload-a]')) window.partnerASurvey = json;
          else window.partnerBSurvey = json;
        } catch {}
      }
      setTimeout(runFill, 150);
    }
  });

  // Expose manual trigger + run once
  window.__compatRunFill = runFill;
document.addEventListener('DOMContentLoaded', () => setTimeout(runFill, 250));
})();
</script>
<!--
Talk Kink • Compatibility Report — Dark-Mode PDF (all-black cells)
WHAT THIS DOES
• Loads jsPDF + AutoTable from CDN only if missing
• Finds your results table (#compatibilityTable, .results-table.compat, or first <table>)
• Uses the FIRST section header on the page (e.g., “Appearance Play”) as the left column label
• Exports a landscape A4 PDF with black background, white text, THICK white grid lines
• Ensures the on-screen scores transfer exactly (including 0). 0/blank are also listed at the end as “Unanswered”.
• Binds to #downloadBtn automatically, or call TKPDF_forceDark() from the console

HOW TO USE (Codex-ready steps)
1) Open compatibility.html
2) Paste this entire <script> block just before </body>
3) Ensure your results table is rendered in the DOM when the user clicks “Download PDF”
4) Click the button with id="downloadBtn" (or run TKPDF_forceDark() in the console)

RESULT
• A file named compatibility-dark.pdf is downloaded with:
  – main results table in dark theme
  – a second table “Unanswered (0 or blank)” listing any category Partner A or B didn’t answer
-->

<script>
(function () {
  const LOG = (...a) => console.log('[TK-PDF]', ...a);

  /* -------------------- loader -------------------- */
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      if (document.querySelector(`script[src="${src}"]`)) return resolve();
      const s = document.createElement('script');
      s.src = src;
      s.onload = resolve;
      s.onerror = () => reject(new Error('Failed to load ' + src));
      document.head.appendChild(s);
    });
  }
  async function ensureLibs() {
    if (!(window.jspdf && window.jspdf.jsPDF)) {
      await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js');
    }
    const hasAT =
      (window.jspdf && window.jspdf.jsPDF && window.jspdf.jsPDF.API && window.jspdf.jsPDF.API.autoTable);
    if (!hasAT) {
      await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.3/jspdf.plugin.autotable.min.js');
    }
  }

  /* -------------------- DOM helpers -------------------- */
  function findTable() {
    return (
      document.querySelector('#compatibilityTable') ||
      document.querySelector('.results-table.compat') ||
      document.querySelector('table')
    );
  }
  const tidy = (s) => (s || '').replace(/\s+/g, ' ').trim();

  // Extract first integer-like token (supports 0..5)
  function rawInt(v) {
    const m = String(v ?? '').match(/-?\d+/);
    if (!m) return null;
    const n = parseInt(m[0], 10);
    return Number.isFinite(n) ? n : null;
  }
  const isValidScore = (n) => n != null && Number.isInteger(n) && n >= 1 && n <= 5;
  const isZeroOrBlank = (raw) => raw == null || raw === 0;

  // Label cleanup: dedupe words, tiny fixes, rename "Cum" -> "Cum Play"
  function cleanLabel(s) {
    let t = tidy(s);
    t = t.replace(/\b([A-Za-z/’'-]+)\s*\1\b/g, '$1'); // e.g., "Blood Blood" -> "Blood"
    t = t.replace(/\bCum\b/g, 'Cum Play');
    return t;
  }

  /* -------------------- table parsing -------------------- */
  function extractRows(table) {
    const trs = [...table.querySelectorAll('tr')];
    const rows = [];     // main table rows
    const missing = [];  // [Category, missA, missB] for 0/blank
    let firstSectionHeader = 'Category';

    for (const tr of trs) {
      const tds = [...tr.querySelectorAll('td')];
      if (!tds.length) continue;

      const texts = tds.map(td => cleanLabel(td.textContent));

      // Section header detection: one <td> that spans the row (or others empty)
      if (tds.length === 1 || (texts[0] && texts.slice(1).every(x => !x))) {
        if (firstSectionHeader === 'Category') firstSectionHeader = texts[0];
        rows.push([{
          content: texts[0],
          colSpan: 4,
          styles: { fontStyle: 'bold', halign: 'left', fillColor: [0,0,0], textColor: [255,255,255] }
        }]);
        continue;
      }

      // Category text is first cell
      const category = cleanLabel(texts[0] || '—');

      // Pick Partner A = first numeric, Partner B = last numeric (from the row)
      const raws = texts.map(rawInt);
      const numIdx = raws.map((n, i) => (n !== null ? i : -1)).filter(i => i >= 0);
      const aRaw = numIdx.length ? raws[numIdx[0]] : null;
      const bRaw = numIdx.length ? raws[numIdx[numIdx.length - 1]] : null;

      // What to SHOW in the PDF:
      // - If it's 0, show "0" (to match the on-screen table)
      // - If 1..5, show the number
      // - Otherwise "—"
      const aShow = (aRaw === 0) ? '0' : (isValidScore(aRaw) ? String(aRaw) : '—');
      const bShow = (bRaw === 0) ? '0' : (isValidScore(bRaw) ? String(bRaw) : '—');

      // Match %: use present % cell if any; else compute only when both scores are valid (1..5)
      let matchCell = texts.find(c => /%$/.test(c)) || '—';
      if (matchCell === '—' && isValidScore(aRaw) && isValidScore(bRaw)) {
        const pct = Math.round(100 - (Math.abs(aRaw - bRaw) / 5) * 100);
        matchCell = `${Math.max(0, Math.min(100, pct))}%`;
      }

      // Missing (0 or blank) tracker
      const missA = isZeroOrBlank(aRaw);
      const missB = isZeroOrBlank(bRaw);
      if (missA || missB) {
        missing.push([category, missA ? '✖' : '—', missB ? '✖' : '—']);
      }

      // Push row (ALL BLACK cells w/ white text)
      rows.push([
        { content: category,  styles: { fillColor: [0,0,0], textColor: [255,255,255] } },
        { content: aShow,     styles: { fillColor: [0,0,0], textColor: [255,255,255] } },
        { content: matchCell, styles: { fillColor: [0,0,0], textColor: [255,255,255] } },
        { content: bShow,     styles: { fillColor: [0,0,0], textColor: [255,255,255] } },
      ]);
    }
    return { rows, missing, firstSectionHeader };
  }

  /* -------------------- PDF export -------------------- */
  async function TKPDF_export() {
    try {
      await ensureLibs();
      const { jsPDF } = window.jspdf;

      const table = findTable();
      if (!table) return alert('No table found on the page.');

      const { rows, missing, firstSectionHeader } = extractRows(table);

      const doc = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });
      const pageW = doc.internal.pageSize.getWidth();
      const pageH = doc.internal.pageSize.getHeight();
      const marginLR = 30;
      const usable = pageW - marginLR * 2;

      // Dark page painter (fixes "white boxes")
      const paintBg = () => { doc.setFillColor(0,0,0); doc.rect(0,0,pageW,pageH,'F'); doc.setTextColor(255,255,255); };

      paintBg();
      doc.setFontSize(24);
      doc.text('Talk Kink • Compatibility Report', pageW/2, 42, { align: 'center' });

      // Column widths (kept constant to avoid overflow warnings)
      const Awidth = 90, Mwidth = 110, Bwidth = 90;
      const CatWidth = usable - (Awidth + Mwidth + Bwidth);

      doc.autoTable({
        head: [[firstSectionHeader, 'Partner A', 'Match %', 'Partner B']],
        body: rows,
        startY: 64,
        margin: { left: marginLR, right: marginLR },
        styles: {
          fontSize: 11,
          cellPadding: 6,
          textColor: [255,255,255],
          fillColor: [0,0,0],
          lineColor: [255,255,255],
          lineWidth: 1.2,
          halign: 'center',
          valign: 'middle',
          overflow: 'linebreak'
        },
        headStyles: {
          fillColor: [0,0,0],
          textColor: [255,255,255],
          fontStyle: 'bold',
          lineColor: [255,255,255],
          lineWidth: 1.4
        },
        columnStyles: {
          0: { cellWidth: CatWidth, halign: 'left' },
          1: { cellWidth: Awidth },
          2: { cellWidth: Mwidth },
          3: { cellWidth: Bwidth }
        },
        willDrawPage: paintBg
      });

      if (missing.length) {
        doc.autoTable({
          head: [['Unanswered Categories (0 or blank)', 'Partner A', 'Partner B']],
          body: missing.map(r => r.map(c => ({ content: c, styles: { fillColor: [0,0,0], textColor: [255,255,255] } }))),
          startY: (doc.lastAutoTable && doc.lastAutoTable.finalY ? doc.lastAutoTable.finalY : 64) + 20,
          margin: { left: marginLR, right: marginLR },
          styles: {
            fontSize: 11,
            cellPadding: 6,
            textColor: [255,255,255],
            fillColor: [0,0,0],
            lineColor: [255,255,255],
            lineWidth: 1.2
          },
          headStyles: { fillColor: [0,0,0], textColor: [255,255,255], fontStyle: 'bold' },
          columnStyles: { 0: { cellWidth: usable - 180 }, 1: { cellWidth: 90 }, 2: { cellWidth: 90 } },
          willDrawPage: paintBg
        });
      }

      doc.save('compatibility-dark.pdf');
      LOG('Export complete');
    } catch (err) {
      console.error('[TK-PDF] Export failed:', err);
      alert('PDF export failed: ' + (err?.message || err));
    }
  }

  // Public + button binding
  window.TKPDF_forceDark = TKPDF_export;
  const btn = document.querySelector('#downloadBtn');
  if (btn) btn.addEventListener('click', (e) => { e.preventDefault(); TKPDF_export(); });
  LOG('Bound Download PDF');
})();
</script>


<!-- ===== TK Compatibility Page Hardening Patch (v2) — paste before </body> ===== -->

<!-- Fix PDF export: ensure jsPDF + autoTable are present BEFORE any export code runs -->
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.1/dist/jspdf.plugin.autotable.min.js" defer></script>
<script>
(function ensureJsPDF(){
  function ready(){
    if (window.jspdf && window.jspdf.jsPDF) {
      window.jsPDF = window.jspdf.jsPDF;
      try { new window.jsPDF({compress:false}); } catch(_) {}
    }
  }
  window.addEventListener('load', ready, {once:true});
  setTimeout(ready, 600);
})();
</script>

<script>
(function(){
  // ----------------- Tiny safe coercers -----------------
  const STR  = v => (v == null ? '' : (typeof v === 'string' ? v : String(v)));
  const TRIM = v => STR(v).trim();
  const NUM  = v => { const n = Number(v); return Number.isFinite(n) ? n : 0; };
  const OBJ  = v => v && typeof v === 'object' && !Array.isArray(v);

  // ----------------- Canonical survey shape -----------------
  function canonSurvey(raw){
    if (!raw || typeof raw !== 'object') throw new Error('bad survey');

    const meta = OBJ(raw.meta) ? raw.meta : {};
    const baseSite = TRIM(raw.site || meta.site || meta.origin);
    const baseGenerated = TRIM(raw.generatedAt || meta.generatedAt || meta.exportedAt || meta.timestamp);

    const finalize = (list) => {
      const answers = (Array.isArray(list) ? list : [])
        .filter(Boolean)
        .map(a => ({
          key   : TRIM(a?.key),
          label : TRIM(a?.label),
          rating: NUM(a?.rating)
        }));
      const answersByKey = Object.fromEntries(answers.map(a => [a.key, a.rating]));
      return {
        schema: 'tk-survey.v1',
        site: baseSite,
        generatedAt: baseGenerated,
        answers,
        answersByKey
      };
    };

    if (Array.isArray(raw.answers)) {
      return finalize(raw.answers);
    }

    if (OBJ(raw.answers)) {
      const mapped = Object.entries(raw.answers).map(([k, v]) => ({
        key: k,
        label: '',
        rating: v
      }));
      return finalize(mapped);
    }

    if (OBJ(raw.answersByKey)) {
      const mapped = Object.entries(raw.answersByKey).map(([k, v]) => ({
        key: k,
        label: '',
        rating: v
      }));
      return finalize(mapped);
    }

    if (Array.isArray(raw.categories)) {
      const flat = [];
      raw.categories.forEach(c => {
        (c?.questions || []).forEach(q => {
          flat.push({ key: q?.key || q?.id || q?.name,
                      label: q?.label || q?.text,
                      rating: q?.rating });
        });
      });
      return finalize(flat);
    }

    return finalize([]);
  }

  function sanitizeSurvey(sv){
    if (!sv || typeof sv !== 'object') return;
    sv.answers = (Array.isArray(sv.answers) ? sv.answers : [])
      .filter(Boolean)
      .map(a => ({ key: TRIM(a?.key), label: TRIM(a?.label), rating: NUM(a?.rating) }));
    sv.answersByKey = Object.fromEntries(sv.answers.map(a => [a.key, a.rating]));
  }

  function sanitizeUnionArray(arr){
    if (!Array.isArray(arr)) return arr;
    return arr.map(r => {
      if (!r || typeof r !== 'object') return r;
      r.key      = TRIM(r.key);
      r.label    = TRIM(r.label);
      r.group    = TRIM(r.group);
      r.category = TRIM(r.category);
      return r;
    });
  }

  // ----------------- Wrap JSON.parse (network & inline JSON) -----------------
  (function wrapJSONParse(){
    const _parse = JSON.parse;
    JSON.parse = function(str, reviver){
      const obj = _parse(str, reviver);
      try {
        if (obj && typeof obj === 'object') {
          // Detect & canonicalize surveys
          if (Array.isArray(obj.answers) || obj.answersByKey || Array.isArray(obj.categories)) {
            return canonSurvey(obj);
          }
          // Detect likely union data and sanitize labels/keys
          const union = (Array.isArray(obj.union) && obj.union) ||
                        (Array.isArray(obj.rows)  && obj.rows)  ||
                        (Array.isArray(obj.kinks) && obj.kinks);
          if (union) {
            union.splice(0, union.length, ...sanitizeUnionArray(union));
          }
        }
      } catch(e) { console.warn('[compat] JSON.parse patch fell back:', e); }
      return obj;
    };
  })();

  // ----------------- Hook FileReader so uploads are safe BEFORE site code runs -----------------
  (function patchFileReader(){
    const orig = FileReader.prototype.readAsText;
    FileReader.prototype.readAsText = function(blob){
      // Make sure our handler runs first (capture)
      const fix = (ev) => {
        try {
          const txt = String(ev.target.result || '');
          // If it looks like JSON, canonicalize and replace the result string itself.
          // This way, any subsequent "JSON.parse(e.target.result)" gets the safe shape.
          if (txt.trim().startsWith('{') || txt.trim().startsWith('[')) {
            let parsed = JSON.parse(txt);            // goes through our JSON.parse wrapper
            parsed = canonSurvey(parsed);            // belt-and-suspenders
            ev.target.result = JSON.stringify(parsed);
          }
        } catch (err) {
          console.warn('[compat] FileReader patch could not normalize upload:', err);
        }
      };
      this.addEventListener('load', fix, {once:true, capture:true});
      return orig.apply(this, arguments);
    };
  })();

  // ----------------- Ensure safe globals & wrap compute -----------------
  function ensureDefaults(){
    if (!window.SurveyA) window.SurveyA = { schema:'tk-survey.v1', answers:[], answersByKey:{} };
    if (!window.SurveyB) window.SurveyB = { schema:'tk-survey.v1', answers:[], answersByKey:{} };
    sanitizeSurvey(window.SurveyA);
    sanitizeSurvey(window.SurveyB);
  }

  function patchCompute(){
    ['calculateCompatibility','updateComparison','filterGeneralOptions'].forEach(name=>{
      const fn = window[name];
      if (typeof fn === 'function' && !fn.__tkSafe) {
        const wrapped = function(...args){
          try { ensureDefaults(); } catch(_) {}
          try { return fn.apply(this, args); }
          catch(e){
            console.error(`[compat] ${name} failed (guarded)`, e);
            // Keep the UI alive even if one pass failed
            return null;
          }
        };
        wrapped.__tkSafe = true;
        window[name] = wrapped;
      }
    });
  }

  // ----------------- Init -----------------
  function init(){
    ensureDefaults();
    patchCompute();
  }
  window.addEventListener('load', init, {once:true});
  setTimeout(init, 700);
  new MutationObserver(()=>{ patchCompute(); })
    .observe(document.documentElement, {childList:true, subtree:true});
})();
</script>
<!-- ===== /TK Compatibility Page Hardening Patch (v2) ===== -->

<!-- ---------- End Safe Bootstrap ---------- -->
<script>
/* ===== Compatibility page: robust file-input wiring =====
   Paste this at the very end of /compatibility.html, right before </body>.
   It only replaces the “wireUploaders” part and keeps your existing
   normalize/maybeRecompute logic working. If you don’t have those yet,
   this snippet also provides safe defaults. */

(function () {
  // ---- keep or reuse your existing helpers if already defined ----
  const sTrim = v => (v == null ? '' : String(v)).trim();
  function clamp05(n){
    n = Number(n);
    if (!Number.isFinite(n)) return 0;
    if (n > 5 && n <= 10) return Math.max(0, Math.min(5, n / 2));
    return Math.max(0, Math.min(5, n));
  }

  function extractScore(raw){
    if (raw == null) return 0;
    if (typeof raw === 'object'){
      if (Array.isArray(raw)){
        const first = raw.find(v => v != null);
        return extractScore(first);
      }
      const keys = ['score','value','val','v','rank','answer','rating','points'];
      for (const key of keys){
        if (raw[key] != null) return extractScore(raw[key]);
      }
      return 0;
    }
    if (typeof raw === 'string'){
      const txt = raw.trim();
      if (!txt) return 0;
      if (/^\d+%$/.test(txt)){
        const pct = Number(txt.slice(0, -1));
        return Number.isFinite(pct) ? pct / 20 : 0;
      }
      if (/^\d+\s*\/\s*\d+$/.test(txt)){
        const [a, b] = txt.split('/').map(s => Number(s.trim()));
        if (Number.isFinite(a) && Number.isFinite(b) && b) return a * (5 / b);
      }
      const n = Number(txt);
      if (Number.isFinite(n)) return n;
      return 0;
    }
    if (typeof raw === 'number') return raw;
    return 0;
  }

  function normalizeSurvey(json){
    const map = new Map();
    const add = (id, val) => {
      const key = sTrim(id);
      if (!key) return;
      map.set(key, clamp05(val));
    };
    const fromArray = (arr, prefix='item') => {
      if (!Array.isArray(arr)) return;
      const base = sTrim(prefix) || 'item';
      arr.forEach((entry, idx) => {
        if (entry == null) return;
        let id = '';
        if (typeof entry === 'object' && !Array.isArray(entry)){
          id = entry.id ?? entry.key ?? entry.name ?? entry.label ?? entry.slug ?? '';
        }
        if (!id) id = `${base}_${idx + 1}`;
        add(id, extractScore(entry));
      });
    };

    if (!json) return {map,count:0};
    if (Array.isArray(json)){
      fromArray(json);
      return {map,count:map.size};
    }
    if (json.answers && !Array.isArray(json.answers) && typeof json.answers === 'object'){
      for (const [k, v] of Object.entries(json.answers)) add(k, extractScore(v));
      return {map,count:map.size};
    }
    if (Array.isArray(json.answers)){
      fromArray(json.answers, 'answer');
      return {map,count:map.size};
    }
    if (Array.isArray(json.cells)){
      fromArray(json.cells, 'cell');
      return {map,count:map.size};
    }
    if (Array.isArray(json.rows)){
      fromArray(json.rows, 'row');
      return {map,count:map.size};
    }
    if (Array.isArray(json.data)){
      fromArray(json.data, 'data');
      return {map,count:map.size};
    }
    if (Array.isArray(json?.data?.cells)){
      fromArray(json.data.cells, 'cell');
      return {map,count:map.size};
    }
    if (json.map && typeof json.map === 'object'){
      for (const [k, v] of Object.entries(json.map)) add(k, extractScore(v));
      if (map.size) return {map,count:map.size};
    }

    if (json && typeof json === 'object'){
      for (const [k, v] of Object.entries(json)){
        if (/^(schema|meta|page|site|exportedAt)$/i.test(k)) continue;
        if (Array.isArray(v)){
          fromArray(v, k || 'item');
        } else if (v && typeof v === 'object' && !Array.isArray(v)){
          const id = sTrim(v.id ?? v.key ?? v.name ?? v.label ?? k);
          add(id || k, extractScore(v));
        } else {
          add(k, extractScore(v));
        }
      }
    }

    return {map,count:map.size};
  }

  // ensure global storage
  window._tkCompat = window._tkCompat || { A:null, B:null };

  function fileToSurveyMap(file, cb){
    const r = new FileReader();
    r.onload = () => {
      try{
        const raw = String(r.result || '');
        const clean = raw.replace(/^\uFEFF/, '').trim();
        const parser = window.TK_LABELS?.parseSurveyJSON;
        const parsed = parser ? parser(clean) : JSON.parse(clean);
        cb(null, normalizeSurvey(parsed));
      }
      catch(err){ cb(err); }
    };
    r.onerror = () => cb(r.error || new Error('read failed'));
    r.readAsText(file);
  }

  // Very robust partner detection
  function detectPartnerFrom(el){
    const textBag = [
      el.dataset?.partner, el.name, el.id,
      el.getAttribute?.('aria-label'),
      el.getAttribute?.('title')
    ].filter(Boolean).join(' ').toLowerCase();

    if(/\b(b|partner\s*b|survey\s*b|file\s*b)\b/.test(textBag)) return 'B';
    if(/\b(a|partner\s*a|survey\s*a|file\s*a)\b/.test(textBag)) return 'A';

    // Look around in the label/button text
    const label = el.closest('label')?.textContent?.toLowerCase() || '';
    const near  = el.closest('form,section,div')?.textContent?.slice(0,200)?.toLowerCase() || '';
    const bag2  = (label + ' ' + near);
    if(/partner[^a-z]*b/.test(bag2) || /upload.*partner/i.test(bag2)) return 'B';
    if(/your.*survey/.test(bag2) || /partner[^a-z]*a/.test(bag2)) return 'A';

    return null;
  }

  // fallback ordering: first file input we see = A, second = B
  const seenOrder = [];
  function fallbackAB(el){
    if(!seenOrder.includes(el)) seenOrder.push(el);
    return (seenOrder.indexOf(el) === 0) ? 'A' : 'B';
  }

  // Render/update table (keeps it simple; replace if you already have your renderer)
  function maybeRecompute(){
    const A = window._tkCompat.A?.map || new Map();
    const B = window._tkCompat.B?.map || new Map();
    const keys = new Set([...A.keys(), ...B.keys()]);

    const tbody = document.querySelector('#compatTable tbody') || document.querySelector('table tbody');
    if(!tbody){ 
      console.info('[compat] (no table tbody found) filled Partner A cells:', [...A.values()].filter(v=>v!=null).length,
                   '; Partner B cells:', [...B.values()].filter(v=>v!=null).length);
      return;
    }

    tbody.innerHTML = '';
    keys.forEach(k=>{
      const a = A.get(k);
      const b = B.get(k);
      const pct = typeof window.tkMatchPercent === 'function'
        ? window.tkMatchPercent(a, b)
        : (Number.isFinite(a) && Number.isFinite(b)
            ? Math.round((1 - Math.abs(a - b) / 5) * 100)
            : null);
      const tr = tkAppendComparisonRow(tbody, k, a, pct, b);
      if (tr) {
        tr.setAttribute('data-id', k);
        tr.setAttribute('data-full', k);
      }
    });

    console.info('[compat] filled Partner A cells:', [...A.values()].filter(v=>v!=null).length,
                 '; Partner B cells:', [...B.values()].filter(v=>v!=null).length);
  }

  // Attach one capture listener to catch *any* file input change on the page
  function wireAnyFileInputs(){
    document.addEventListener('change', function onFileChange(e){
      const el = e.target;
      if(!(el instanceof HTMLInputElement) || el.type !== 'file') return;
      const file = el.files && el.files[0];
      if(!file) return;

      // Decide A or B
      let who = detectPartnerFrom(el);
      if(!who){
        // try to infer from the order of file inputs encountered
        who = fallbackAB(el);
      }

      fileToSurveyMap(file, (err, norm)=>{
        try {
          if(err || !norm){
            alert(`Invalid JSON for Survey ${who || 'A/B'}.\nPlease upload the unmodified JSON file exported from the survey page.`);
            return;
          }
          window._tkCompat[who] = norm;
          console.info(`[compat] bootstrapped ${norm.count} rows for ${who} from JSON.`);
          maybeRecompute();
        } finally {
          try { el.value = ''; } catch (_) {}
        }
      });
    }, true); // use capture so hidden inputs behind buttons still trigger us
  }

  // Small style tweak so numbers look centered
  (function addCompatStyle(){
    const st = document.createElement('style');
    st.textContent = `.ta-c{text-align:center} table td,table th{vertical-align:middle}`;
    document.head.appendChild(st);
  })();

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', wireAnyFileInputs);
  } else {
    wireAnyFileInputs();
  }
})();
</script>
<script>
/* ===== TK Compatibility: robust survey upload wiring =====
   Drop this ONCE at the very end of /compatibility.html (right before </body>).
   It stores uploads into window._tkCompat.A / .B and (re)computes the table. */

(function () {
  // ---------- helpers ----------
  const sTrim = v => (v == null ? '' : String(v)).trim();
  function clamp05(n){
    n = Number(n);
    if (!Number.isFinite(n)) return 0;
    if (n > 5 && n <= 10) return Math.max(0, Math.min(5, n / 2));
    return Math.max(0, Math.min(5, n));
  }

  function extractScore(raw){
    if (raw == null) return 0;
    if (typeof raw === 'object'){
      if (Array.isArray(raw)){
        const first = raw.find(v => v != null);
        return extractScore(first);
      }
      const keys = ['score','value','val','v','rank','answer','rating','points'];
      for (const key of keys){
        if (raw[key] != null) return extractScore(raw[key]);
      }
      return 0;
    }
    if (typeof raw === 'string'){
      const txt = raw.trim();
      if (!txt) return 0;
      if (/^\d+%$/.test(txt)){
        const pct = Number(txt.slice(0, -1));
        return Number.isFinite(pct) ? pct / 20 : 0;
      }
      if (/^\d+\s*\/\s*\d+$/.test(txt)){
        const [a, b] = txt.split('/').map(s => Number(s.trim()));
        if (Number.isFinite(a) && Number.isFinite(b) && b) return a * (5 / b);
      }
      const n = Number(txt);
      if (Number.isFinite(n)) return n;
      return 0;
    }
    if (typeof raw === 'number') return raw;
    return 0;
  }

  function normalizeSurvey(json){
    const map = new Map();
    const add = (id, val) => {
      const key = sTrim(id);
      if (!key) return;
      map.set(key, clamp05(val));
    };
    const fromArray = (arr, prefix='item') => {
      if (!Array.isArray(arr)) return;
      const base = sTrim(prefix) || 'item';
      arr.forEach((entry, idx) => {
        if (entry == null) return;
        let id = '';
        if (typeof entry === 'object' && !Array.isArray(entry)){
          id = entry.id ?? entry.key ?? entry.name ?? entry.label ?? entry.slug ?? '';
        }
        if (!id) id = `${base}_${idx + 1}`;
        add(id, extractScore(entry));
      });
    };

    if (!json) return {map,count:0};
    if (Array.isArray(json)){
      fromArray(json);
      return {map,count:map.size};
    }
    if (json.answers && typeof json.answers==='object' && !Array.isArray(json.answers)){
      for (const [k, v] of Object.entries(json.answers)) add(k, extractScore(v));
      return {map,count:map.size};
    }
    if (Array.isArray(json.answers)){
      fromArray(json.answers, 'answer');
      return {map,count:map.size};
    }
    if (Array.isArray(json.cells)){
      fromArray(json.cells, 'cell');
      return {map,count:map.size};
    }
    if (Array.isArray(json.rows)){
      fromArray(json.rows, 'row');
      return {map,count:map.size};
    }
    if (Array.isArray(json.data)){
      fromArray(json.data, 'data');
      return {map,count:map.size};
    }
    if (Array.isArray(json?.data?.cells)){
      fromArray(json.data.cells, 'cell');
      return {map,count:map.size};
    }
    if (json.map && typeof json.map === 'object'){
      for (const [k, v] of Object.entries(json.map)) add(k, extractScore(v));
      if (map.size) return {map,count:map.size};
    }

    if (json && typeof json === 'object'){
      for (const [k, v] of Object.entries(json)){
        if (/^(schema|meta|page|site|exportedAt)$/i.test(k)) continue;
        if (Array.isArray(v)){
          fromArray(v, k || 'item');
        } else if (v && typeof v === 'object' && !Array.isArray(v)){
          const id = sTrim(v.id ?? v.key ?? v.name ?? v.label ?? k);
          add(id || k, extractScore(v));
        } else {
          add(k, extractScore(v));
        }
      }
    }

    return {map,count:map.size};
  }

  // Keep a single global store
  window._tkCompat = window._tkCompat || { A:null, B:null };

  // ---------- recompute / render ----------
  function defaultRender(){
    const A = window._tkCompat.A?.map || new Map();
    const B = window._tkCompat.B?.map || new Map();
    const keys = new Set([...A.keys(), ...B.keys()]);
    const tbody = document.querySelector('#compatTable tbody') || document.querySelector('table tbody');

    if(!tbody){
      console.info('[compat] (no table tbody found) filled Partner A cells:',
                   [...A.values()].filter(v=>v!=null).length,
                   '; Partner B cells:',
                   [...B.values()].filter(v=>v!=null).length);
      return;
    }

    tbody.innerHTML = '';
    keys.forEach(k=>{
      const a = A.get(k), b = B.get(k);
      const match = (a==null || b==null) ? '—' : Math.round((1 - Math.abs(a-b)/5)*100);
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${k}</td>
                      <td class="ta-c">${a==null?'—':a}</td>
                      <td class="ta-c">${match}</td>
                      <td class="ta-c">${b==null?'—':b}</td>`;
      tbody.appendChild(tr);
    });

    console.info('[compat] filled Partner A cells:',
                 [...A.values()].filter(v=>v!=null).length,
                 '; Partner B cells:',
                 [...B.values()].filter(v=>v!=null).length);
  }

  function recompute(){
    // If your page already exposes a recompute hook, use it. Else do the default.
    if (typeof window._tkCompatRecompute === 'function') {
      try { window._tkCompatRecompute(); return; } catch(e){ console.warn(e); }
    }
    defaultRender();
  }

  // ---------- partner detection ----------
  let lastIntent = null;
  let lastIntentAt = 0;

  // Remember which upload button was clicked most recently
  document.addEventListener('click', (e)=>{
    const btn = e.target.closest('button,a,input[type="button"],input[type="submit"]');
    if(!btn) return;
    const txt = (btn.textContent || btn.value || '').toLowerCase();
    if(/partner.?s?\s+survey|partner\b/.test(txt)) { lastIntent = 'B'; lastIntentAt = Date.now(); }
    else if(/your\s+survey|upload\s+your|^back$/.test(txt)) { lastIntent = 'A'; lastIntentAt = Date.now(); }
  }, true);

  // Strong signal from input attributes
  function detectPartnerFromInput(input){
    const bag = [
      input.dataset?.partner,
      input.name, input.id,
      input.getAttribute('aria-label'),
      input.getAttribute('title')
    ].filter(Boolean).join(' ').toLowerCase();

    if(/\b(b|partner\s*b|survey\s*b|file\s*b)\b/.test(bag)) return 'B';
    if(/\b(a|partner\s*a|survey\s*a|file\s*a)\b/.test(bag)) return 'A';

    const lbl = input.closest('label')?.textContent?.toLowerCase() || '';
    const near = input.closest('form,section,div')?.textContent?.slice(0,200)?.toLowerCase() || '';
    const around = lbl + ' ' + near;
    if(/partner[^a-z]*b/.test(around)) return 'B';
    if(/your.*survey|partner[^a-z]*a/.test(around)) return 'A';
    return null;
  }

  // Fallback ordering across inputs
  const inputSeen = [];
  function fallbackSlotFor(input){
    if(!inputSeen.includes(input)) inputSeen.push(input);
    // first file input we ever see → A, second → B
    return inputSeen.indexOf(input) === 0 ? 'A' : 'B';
  }

  // ---------- wire uploads (single capture listener) ----------
  function wireUploads(){
    document.addEventListener('change', (e)=>{
      const el = e.target;
      if(!(el instanceof HTMLInputElement) || el.type !== 'file') return;
      const file = el.files && el.files[0];
      if(!file) return;

      // decide who
      let who = detectPartnerFromInput(el);
      if(!who && lastIntent && Date.now() - lastIntentAt < 8000) who = lastIntent; // use recent button click (8s window)
      if(!who) who = fallbackSlotFor(el);

      const reader = new FileReader();
      reader.onload = () => {
        try {
          const raw = String(reader.result || '');
          const clean = raw.replace(/^\uFEFF/, '').trim();
          const parser = window.TK_LABELS?.parseSurveyJSON;
          const json = parser ? parser(clean) : JSON.parse(clean);
          const norm = normalizeSurvey(json);
          window._tkCompat[who] = norm;
          console.info(`[compat] stored Survey ${who} with ${norm.count} answers`);
          recompute();
        } catch (err) {
          console.error('[compat] parse/normalize failed:', err);
          alert(`Invalid JSON for Survey ${who}. Please upload the unmodified JSON file exported from this site.`);
        }
      };
      reader.onerror = () => {
        alert(`Could not read file (${reader.error || 'unknown error'})`);
      };
      reader.readAsText(file);
      try { el.value = ''; } catch (_) {}
    }, true);

    // small visual centering helper
    const st = document.createElement('style');
    st.textContent = `.ta-c{text-align:center} table td,table th{vertical-align:middle}`;
    document.head.appendChild(st);
  }

  if(document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', wireUploads);
  } else {
    wireUploads();
  }
})();
</script>
<script>
(() => {
  /**
   * Compatibility table enhancer:
   *  1) Inserts a compact summary under each Category code (first column)
   *  2) Renders a percentage bar in the “Match %” column
   *
   * Notes:
   *  - If you expose an index like window.tkKinksIndex[code] = { short/name/label },
   *    that label is used. Otherwise a readable version of the code is derived.
   *  - If a numeric percent already exists in the “Match %” cell, it’s reused.
   *    Otherwise a visual percent is computed from the two 0–5 ratings.
   */

  // ---------- helpers ----------
  const $ = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

  // Friendly human label from code (fallback)
  const friendly = id => id
    .replace(/^cb[_-]/i, '')            // drop common prefix
    .replace(/[_-]+/g, ' ')
    .replace(/\b\w/g, m => m.toUpperCase());  // title-case

  // Try to read a short label from a global index; fallback to friendlyizer
  function getSummaryFor(id){
    const ix = window.tkKinksIndex || window.tkKinks || window.KINKS_INDEX;
    if (ix && ix[id]) {
      return ix[id].short || ix[id].name || ix[id].label || friendly(id);
    }
    return friendly(id);
  }

  // Compute a visual % if table hasn’t put one there. Based on 0–5 scale:
  // equal = 100%, 1 step apart = 80%, …, 5 apart = 0%.
  const visualPercent = (a, b) => {
    if (a == null || b == null || a === '' || b === '' || isNaN(a) || isNaN(b)) return null;
    const av = Number(a), bv = Number(b);
    if (!isFinite(av) || !isFinite(bv)) return null;
    const pct = Math.max(0, 100 - 20 * Math.abs(av - bv));
    return Math.round(pct);
  };

  const numInCell = td => {
    const t = (td?.textContent || '').trim();
    const n = Number(t);
    return Number.isFinite(n) ? n : null;
  };

  // ---------- find the compatibility table ----------
  const table = $$('table').find(t => {
    const ths = $$('thead th, tr:first-child th', t).map(th => (th.textContent||'').trim().toLowerCase());
    return ths.length >= 3 &&
           ths[0].startsWith('category') &&
           ths.some(h => h.includes('match')) &&
           ths.some(h => h.includes('partner a'));
  });
  if (!table) return;

  // Identify column indexes (fallbacks if head cells aren’t present)
  const headCells = $$('thead tr th', table);
  const getColIndex = (needle) => {
    const idx = headCells.findIndex(th => (th.textContent||'').toLowerCase().includes(needle));
    return idx >= 0 ? idx : null;
  };
  const colCategory = getColIndex('category') ?? 0;
  const colA        = getColIndex('partner a') ?? 1;
  const colMatch    = getColIndex('match') ?? 2;
  const colB        = getColIndex('partner b') ?? 3;

  // Process rows (supports tables without <tbody>)
  const rows = $$('tbody tr', table).length ? $$('tbody tr', table) : $$('tr', table).slice(1);

  rows.forEach(tr => {
    const tds = $$('td', tr);
    if (tds.length < Math.max(colB, colMatch, colCategory) + 1) return;

    // 1) Category subtitle
    const tdCat = tds[colCategory];
    const code  = (tdCat.textContent || '').trim();
    if (code) {
      tdCat.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.className = 'tk-catwrap';
      const codeEl = document.createElement('div');
      codeEl.className = 'tk-code';
      codeEl.textContent = code;
      const subEl = document.createElement('div');
      subEl.className = 'tk-sub';
      subEl.textContent = getSummaryFor(code);
      subEl.title = subEl.textContent; // full on hover
      wrap.append(codeEl, subEl);
      tdCat.append(wrap);
    }

    // 2) Match % meter
    const tdA = tds[colA], tdB = tds[colB], tdM = tds[colMatch];
    const aVal = numInCell(tdA), bVal = numInCell(tdB);

    // If a percent already exists, reuse it; else compute visual percent
    let pct = null;
    const existing = (tdM.textContent || '').trim();
    const existingNum = Number(existing.replace('%',''));
    if (Number.isFinite(existingNum)) {
      pct = Math.max(0, Math.min(100, Math.round(existingNum)));
    } else {
      pct = visualPercent(aVal, bVal);
    }

    tdM.innerHTML = '';
    if (pct == null) {
      tdM.textContent = '—';
    } else {
      const meter = document.createElement('div');
      meter.className = 'tk-meter';
      const fill = document.createElement('div');
      fill.className = 'tk-fill';
      fill.style.width = pct + '%';
      meter.appendChild(fill);

      const label = document.createElement('span');
      label.className = 'tk-pct';
      label.textContent = pct + '%';
      tdM.append(meter, label);
    }
  });
})();
</script>
<script>
(() => {
  const isNum = v => typeof v === 'number' && Number.isFinite(v);
  const clean = s => (s || '').toString().replace(/\s+/g, ' ').trim();
  const shortLabel = (s, max = 44) => {
    s = clean(s).replace(/[\u2013\u2014\-•]+/g, '-');
    if (s.length <= max) return s;
    const cut = s.slice(0, max).lastIndexOf(' ');
    return (cut > 24 ? s.slice(0, cut) : s.slice(0, max - 1)) + '…';
  };

  function pickStoredSurvey() {
    const keys = [
      'tk:compat:a',
      'tk:compat:b',
      'tk:survey:a',
      'tk:survey:b',
      'tk:compat:survey:a',
      'tk:compat:survey:b'
    ];
    const out = {};
    keys.forEach(k => {
      try {
        const v = localStorage.getItem(k);
        if (v) out[k] = JSON.parse(v);
      } catch (err) {
        console.warn('[compat] Failed to parse stored survey', k, err);
      }
    });
    return out;
  }

  function buildLabelMap(surv) {
    const map = {};
    if (!surv) return map;
    const pools = [
      surv.answers,
      surv.categories,
      surv.questions,
      surv.items,
      surv.data
    ].filter(Boolean);

    for (const arr of pools) {
      if (!Array.isArray(arr)) continue;
      for (const it of arr) {
        const id = it?.id || it?.key || it?.code || it?.slug;
        if (!id) continue;
        const title = it?.title || it?.label || it?.name || it?.question || it?.q || it?.text || it?.desc;
        if (title && !map[id]) map[id] = clean(title);
      }
    }

    (Array.isArray(surv.answers) ? surv.answers : []).forEach(a => {
      const id = a?.id;
      const t = a?.meta?.title || a?.meta?.label;
      if (id && t && !map[id]) map[id] = clean(t);
    });
    return map;
  }

  function matchPercent(a, b, max = 5) {
    if (!isNum(a) || !isNum(b)) return null;
    const diff = Math.abs(a - b);
    return Math.round((1 - diff / max) * 100);
  }

  function findCompatTable() {
    const tables = [...document.querySelectorAll('table')];
    return tables.find(t => {
      const hs = [...t.querySelectorAll('thead th, tr:first-child th')]
        .map(e => clean(e.textContent).toLowerCase());
      return hs.includes('category') && hs.includes('partner a') && hs.includes('partner b');
    });
  }

  function upgradeTable() {
    const table = findCompatTable();
    if (!table) return;

    const store = pickStoredSurvey();
    const maps = Object.values(store).map(buildLabelMap);
    const labelFor = (id) => {
      for (const m of maps) {
        if (m && m[id]) return m[id];
      }
      return null;
    };

    const rows = [...table.querySelectorAll('tbody tr')];
    rows.forEach(tr => {
      const tds = [...tr.children];
      if (tds.length < 4) return;

      const [tdCat, tdA, tdMatch, tdB] = tds;
      if (!tdCat.querySelector('.tk-cat, .tk-catwrap, .tk-cat-wrap')) {
        const idText = clean(tdCat.textContent);
        const full = labelFor(idText);
        if (full) {
          const short = shortLabel(full);
          tdCat.textContent = '';
          const span = document.createElement('span');
          span.className = 'tk-cat';
          span.textContent = short;
          span.setAttribute('data-full', '1');
          span.title = full;
          tdCat.appendChild(span);
        } else {
          tdCat.classList.add('tk-cat');
        }
      }

      if (tdMatch.querySelector('.tk-bar, .tk-match-chip, .tk-meter')) return;

      const existingMatch = tdMatch.textContent;
      const a = parseFloat(clean(tdA.textContent).replace(/[^\d.-]/g, ''));
      const b = parseFloat(clean(tdB.textContent).replace(/[^\d.-]/g, ''));
      const pct = matchPercent(a, b, 5);

      tdMatch.textContent = '';
      if (pct == null) {
        const fallback = clean(existingMatch);
        tdMatch.textContent = fallback || '—';
        return;
      }
      const bar = document.createElement('div');
      bar.className = 'tk-bar';
      bar.style.setProperty('--pct', pct + '%');

      const fill = document.createElement('i');
      const label = document.createElement('span');
      label.textContent = pct + '%';

      bar.appendChild(fill);
      bar.appendChild(label);
      tdMatch.appendChild(bar);
    });
  }

  const kick = () => requestAnimationFrame(() => setTimeout(upgradeTable, 60));
  window.addEventListener('load', kick);
  document.addEventListener('DOMContentLoaded', kick);
  window.addEventListener('tk:compat:rendered', upgradeTable);
})();
</script>
<script>
/* =========================================================================
   KSV COMPAT: accept same JSON for A & B, tolerant parsing, and
   hijack existing file-input listeners so legacy "invalid" alert can't fire.
   Paste once near </body> in compatibility.html.
   ======================================================================= */

/* Globals your existing code can consume */
window.ksvSurveyA = window.ksvSurveyA || null;
window.ksvSurveyB = window.ksvSurveyB || null;

/* ------ tolerant parser (handles BOM, different shapes) ------ */
function ksvParseSurveyJsonText(rawText, who) {
  if (typeof rawText !== 'string') return { ok:false, reason:'Internal: non-string' };
  let text = rawText.replace(/^\uFEFF/, '').trim();       // strip BOM
  let obj;
  try { obj = JSON.parse(text); }
  catch { return { ok:false, reason:'Not valid JSON' }; }

  let answers = null;
  if (Array.isArray(obj?.answers)) answers = obj.answers;          // canonical
  if (!answers && Array.isArray(obj)) answers = obj;                // raw array
  if (!answers && Array.isArray(obj?.cells)) answers = obj.cells;   // {cells:[…]}
  if (!answers && Array.isArray(obj?.data?.cells)) answers = obj.data.cells;
  if (!answers && obj && typeof obj === 'object' && obj.map && typeof obj.map === 'object') {
    answers = Object.values(obj.map);
  }
  if (!answers) return { ok:false, reason:'Missing answers/cells array' };

  const toNum = (x) => {
    if (x == null) return null;
    if (typeof x === 'object') x = x.score ?? x.value ?? x.val ?? x.v ?? x.s ?? x.rank ?? x.answer;
    const n = Number(x);
    return Number.isFinite(n) ? Math.max(0, Math.min(5, n)) : null;
  };
  const cells = answers.map(toNum);

  if (cells.length !== 35) return { ok:false, reason:`Expected 35 answers, got ${cells.length}` };
  for (let i = 0; i < cells.length; i++) if (cells[i] == null) cells[i] = 0;

  console.log(`[compat] stored Survey ${who} with ${cells.length} answers`);
  return { ok:true, cells };
}

/* ------ file → text ------ */
function ksvReadFileAsText(file) {
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = () => resolve(String(fr.result || ''));
    fr.onerror = () => reject(fr.error || new Error('read failed'));
    fr.readAsText(file);
  });
}

/* ------ trigger your table refresh ------ */
function ksvRefreshUI(who) {
  // Call whichever hook exists in your page
  if (typeof window.ksvOnSurveyLoaded === 'function') {
    who && window.ksvOnSurveyLoaded(who, who === 'A' ? window.ksvSurveyA : window.ksvSurveyB);
  } else if (typeof window.updateComparison === 'function') {
    window.updateComparison();
  }
}

/* ------ core hijacker: capture file inputs and own the event ------ */
async function ksvHandleFileInput(ev) {
  const input = ev.target;
  if (!(input instanceof HTMLInputElement)) return;

  // Only handle JSON file pickers
  const isFile = input.type === 'file';
  const accept = (input.getAttribute('accept') || '').toLowerCase();
  if (!isFile || (!accept.includes('json') && !accept.includes('.json'))) return;

  // Stop legacy listeners from running
  ev.stopImmediatePropagation();
  ev.preventDefault();

  const file = input.files && input.files[0];
  if (!file) return;

  // Decide A or B. Heuristics: id/name contains 'b' → B, else
  // if A is empty → A; else if B empty → B; else default to A.
  const idn = ((input.id || '') + ' ' + (input.name || '')).toLowerCase();
  let who = idn.includes('partnerb') || idn.includes('surveyb') || idn.includes('uploadb') || /\b[b]\b/.test(idn)
            ? 'B'
            : idn.includes('partnera') || idn.includes('surveya') || idn.includes('uploada')
            ? 'A'
            : (Array.isArray(window.ksvSurveyA) ? (Array.isArray(window.ksvSurveyB) ? 'A' : 'B') : 'A');

  try {
    const text = await ksvReadFileAsText(file);
    const parsed = ksvParseSurveyJsonText(text, who);
    if (!parsed.ok) {
      alert(`Invalid JSON for Survey ${who}.\nReason: ${parsed.reason}\nPlease upload the unmodified JSON file exported from this site.`);
      console.warn(`[compat] Survey ${who} rejected: ${parsed.reason}`);
      return;
    }
    if (who === 'A') window.ksvSurveyA = parsed.cells;
    if (who === 'B') window.ksvSurveyB = parsed.cells;

    console.log(`[compat] filled Partner ${who} cells: ${parsed.cells.length}`);
    ksvRefreshUI(who);
  } finally {
    // Allow selecting the *same* file again (browsers suppress change otherwise)
    input.value = '';
  }
}

/* Attach capture listeners to any current or future file inputs */
function ksvBindAllFileInputs(root = document) {
  root.querySelectorAll('input[type="file"]').forEach((inp) => {
    if (!inp.__ksvHijacked) {
      inp.addEventListener('change', ksvHandleFileInput, true); // capture
      inp.__ksvHijacked = true;
    }
  });
}
ksvBindAllFileInputs(document);

/* Observe future additions (dialogs creating inputs late, etc.) */
const mo = new MutationObserver((muts) => {
  for (const m of muts) {
    m.addedNodes && m.addedNodes.forEach((n) => {
      if (n.nodeType === 1) ksvBindAllFileInputs(n);
    });
  }
});
mo.observe(document.documentElement, { childList: true, subtree: true });

/* Optional convenience: button to copy A → B for solo testing
   Add this in your HTML if you want:
   <button id="copyAtoB" class="themed-button">Use A for B</button>
*/
document.getElementById('copyAtoB')?.addEventListener('click', () => {
  if (!Array.isArray(window.ksvSurveyA) || window.ksvSurveyA.length !== 35) {
    alert('Load Survey A first, then copy it to B.'); return;
  }
  window.ksvSurveyB = [...window.ksvSurveyA];
  console.log('[compat] Partner B set from Partner A');
  ksvRefreshUI('B');
});
</script>



  <script defer src="/js/compat_labels_bars_safe.js"></script>
</body>
</html>
