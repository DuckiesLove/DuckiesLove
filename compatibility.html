<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>See Our Compatibility</title>
  <!-- Import theme and global layout styles -->
  <link rel="stylesheet" href="/css/theme.css" />
  <link rel="stylesheet" href="/css/global.css" />
  <link rel="stylesheet" href="/css/compat-table.css" />
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script>
/**
 * Kink Compatibility — Single-source renderer that replaces window.updateComparison
 *
 * What this does:
 *  - Renders a standards-based table per category (THEAD/TBODY)
 *  - Emits <tr data-full="Exact full label"> so JSON keys can match deterministically
 *  - Tags “Partner A” cells with .pa and “Partner B” cells with .pb
 *  - Fills A/B immediately from window.partnerASurvey / window.partnerBSurvey (or window.surveyA/B)
 *  - Recomputes a simple % “Match” after fill
 *  - Requires NO extra helper scripts at the bottom of the page
 *
 * Requirements:
 *  - Add data-compat-root to the wrapper that should receive the tables:
 *      <div id="compat-container" data-compat-root></div>
 *  - Upload handlers must set:
 *      window.partnerASurvey (or window.surveyA)
 *      window.partnerBSurvey (or window.surveyB)
 *  - Call window.updateComparison(rowsByCategory) with your data.
 *
 * Expected input (rowsByCategory):
 * {
 *   "Appearance & Dress": [
 *     { id:"appearance_outfit", label:"Choosing my partner's outfit for the day or a scene" },
 *     { id:"appearance_underwear", label:"Selecting their underwear, lingerie, or base layers" },
 *     ...
 *   ],
 *   "Bondage": [ { id:"bondage_rope", label:"Rope (tying, harnesses, decorative)" }, ... ],
 *   ...
 * }
 */
(function(){
  // ---------- Normalizer & Survey -> Lookup ----------
  function norm(s){
    return String(s||'')
      .replace(/[\u2018\u2019\u2032]/g,"'")
      .replace(/[\u201C\u201D\u2033]/g,'"')
      .replace(/[\u2013\u2014]/g,'-')
      .replace(/\u2026/g,'')
      .replace(/\s*\.\.\.\s*$/,'')
      .replace(/\s+/g,' ')
      .trim().toLowerCase();
  }

  function toLookup(json){
    const map = new Map();
    if (!json || typeof json !== 'object') return map;

    // Flat { key: number } object
    if (!Array.isArray(json) && !json.items && !json.survey) {
      for (const [k,v] of Object.entries(json)) {
        const n = Number(v);
        if (Number.isFinite(n)) map.set(norm(k), n);
      }
      return map;
    }

    // {items:[{name|label|key|id, rating|score|value}]}
    const items = Array.isArray(json.items) ? json.items : [];
    if (items.length) {
      for (const it of items) {
        const k = norm(it?.name ?? it?.label ?? it?.key ?? it?.id ?? '');
        const n = Number(it?.rating ?? it?.score ?? it?.value);
        if (k && Number.isFinite(n)) map.set(k, n);
      }
      return map;
    }

    // Nested survey export { survey: { Category: { Giving/Receiving/General:[...] } } }
    if (json.survey && typeof json.survey === 'object') {
      Object.values(json.survey).forEach(section=>{
        ['Giving','Receiving','General'].forEach(bucket=>{
          const arr = Array.isArray(section?.[bucket]) ? section[bucket] : [];
          arr.forEach(item=>{
            const k = norm(item?.name ?? item?.label ?? item?.id ?? '');
            const n = Number(item?.rating ?? item?.score ?? item?.value);
            if (k && Number.isFinite(n)) {
              map.set(k, Math.max(map.get(k) ?? -Infinity, n)); // prefer max on duplicates
            }
          });
        });
      });
    }
    return map;
  }

  // ---------- Fill helpers ----------
  function fillPartnerCells(tbody, cls, lookup){
    if (!lookup || !lookup.size) return 0;
    let wrote = 0;
    tbody.querySelectorAll('tr').forEach(tr=>{
      const td = tr.querySelector('td.'+cls);
      if (!td) return;
      const current = (td.textContent||'').trim();
      if (current && !/^[-–—]$/.test(current)) return; // don't overwrite real values
      const key = norm(tr.getAttribute('data-full') || tr.getAttribute('data-id') || '');
      if (!key) return;
      const val = lookup.get(key);
      if (val == null) return;
      td.textContent = String(val);
      wrote++;
    });
    return wrote;
  }

  // Simple similarity metric for the “Match” column (1–5 scale assumed)
  function computeMatch(a, b){
    const na = Number(a), nb = Number(b);
    if (!Number.isFinite(na) || !Number.isFinite(nb)) return '';
    const diff = Math.abs(na - nb);          // 0..4
    const pct  = Math.round((1 - diff/4) * 100);
    return pct + '%';
  }

  // ---------- Category renderer ----------
  function renderCategoryTable(category, items, mount){
    const section = document.createElement('section');
    section.className = 'compat-section';

    const title = document.createElement('h2');
    title.className = 'section-title';
    title.textContent = category;
    section.appendChild(title);

    const table = document.createElement('table');
    table.className = 'compat-table';

    const thead = document.createElement('thead');
    const thr = document.createElement('tr');
    const hCat   = document.createElement('th'); hCat.textContent    = 'Category';
    const hA     = document.createElement('th'); hA.textContent      = 'Partner A';
    const hMatch = document.createElement('th'); hMatch.textContent  = 'Match';
    const hB     = document.createElement('th'); hB.textContent      = 'Partner B';
    thr.append(hCat, hA, hMatch, hB);
    thead.appendChild(thr);

    const tbody = document.createElement('tbody');

    items.forEach(row=>{
      const tr = document.createElement('tr');
      if (row.id)    tr.setAttribute('data-id', row.id);
      if (row.label) tr.setAttribute('data-full', row.label); // full label for matching

      const tdLabel = document.createElement('td'); tdLabel.textContent = row.label || '';
      const tdA     = document.createElement('td'); tdA.className = 'pa'; tdA.textContent = '-';
      const tdMatch = document.createElement('td'); tdMatch.className = 'match'; tdMatch.textContent = '';
      const tdB     = document.createElement('td'); tdB.className = 'pb'; tdB.textContent = '-';

      tr.append(tdLabel, tdA, tdMatch, tdB);
      tbody.appendChild(tr);
    });

    table.append(thead, tbody);
    section.appendChild(table);
    mount.appendChild(section);

    // Immediate fill if surveys already uploaded
    const aLookup = toLookup(window.partnerASurvey || window.surveyA || null);
    const bLookup = toLookup(window.partnerBSurvey || window.surveyB || null);
    const wroteA  = fillPartnerCells(tbody, 'pa', aLookup);
    const wroteB  = fillPartnerCells(tbody, 'pb', bLookup);

    if (wroteA || wroteB) {
      tbody.querySelectorAll('tr').forEach(tr=>{
        const a = tr.querySelector('td.pa')?.textContent;
        const b = tr.querySelector('td.pb')?.textContent;
        const m = tr.querySelector('td.match');
        if (m) m.textContent = computeMatch(a, b);
      });
      if (typeof window.populateFlags === 'function') window.populateFlags();
    }
  }

  // ---------- Public API (drop-in replacement) ----------
  window.updateComparison = function(rowsByCategory){
    const root = document.querySelector('[data-compat-root]') || document.querySelector('#pdf-container');
    if (!root) { console.error('[compat] Missing container: add data-compat-root to the wrapper.'); return; }

    // Reset and rebuild all categories
    root.innerHTML = '';
    if (Array.isArray(rowsByCategory)) {
      renderCategoryTable('All', rowsByCategory, root);
    } else {
      Object.entries(rowsByCategory || {}).forEach(([cat, items])=>{
        renderCategoryTable(cat, Array.isArray(items) ? items : [], root);
      });
    }
  };

  // Refill on upload change (after rows exist)
  document.addEventListener('change', (e)=>{
    const isA = e.target && e.target.matches('#uploadSurveyA,[data-upload-a]');
    const isB = e.target && e.target.matches('#uploadSurveyB,[data-upload-b]');
    if (!(isA || isB)) return;

    setTimeout(()=>{
      const root = document.querySelector('[data-compat-root]') || document.querySelector('#pdf-container');
      if (!root) return;

      const aLookup = toLookup(window.partnerASurvey || window.surveyA || null);
      const bLookup = toLookup(window.partnerBSurvey || window.surveyB || null);

      root.querySelectorAll('table').forEach(table=>{
        const tbody = table.querySelector('tbody');
        const wroteA = fillPartnerCells(tbody, 'pa', aLookup);
        const wroteB = fillPartnerCells(tbody, 'pb', bLookup);

        if (wroteA || wroteB) {
          tbody.querySelectorAll('tr').forEach(tr=>{
            const a = tr.querySelector('td.pa')?.textContent;
            const b = tr.querySelector('td.pb')?.textContent;
            const m = tr.querySelector('td.match');
            if (m) m.textContent = computeMatch(a, b);
          });
        }
      });
      if (typeof window.populateFlags === 'function') window.populateFlags();
    }, 150);
  });
})();
</script>
  <style>
  #compat-container {
    width: 100%;
    max-width: 100%;
  }
  table {
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    text-align: center;
    vertical-align: middle;
    padding: 6px;
  }
  th:first-child, td:first-child {
    text-align: left;
    padding-left: 10px;
  }
  </style>
  <style>
    .upload-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      margin-top: 3rem;
    }

      .upload-button {
        position: relative;
        display: inline-block;
      }

    .upload-button input[type="file"] {
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .wide-button {
      min-width: 260px;
      max-width: 300px;
      width: 100%;
    }
  </style>
  <style>
    /* Keep rows from splitting in both web and print */
    .compat-section tr { break-inside: avoid; page-break-inside: avoid; }

    /* Make sure tables are fixed-width to avoid right-side cutoff */
    .compat-section table {
      width: 100% !important;
      table-layout: fixed !important;
      border-collapse: collapse !important;
    }

    /* Optional: make header clean (no decorative lines/boxes) */
    .section-title, .category-header, .compat-category {
      border: none !important;
      box-shadow: none !important;
      background: transparent !important;
    }
  </style>
</head>
<body class="theme-dark">
  <div class="main-container themed">
    <h1 class="page-title">See Our Compatibility</h1>
    <div class="upload-container">
      <button class="themed-button wide-button" onclick="window.history.back()">← Back</button>

      <label id="uploadYourSurvey" class="upload-button themed-button wide-button">
        <input id="uploadSurveyA" type="file" accept="application/json" />
        Upload Your Survey
      </label>

      <label id="uploadPartnerSurvey" class="upload-button themed-button wide-button">
        <input id="uploadSurveyB" type="file" accept="application/json" />
        Upload Partner’s Survey
      </label>

      <button class="themed-button wide-button" id="downloadBtn">Download PDF</button>
    </div>

    <div id="comparisonResults">
      <div id="loading-spinner" class="loading-overlay"><div class="spinner"></div></div>
      <div id="compat-container" data-compat-root></div>
      <div class="print-footer"></div>
    </div>
  </div>

  <script src="js/template-survey.js"></script>
  <script type="module" src="js/compatibilityPage.js"></script>
  <script type="module">
    import { initTheme, applyThemeColors } from './js/theme.js';
    initTheme();
    window.applyThemeColors = applyThemeColors;
  </script>
  <script>
    fetch("/check-session", { credentials: "include" })
      .then(res => {
        if (res.status === 401) {
          window.location.href = "/token.html";
        }
      });
  </script>

  <script type="module">
    import { downloadCompatibilityPDF } from '/js/pdfDownload.js';
    // auto-wire is built into the module, but this exposes it if you need to call it manually:
    window.downloadCompatibilityPDF = downloadCompatibilityPDF;
  </script>
</body>
</html>
