<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Kill-switch for legacy Partner-B bootstrap that caused "freeze after first upload" -->
  <script>
    // Hard disable any code path that auto-fills Partner B from internal JSON.
    // This must be loaded before every other script.
    window.TK_DISABLE_BOOTSTRAP_B = true;
    console.info('[compat] kill-switch enabled');
    // one-time guard so labels/overrides merge only once per load
    window._tkLabelsMerged = false;
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>See Our Compatibility</title>
  <style>
    /* Kill any category dock/panel overlays without layout shift */
    #tkDockCard,
    #categorySurveyPanel,
    aside.category-panel,
    .category-panel,
    [data-testid="select-categories-panel"],
    #tkOverlay,
    .tk-overlay {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }

    /* Ensure body isn't pushed for a removed dock */
    html.tk-dock body {
      margin-left: 0 !important;
    }
  </style>
  <script>
    (function killCategoryPanel() {
      const selectors = [
        '#tkDockCard',
        '#categorySurveyPanel',
        'aside.category-panel',
        '.category-panel',
        '[data-testid="select-categories-panel"]',
        '#tkOverlay',
        '.tk-overlay'
      ];

      window.__TK_DISABLE_PANEL__ = true;
      window.__TK_DISABLE_PORTAL__ = true;

      const purge = () => {
        document.documentElement.classList.remove('tk-dock');
        if (document.body) {
          document.body.style.marginLeft = '';
        }
        selectors.forEach((selector) => {
          document.querySelectorAll(selector).forEach((node) => node.remove());
        });
      };

      purge();

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', purge, { once: true });
      }

      const observer = new MutationObserver(purge);
      observer.observe(document.documentElement, { childList: true, subtree: true });
      setTimeout(() => observer.disconnect(), 4000);
    })();
  </script>
  <!-- COMPAT PAGE: recentre layout + neutralize any dock margin -->
  <style id="compat-centering">
    :root {
      --tk-dock-width: 0px !important;
    }

    html,
    body {
      margin: 0;
    }

    .compat-page,
    .compat-wrapper,
    #compatRoot,
    main,
    .page,
    .container {
      max-width: 960px;
      margin: 0 auto !important;
      padding: 40px 16px;
    }

    .compat-buttons,
    .compat-actions {
      display: flex;
      flex-direction: column;
      gap: 24px;
      align-items: center;
    }

    .compat-buttons .themed-button,
    .compat-actions .themed-button,
    .themed-button.compat {
      width: min(680px, 90vw);
    }
  </style>

  <script>
    (function () {
      try {
        if (document.body) {
          document.body.style.marginLeft = '0px';
        }
        document.documentElement.style.setProperty('--tk-dock-width', '0px');

        const host = document.querySelector(
          '#compatRoot, .compat-page, .compat-wrapper, main, .page, .container'
        );

        if (host) {
          Object.assign(host.style, {
            maxWidth: '960px',
            margin: '0 auto',
            padding: '40px 16px'
          });
        }

        document.querySelectorAll('.themed-button').forEach((btn) => {
          Object.assign(btn.style, {
            width: 'min(680px, 90vw)',
            margin: '0 auto',
            display: 'block'
          });
        });
      } catch (err) {
        console.warn('[compat] unable to apply centering overrides', err);
      }
    })();
  </script>
  <style id="tk-compat-center">
    /* Remove any panel/dock if an older script injected it */
    #tkDockCard,
    #categorySurveyPanel,
    .category-panel,
    .tk-overlay {
      display: none !important;
    }

    html,
    body {
      margin: 0;
    }

    body[style*="margin-left"] {
      margin-left: 0 !important;
    }

    /* Center the content column */
    .compat-wrap,
    .compat-container,
    .container,
    main,
    #app {
      box-sizing: border-box;
      max-width: 960px;
      width: min(960px, 92vw);
      margin-inline: auto;
      padding-inline: 16px;
    }

    .compat-wrap > *,
    .compat-container > *,
    .container > *,
    main > * {
      max-width: 100%;
    }
  </style>
  <script>
    (function () {
      const clearDock = () => {
        // Nuke any leftover dock/overlay/panel on this page
        for (const sel of ['#tkDockCard', '.tk-overlay', '#categorySurveyPanel', '.category-panel']) {
          const n = document.querySelector(sel);
          if (n) n.remove();
        }

        const body = document.body;
        if (body) {
          body.style.marginLeft = '';
        }

        const dock = document.querySelector('#compat-dock');
        if (dock) {
          dock.style.removeProperty('margin-bottom');
        }
      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', clearDock, { once: true });
      } else {
        clearDock();
      }
    })();
  </script>
  <!-- Import theme and global layout styles -->
  <link rel="stylesheet" href="/css/theme.css" />
  <link rel="stylesheet" href="/css/global.css" />
  <link rel="stylesheet" href="/css/compat-table.css" />
  <link rel="stylesheet" href="/css/font-failopen.css">
  <link rel="stylesheet" href="/css/compatibility.css" />
  <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg" />

  <style>
    /* --- Percent bar (Match %) --- */
    .pct {
      position: relative;
      width: 100%;
      height: 22px;
      border: 1px solid #3ddbf3;
      border-radius: 6px;
      background: rgba(61,219,243,0.08);
      overflow: hidden;
    }
    .pct-fill {
      position: absolute;
      inset: 0;
      width: 0%;
      background: linear-gradient(90deg, #18a0fb, #3df3c3);
      transition: width .35s ease;
    }
    .pct-text {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-variant-numeric: tabular-nums;
      font-weight: 600;
    }
    /* Friendly label text in first column (wrap nicely on small screens) */
    .tk-cat {
      white-space: normal;
      line-height: 1.2;
    }
    .tk-code {
      opacity: .5;
      font-size: .85em;
      margin-left: .4rem;
    }
  </style>
  <style>
    td.pct-cell .pct { position: relative; height: 1.1em; line-height: 1.1em; }
    td.pct-cell .pct .bar { position:absolute; left:0; top:0; bottom:0; width:0%;
                            background:rgba(0,255,255,0.25); border-radius:2px; }
    td.pct-cell .pct .txt { position:relative; display:block; text-align:center; }
    td.pct-cell { min-width:5rem; }
  </style>
  <style>
  #pdf-container {
    width: 100%;
    max-width: 100%;
  }
  table {
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    text-align: center;
    vertical-align: middle;
    padding: 6px;
  }
  th:first-child, td:first-child {
    text-align: left;
    padding-left: 10px;
  }
  </style>
  <style>
    .upload-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      margin-top: 3rem;
    }

    .upload-button {
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
    }

    .upload-button input[type="file"] {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .upload-button .upload-trigger {
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .upload-button .upload-trigger:focus-visible {
      outline: 2px solid rgba(61, 219, 243, 0.9);
      outline-offset: 2px;
    }

    .wide-button {
      min-width: 260px;
      max-width: 300px;
      width: 100%;
    }
    .export-tip {
      font-size: 0.9rem;
      margin: 0;
    }
  </style>
  <style>
    /* Keep rows from splitting in both web and print */
    .compat-section tr { break-inside: avoid; page-break-inside: avoid; }

    /* Make sure tables are fixed-width to avoid right-side cutoff */
    .compat-section table {
      width: 100% !important;
      table-layout: fixed !important;
      border-collapse: collapse !important;
    }

    /* Optional: make header clean (no decorative lines/boxes) */
    .section-title, .category-header, .compat-category {
      border: none !important;
      box-shadow: none !important;
      background: transparent !important;
    }
  </style>
  <style>
    /* Force LIGHT pdf colors by default; override via body[style] if you want dark */
    :root { --pdf-bg:#fff; --pdf-text:#000; }
    .pdf-export, #pdfWrapper, .pdf-container {
      background: var(--pdf-bg) !important;
      color: var(--pdf-text) !important;
    }
  </style>
  <style>
    /* optional polish to match your theme */
    .tk-compat th, .tk-compat td{
      border-bottom:1px solid #00e6ff33;
      padding:.55rem .8rem;
      vertical-align:middle;
    }
    .tk-compat td.ta-c{ text-align:center; }
  </style>
  <style>
  /* Small, unobtrusive subtitle under the category code */
  .tk-catwrap { display:flex; flex-direction:column; gap:2px; }
  .tk-catwrap .tk-code { font-weight:600; letter-spacing:0.02em; }
  .tk-catwrap .tk-sub  {
    font-weight:500; opacity:.78;
    font-size: clamp(11px,.9vw,13px);
    line-height:1.2;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    max-width: min(48vw, 780px);  /* fits your wide first column */
  }

  /* Match % meter (tuned for your dark theme) */
  .tk-meter {
    position: relative;
    height: 10px; min-width: 110px;
    background: rgba(0, 230, 255, .12);
    border-radius: 999px;
    outline: 1px solid rgba(0,230,255,.20);
    overflow: hidden;
  }
  .tk-meter > .tk-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg,
      rgba(0,230,255,.88), rgba(120,255,250,.95));
    box-shadow: 0 0 10px rgba(0,230,255,.35) inset;
    border-radius: inherit;
    transition: width .35s ease;
  }
  .tk-meter + .tk-pct {
    display:inline-block; min-width: 42px;
    font-weight:800; letter-spacing:.02em;
    margin-left:.5rem; opacity:.9;
  }

  /* Keep row height stable on narrow screens */
  @media (max-width: 720px){
    .tk-catwrap .tk-sub { max-width: 70vw; }
    .tk-meter { min-width: 80px; }
  }
  </style>
  <style>
  /* ====== Match % chip (compact, no layout shift) ====== */
  .tk-match-chip{
    display:inline-flex; flex-direction:column; align-items:center; gap:6px;
    min-width:70px; line-height:1; vertical-align:middle;
  }
  .tk-match-num{ font-weight:800; letter-spacing:.02em; }
  .tk-match-bar{
    position:relative; width:90px; height:7px; border-radius:999px;
    outline:1px solid rgba(0,230,255,.35);
    background:rgba(0,230,255,.10); overflow:hidden;
  }
  .tk-match-fill{
    display:block; height:100%; width:var(--w,0%);
    background:linear-gradient(90deg,#00e6ff,#3bffc4);
    border-radius:inherit; transition:width .25s ease;
  }
  /* Dim the bar if the value is “missing” on that row */
  .tk-match-chip[data-missing="1"] .tk-match-bar{ opacity:.38; }

  /* ====== Category main + tiny subline (summary) ====== */
  .tk-cat-wrap{ display:flex; flex-direction:column; gap:3px; }
  .tk-cat-main{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .tk-cat-sub{
    font-size:.82em; color:#9beff7; opacity:.78;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    max-width:48ch;  /* keep it subtle; doesn’t stretch your layout */
  }
  /* On narrow screens you can hide the subline if you want */
  @media (max-width: 680px){
    .tk-cat-sub{ display:none; }
  }
  </style>
  <style>
  /* Compatibility table progressive enhancement (fallback match bar + labels) */
  td.ksv-match { white-space: nowrap; }

  .ksv-matchwrap{
    display:flex; flex-direction:column; align-items:center; gap:.4rem;
    min-width:8rem;
  }
  .ksv-pct{
    font: 800 0.95rem/1.1 system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    letter-spacing:.02em; color:#d9ffff;
  }
  .ksv-bar{
    width:100%; height:6px; border-radius:999px;
    background: rgba(0,230,255,.12);
    outline: 1px solid rgba(0,230,255,.35);
    overflow:hidden;
  }
  .ksv-bar > i{
    display:block; height:100%; width:var(--w,0%);
    background: linear-gradient(90deg,#00e6ff 0%, #5fffd6 100%);
    box-shadow: 0 0 6px #00e6ff66 inset;
  }

  .tk-upload-messages {
    display: grid;
    gap: 0.35rem;
    margin: 0.75rem auto 0;
    max-width: 32rem;
  }

  .tk-upload-status {
    font: 500 0.92rem/1.35 "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    color: #c9f4ff;
    text-align: center;
    padding: 0.45rem 0.75rem;
    background: rgba(0, 230, 255, 0.08);
    border: 1px solid rgba(0, 230, 255, 0.18);
    border-radius: 0.75rem;
    margin: 0;
  }

  .tk-upload-status[data-state="info"] {
    color: #c9f4ff;
  }

  .tk-upload-status[data-state="success"] {
    color: #9fffd6;
    background: rgba(53, 255, 197, 0.08);
    border-color: rgba(105, 255, 213, 0.25);
  }

  .tk-upload-status[data-state="error"] {
    color: #ffc1ce;
    background: rgba(255, 70, 102, 0.07);
    border-color: rgba(255, 102, 133, 0.2);
  }

  .tk-consent-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(4, 16, 28, 0.82);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    padding: 1.5rem;
  }

  .tk-consent-card {
    background: #04111c;
    border: 1px solid rgba(0, 230, 255, 0.25);
    box-shadow: 0 24px 60px rgba(0, 0, 0, 0.45);
    border-radius: 1rem;
    padding: 1.65rem;
    max-width: min(34rem, 100%);
    color: #f2fbff;
  }

  .tk-consent-card h2 {
    font: 700 1.2rem/1.3 "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    margin: 0 0 0.75rem;
  }

  .tk-consent-card p {
    margin: 0 0 1.25rem;
    font: 500 0.98rem/1.6 "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    color: #c8e9ff;
  }

  .tk-consent-actions {
    display: flex;
    justify-content: flex-end;
    gap: 0.75rem;
  }

  .tk-btn.tk-btn-secondary {
    background: rgba(0, 230, 255, 0.08);
  }

  .tk-btn.tk-btn-secondary:hover {
    background: rgba(0, 230, 255, 0.14);
  }

  .tk-consent-backdrop[hidden] {
    display: none;
  }

  td.ksv-cat{
    word-break: break-word;
  }
  .ksv-cat .ksv-cat-text{
    display:inline;
  }
  </style>

  <link rel="stylesheet" href="/assets/css/comparison.css" />
</head>
<body data-page="compat">
  <main class="tk-landing">
    <h1 class="tk-title">TalkKink Compatibility</h1>

    <div class="tk-menu">
      <label id="yourBtn" for="yourFile" class="tk-btn">Upload Your Survey</label>
      <label id="partnerBtn" for="partnerFile" class="tk-btn">Upload Partner’s Survey</label>
      <button id="downloadBtn" class="tk-btn" disabled>Download PDF</button>
    </div>

    <div class="tk-upload-messages" aria-live="polite" aria-atomic="true">
      <p id="yourStatus" class="tk-upload-status" role="status" hidden></p>
      <p id="partnerStatus" class="tk-upload-status" role="status" hidden></p>
    </div>

        <a href="https://talkkink.org/KinkSurveyPage/index.html" class="tk-btn back">← Back</a>

    <input id="yourFile" type="file" accept="application/json" hidden />
    <input id="partnerFile" type="file" accept="application/json" hidden />

  <script>
    (function () {
      const PARTNER_INPUT_SEL = '#partnerFile';
      const CONSENT_KEY = 'tk.partnerConsent.v1';

      const partnerInput = document.querySelector(PARTNER_INPUT_SEL);
      if (!partnerInput) return;

      let passthroughOnce = false;

      document.addEventListener(
        'change',
        async (ev) => {
          const t = ev.target;
          if (!(t instanceof HTMLInputElement) || t !== partnerInput) return;

          if (passthroughOnce) return;

          try {
            if (sessionStorage.getItem(CONSENT_KEY) === '1') return;
          } catch (err) {
            console.warn('[compat] unable to read consent flag', err);
          }

          ev.stopImmediatePropagation();
          ev.stopPropagation();

          const ok = await requestPartnerConsentDialog();
          if (!ok) {
            t.value = '';
            return;
          }

          try {
            sessionStorage.setItem(CONSENT_KEY, '1');
          } catch (err) {
            console.warn('[compat] unable to persist consent flag', err);
          }

          passthroughOnce = true;
          setTimeout(() => {
            t.dispatchEvent(new Event('change', { bubbles: true }));
            passthroughOnce = false;
          }, 0);
        },
        true
      );

      async function requestPartnerConsentDialog() {
        return confirm(
          'Before importing a partner’s survey, confirm you have their explicit consent to upload and compare their responses here.\n\n' +
            'Click “OK” to confirm consent and continue, or “Cancel” to stop.'
        );
      }

      window.tkResetPartnerConsent = function () {
        try {
          sessionStorage.removeItem(CONSENT_KEY);
        } catch (err) {
          console.warn('[compat] unable to reset consent flag', err);
        }
        console.info('[compat] partner consent reset for this tab.');
      };
    })();
  </script>
  </main>

  <script>
    function ksvParseSurveyJsonText(jsonText, partner = 'A') {
      const fail = (reason) => ({ ok: false, reason, cells: [], survey: null });
      if (typeof jsonText !== 'string') return fail('No JSON payload provided');

      let payload;
      try {
        payload = JSON.parse(jsonText);
      } catch (err) {
        return fail('Invalid JSON');
      }

      const answers = {};
      const answersByKey = {};
      let maxIndex = 0;

      const clamp = (value) => {
        const n = Number(value);
        if (!Number.isFinite(n)) return 0;
        if (n < 0) return 0;
        if (n > 5) return 5;
        return Math.round(n);
      };

      const toRating = (value) => {
        if (value == null || value === '') return 0;
        if (typeof value === 'number' && Number.isFinite(value)) return clamp(value);
        if (typeof value === 'string') {
          const trimmed = value.trim();
          if (!trimmed) return 0;
          const match = trimmed.match(/-?\d+(?:\.\d+)?/);
          if (match) return clamp(Number(match[0]));
        }
        return 0;
      };

      const applyRating = (index, value) => {
        const idx = Number(index);
        if (!Number.isFinite(idx) || idx <= 0) return;
        const normalized = toRating(value);
        const key = String(idx);
        answersByKey[key] = normalized;
        if (idx > maxIndex) maxIndex = idx;
      };

      const absorbArray = (arr) => {
        if (!Array.isArray(arr)) return;
        arr.forEach((value, i) => applyRating(i + 1, value));
      };

      const absorbObject = (obj) => {
        if (!obj || typeof obj !== 'object') return;
        Object.keys(obj)
          .sort((a, b) => Number(a) - Number(b))
          .forEach((key) => applyRating(key, obj[key]));
      };

      if (Array.isArray(payload)) {
        absorbArray(payload);
      } else if (payload && typeof payload === 'object') {
        absorbArray(payload.cells);
        absorbArray(payload.answers);
        absorbObject(payload.answersByKey);
        absorbObject(payload.answersById);
        absorbObject(payload.ratings);
      } else {
        return fail('Unsupported survey payload');
      }

      if (!maxIndex) {
        return fail('No survey answers found');
      }

      for (let i = 1; i <= maxIndex; i += 1) {
        const key = String(i);
        const rating = Object.prototype.hasOwnProperty.call(answersByKey, key)
          ? answersByKey[key]
          : 0;
        answers[key] = rating;
        answersByKey[key] = rating;
      }

      const cells = Array.from({ length: maxIndex }, (_, i) => answersByKey[String(i + 1)] ?? 0);
      return { ok:true, cells, survey: { answers, answersByKey } };
}

    window.ksvParseSurveyJsonText = ksvParseSurveyJsonText;
  </script>

  <!-- CODEX: Resilient dark PDF exporter (dual-CDN, guarded parsing, consent, diagnostics) -->
  <script>
(function () {
  const $ = (selector, root = document) => root.querySelector(selector);
  const dispatch = (name, detail) => document.dispatchEvent(new CustomEvent(name, { detail }));

  const yourBtn = $('#yourBtn');
  const partnerBtn = $('#partnerBtn');
  const downloadBtn = $('#downloadBtn');
  const yourInput = $('#yourFile');
  const partnerInput = $('#partnerFile');
  const yourStatus = $('#yourStatus');
  const partnerStatus = $('#partnerStatus');

  if (!yourInput || !partnerInput || !downloadBtn) {
    console.error('[compat] Required elements missing (#yourFile, #partnerFile, #downloadBtn).');
  }

  window.__TK_FAST_UPLOADS__ = true;
  window.__TK_ALLOW_SINGLE_PDF__ = true;

  // ---------- STATE ----------
  let yourBlob = null;
  let partnerBlob = null;
  let yourJSON = null;
  let partnerJSON = null;
  const parseTimers = new Map();
  const statusEls = { self: yourStatus, partner: partnerStatus };

  // ---------- HELPERS ----------
  function setStatus(which, message, state = 'info') {
    const el = statusEls[which];
    if (!el) return;
    if (!message) {
      el.hidden = true;
      el.textContent = '';
      el.removeAttribute('data-state');
      return;
    }
    el.hidden = false;
    el.textContent = message;
    el.dataset.state = state;
  }

  function resetSelection(which, { resetStatus = true } = {}) {
    if (which === 'self') {
      yourBlob = null;
      yourJSON = null;
    } else {
      partnerBlob = null;
      partnerJSON = null;
    }
    if (resetStatus) setStatus(which, '', '');
  }

  const allowSingle = () => Boolean(window.__TK_ALLOW_SINGLE_PDF__ || document.body?.dataset?.allowSinglePdf === 'true');

  function updateDownloadState() {
    if (!downloadBtn) return;
    const ready = allowSingle() ? Boolean(yourJSON || partnerJSON) : Boolean(yourJSON && partnerJSON);
    downloadBtn.disabled = !ready;
  }

  function openPicker(input) {
    if (!input) return;
    input.value = '';
    input.click();
  }

  yourBtn && yourBtn.addEventListener('click', (event) => {
    event.preventDefault();
    openPicker(yourInput);
  });

  partnerBtn && partnerBtn.addEventListener('click', (event) => {
    event.preventDefault();
    openPicker(partnerInput);
  });

  const CONSENT_KEY = 'tk.partnerConsent.v1';

  function getConsentFlag() {
    try {
      return sessionStorage.getItem(CONSENT_KEY) === '1';
    } catch (err) {
      console.warn('[compat] unable to access consent flag', err);
      return false;
    }
  }

  function setConsentFlag() {
    try {
      sessionStorage.setItem(CONSENT_KEY, '1');
    } catch (err) {
      console.warn('[compat] unable to persist consent flag', err);
    }
  }

  function scheduleParse(which) {
    if (parseTimers.has(which)) {
      clearTimeout(parseTimers.get(which));
    }
    const timer = setTimeout(async () => {
      parseTimers.delete(which);
      try {
        await parseAndCache(which);
      } catch (error) {
        console.error('[compat] Unable to parse survey', error);
        const id = error?.which || which;
        resetSelection(id, { resetStatus: false });
        let message = 'Upload failed. Please try again.';
        if (error instanceof SyntaxError) {
          message = 'Invalid file — expected a TalkKink JSON export.';
        } else if (error?.message === 'No survey answers found') {
          message = 'Upload failed — no survey answers detected.';
        }
        setStatus(id, message, 'error');
        updateDownloadState();
        dispatch('compat:file-selected', { which: id, file: null });
      }
    }, 0);
    parseTimers.set(which, timer);
  }

  document.addEventListener(
    'change',
    (event) => {
      const target = event.target;
      if (!(target instanceof HTMLInputElement)) return;
      if (target !== yourInput && target !== partnerInput) return;

      event.stopImmediatePropagation();
      event.stopPropagation();

      const which = target === partnerInput ? 'partner' : 'self';
      const file = target.files?.[0];

      const run = async () => {
        if (!file) {
          target.value = '';
          resetSelection(which);
          updateDownloadState();
          dispatch('compat:file-selected', { which, file: null });
          return;
        }

        if (which === 'partner' && !getConsentFlag()) {
          const ok = confirm(
            'Before importing a partner’s survey, confirm you have their explicit consent to upload and compare their responses here.\n\n' +
              'Click “OK” to confirm consent and continue, or “Cancel” to stop.'
          );
          if (!ok) {
            target.value = '';
            resetSelection('partner');
            setStatus('partner', 'Upload canceled — partner consent required.', 'info');
            updateDownloadState();
            dispatch('compat:file-selected', { which: 'partner', file: null });
            return;
          }
          setConsentFlag();
        }

        if (which === 'self') {
          yourBlob = file;
          yourJSON = null;
          setStatus('self', 'Processing your survey…', 'info');
        } else {
          partnerBlob = file;
          partnerJSON = null;
          setStatus('partner', 'Processing partner survey…', 'info');
        }

        dispatch('compat:file-selected', { which, file });
        updateDownloadState();
        target.value = '';
        scheduleParse(which);
      };

      run().catch((error) => {
        console.error('[compat] File selection failed', error);
        resetSelection(which);
        updateDownloadState();
        dispatch('compat:file-selected', { which, file: null });
      });
    },
    true
  );

  function clampScore(value) {
    const num = Number(value);
    if (!Number.isFinite(num)) return 0;
    if (num <= 0) return 0;
    if (num >= 5) return 5;
    return Math.round(num);
  }

  const ROLE_ALIASES = {
    giving: 'Giving',
    giver: 'Giving',
    dom: 'Dominant',
    dominant: 'Dominant',
    top: 'Dominant',
    receiving: 'Receiving',
    receiver: 'Receiving',
    sub: 'Submissive',
    submissive: 'Submissive',
    bottom: 'Submissive',
    switch: 'Switch',
    general: 'General',
    neutral: 'General'
  };

  function normalizeRole(value) {
    if (!value) return 'General';
    const key = String(value).trim().toLowerCase();
    return ROLE_ALIASES[key] || (key ? key[0].toUpperCase() + key.slice(1) : 'General');
  }

  function tidyLabel(value, fallback = '') {
    const str = String(value || '').replace(/\s+/g, ' ').trim();
    return str || fallback;
  }

  function normalizeCompatPayload(raw, which) {
    if (!raw) return raw;

    if (Array.isArray(raw)) {
      const answers = raw.map((score, idx) => ({
        kinkId: `item-${idx + 1}`,
        side: 'general',
        score
      }));
      return normalizeCompatPayload({ answers }, which);
    }

    if (typeof raw !== 'object') return raw;

    const normalized = { ...raw };

    const responses = Array.isArray(normalized.responses)
      ? normalized.responses
          .map((entry, idx) => {
            if (!entry || typeof entry !== 'object') return null;
            const baseId = String(entry.id || `${which || 'A'}-${idx + 1}`);
            const role = normalizeRole(entry.role || entry.side || entry.channel);
            const rating = clampScore(entry.rating ?? entry.score ?? entry.value ?? 0);
            const prompt = tidyLabel(entry.prompt || entry.label || entry.title || entry.name || entry.question, baseId);
            const category = tidyLabel(
              entry.category || entry.categoryName || entry.group || entry.section,
              normalized.meta?.surveyTitle || ''
            );
            return {
              ...entry,
              id: baseId,
              role,
              rating,
              prompt,
              category
            };
          })
          .filter(Boolean)
      : [];

    normalized.responses = responses;

    const seenIds = new Set(responses.map((entry) => entry.id));
    const ensureAnswersArray = () => {
      const sources = [];
      if (Array.isArray(normalized.answers)) sources.push(normalized.answers);
      if (Array.isArray(normalized.survey?.answers)) sources.push(normalized.survey.answers);
      if (Array.isArray(normalized.survey?.responses)) sources.push(normalized.survey.responses);
      return sources.flat();
    };

    const candidates = ensureAnswersArray();

    candidates.forEach((answer, idx) => {
      if (!answer || typeof answer !== 'object') return;
      const kinkId = tidyLabel(answer.kinkId || answer.id || answer.key || answer.name || answer.questionId, `item-${idx + 1}`);
      const sideRaw = String(answer.side || answer.role || answer.channel || 'general');
      const role = normalizeRole(sideRaw);
      const score = clampScore(answer.score ?? answer.rating ?? answer.value ?? answer.answer ?? 0);
      const category = tidyLabel(
        answer.category || answer.categoryName || answer.group || answer.section || answer.categoryId,
        normalized.meta?.surveyTitle || ''
      );
      const prompt = tidyLabel(answer.title || answer.label || answer.prompt || answer.name || kinkId, kinkId);
      const idHint = tidyLabel(answer.id || '', kinkId);
      const baseId = idHint && idHint !== kinkId ? idHint : kinkId;
      const sideKey = sideRaw.trim().toLowerCase() || 'general';
      const composedId = baseId.toLowerCase().endsWith(`-${sideKey}`) ? baseId : `${baseId}-${sideKey}`;
      if (!seenIds.has(composedId)) {
        responses.push({
          id: composedId,
          kinkId,
          role,
          rating: score,
          category,
          prompt
        });
        seenIds.add(composedId);
      }
    });

    if (!normalized.answersById || typeof normalized.answersById !== 'object') {
      normalized.answersById = {};
    }

    responses.forEach((entry, idx) => {
      if (!entry || typeof entry !== 'object') return;
      const id = tidyLabel(entry.id, `${which || 'A'}-${idx + 1}`);
      const score = clampScore(entry.rating ?? entry.score ?? entry.value ?? 0);
      normalized.answersById[id] = score;
    });

    if (!normalized.answersByKey || typeof normalized.answersByKey !== 'object') {
      const map = {};
      responses.forEach((entry, idx) => {
        map[String(idx + 1)] = clampScore(entry.rating ?? entry.score ?? entry.value ?? 0);
      });
      if (Object.keys(map).length) normalized.answersByKey = map;
    }

    return normalized;
  }

  function rowsFromTalkKink(json) {
    if (!json) return [];

    const rows = [];
    const pushRow = (source, idx = 0) => {
      if (!source || typeof source !== 'object') return;
      const score = clampScore(source.score ?? source.rating ?? source.value ?? source.answer ?? 0);
      const label = tidyLabel(source.item || source.prompt || source.title || source.label || source.name || source.id, `Item ${idx + 1}`);
      const role = normalizeRole(source.role || source.side || source.channel || source.position);
      const category = tidyLabel(source.category || source.categoryName || source.group || source.section, 'Other');
      const kinkKey = tidyLabel(source.kinkId || source.id || label, label);
      rows.push({
        Category: category || 'Other',
        Item: label ? label.charAt(0).toUpperCase() + label.slice(1) : 'Item',
        Role: role,
        Score: score,
        _key: `${kinkKey}|${role}`.toLowerCase()
      });
    };

    if (Array.isArray(json.responses) && json.responses.length) {
      json.responses.forEach((resp, idx) => pushRow(resp, idx));
    } else if (Array.isArray(json.answers) && json.answers.length) {
      json.answers.forEach((answer, idx) => pushRow(answer, idx));
    } else if (json.answersById && typeof json.answersById === 'object') {
      Object.entries(json.answersById).forEach(([id, score], idx) => {
        if (!id) return;
        const parts = String(id).split('-');
        const role = normalizeRole(parts.at(-1));
        const base = parts.slice(0, -1).join('-');
        const label = tidyLabel(
          parts
            .slice(2, -1)
            .join(' ')
            .replace(/\bTv\b/gi, 'TV'),
          `Item ${idx + 1}`
        );
        const category = tidyLabel(parts.slice(0, 2).join(' '), 'Other');
        rows.push({
          Category: category || 'Other',
          Item: label ? label.charAt(0).toUpperCase() + label.slice(1) : 'Item',
          Role: role,
          Score: clampScore(score),
          _key: `${base}|${role}`.toLowerCase()
        });
      });
    }

    const deduped = Array.from(
      rows.reduce((map, row) => {
        if (!map.has(row._key)) map.set(row._key, row);
        return map;
      }, new Map()).values()
    );

    deduped.sort(
      (a, b) =>
        a.Category.localeCompare(b.Category) ||
        a.Role.localeCompare(b.Role) ||
        a.Item.localeCompare(b.Item)
    );

    return deduped;
  }

  function buildComparisonBody(rowsA, rowsB) {
    const key = (r) => (r._key || `${r.Role}|${r.Item}`).toLowerCase();
    const mapA = Object.fromEntries(rowsA.map((r) => [key(r), r]));
    const mapB = Object.fromEntries(rowsB.map((r) => [key(r), r]));
    const keys = [...new Set([...Object.keys(mapA), ...Object.keys(mapB)])].sort();
    const body = [];
    for (const k of keys) {
      const a = mapA[k];
      const b = mapB[k];
      const item = a?.Item || b?.Item || '';
      const aScore = Number.isFinite(a?.Score) ? a.Score : '';
      const bScore = Number.isFinite(b?.Score) ? b.Score : '';

      let matchText = '';
      let flagColor = null;
      if (a && b) {
        const diff = Math.abs(a.Score - b.Score);
        const pct = Math.max(0, Math.min(100, Math.round((1 - diff / 5) * 100)));
        matchText = `${pct}%`;
        if (pct > 85) flagColor = FLAG_GREEN;
        else if (pct >= 50) flagColor = FLAG_YELLOW;
        else flagColor = FLAG_RED;
      }
      body.push({
        item,
        aScore: String(aScore),
        matchText,
        flagColor,
        bScore: String(bScore)
      });
    }
    return body;
  }

  async function parseAndCache(which) {
    const isSelf = which === 'self';
    const blob = isSelf ? yourBlob : partnerBlob;
    if (!blob) return null;

    if (isSelf ? yourJSON : partnerJSON) {
      return isSelf ? yourJSON : partnerJSON;
    }

    const text = await blob.text();
    let json;
    try {
      json = JSON.parse(text);
    } catch (err) {
      err.which = which;
      throw err;
    }

    json = normalizeCompatPayload(json, which);

    if (!json || !json.answersById || !Object.keys(json.answersById).length) {
      const error = new Error('No survey answers found');
      error.which = which;
      throw error;
    }

    if (isSelf) {
      yourJSON = json;
      window.talkkinkMine = json;
      window.talkkinkSurvey = json;
    } else {
      partnerJSON = json;
      window.talkkinkPartner = json;
    }

    dispatch('compat:json-ready', {
      which,
      json,
      fileName: blob.name || ''
    });

    if (which === 'partner') {
      setStatus(which, 'Partner survey ready ✓ — consent recorded.', 'success');
    } else {
      setStatus(which, 'Your survey ready ✓', 'success');
    }

    updateDownloadState();
    return json;
  }

  class MiniPDF {
    constructor({ width = 612, height = 792 } = {}) {
      this.width = width;
      this.height = height;
      this.pages = [];
      this.fontSize = 12;
      this.currentFont = 'F1';
      this.textColor = [0, 0, 0];
      this.fillColor = [0, 0, 0];
      this.strokeColor = [0, 0, 0];
      this.lineWidth = 1;
      this.addPage();
    }

    addPage() {
      this.pages.push({ commands: [] });
      this.pageIndex = this.pages.length - 1;
    }

    _cmd(cmd) {
      this.pages[this.pageIndex].commands.push(cmd);
    }

    _formatColor(color) {
      return color
        .map((value) => {
          const num = Math.max(0, Math.min(255, Number(value) || 0)) / 255;
          return num.toFixed(3).replace(/\.0+$/, '').replace(/0+$/, '').replace(/\.$/, '') || '0';
        })
        .join(' ');
    }

    setFillColor(r = 0, g = 0, b = 0) {
      this.fillColor = [r, g, b];
    }

    setDrawColor(r = 0, g = 0, b = 0) {
      this.strokeColor = [r, g, b];
    }

    setTextColor(r = 0, g = 0, b = 0) {
      this.textColor = [r, g, b];
    }

    setLineWidth(width = 1) {
      const num = Number(width);
      this.lineWidth = Number.isFinite(num) && num > 0 ? num : 1;
    }

    setFont(_font = 'helvetica', style = 'normal') {
      const s = String(style || '').toLowerCase();
      this.currentFont = s.includes('bold') ? 'F2' : 'F1';
    }

    setFontSize(size = 12) {
      const num = Number(size);
      if (Number.isFinite(num) && num > 0) {
        this.fontSize = num;
      }
    }

    measureText(text, fontSize = this.fontSize) {
      const str = String(text ?? '');
      return str.length * (fontSize * 0.55);
    }

    _escape(text) {
      return String(text ?? '')
        .replace(/\\/g, '\\\\')
        .replace(/\(/g, '\\(')
        .replace(/\)/g, '\\)')
        .replace(/\r?\n/g, '\\n');
    }

    text(text, x, y, opts = {}) {
      const lines = String(text ?? '').split(/\r?\n/);
      const align = String(opts.align || '').toLowerCase();
      const lineHeight = opts.lineHeight || this.fontSize * 1.2;
      lines.forEach((line, idx) => {
        const width = this.measureText(line, this.fontSize);
        let drawX = x;
        if (align === 'center') drawX = x - width / 2;
        else if (align === 'right') drawX = x - width;
        const drawY = y + idx * lineHeight;
        const pdfY = this.height - drawY;
        const color = this._formatColor(this.textColor);
        const escaped = this._escape(line);
        const cmd = [
          `${color} rg`,
          `BT /${this.currentFont} ${this.fontSize.toFixed(2)} Tf`,
          `${drawX.toFixed(2)} ${pdfY.toFixed(2)} Td (${escaped}) Tj`,
          'ET'
        ].join('\n');
        this._cmd(cmd);
      });
    }

    rect(x, y, w, h, mode = 'S') {
      const pdfY = this.height - y - h;
      const fill = this._formatColor(this.fillColor);
      const stroke = this._formatColor(this.strokeColor);
      const lw = this.lineWidth.toFixed(2).replace(/\.0+$/, '').replace(/0+$/, '').replace(/\.$/, '') || '1';
      let op = 'S';
      if (mode === 'F') op = 'f';
      else if (mode === 'FD' || mode === 'DF') op = 'B';
      const cmds = [];
      if (op === 'f' || op === 'B') cmds.push(`${fill} rg`);
      if (op === 'S' || op === 'B') {
        cmds.push(`${stroke} RG`);
        cmds.push(`${lw} w`);
      }
      cmds.push(`${x.toFixed(2)} ${pdfY.toFixed(2)} ${w.toFixed(2)} ${h.toFixed(2)} re`);
      cmds.push(op);
      this._cmd(cmds.join('\n'));
    }

    line(x1, y1, x2, y2) {
      const pdfY1 = this.height - y1;
      const pdfY2 = this.height - y2;
      const stroke = this._formatColor(this.strokeColor);
      const lw = this.lineWidth.toFixed(2).replace(/\.0+$/, '').replace(/0+$/, '').replace(/\.$/, '') || '1';
      const cmd = [
        `${stroke} RG`,
        `${lw} w`,
        `${x1.toFixed(2)} ${pdfY1.toFixed(2)} m`,
        `${x2.toFixed(2)} ${pdfY2.toFixed(2)} l`,
        'S'
      ].join('\n');
      this._cmd(cmd);
    }

    circle(cx, cy, radius, mode = 'S') {
      const r = Number(radius);
      if (!Number.isFinite(r) || r <= 0) return;
      const fmt = (value) =>
        value.toFixed(2).replace(/\.0+$/, '').replace(/0+$/, '').replace(/\.$/, '') || '0';
      const toPdfY = (value) => this.height - value;
      const c = r * 0.5522847498;
      const segments = [
        [cx + c, cy - r, cx + r, cy - c, cx + r, cy],
        [cx + r, cy + c, cx + c, cy + r, cx, cy + r],
        [cx - c, cy + r, cx - r, cy + c, cx - r, cy],
        [cx - r, cy - c, cx - c, cy - r, cx, cy - r]
      ];
      const path = [`${fmt(cx)} ${fmt(toPdfY(cy - r))} m`];
      segments.forEach(([cp1x, cp1y, cp2x, cp2y, x, y]) => {
        path.push(
          `${fmt(cp1x)} ${fmt(toPdfY(cp1y))} ${fmt(cp2x)} ${fmt(toPdfY(cp2y))} ${fmt(x)} ${fmt(toPdfY(y))} c`
        );
      });
      path.push('h');
      let op = 'S';
      if (mode === 'F') op = 'f';
      else if (mode === 'FD' || mode === 'DF') op = 'B';
      const cmds = [];
      if (op === 'f' || op === 'B') cmds.push(`${this._formatColor(this.fillColor)} rg`);
      if (op === 'S' || op === 'B') {
        cmds.push(`${this._formatColor(this.strokeColor)} RG`);
        const lw = this.lineWidth.toFixed(2).replace(/\.0+$/, '').replace(/0+$/, '').replace(/\.$/, '') || '1';
        cmds.push(`${lw} w`);
      }
      cmds.push(path.join('\n'));
      cmds.push(op);
      this._cmd(cmds.join('\n'));
    }

    save(filename = 'document.pdf') {
      const objects = [];
      const pageRefs = [];

      objects.push({ name: 'font_regular', body: '<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>' });
      objects.push({ name: 'font_bold', body: '<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica-Bold >>' });

      this.pages.forEach((page, idx) => {
        const stream = page.commands.join('\n');
        const contentName = `content_${idx}`;
        const pageName = `page_${idx}`;
        objects.push({
          name: contentName,
          body: `<< /Length ${stream.length} >>\nstream\n${stream}\nendstream`
        });
        objects.push({
          name: pageName,
          body: `<< /Type /Page /Parent {{pages}} 0 R /MediaBox [0 0 ${this.width} ${this.height}] /Resources << /Font << /F1 {{font_regular}} 0 R /F2 {{font_bold}} 0 R >> >> /Contents {{${contentName}}} 0 R >>`
        });
        pageRefs.push(`{{${pageName}}} 0 R`);
      });

      objects.push({
        name: 'pages',
        body: `<< /Type /Pages /Kids [ ${pageRefs.join(' ')} ] /Count ${this.pages.length} >>`
      });

      objects.push({ name: 'catalog', body: '<< /Type /Catalog /Pages {{pages}} 0 R >>' });

      const refMap = new Map();
      objects.forEach((obj, idx) => {
        refMap.set(obj.name, idx + 1);
      });

      const resolveRefs = (body) =>
        body.replace(/\{\{([^}]+)\}\}/g, (_, name) => {
          const ref = refMap.get(name);
          if (!ref) throw new Error(`Unknown PDF reference: ${name}`);
          return String(ref);
        });

      let pdf = '%PDF-1.4\n';
      const offsets = [0];
      objects.forEach((obj, idx) => {
        offsets.push(pdf.length);
        pdf += `${idx + 1} 0 obj\n${resolveRefs(obj.body)}\nendobj\n`;
      });

      const xref = pdf.length;
      pdf += `xref\n0 ${objects.length + 1}\n`;
      pdf += '0000000000 65535 f \n';
      for (let i = 1; i <= objects.length; i += 1) {
        pdf += offsets[i].toString().padStart(10, '0') + ' 00000 n \n';
      }
      const rootRef = refMap.get('catalog');
      pdf += `trailer\n<< /Size ${objects.length + 1} /Root ${rootRef} 0 R >>\nstartxref\n${xref}\n%%EOF`;

      const blob = new Blob([pdf], { type: 'application/pdf' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = filename;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      setTimeout(() => {
        URL.revokeObjectURL(link.href);
        link.remove();
      }, 0);
    }
  }

  const FLAG_GREEN = [0, 200, 140];
  const FLAG_YELLOW = [255, 210, 70];
  const FLAG_RED = [255, 86, 86];

  function wrapText(text, maxWidth, fontSize = 10) {
    const raw = String(text ?? '').trim();
    if (!raw) return [''];
    const approxCharWidth = fontSize * 0.55;
    const maxChars = Math.max(Math.floor(maxWidth / approxCharWidth), 1);
    const words = raw.split(/\s+/);
    const lines = [];
    let current = '';
    const flush = () => {
      if (current) {
        lines.push(current);
        current = '';
      }
    };
    words.forEach((word) => {
      if (!word) return;
      if (!current.length) {
        if (word.length <= maxChars) {
          current = word;
        } else {
          for (let i = 0; i < word.length; i += maxChars) {
            const chunk = word.slice(i, i + maxChars);
            if (chunk.length === maxChars) lines.push(chunk);
            else current = chunk;
          }
        }
        return;
      }
      if (current.length + 1 + word.length <= maxChars) {
        current += ` ${word}`;
        return;
      }
      flush();
      if (word.length <= maxChars) {
        current = word;
      } else {
        for (let i = 0; i < word.length; i += maxChars) {
          const chunk = word.slice(i, i + maxChars);
          if (chunk.length === maxChars) lines.push(chunk);
          else current = chunk;
        }
      }
    });
    flush();
    return lines.length ? lines : [''];
  }

  function drawTextBlock(doc, lines, x, y, width, height, { align = 'left', fontSize = 10, fontStyle = 'normal' } = {}) {
    const cleanLines = lines.length ? lines : [''];
    const lineHeight = fontSize * 1.2;
    const totalHeight = cleanLines.length * lineHeight;
    const offsetY = y + Math.max((height - totalHeight) / 2, 0) + lineHeight - 2;
    doc.setFont('helvetica', fontStyle);
    doc.setFontSize(fontSize);
    cleanLines.forEach((line, idx) => {
      let drawX = x;
      if (align === 'center') drawX = x + width / 2;
      else if (align === 'right') drawX = x + width;
      doc.text(line, drawX, offsetY + idx * lineHeight, { align });
    });
  }

  async function generateDarkPDF(yourJSON, partnerJSON) {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit: 'pt', format: 'letter' });

    const W = doc.internal.pageSize.getWidth();
    const H = doc.internal.pageSize.getHeight();

    const CONTENT_W = Math.min(680, W - 96);
    const ML = (W - CONTENT_W) / 2;
    const MR = ML;

    function paint() {
      doc.setFillColor(10, 10, 12);
      doc.rect(0, 0, W, H, 'F');

      doc.setTextColor(255, 255, 255);
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(20);
      doc.text('TalkKink Compatibility', W / 2, 50, { align: 'center' });

      doc.setFont('helvetica', 'normal');
      doc.setFontSize(9);
      doc.setTextColor(170, 200, 255);
      doc.text('Generated: ' + new Date().toLocaleString(), W / 2, 64, { align: 'center' });

      doc.setDrawColor(0, 255, 255);
      doc.setLineWidth(1);
      doc.line(ML, 72, W - MR, 72);
    }
    paint();

    const CYAN = [0, 255, 255];
    const BODY1 = [8, 8, 10];
    const BODY2 = [13, 13, 17];
    const GRID = [30, 30, 38];
    const WHITE = [255, 255, 255];
    const GREEN = [0, 200, 140];
    const YELLOW = [255, 210, 70];
    const RED = [255, 86, 86];

    const base = {
      theme: 'grid',
      tableWidth: CONTENT_W,
      margin: { left: ML, right: MR },
      styles: {
        font: 'helvetica',
        fontSize: 10,
        cellPadding: 4,
        textColor: WHITE,
        fillColor: BODY1,
        lineColor: GRID,
        lineWidth: 0.25
      },
      alternateRowStyles: { fillColor: BODY2 },
      headStyles: {
        fillColor: [0, 0, 0],
        textColor: CYAN,
        lineColor: GRID,
        lineWidth: 0.25,
        fontStyle: 'bold'
      },
      didAddPage: () => paint()
    };

    const rowsFrom = (json) => {
      if (!json) return [];
      const map = json.answersById || {};
      const out = [];
      for (const [id, score] of Object.entries(map)) {
        const parts = id.split('-');
        const role = parts.at(-1);
        const category = (parts[0] + ' ' + parts[1]).replace(/\b\w/g, (m) => m.toUpperCase());
        const item = parts
          .slice(2, -1)
          .join(' ')
          .replace(/\bTv\b/gi, 'TV')
          .replace(/\s+/g, ' ')
          .trim();
        out.push({
          Category: category,
          Item: item.charAt(0).toUpperCase() + item.slice(1),
          Role: role.charAt(0).toUpperCase() + role.slice(1),
          Score: Number(score)
        });
      }
      out.sort(
        (a, b) =>
          a.Category.localeCompare(b.Category) ||
          a.Role.localeCompare(b.Role) ||
          a.Item.localeCompare(b.Item)
      );
      return out;
    };

    const A = rowsFrom(window.yourJSON || yourJSON);
    const B = rowsFrom(window.partnerJSON || partnerJSON);
    const hasA = A.length > 0;
    const hasB = B.length > 0;

    let y = 96;
    const cat = (t) => {
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(16);
      doc.setTextColor(WHITE[0], WHITE[1], WHITE[2]);
      doc.text(t, W / 2, y, { align: 'center' });
      y += 12;
    };

    function buildAB(Arows, Brows) {
      const key = (r) => `${r.Role}|${r.Item}`.toLowerCase();
      const aMap = Object.fromEntries(Arows.map((r) => [key(r), r]));
      const bMap = Object.fromEntries(Brows.map((r) => [key(r), r]));
      const keys = [...new Set([...Object.keys(aMap), ...Object.keys(bMap)])].sort();
      return keys.map((k) => {
        const a = aMap[k];
        const b = bMap[k];
        const item = a?.Item || b?.Item || '';
        const aS = Number.isFinite(a?.Score) ? a.Score : null;
        const bS = Number.isFinite(b?.Score) ? b.Score : null;

        let pct = null;
        let color = null;
        if (aS != null && bS != null) {
          pct = Math.round((1 - Math.abs(aS - bS) / 5) * 100);
          if (pct > 85) color = GREEN;
          else if (pct >= 50) color = YELLOW;
          else color = RED;
        }
        return {
          item,
          a: aS == null ? '' : String(aS),
          match: pct == null ? '' : pct + '%',
          flag: '',
          _flagColor: color,
          b: bS == null ? '' : String(bS)
        };
      });
    }

    function flagShapeHook(flagKey){
      return {
        didDrawCell(data){
          if (data.section !== 'body' || data.column.dataKey !== flagKey) return;

          const color = data.row?.raw?._flagColor;
          if (!color) return;

          const { x, y, height } = data.cell;
          const poleX = x + 10;
          const poleTop = y + 6;
          const poleBottom = y + height - 6;

          // Pennant geometry
          const px = poleX + 1;     // pennant start (slightly right of pole)
          const h  = 10;            // pennant height
          const w  = 14;            // pennant width
          const py = (poleTop + poleBottom)/2 - h/2;

          // Draw pole (subtle gray)
          const prevStroke = doc.getDrawColor();
          doc.setDrawColor(180,180,190);
          doc.setLineWidth(1);
          doc.line(poleX, poleTop, poleX, poleBottom);

          // Try to draw a FILLED triangular pennant using jsPDF.lines (stable across builds)
          const prevFill = doc.getFillColor();
          try {
            doc.setFillColor(color[0], color[1], color[2]);
            doc.setDrawColor(color[0], color[1], color[2]);
            // Path: (px,py) -> (px+w, py+h/2) -> (px, py+h) -> close
            // Signature: lines(segments, startX, startY, scale=1, style='F', closed=true)
            doc.lines(
              [
                [ w,   h/2],   // to (px+w, py+h/2)
                [-w,   h/2]    // to (px,   py+h)
              ],
              px, py,
              1,              // scale (NUMBER, not array) — prevents crash
              'F',            // fill
              true            // closed path
            );
          } catch (e) {
            // Fallback: draw a colored dot so PDF still generates
            const cx = px + 6, cy = py + h/2, r = 4;
            doc.setFillColor(color[0], color[1], color[2]);
            doc.circle(cx, cy, r, 'F');
          } finally {
            doc.setFillColor(prevFill);
            doc.setDrawColor(prevStroke);
          }
        }
      };
    }

    if (hasA && hasB) {
      const cats = [...new Set([...A, ...B].map((r) => r.Category))];
      for (const c of cats) {
        cat(c);
        const body = buildAB(
          A.filter((r) => r.Category === c),
          B.filter((r) => r.Category === c)
        );

        const itemWidth = CONTENT_W - (70 + 60 + 50 + 70);

        doc.autoTable({
          ...base,
          ...flagShapeHook('flag'),
          startY: y + 8,
          columns: [
            { header: 'Item', dataKey: 'item' },
            { header: 'Partner A', dataKey: 'a' },
            { header: 'Match', dataKey: 'match' },
            { header: 'Flag', dataKey: 'flag' },
            { header: 'Partner B', dataKey: 'b' }
          ],
          body,
          columnStyles: {
            item: { cellWidth: itemWidth },
            a: { cellWidth: 70, halign: 'center' },
            match: { cellWidth: 60, halign: 'center' },
            flag: { cellWidth: 50, halign: 'left' },
            b: { cellWidth: 70, halign: 'center' }
          }
        });

        y = doc.lastAutoTable.finalY + 18;
        if (y > H - 72) {
          doc.addPage();
          paint();
          y = 96;
        }
      }
    } else {
      const rows = hasA ? A : B;
      const who = hasA ? 'Partner A' : 'Partner';
      const cats = [...new Set(rows.map((r) => r.Category))];
      for (const c of cats) {
        cat(`${c} — ${who}`);
        doc.autoTable({
          ...base,
          startY: y + 8,
          head: [['Item', 'Score']],
          body: rows
            .filter((r) => r.Category === c)
            .map((r) => [r.Item, String(r.Score)]),
          columnStyles: {
            0: { cellWidth: CONTENT_W - 70 },
            1: { cellWidth: 70, halign: 'center' }
          }
        });
        y = doc.lastAutoTable.finalY + 18;
        if (y > H - 72) {
          doc.addPage();
          paint();
          y = 96;
        }
      }
    }

    const name = hasA && hasB ? 'compatibility-pretty-dark.pdf' : 'partner-survey-pretty-dark.pdf';
    doc.save(name);
  }


  window.generateDarkPDF = generateDarkPDF;

  downloadBtn &&
    downloadBtn.addEventListener(
      'click',
      async (event) => {
        event.preventDefault();
        event.stopImmediatePropagation();
        event.stopPropagation();
        try {
          await Promise.all([parseAndCache('self'), parseAndCache('partner')]);

          if (!yourJSON && !partnerJSON) {
            alert('Load at least one survey first (yours or partner).');
            console.warn('[compat] No survey loaded; aborting PDF.');
            return;
          }

          await generateDarkPDF(yourJSON, partnerJSON);
        } catch (error) {
          console.error('[compat] PDF generation failed:', error);
          alert('Sorry—could not generate the PDF.');
        }
      },
      true
    );

  updateDownloadState();

  window.tkResetPartnerConsent = () => {
    try {
      sessionStorage.removeItem(CONSENT_KEY);
    } catch (err) {
      console.warn('[compat] unable to reset consent flag', err);
    }
    console.info('[compat] Partner consent reset for this tab.');
  };
})();
  </script>


    <script defer src="/assets/js/comparison.js"></script>
  <script defer>
    /**
     * Safely clear margin on the dock *only if it exists on this page*.
     * This replaces any previous null-unsafe code around lines ~188–192.
     */
    (function () {
      const SELECTOR = '#compat-dock, .compat-dock, [data-compat-dock]';

      function clearDockMarginSafe() {
        const el = document.querySelector(SELECTOR);
        if (!el) return;                  // No-op if the dock isn't present
        el.style.removeProperty('margin');
        el.style.removeProperty('margin-bottom');
      }

      // Run after DOM is parsed; also handle late mounts briefly
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', clearDockMarginSafe, { once: true });
      } else {
        queueMicrotask(clearDockMarginSafe);
      }
      const mo = new MutationObserver(() => {
        const el = document.querySelector(SELECTOR);
        if (el) { clearDockMarginSafe(); mo.disconnect(); }
      });
      mo.observe(document.documentElement, { childList: true, subtree: true });
      setTimeout(() => mo.disconnect(), 3000);
    })();
  </script>
</body>

</html>
