<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>See Our Compatibility</title>
  <!-- Import theme and global layout styles -->
  <link rel="stylesheet" href="/css/theme.css" />
  <link rel="stylesheet" href="/css/global.css" />
  <link rel="stylesheet" href="/css/compat-table.css" />
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet" />
  <style>
  #pdf-container {
    width: 100%;
    max-width: 100%;
  }
  table {
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    text-align: center;
    vertical-align: middle;
    padding: 6px;
  }
  th:first-child, td:first-child {
    text-align: left;
    padding-left: 10px;
  }
  </style>
  <style>
    .upload-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      margin-top: 3rem;
    }

      .upload-button {
        position: relative;
        display: inline-block;
      }

    .upload-button input[type="file"] {
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .wide-button {
      min-width: 260px;
      max-width: 300px;
      width: 100%;
    }
  </style>
  <style>
    /* Keep rows from splitting in both web and print */
    .compat-section tr { break-inside: avoid; page-break-inside: avoid; }

    /* Make sure tables are fixed-width to avoid right-side cutoff */
    .compat-section table {
      width: 100% !important;
      table-layout: fixed !important;
      border-collapse: collapse !important;
    }

    /* Optional: make header clean (no decorative lines/boxes) */
    .section-title, .category-header, .compat-category {
      border: none !important;
      box-shadow: none !important;
      background: transparent !important;
    }
  </style>
</head>
<body class="theme-dark">
  <div class="main-container themed">
    <h1 class="page-title">See Our Compatibility</h1>
    <div class="upload-container">
      <button class="themed-button wide-button" onclick="window.history.back()">‚Üê Back</button>

      <label id="uploadYourSurvey" class="upload-button themed-button wide-button">
        <input id="uploadSurveyA" type="file" accept="application/json" />
        Upload Your Survey
      </label>

      <label id="uploadPartnerSurvey" class="upload-button themed-button wide-button">
        <input id="uploadSurveyB" type="file" accept="application/json" />
        Upload Partner‚Äôs Survey
      </label>

      <button class="themed-button wide-button" id="downloadBtn">Download PDF</button>
    </div>

    <div id="comparisonResults">
      <div id="loading-spinner" class="loading-overlay"><div class="spinner"></div></div>
      <div id="pdf-container" class="compat-root" data-compat-root></div>
      <div class="print-footer"></div>
    </div>
  </div>

  <script src="js/template-survey.js"></script>
  <script type="module" src="js/compatibilityPage.js"></script>
  <script type="module">
    import { initTheme, applyThemeColors } from './js/theme.js';
    initTheme();
    window.applyThemeColors = applyThemeColors;
  </script>
  <!-- Safe session check script -->
  <script>
  /**
   * Safe session check:
   * - Silently ignores 404 / network errors (useful on static hosting & local previews)
   * - Only redirects on 401 Unauthorized
   * - Won‚Äôt throw or spam the console
   *
   * How to use:
   * 1) Paste this block.
   * 2) Delete the old:
   *      fetch("/check-session", { credentials: "include" })
   *        .then(res => { if (res.status === 401) window.location.href = "/token.html"; });
   * 3) Call safeCheckSession(); (or skip entirely if you don‚Äôt need auth)
   */

  (function(){
    function safeCheckSession(opts){
      const cfg = Object.assign({
        url: '/check-session',          // change if your API path differs
        redirectTo: '/token.html',      // where to send on 401
        credentials: 'include',         // send cookies if present
        log: false                      // set true to log non-401 statuses
      }, (opts || {}));

      try {
        fetch(cfg.url, { credentials: cfg.credentials })
          .then(res => {
            if (res.status === 401) {
              // Only redirect on explicit 401
              window.location.href = cfg.redirectTo;
              return;
            }
            // Silence 404s and other statuses unless logging is enabled
            if (cfg.log && res.status !== 204 && res.status !== 200) {
              console.info('[session] status:', res.status);
            }
          })
          .catch(() => {
            // Network error / CORS / offline ‚Äî ignore quietly
          });
      } catch (_) {
        // Older browsers / unexpected errors ‚Äî ignore
      }
    }

    // OPTIONAL: run automatically on load (safe even if endpoint doesn‚Äôt exist)
    document.addEventListener('DOMContentLoaded', function(){
      safeCheckSession();
    });

    // Expose if you want to call manually later
    window.safeCheckSession = safeCheckSession;
  })();
  </script>

<script>
/* ===================== COMPAT: Robust A/B Fill (markup-agnostic) ===================== *
 * Supports three table shapes:
 *  1) Cells with data-partner-a / data-partner-b attributes             (preferred)
 *  2) Cells with .pa / .pb classes                                      (legacy)
 *  3) No markers, but THEAD headers literally "Partner A" / "Partner B" (auto-tag)
 *
 * Also:
 *  - Annotates rows with data-full (full visible label) and data-id (normalized key)
 *  - Matches JSON -> rows by data-id -> data-full -> visible text -> fuzzy overlap
 *  - Bootstraps a simple table if your container has 0 rows
 *  - Recomputes a Match % (assumes 1‚Äì5 scale)
 *
 * Requirements:
 *  - Your wrapper has data-compat-root OR you use #pdf-container
 *  - First column is the label cell (visible text)
 *  - Keep THEAD headers: Category | Partner A | Match | Partner B (lets us auto-tag A/B)
 */

(function(){
  /* ---------- normalizers ---------- */
  function norm(s){
    return String(s||'')
      .replace(/[\u2018\u2019\u2032]/g,"'")
      .replace(/[\u201C\u201D\u2033]/g,'"')
      .replace(/[\u2013\u2014]/g,'-')
      .replace(/\u2026/g,'')
      .replace(/[^\w\s'-]/g,' ')
      .replace(/\s+/g,' ')
      .trim().toLowerCase();
  }
  const toks = s => norm(s).split(' ').filter(Boolean);

  /* ---------- JSON ‚Üí lookup ---------- */
  function toLookup(json){
    const map = new Map();
    if (!json || typeof json !== 'object') return map;

    // flat {key:value}
    if (!Array.isArray(json) && !json.items && !json.survey){
      for (const [k,v] of Object.entries(json)){
        const n = Number(v); if (Number.isFinite(n)) map.set(norm(k), n);
      }
      return map;
    }

    // items array
    if (Array.isArray(json.items)){
      for (const it of json.items){
        const k = norm(it?.name ?? it?.label ?? it?.key ?? it?.id ?? '');
        const n = Number(it?.rating ?? it?.score ?? it?.value);
        if (k && Number.isFinite(n)) map.set(k, n);
      }
      return map;
    }

    // nested survey export
    if (json.survey && typeof json.survey === 'object'){
      Object.values(json.survey).forEach(section=>{
        ['Giving','Receiving','General'].forEach(bucket=>{
          (Array.isArray(section?.[bucket])?section[bucket]:[]).forEach(it=>{
            const k = norm(it?.name ?? it?.label ?? it?.id ?? '');
            const n = Number(it?.rating ?? it?.score ?? it?.value);
            if (k && Number.isFinite(n)) map.set(k, Math.max(map.get(k)??-Infinity, n));
          });
        });
      });
    }
    return map;
  }

  /* ---------- DOM helpers ---------- */
  function getRoot(){
    return document.querySelector('[data-compat-root]') || document.querySelector('#pdf-container') || document.body;
  }

  // If no rows exist, create a simple "All" table from the union of JSON keys
  function bootstrapIfEmpty(root){
    const hasRows = root.querySelectorAll('tbody tr').length > 0;
    if (hasRows) return false;

    const aMap = toLookup(window.partnerASurvey || window.surveyA || {});
    const bMap = toLookup(window.partnerBSurvey || window.surveyB || {});
    const keys = new Set([...aMap.keys(), ...bMap.keys()]);
    if (!keys.size) return false;

    const section = document.createElement('section'); section.className = 'compat-section';
    const h2 = document.createElement('h2'); h2.className = 'section-title'; h2.textContent = 'All'; section.appendChild(h2);

    const table = document.createElement('table'); table.className = 'compat-table';
    const thead = document.createElement('thead'); const thr = document.createElement('tr');
    ['Category','Partner A','Match','Partner B'].forEach(t=>{ const th=document.createElement('th'); th.textContent=t; thr.appendChild(th); });
    thead.appendChild(thr);
    const tbody = document.createElement('tbody');

    keys.forEach(k=>{
      const tr = document.createElement('tr');
      tr.setAttribute('data-id', k);
      tr.setAttribute('data-full', k);
      const td0 = document.createElement('td'); td0.textContent = k;
      const tda = document.createElement('td'); tda.className = 'pa'; tda.setAttribute('data-partner-a',''); tda.textContent = aMap.has(k) ? aMap.get(k) : '-';
      const tdm = document.createElement('td'); tdm.className = 'match';
      const tdb = document.createElement('td'); tdb.className = 'pb'; tdb.setAttribute('data-partner-b',''); tdb.textContent = bMap.has(k) ? bMap.get(k) : '-';
      tr.append(td0, tda, tdm, tdb); tbody.appendChild(tr);
    });

    table.append(thead, tbody); section.appendChild(table);
    root.innerHTML = ''; root.appendChild(section);
    console.log(`[compat] bootstrapped ${keys.size} rows from JSON union.`);
    return true;
  }

  // Ensure each row has data-full and data-id
  function annotateRows(root){
    root.querySelectorAll('table tbody tr').forEach(tr=>{
      const first = tr.querySelector('td:first-child, th:first-child');
      const vis = first ? (first.textContent || '') : '';
      if (!tr.hasAttribute('data-full') && vis) tr.setAttribute('data-full', vis);
      if (!tr.hasAttribute('data-id')){
        const canon = norm(tr.getAttribute('data-full') || vis);
        if (canon) tr.setAttribute('data-id', canon);
      }
    });
  }

  // If there are no .pa/.pb markers, use THEAD headers to tag the columns
  function ensurePartnerMarkers(root){
    root.querySelectorAll('table').forEach(table=>{
      const thead = table.querySelector('thead tr'); if (!thead) return;
      const ths = Array.from(thead.children).map(th => norm(th.textContent));
      const idxA = ths.indexOf('partner a');
      const idxB = ths.indexOf('partner b');

      const tbody = table.querySelector('tbody'); if (!tbody) return;
      if (idxA >= 0 && !tbody.querySelector('td.pa, td[data-partner-a]')){
        tbody.querySelectorAll('tr').forEach(tr=>{ const td = tr.children[idxA]; if (td){ td.classList.add('pa'); td.setAttribute('data-partner-a',''); }});
      }
      if (idxB >= 0 && !tbody.querySelector('td.pb, td[data-partner-b]')){
        tbody.querySelectorAll('tr').forEach(tr=>{ const td = tr.children[idxB]; if (td){ td.classList.add('pb'); td.setAttribute('data-partner-b',''); }});
      }
    });
  }

  /* ---------- matching ---------- */
  function rowKeyBundle(tr){
    const id   = tr.getAttribute('data-id')   || '';
    const full = tr.getAttribute('data-full') || '';
    const vis  = tr.querySelector('td:first-child, th:first-child')?.textContent || '';
    return { kId: norm(id), kFull: norm(full), kVis: norm(vis) };
  }

  function pickValue(keys, lookup){
    // 1) exact id
    if (keys.kId && lookup.has(keys.kId)) return lookup.get(keys.kId);
    // 2) exact full
    if (keys.kFull && lookup.has(keys.kFull)) return lookup.get(keys.kFull);
    // 3) exact visible
    if (keys.kVis && lookup.has(keys.kVis)) return lookup.get(keys.kVis);
    // 4) contains (either direction)
    for (const [lk, val] of lookup.entries()){
      if (lk.includes(keys.kFull) || keys.kFull.includes(lk)) return val;
      if (lk.includes(keys.kVis)  || keys.kVis.includes(lk))  return val;
    }
    // 5) token overlap ‚â•60% or ‚â•4 shared tokens
    const tryKeys = [keys.kFull, keys.kVis].filter(Boolean);
    for (const rk of tryKeys){
      const rt = toks(rk); if (!rt.length) continue;
      for (const [lk, val] of lookup.entries()){
        const lt = toks(lk); if (!lt.length) continue;
        const set = new Set(lt);
        const shared = rt.filter(t=>set.has(t)).length;
        const overlap = Math.min(shared/rt.length, shared/lt.length);
        if (shared >= 4 || overlap >= 0.6) return val;
      }
    }
    return undefined;
  }

  /* ---------- fill + match ---------- */
  function fillColumn(root, selectorList, lookup){
    if (!lookup || !lookup.size) return 0;
    const rows = root.querySelectorAll('table tbody tr');
    let wrote = 0;
    rows.forEach(tr=>{
      const td = tr.querySelector(selectorList);
      if (!td) return;
      const current = (td.textContent || '').trim();
      if (current && !/^[-‚Äì‚Äî]$/.test(current)) return; // don't overwrite real values
      const val = pickValue(rowKeyBundle(tr), lookup);
      if (val == null) return;
      td.textContent = String(val);
      wrote++;
    });
    return wrote;
  }

  function computeMatch(a, b){
    const na = Number(a), nb = Number(b);
    if (!Number.isFinite(na) || !Number.isFinite(nb)) return '';
    const diff = Math.abs(na - nb);                      // 0..4
    return Math.round((1 - diff/4) * 100) + '%';         // 100..0
  }

  function recomputeMatches(root){
    root.querySelectorAll('table tbody tr').forEach(tr=>{
      const a = tr.querySelector('td[data-partner-a], td.pa')?.textContent;
      const b = tr.querySelector('td[data-partner-b], td.pb')?.textContent;
      const m = tr.querySelector('td[data-match]') || tr.children[2]; // assume 3rd col if standard
      if (m && m.tagName === 'TD') m.textContent = computeMatch(a, b);
    });
  }

  /* ---------- main entry ---------- */
  function runFill(){
    const root = getRoot();
    if (!root) return;

    // If empty, create a minimal table so we can fill something
    bootstrapIfEmpty(root);

    // Make keys discoverable & cells targetable
    annotateRows(root);
    ensurePartnerMarkers(root);

    const aMap = toLookup(window.partnerASurvey || window.surveyA || {});
    const bMap = toLookup(window.partnerBSurvey || window.surveyB || {});

    const wroteA = fillColumn(root, 'td[data-partner-a], td.pa', aMap);
    const wroteB = fillColumn(root, 'td[data-partner-b], td.pb', bMap);

    if (wroteA || wroteB) recomputeMatches(root);
    if (typeof window.populateFlags === 'function') window.populateFlags();

    console.log(`[compat] filled Partner A cells: ${wroteA}; Partner B cells: ${wroteB}`);
  }

  // Wire uploads (Partner A / Partner B)
  document.addEventListener('change', async e=>{
    if (!e.target) return;
    if (e.target.matches('#uploadSurveyA,[data-upload-a],#uploadSurveyB,[data-upload-b]')){
      // If your upload handlers already parse JSON and set window.partnerASurvey/window.partnerBSurvey,
      // runFill will use them. If not, attempt quick inline parsing:
      const f = e.target.files && e.target.files[0];
      if (f && !window.partnerASurvey && !window.partnerBSurvey){
        try {
          const json = JSON.parse(await f.text());
          if (e.target.matches('#uploadSurveyA,[data-upload-a]')) window.partnerASurvey = json;
          else window.partnerBSurvey = json;
        } catch {}
      }
      setTimeout(runFill, 150);
    }
  });

  // Expose manual trigger + run once
  window.__compatRunFill = runFill;
  document.addEventListener('DOMContentLoaded', () => setTimeout(runFill, 250));
})();
</script>

<!-- OPTIONAL: Minimal wiring if you don‚Äôt already parse and call handlers -->
<script>
  // If you already parse uploads elsewhere, you can delete this block.
  const upA = document.querySelector('#uploadSurveyA,[data-upload-a]');
  if (upA) upA.addEventListener('change', async e=>{
    const f=e.target.files?.[0]; if (!f) return;
    try { window.partnerASurvey = JSON.parse(await f.text()); } catch {}
    if (window.__compatRunFill) window.__compatRunFill();
  });
  const upB = document.querySelector('#uploadSurveyB,[data-upload-b]');
  if (upB) upB.addEventListener('change', async e=>{
    const f=e.target.files?.[0]; if (!f) return;
    try { window.partnerBSurvey = JSON.parse(await f.text()); } catch {}
    if (window.__compatRunFill) window.__compatRunFill();
  });
</script>
<!-- =========================
Talk Kink ‚Äî PDF Export (ONE DROP-IN)
Purpose: Create a black-background PDF from your on-page comparison table with ONE centered ‚ÄúTalk Kink‚Äù title.
What it expects on the page: a rendered comparison table with headers that read (case-insensitive):
  Category | Partner A | Match | Flag | Partner B
Table can live inside #compat-container or #pdf-container (or be the first visible <table>).

HOW TO INSTALL (copy this whole block as-is):
1) Paste this entire snippet near the END of compatibility.html (just before </body>).
2) Make sure you have a ‚ÄúDownload PDF‚Äù button somewhere (id="downloadBtn" or data-download-pdf). If not, add:
   <button id="downloadBtn" type="button">Download PDF</button>
3) Hard refresh the page (Ctrl/Cmd + Shift + R). Click ‚ÄúDownload PDF‚Äù.

This exporter:
- Finds your table automatically (#compat-container ‚Üí #pdf-container ‚Üí first visible <table>)
- Maps columns by header text (so DOM order doesn‚Äôt break the export)
- Centers a single ‚ÄúTalk Kink‚Äù title, not touching the top
- Wraps long Category text; sizes columns dynamically for Letter landscape
- Keeps the page black with white text (no web layout changes)
========================= -->

<!-- REQUIRED LIBS (load once) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.4/jspdf.plugin.autotable.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script>
(function(){
  const PDF_TITLE   = 'Talk Kink';
  const PDF_FONT    = 'helvetica';   // If you embed a custom font (e.g., Fredoka One), change this name and register it below
  const TITLE_Y     = 84;            // Title baseline from top (increase to move down)
  const TITLE_SIZE  = 48;            // Title font size
  const TABLE_GAP   = 34;            // Distance from title baseline to top of table
  const MARGIN_LR   = 36;            // Left/right margins (‚âà0.5")

  const norm = s => String(s||'').replace(/\s+/g,' ').trim().toLowerCase();

  function findComparisonTable(){
    const selectors = [
      '#compat-container table:where(:not([hidden]))',
      '#pdf-container table:where(:not([hidden]))',
      'table:where(:not([hidden]))'
    ];
    for (const q of selectors){
      const el = document.querySelector(q);
      if (el) return el;
    }
    return null;
  }

  // Extract rows as arrays: [Category, Partner A, Match, Flag, Partner B]
  function extractRows(table){
    const WANT = ['category','partner a','match','flag','partner b'];

    // Build header index map by text
    const headerRow = table.querySelector('thead tr')
      || Array.from(table.querySelectorAll('tr')).find(r => r.querySelector('th'));
    const map = {};
    if (headerRow){
      Array.from(headerRow.querySelectorAll('th')).forEach((th, i) => {
        const label = norm(th.innerText || th.textContent);
        if (WANT.includes(label)) map[label] = i;
      });
    }

    // Prefer <tbody> rows; else any <tr> with <td>
    const bodyRows = Array.from(table.querySelectorAll('tbody tr')).filter(r => r.querySelectorAll('td').length);
    const rows = bodyRows.length ? bodyRows
      : Array.from(table.querySelectorAll('tr')).filter(r => r.querySelectorAll('td').length);

    const idx = {
      category:  ('category' in map)   ? map['category']   : 0,
      a:         ('partner a' in map)  ? map['partner a']  : 1,
      match:     ('match' in map)      ? map['match']      : 2,
      flag:      ('flag' in map)       ? map['flag']       : 3,
      b:         ('partner b' in map)  ? map['partner b']  : 4
    };

    return rows.map(tr => {
      const cells = Array.from(tr.querySelectorAll('td'));
      const read  = i => (cells[i]?.innerText || cells[i]?.textContent || '').trim();
      const flagCell  = cells[idx.flag];
      const flagAttr  = flagCell?.getAttribute?.('data-flag') || ''; // prefer explicit data-flag
      const flagValue = flagAttr || read(idx.flag);
      return [ read(idx.category), read(idx.a), read(idx.match), flagValue, read(idx.b) ];
    });
  }

  // Main exporter
  function downloadCompatibilityPDF(){
    console.time('[pdf] build');
    console.info('[pdf] starting‚Ä¶');

    const jsPDFctor = window.jspdf?.jsPDF;
    if (!jsPDFctor || !window.jspdf?.autoTable){
      alert('Missing jsPDF and/or AutoTable. Keep the two CDN <script> tags above this block.');
      console.error('[pdf] libs missing');
      return;
    }

    const table = findComparisonTable();
    if (!table){
      alert('Could not find the comparison table on this page.');
      console.error('[pdf] table not found');
      return;
    }

    const body = extractRows(table);
    const HEAD = ['Category','Partner A','Match','Flag','Partner B'];

    const doc = new jsPDFctor({ orientation: 'landscape', unit: 'pt', format: 'letter' });
    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();

    // Black background
    doc.setFillColor(0,0,0);
    doc.rect(0,0,pageW,pageH,'F');

    // Title (single, centered, not touching top)
    doc.setFont(PDF_FONT,'bold');
    doc.setFontSize(TITLE_SIZE);
    doc.setTextColor(255,255,255);
    doc.text(PDF_TITLE, pageW/2, TITLE_Y, { align: 'center' });

    // Dynamic column widths
    const availW = pageW - (MARGIN_LR*2);
    const catW   = Math.max(420, availW * 0.62); // generous space for Category
    const restW  = Math.max(200, availW - catW); // remaining width
    const eachW  = Math.max(70,  restW / 4);     // Partner A / Match / Flag / Partner B

    const startY = TITLE_Y + TABLE_GAP;

    // Table render
    doc.autoTable({
      head: [HEAD],
      body,
      startY,
      theme: 'plain',
      margin: { left: MARGIN_LR, right: MARGIN_LR },
      styles: {
        font: PDF_FONT,
        fontSize: 12,
        textColor: [255,255,255],
        fillColor: [0,0,0],
        lineWidth: 0,
        cellPadding: { top: 5, right: 6, bottom: 5, left: 6 },
        overflow: 'linebreak'  // wrap long text in Category
      },
      headStyles: {
        fontStyle: 'bold',
        fontSize: 14,
        textColor: [255,255,255],
        halign: 'left',
        fillColor: [0,0,0]
      },
      columnStyles: {
        0: { cellWidth: catW,  halign: 'left'   }, // Category
        1: { cellWidth: eachW, halign: 'center' }, // Partner A
        2: { cellWidth: eachW, halign: 'center' }, // Match
        3: { cellWidth: eachW, halign: 'center' }, // Flag (‚≠ê/üö© or text)
        4: { cellWidth: eachW, halign: 'center' }  // Partner B
      }
    });

    // Save (you can customize the name)
    // const filename = 'kink-compatibility_' + Date.now() + '.pdf';
    // doc.save(filename);
    doc.save('kink-compatibility.pdf');

    console.info('[pdf] done.');
    console.timeEnd('[pdf] build');
  }

  // Expose + wire the button (id="downloadBtn" or [data-download-pdf])
  window.downloadCompatibilityPDF = downloadCompatibilityPDF;
  document.addEventListener('DOMContentLoaded', () => {
    const btn = document.getElementById('downloadBtn') || document.querySelector('[data-download-pdf]');
    if (btn) btn.addEventListener('click', downloadCompatibilityPDF);
  });

  // ---------- OPTIONAL: embed custom font (Fredoka One) ----------
  // 1) Convert TTF ‚Üí Base64 VFS (e.g., using jsPDF font converter) and paste below.
  // 2) Then set PDF_FONT = 'FredokaOne' at the top.
  //
  // const vfsFredoka = 'BASE64_TTF_STRING_GOES_HERE';
  // const docTmp = new (window.jspdf.jsPDF)();
  // docTmp.addFileToVFS('FredokaOne-Regular.ttf', vfsFredoka);
  // docTmp.addFont('FredokaOne-Regular.ttf', 'FredokaOne', 'normal');
  // (You only need to run the addFileToVFS/addFont once per page load.)
})();
</script>

</body>
</html>
