<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>See Our Compatibility</title>
  <!-- Import theme and global layout styles -->
  <link rel="stylesheet" href="/css/theme.css" />
  <link rel="stylesheet" href="/css/global.css" />
  <link rel="stylesheet" href="/css/compat-table.css" />
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
  #compat-container {
    width: 100%;
    max-width: 100%;
  }
  table {
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    text-align: center;
    vertical-align: middle;
    padding: 6px;
  }
  th:first-child, td:first-child {
    text-align: left;
    padding-left: 10px;
  }
  </style>
  <style>
    .upload-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      margin-top: 3rem;
    }

      .upload-button {
        position: relative;
        display: inline-block;
      }

    .upload-button input[type="file"] {
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .wide-button {
      min-width: 260px;
      max-width: 300px;
      width: 100%;
    }
  </style>
  <style>
    /* Keep rows from splitting in both web and print */
    .compat-section tr { break-inside: avoid; page-break-inside: avoid; }

    /* Make sure tables are fixed-width to avoid right-side cutoff */
    .compat-section table {
      width: 100% !important;
      table-layout: fixed !important;
      border-collapse: collapse !important;
    }

    /* Optional: make header clean (no decorative lines/boxes) */
    .section-title, .category-header, .compat-category {
      border: none !important;
      box-shadow: none !important;
      background: transparent !important;
    }
  </style>
</head>
<body class="theme-dark">
  <div class="main-container themed">
    <h1 class="page-title">See Our Compatibility</h1>
    <div class="upload-container">
      <button class="themed-button wide-button" onclick="window.history.back()">← Back</button>

      <label id="uploadYourSurvey" class="upload-button themed-button wide-button">
        <input id="uploadSurveyA" type="file" accept="application/json" />
        Upload Your Survey
      </label>

      <label id="uploadPartnerSurvey" class="upload-button themed-button wide-button">
        <input id="uploadSurveyB" type="file" accept="application/json" />
        Upload Partner’s Survey
      </label>

      <button class="themed-button wide-button" id="downloadBtn">Download PDF</button>
    </div>

    <div id="comparisonResults">
      <div id="loading-spinner" class="loading-overlay"><div class="spinner"></div></div>
      <div id="compat-container" data-compat-root></div>
      <div class="print-footer"></div>
    </div>
  </div>

  <script src="js/template-survey.js"></script>
  <script type="module" src="js/compatibilityPage.js"></script>
  <script type="module">
    import { initTheme, applyThemeColors } from './js/theme.js';
    initTheme();
    window.applyThemeColors = applyThemeColors;
  </script>
  <script>
    fetch("/check-session", { credentials: "include" })
      .then(res => {
        if (res.status === 401) {
          window.location.href = "/token.html";
        }
      });
  </script>

  <script type="module">
    import { downloadCompatibilityPDF } from '/js/pdfDownload.js';
    // auto-wire is built into the module, but this exposes it if you need to call it manually:
    window.downloadCompatibilityPDF = downloadCompatibilityPDF;
  </script>
<!-- ===================== COMPATIBILITY AUTO-FILL (A & B) — ONE DROP-IN =====================
HOW TO USE (copy/paste this whole block into compatibility.html before </body>):

1) Ensure you have a container for the comparison table:
   <div id="compat-container" data-compat-root></div>

2) Make sure you have two JSON upload inputs (keep yours if you already have them):
   <input id="uploadSurveyA" type="file" accept="application/json">
   <input id="uploadSurveyB" type="file" accept="application/json">

3) Table markup (if you already render a table, keep it; this script can also bootstrap one):
   - Rows live in <tbody><tr>...</tr></tbody>
   - First column: human-readable label.
   - Partner A cell has  data-partner-a
   - Match cell      has  data-match
   - Partner B cell has  data-partner-b
   - (Best) each <tr> carries a stable key via data-id and/or the full label via data-full.

   Example row:
   <tr data-id="appearance_outfit" data-full="Choosing my partner's outfit for the day or a scene">
     <td>Choosing my partner's outfit for the day or a scene</td>
     <td data-partner-a>-</td>
     <td data-match></td>
     <td data-partner-b>-</td>
   </tr>

4) Upload flow (wiring is included below):
   - Selecting a JSON file for Partner A/B calls handlePartnerAUpload/handlePartnerBUpload automatically.
   - The script supports JSON in these forms:
       a) Flat object: { "Some Label": 4, "Another": 5, ... }
       b) Items array: { items: [ {name|label|key|id, rating|score|value}, ... ] }
       c) Nested export:
          {
            "survey": {
              "Category Name": {
                "Giving":    [{name, rating}, ...],
                "Receiving": [{name, rating}, ...],
                "General":   [{name, rating}, ...]
              }
            }
          }

5) After fill, the script recomputes % Match (assuming 1–5 scores).
   You can also call window.updateComparison() at any time to recompute matches.

6) If no table is present yet, the script bootstraps a minimal “All” table
   from the union of keys in A/B JSON so you can still export/test.

========================================================================================== -->

<script>
(function(){
  // ===================== Config (edit only if needed) =====================
  const ROOT_SEL = '[data-compat-root], #compat-container'; // where the tables live
  const A_SEL    = 'td[data-partner-a]';
  const B_SEL    = 'td[data-partner-b]';
  const M_SEL    = 'td[data-match]';

  // ===================== Normalization & tokenization =====================
  function norm(s){
    return String(s||'')
      .replace(/[\u2018\u2019\u2032]/g,"'")
      .replace(/[\u201C\u201D\u2033]/g,'"')
      .replace(/[\u2013\u2014]/g,'-')
      .replace(/\u2026/g,'')
      .replace(/[^\w\s'-]/g,' ')   // keep letters/digits/space/hyphen/apostrophe
      .replace(/\s+/g,' ')
      .trim().toLowerCase();
  }
  const toks = s => norm(s).split(' ').filter(Boolean);

  // ===================== JSON -> Lookup (supports all shapes) =====================
  function toLookup(json){
    const map = new Map();
    if (!json || typeof json !== 'object') return map;

    // 1) Flat object: { "Label": 4, ... }
    if (!Array.isArray(json) && !json.items && !json.survey) {
      for (const [k,v] of Object.entries(json)) {
        const n = Number(v);
        if (Number.isFinite(n)) map.set(norm(k), n);
      }
      return map;
    }

    // 2) Items array
    if (Array.isArray(json.items)) {
      for (const it of json.items) {
        const k = norm(it?.name ?? it?.label ?? it?.key ?? it?.id ?? '');
        const n = Number(it?.rating ?? it?.score ?? it?.value);
        if (k && Number.isFinite(n)) map.set(k, n);
      }
      return map;
    }

    // 3) Nested survey export
    if (json.survey && typeof json.survey === 'object') {
      Object.values(json.survey).forEach(section=>{
        ['Giving','Receiving','General'].forEach(bucket=>{
          const arr = Array.isArray(section?.[bucket]) ? section[bucket] : [];
          arr.forEach(it=>{
            const k = norm(it?.name ?? it?.label ?? it?.id ?? '');
            const n = Number(it?.rating ?? it?.score ?? it?.value);
            if (k && Number.isFinite(n)) {
              // prefer max if duplicates
              map.set(k, Math.max(map.get(k) ?? -Infinity, n));
            }
          });
        });
      });
    }
    return map;
  }

  // ===================== Key extraction from a row =====================
  function rowKeys(tr){
    const id   = tr.getAttribute('data-id')   || '';
    const full = tr.getAttribute('data-full') || '';
    const vis  = tr.querySelector('td:first-child, th:first-child')?.textContent || '';
    return { kId:norm(id), kFull:norm(full), kVis:norm(vis) };
  }

  // ===================== Matching: exact -> contains -> fuzzy =====================
  function matchValue(keys, lookup){
    // exact by data-id / data-full / visible text
    if (keys.kId   && lookup.has(keys.kId))   return lookup.get(keys.kId);
    if (keys.kFull && lookup.has(keys.kFull)) return lookup.get(keys.kFull);
    if (keys.kVis  && lookup.has(keys.kVis))  return lookup.get(keys.kVis);

    // contains (either direction)
    for (const [lk, val] of lookup.entries()){
      if (lk.includes(keys.kFull) || keys.kFull.includes(lk)) return val;
      if (lk.includes(keys.kVis)  || keys.kVis.includes(lk))  return val;
    }

    // token overlap (≥60% overlap OR ≥4 shared tokens)
    const tryKeys = [keys.kFull, keys.kVis].filter(Boolean);
    for (const rk of tryKeys){
      const rt = toks(rk); if (!rt.length) continue;
      for (const [lk, val] of lookup.entries()){
        const lt = toks(lk); if (!lt.length) continue;
        const set = new Set(lt);
        const shared = rt.filter(t=>set.has(t)).length;
        const overlap = Math.min(shared/rt.length, shared/lt.length);
        if (shared >= 4 || overlap >= 0.6) return val;
      }
    }
    return undefined;
  }

  // ===================== Fill helper =====================
  function fillColumn(root, cellSelector, lookup){
    if (!lookup || !lookup.size) return 0;
    const rows = root.querySelectorAll('tbody tr');
    let wrote = 0, seen = 0;

    rows.forEach(tr=>{
      const td = tr.querySelector(cellSelector);
      if (!td) return;
      seen++;
      const cur = (td.textContent||'').trim();
      if (cur && !/^[-–—]$/.test(cur)) return; // don't overwrite existing real values
      const val = matchValue(rowKeys(tr), lookup);
      if (val == null) return;
      td.textContent = String(val);
      wrote++;
    });

    console.log(`[compat] filled ${cellSelector} : ${wrote}/${seen}`);
    return wrote;
  }

  // ===================== Match computation (assumes 1–5 scores) =====================
  function computeMatch(a, b){
    const na = Number(a), nb = Number(b);
    if (!Number.isFinite(na) || !Number.isFinite(nb)) return '';
    const diff = Math.abs(na - nb);            // 0..4
    return Math.round((1 - diff/4) * 100) + '%';
  }

  // ===================== Public: recompute matches for all rows =====================
  window.updateComparison = function(){
    const root = document.querySelector(ROOT_SEL);
    if (!root) return;
    root.querySelectorAll('tbody tr').forEach(tr=>{
      const a = tr.querySelector(A_SEL)?.textContent;
      const b = tr.querySelector(B_SEL)?.textContent;
      const m = tr.querySelector(M_SEL);
      if (m) m.textContent = computeMatch(a, b);
    });
  };

  // ===================== Bootstrap a table if none exists =====================
  function bootstrapIfEmpty(){
    const root = document.querySelector(ROOT_SEL);
    if (!root) return false;

    const hasRows = root.querySelectorAll('tbody tr').length > 0;
    if (hasRows) return false;

    const aMap = toLookup(window.partnerASurvey || window.surveyA || {});
    const bMap = toLookup(window.partnerBSurvey || window.surveyB || {});
    const keys = new Set([...aMap.keys(), ...bMap.keys()]);
    if (!keys.size) return false; // nothing to show yet

    const section = document.createElement('section');
    section.className = 'compat-section';

    const h2 = document.createElement('h2');
    h2.className = 'section-title';
    h2.textContent = 'All';
    section.appendChild(h2);

    const table = document.createElement('table');
    table.className = 'compat-table';

    const thead = document.createElement('thead');
    const thr = document.createElement('tr');
    ['Category','Partner A','Match','Partner B'].forEach(t=>{
      const th = document.createElement('th'); th.textContent = t; thr.appendChild(th);
    });
    thead.appendChild(thr);

    const tbody = document.createElement('tbody');
    keys.forEach(k=>{
      const tr = document.createElement('tr');
      tr.setAttribute('data-id', k);
      tr.setAttribute('data-full', k);

      const tdLabel = document.createElement('td'); tdLabel.textContent = k;
      const tdA = document.createElement('td'); tdA.setAttribute('data-partner-a',''); tdA.textContent='-';
      const tdM = document.createElement('td'); tdM.setAttribute('data-match',''); tdM.textContent='';
      const tdB = document.createElement('td'); tdB.setAttribute('data-partner-b',''); tdB.textContent='-';

      tr.append(tdLabel, tdA, tdM, tdB);
      tbody.appendChild(tr);
    });

    table.append(thead, tbody);
    section.appendChild(table);
    root.innerHTML = '';
    root.appendChild(section);

    console.log(`[compat] bootstrapped ${keys.size} rows from JSON union.`);
    return true;
  }

  // ===================== Upload handlers (public) =====================
  window.handlePartnerAUpload = async function(json){
    // optional: allow passing a File object directly
    if (json && typeof File !== 'undefined' && json instanceof File) {
      try { json = JSON.parse(await json.text()); } catch(_) { alert('Invalid Partner A JSON'); return; }
    }
    console.log('[compat] Partner A JSON loaded', json);
    // ensure table exists
    bootstrapIfEmpty();
    // fill A then recompute matches
    const root = document.querySelector(ROOT_SEL);
    const wrote = fillColumn(root, A_SEL, toLookup(json));
    window.updateComparison();
    if (!wrote) console.warn('[compat] Partner A wrote 0 cells — check row keys vs JSON labels/ids.');
  };

  window.handlePartnerBUpload = async function(json){
    if (json && typeof File !== 'undefined' && json instanceof File) {
      try { json = JSON.parse(await json.text()); } catch(_) { alert('Invalid Partner B JSON'); return; }
    }
    console.log('[compat] Partner B JSON loaded', json);
    bootstrapIfEmpty();
    const root = document.querySelector(ROOT_SEL);
    const wrote = fillColumn(root, B_SEL, toLookup(json));
    window.updateComparison();
    if (!wrote) console.warn('[compat] Partner B wrote 0 cells — check row keys vs JSON labels/ids.');
  };

  // ===================== Wire file inputs automatically =====================
  document.addEventListener('change', async (e)=>{
    const el = e.target;
    if (!el || el.type !== 'file' || !el.files || !el.files[0]) return;
    const file = el.files[0];
    if (el.id === 'uploadSurveyA') {
      await window.handlePartnerAUpload(file);
    } else if (el.id === 'uploadSurveyB') {
      await window.handlePartnerBUpload(file);
    }
  });

  // Optional: if JSON objects are already on the page (window.partnerASurvey / partnerBSurvey),
  // try a first fill after load.
  document.addEventListener('DOMContentLoaded', ()=>{
    if (window.partnerASurvey) window.handlePartnerAUpload(window.partnerASurvey);
    if (window.partnerBSurvey) window.handlePartnerBUpload(window.partnerBSurvey);
  });
})();
</script>

</body>
</html>
