<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>See Our Compatibility</title>
  <!-- Import theme and global layout styles -->
  <link rel="stylesheet" href="/css/theme.css" />
  <link rel="stylesheet" href="/css/global.css" />
  <link rel="stylesheet" href="/css/compat-table.css" />
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
  #pdf-container {
    width: 100%;
    max-width: 100%;
  }
  table {
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    text-align: center;
    vertical-align: middle;
    padding: 6px;
  }
  th:first-child, td:first-child {
    text-align: left;
    padding-left: 10px;
  }
  </style>
  <style>
    .upload-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      margin-top: 3rem;
    }

      .upload-button {
        position: relative;
        display: inline-block;
      }

    .upload-button input[type="file"] {
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .wide-button {
      min-width: 260px;
      max-width: 300px;
      width: 100%;
    }
  </style>
  <style>
    /* Keep rows from splitting in both web and print */
    .compat-section tr { break-inside: avoid; page-break-inside: avoid; }

    /* Make sure tables are fixed-width to avoid right-side cutoff */
    .compat-section table {
      width: 100% !important;
      table-layout: fixed !important;
      border-collapse: collapse !important;
    }

    /* Optional: make header clean (no decorative lines/boxes) */
    .section-title, .category-header, .compat-category {
      border: none !important;
      box-shadow: none !important;
      background: transparent !important;
    }
  </style>
</head>
<body class="theme-dark">
  <div class="main-container themed">
    <h1 class="page-title">See Our Compatibility</h1>
    <div class="upload-container">
      <button class="themed-button wide-button" onclick="window.history.back()">‚Üê Back</button>

      <label id="uploadYourSurvey" class="upload-button themed-button wide-button">
        <input id="uploadSurveyA" type="file" accept="application/json" />
        Upload Your Survey
      </label>

      <label id="uploadPartnerSurvey" class="upload-button themed-button wide-button">
        <input id="uploadSurveyB" type="file" accept="application/json" />
        Upload Partner‚Äôs Survey
      </label>

      <button class="themed-button wide-button" id="downloadBtn">Download PDF</button>
    </div>

    <div id="comparisonResults">
      <div id="loading-spinner" class="loading-overlay"><div class="spinner"></div></div>
      <div id="pdf-container">
        <div id="compatibility-wrapper" class="compatibility-wrapper">
          <div id="comparisonResult"></div>
          <div id="compatibility-report" class="pdf-export-area"></div>
          <div id="print-card-list" class="print-only"></div>
        </div>
      </div>
      <div class="print-footer"></div>
    </div>
  </div>

  <script src="js/template-survey.js"></script>
  <script type="module" src="js/compatibilityPage.js"></script>
  <script type="module">
    import { initTheme, applyThemeColors } from './js/theme.js';
    initTheme();
    window.applyThemeColors = applyThemeColors;
  </script>
  <script>
    fetch("/check-session", { credentials: "include" })
      .then(res => {
        if (res.status === 401) {
          window.location.href = "/token.html";
        }
      });
  </script>

  <script type="module">
    import { downloadCompatibilityPDF } from '/js/pdfDownload.js';
    // auto-wire is built into the module, but this exposes it if you need to call it manually:
    window.downloadCompatibilityPDF = downloadCompatibilityPDF;
  </script>

<script>
/**
 * Partner A loader + Flag column + guarded PDF ‚Äî ALL CATEGORIES
 * - Loads Partner A JSON and fills Column A across every table in #pdf-container
 * - auto-creates ‚ÄúPartner A‚Äù column if missing OR writes into existing one
 * - adds ‚ÄúFlag‚Äù column after ‚ÄúMatch‚Äù (‚≠ê >=90, üö© <=50 or 4/5 vs no-answer)
 * - re-fills after async renders (MutationObserver)
 * - blocks PDF download until Partner A has values
 */

const CFG = {
  container: '#pdf-container',
  uploadA:   '#uploadSurveyA, [data-upload-a]',
  download:  '#downloadBtn, [data-download-pdf]',
  partnerACellSelector: null,         // e.g. 'td.pa' if you already have a class-based Partner A cell; leave null to auto-create column
  createMissingPartnerACol: true,     // true = auto insert ‚ÄúPartner A‚Äù column if missing
  partnerAHeaderText: 'Partner A',
  matchHeaderRegex: /\bmatch\b/i,     // header used to place ‚ÄúFlag‚Äù after
  starMin: 90,                        // ‚≠ê rule
  redFlagMax: 50                      // üö© rule
};

const $1 = (s,r=document)=>r.querySelector(s);
const $$ = (s,r=document)=>Array.from(r.querySelectorAll(s));
const wait = ms=>new Promise(r=>setTimeout(r,ms));
function norm(s){return (s||'').replace(/[\u2018\u2019\u2032]/g,"'").replace(/[\u201C\u201D\u2033]/g,'"').replace(/[\u2013\u2014]/g,'-').replace(/\u2026/g,'...').replace(/\s+/g,' ').trim().toLowerCase();}

/* JSON ‚Üí lookup */
function buildLookup(json){
  const map=new Map();
  if (json && typeof json==='object' && !Array.isArray(json)){
    for (const [k,v] of Object.entries(json)) map.set(norm(k), Number(v));
    return map;
  }
  const items = Array.isArray(json?.items) ? json.items : [];
  for (const it of items){
    const k = norm(it.key ?? it.id ?? it.label ?? it.name ?? '');
    if (k) map.set(k, Number(it.rating ?? it.score ?? it.value ?? 0));
  }
  return map;
}

/* header/column helpers */
function findHeaderIndex(table, testFn){
  const tr = $1('thead tr', table) || $1('tr', table);
  if (!tr) return -1;
  return [...tr.children].findIndex(th => testFn((th.textContent||'').trim()));
}
function partnerAIndex(table){ return findHeaderIndex(table, t => norm(t) === norm(CFG.partnerAHeaderText)); }
function matchIndex(table){ return findHeaderIndex(table, t => CFG.matchHeaderRegex.test(t)); }

function ensurePartnerAColumn(table){
  if (CFG.partnerACellSelector) return;                       // writing to class-based cells
  let idx = partnerAIndex(table);
  if (idx >= 0) return;                                       // already present
  if (!CFG.createMissingPartnerACol) return;

  let head = $1('thead tr', table);
  if (!head){
    table.createTHead();
    head = table.tHead.insertRow();
    const firstBodyRow = $1('tbody tr', table);
    const cols = firstBodyRow ? firstBodyRow.children.length : 1;
    for (let i=0;i<cols;i++) head.appendChild(document.createElement('th'));
    head.children[0].textContent = 'Category';
  }
  const th = document.createElement('th'); th.textContent = CFG.partnerAHeaderText;
  head.insertBefore(th, head.children[1] || null);
  $$('tbody tr', table).forEach(tr=>{
    const td = document.createElement('td'); td.textContent='-';
    tr.insertBefore(td, tr.children[1] || null);
  });
}

function ensureFlagColumn(table){
  const headRow = $1('thead tr', table) || $1('tr', table);
  if (!headRow) return -1;
  let m = matchIndex(table);
  if (m === -1) return -1;

  // remove existing "Flag" columns to avoid duplicates
  [...headRow.children].forEach((th,i)=>{
    const t=(th.textContent||'').trim().toLowerCase();
    if (/^flag(\/star)?$/.test(t)){ headRow.children[i].remove(); $$('tbody tr', table).forEach(tr=> tr.children[i]?.remove()); }
  });

  m = matchIndex(table);
  if (m === -1) return -1;

  const th = document.createElement('th'); th.textContent='Flag';
  headRow.insertBefore(th, headRow.children[m+1] || null);
  $$('tbody tr', table).forEach(tr=>{
    const td=document.createElement('td'); td.className='flag-cell'; td.textContent='';
    tr.insertBefore(td, tr.children[m+1] || null);
  });
  return m+1;
}

/* row identity */
function rowKey(tr){
  const dk = tr.getAttribute('data-key') || tr.getAttribute('data-id');
  if (dk) return norm(dk);
  const labelCell = $1('td:first-child, th:first-child', tr);
  return norm(labelCell?.textContent || '');
}

/* access Partner A cell */
function makeACellAccessors(table){
  if (CFG.partnerACellSelector){
    return {
      get: tr => $1(CFG.partnerACellSelector, tr),
      set: (tr,val)=>{ const td=$1(CFG.partnerACellSelector,tr); if(td) td.textContent=String(val); }
    };
  }
  const idx = partnerAIndex(table);
  return {
    get: tr => (idx>=0 ? tr.children[idx] : null),
    set: (tr,val)=>{ if (idx>=0 && tr.children[idx]) tr.children[idx].textContent=String(val); }
  };
}

/* fill Partner A across ALL categories/tables */
function fillPartnerAAll(json){
  const lookup = buildLookup(json);
  const tables = $$(`${CFG.container} table`);
  let wrote=0;

  for (const table of tables){
    ensurePartnerAColumn(table);
    const acc = makeACellAccessors(table);

    for (const tr of $$('tbody tr', table)){
      if (!tr.children || tr.children.length===0) continue;

      const cur = (acc.get(tr)?.textContent||'').trim();
      if (cur && !/^[-‚Äì]$/.test(cur)) continue;

      const k = rowKey(tr);
      if (!k) continue;

      if (lookup.has(k)){ acc.set(tr, lookup.get(k)); wrote++; continue; }

      // forgiving substring fallback both ways
      let hit=null;
      for (const key of lookup.keys()){
        if (k.includes(key) || key.includes(k)){ hit=key; break; }
      }
      if (hit){ acc.set(tr, lookup.get(hit)); wrote++; }
    }
  }
  return wrote;
}

/* Flags (after A/B + Match exist) */
function populateFlags(){
  const tables = $$(`${CFG.container} table`);
  for (const table of tables){
    const mIdx = matchIndex(table);
    if (mIdx === -1) continue;
    const fIdx = ensureFlagColumn(table);
    if (fIdx === -1) continue;

    const aIdx = partnerAIndex(table);
    const bIdx = findHeaderIndex(table, t => /partner\s*b/i.test(t));

    $$('tbody tr', table).forEach(tr=>{
      const getNum = idx => {
        if (idx<0) return null;
        const t=(tr.children[idx]?.textContent||'').trim();
        if (t==='' || /^[-‚Äì]$/.test(t)) return null;
        const n=Number(String(t).replace('%','')); return Number.isFinite(n)?n:null;
      };
      const pct  = getNum(mIdx);
      const aVal = getNum(aIdx);
      const bVal = getNum(bIdx);

      let icon = '';
      if (pct!=null && pct >= CFG.starMin) icon='‚≠ê';
      const high = v => v!=null && v>=4;
      const noAns = v => v==null;
      if ((pct!=null && pct <= CFG.redFlagMax) || (high(aVal)&&noAns(bVal)) || (high(bVal)&&noAns(aVal))) icon='üö©';

      const cell = tr.children[fIdx];
      if (cell) cell.textContent = icon;
    });
  }
}

/* detect any Partner A in DOM */
function partnerAHasAnyData(){
  const tables = $$(`${CFG.container} table`);
  for (const table of tables){
    const acc = makeACellAccessors(table);
    for (const tr of $$('tbody tr', table)){
      const t=(acc.get(tr)?.textContent||'').trim();
      if (t && !/^[-‚Äì]$/.test(t)) return true;
    }
  }
  return false;
}

/* watch async renders and re-fill */
let compatObserver;
function watchAndFillAfterRender(){
  const root = $1(CFG.container);
  if (!root) return;
  if (compatObserver) compatObserver.disconnect();
  compatObserver = new MutationObserver(()=>{
    if (window.partnerASurvey){
      const wrote = fillPartnerAAll(window.partnerASurvey);
      if (wrote) populateFlags();
    }
  });
  compatObserver.observe(root, {childList:true, subtree:true});
  if (window.partnerASurvey){
    const wrote = fillPartnerAAll(window.partnerASurvey);
    if (wrote) populateFlags();
  }
}

/* upload + download wiring */
async function handleUploadA(file){
  try{
    const text = await file.text();
    const json = JSON.parse(text);
    window.partnerASurvey = window.surveyA = json;

    if (typeof window.updateComparison === 'function'){
      await Promise.resolve(window.updateComparison());
    }
    watchAndFillAfterRender();
    await wait(120);
    const wrote = fillPartnerAAll(window.partnerASurvey);
    if (wrote) populateFlags();

    if (!partnerAHasAnyData()){
      const lookup = buildLookup(window.partnerASurvey);
      const jsonKeys = Array.from(lookup.keys());
      const rowKeys = [];
      const tables = $$(`${CFG.container} table`);
      for (const table of tables){
        for (const tr of $$('tbody tr', table)){
          const k = rowKey(tr);
          if (k) rowKeys.push(k);
        }
      }
      const unmatched = rowKeys.filter(k => !lookup.has(k));
      console.warn('[Partner A] unmatched keys', {rowKeys, jsonKeys, unmatched});
      alert('Partner A looks empty. Ensure row text or data-key matches your JSON keys.');
    }
  }catch(e){
    console.error('[Partner A] JSON error:', e);
    alert('Invalid JSON file.');
  }
}

(function boot(){
  const up = $1(CFG.uploadA);
  if (up){
    up.addEventListener('change', e=>{
      const f = e?.target?.files?.[0];
      if (f) handleUploadA(f);
    });
  } else {
    console.warn('[Partner A] upload input not found (#uploadSurveyA or [data-upload-a]).');
  }

  const btn = $1(CFG.download);
  if (btn){
    const fresh = btn.cloneNode(true); btn.replaceWith(fresh);
    fresh.addEventListener('click', async ev=>{
      if (!partnerAHasAnyData()){
        ev.preventDefault();
        alert('Partner A looks empty. Upload your survey and wait for the table to refresh.');
        return;
      }
      if (typeof window.downloadCompatibilityPDF === 'function'){
        ev.preventDefault();
        await window.downloadCompatibilityPDF();
      }
    });
  }
})();

/* console diagnostics */
window.__compatDump = () => {
  const out = [];
  const tables = $$(`${CFG.container} table`);
  for (const [i,t] of tables.entries()){
    const head = $$('thead tr th', t).map(th=>th.textContent.trim());
    const idx = partnerAIndex(t);
    const rows = $$('tbody tr', t).slice(0,10).map(tr=>{
      const label = $1('td:first-child, th:first-child', tr)?.textContent?.trim() || '';
      const dk = tr.getAttribute('data-key') || tr.getAttribute('data-id') || '';
      return {label, dataKey: dk};
    });
    out.push({table:i, headers: head, partnerAIndex: idx, sampleRows: rows});
  }
  console.log('[__compatDump]', out);
  return out;
};
</script>
<script>
/**
 * CODEX: DO THIS EXACTLY
 * 1) Ensure the page has:
 *      <div id="pdf-container"> ‚Ä¶ your comparison tables ‚Ä¶ </div>
 *      <input id="uploadSurveyB" type="file" accept="application/json">   <!-- "Upload Partner's Survey" -->
 *   (You can also use any element with [data-upload-b] instead of the id.)
 *
 * 2) Paste THIS script at the very end of compatibility.html (right before </body>).
 *    It is SAFE with the Partner A loader already added.
 *
 * 3) Do NOT change layout. This script:
 *    - Fills "Partner B" across ALL tables inside #pdf-container
 *    - Writes to existing <td class="pb"> if present, OR inserts a ‚ÄúPartner B‚Äù column if missing
 *    - Recomputes the Flag column (‚≠ê ‚â• 90% match; üö© ‚â§ 50% match OR 4/5 vs no-answer)
 *
 * 4) After adding:
 *    - Reload ‚Üí Click ‚ÄúUpload Partner‚Äôs Survey‚Äù ‚Üí pick JSON ‚Üí Partner B column fills everywhere
 *    - The existing ‚ÄúDownload PDF‚Äù flow can remain as-is
 */

(function(){
  // ----------------------- CONFIG -----------------------
  const CFG_B = {
    container: '#pdf-container',
    uploadB:   '#uploadSurveyB, [data-upload-b]',
    partnerBHeaderText: 'Partner B',
    partnerBCellSelector: null,     // e.g. 'td.pb' if you ALREADY render a dedicated Partner B cell; leave null to auto-create a column
    createMissingPartnerBCol: true, // true => insert "Partner B" column if missing
    matchHeaderRegex: /\bmatch\b/i, // used to locate the Match column (for Flag recompute)
    starMin: 90,
    redFlagMax: 50
  };

  // Share tiny helpers with A-script if present:
  const $1 = window.__compat$1 || ((s,r=document)=>r.querySelector(s));
  const $$ = window.__compat$$ || ((s,r=document)=>Array.from(r.querySelectorAll(s)));

  function norm(s){
    return (s||'')
      .replace(/[\u2018\u2019\u2032]/g,"'")
      .replace(/[\u201C\u201D\u2033]/g,'"')
      .replace(/[\u2013\u2014]/g,'-')
      .replace(/\u2026/g,'...')
      .replace(/\s+/g,' ')
      .trim().toLowerCase();
  }

  // ----------------------- JSON ‚Üí lookup -----------------------
  function buildLookup(json){
    const map = new Map();
    if (json && typeof json==='object' && !Array.isArray(json)) {
      for (const [k,v] of Object.entries(json)) map.set(norm(k), Number(v));
      return map;
    }
    const items = Array.isArray(json?.items) ? json.items : [];
    for (const it of items){
      const k = norm(it.key ?? it.id ?? it.label ?? it.name ?? '');
      if (k) map.set(k, Number(it.rating ?? it.score ?? it.value ?? 0));
    }
    return map;
  }

  // ----------------------- table helpers -----------------------
  function findHeaderIndex(table, testFn){
    const tr = $1('thead tr', table) || $1('tr', table);
    if (!tr) return -1;
    const cells = [...tr.children];
    return cells.findIndex(th => testFn((th.textContent||'').trim()));
  }
  function partnerBIndex(table){ return findHeaderIndex(table, t => norm(t) === norm(CFG_B.partnerBHeaderText)); }
  function partnerAIndex(table){ return findHeaderIndex(table, t => /\bpartner\s*a\b/i.test(t)); }
  function partnerMatchIndex(table){ return findHeaderIndex(table, t => CFG_B.matchHeaderRegex.test(t)); }

  function ensurePartnerBColumn(table){
    if (CFG_B.partnerBCellSelector) return;                 // writing to class-based cells
    let idx = partnerBIndex(table);
    if (idx >= 0) return;                                   // already present
    if (!CFG_B.createMissingPartnerBCol) return;

    // Insert Partner B as the LAST column (stable default that won't disrupt ‚ÄúFlag‚Äù)
    let head = $1('thead tr', table);
    if (!head){
      table.createTHead();
      head = table.tHead.insertRow();
      const firstBodyRow = $1('tbody tr', table);
      const cols = firstBodyRow ? firstBodyRow.children.length : 1;
      for (let i=0;i<cols;i++) head.appendChild(document.createElement('th'));
      head.children[0].textContent = 'Category';
    }
    const th = document.createElement('th'); th.textContent = CFG_B.partnerBHeaderText;
    head.appendChild(th);

    $$('tbody tr', table).forEach(tr=>{
      const td = document.createElement('td'); td.textContent='-';
      tr.appendChild(td);
    });
  }

  function makeBCellAccessors(table){
    if (CFG_B.partnerBCellSelector){
      return {
        get: tr => $1(CFG_B.partnerBCellSelector, tr),
        set: (tr,val)=>{ const td=$1(CFG_B.partnerBCellSelector,tr); if(td) td.textContent=String(val); }
      };
    }
    const idx = partnerBIndex(table);
    return {
      get: tr => (idx>=0 ? tr.children[idx] : null),
      set: (tr,val)=>{ if (idx>=0 && tr.children[idx]) tr.children[idx].textContent=String(val); }
    };
  }

  function rowKey(tr){
    const dk = tr.getAttribute('data-key') || tr.getAttribute('data-id');
    if (dk) return norm(dk);
    const labelCell = $1('td:first-child, th:first-child', tr);
    return norm(labelCell?.textContent || '');
  }

  // ----------------------- fill Partner B everywhere -----------------------
  function fillPartnerBAll(json){
    const lookup = buildLookup(json);
    const tables = $$(`${CFG_B.container} table`);
    let wrote=0;

    for (const table of tables){
      ensurePartnerBColumn(table);
      const acc = makeBCellAccessors(table);

      for (const tr of $$('tbody tr', table)){
        if (!tr.children || tr.children.length===0) continue;

        const cur = (acc.get(tr)?.textContent||'').trim();
        if (cur && !/^[-‚Äì]$/.test(cur)) continue; // already filled

        const k = rowKey(tr);
        if (!k) continue;

        if (lookup.has(k)){ acc.set(tr, lookup.get(k)); wrote++; continue; }

        // forgiving substring fallback (both ways)
        let hit=null;
        for (const key of lookup.keys()){
          if (k.includes(key) || key.includes(k)){ hit=key; break; }
        }
        if (hit){ acc.set(tr, lookup.get(hit)); wrote++; }
      }
    }
    return wrote;
  }

  // ----------------------- Flag recompute -----------------------
  // If the Partner A script already defined populateFlags, use it.
  // Otherwise define a minimal local version so B upload still updates flags.
  const populateFlags = window.populateFlags || (function(){
    return function localPopulateFlags(){
      const tables = $$(`${CFG_B.container} table`);
      for (const table of tables){
        const mIdx = partnerMatchIndex(table);
        if (mIdx === -1) continue;

        // ensure a Flag column right after Match (remove duplicates)
        const headRow = $1('thead tr', table) || $1('tr', table);
        if (!headRow) continue;
        [...headRow.children].forEach((th,i)=>{
          const t=(th.textContent||'').trim().toLowerCase();
          if (/^flag(\/star)?$/.test(t)){ headRow.children[i].remove(); $$('tbody tr', table).forEach(r=> r.children[i]?.remove()); }
        });
        const th = document.createElement('th'); th.textContent='Flag';
        headRow.insertBefore(th, headRow.children[mIdx+1] || null);
        const fIdx = mIdx+1;

        const aIdx = partnerAIndex(table);
        const bIdx = partnerBIndex(table);

        $$('tbody tr', table).forEach(tr=>{
          const getNum = idx => {
            if (idx<0) return null;
            const t=(tr.children[idx]?.textContent||'').trim();
            if (t==='' || /^[-‚Äì]$/.test(t)) return null;
            const n=Number(String(t).replace('%',''));
            return Number.isFinite(n)?n:null;
          };
          const pct  = getNum(mIdx);
          const aVal = getNum(aIdx);
          const bVal = getNum(bIdx);

          let icon = '';
          if (pct!=null && pct >= CFG_B.starMin) icon = '‚≠ê';
          const high = v => v!=null && v>=4;
          const noAns = v => v==null;
          if ((pct!=null && pct <= CFG_B.redFlagMax) || (high(aVal)&&noAns(bVal)) || (high(bVal)&&noAns(aVal))) {
            icon = 'üö©';
          }
          const cell = tr.children[fIdx];
          if (cell) cell.textContent = icon;
        });
      }
    };
  })();

  // ----------------------- async render support -----------------------
  let observerB;
  function watchAndFillB(){
    const root = $1(CFG_B.container);
    if (!root) return;
    if (observerB) observerB.disconnect();
    observerB = new MutationObserver(()=>{
      if (window.partnerBSurvey){
        const wrote = fillPartnerBAll(window.partnerBSurvey);
        if (wrote) populateFlags();
      }
    });
    observerB.observe(root, {childList:true, subtree:true});
    // initial pass
    if (window.partnerBSurvey){
      const wrote = fillPartnerBAll(window.partnerBSurvey);
      if (wrote) populateFlags();
    }
  }

  // ----------------------- upload wiring -----------------------
  async function handleUploadB(file){
    try{
      const text = await file.text();
      const json = JSON.parse(text);
      window.partnerBSurvey = window.surveyB = json;

      if (typeof window.updateComparison === 'function'){
        await Promise.resolve(window.updateComparison());
      }
      watchAndFillB();
      // small extra delay to catch late layout/fonts
      setTimeout(()=>{
        const wrote = fillPartnerBAll(window.partnerBSurvey);
        if (wrote) populateFlags();
      }, 120);
    }catch(e){
      console.error('[Partner B] JSON error:', e);
      alert('Invalid JSON file for Partner B.');
    }
  }

  // boot
  document.addEventListener('DOMContentLoaded', ()=>{
    const inp = $1(CFG_B.uploadB);
    if (inp){
      inp.addEventListener('change', e=>{
        const f = e?.target?.files?.[0];
        if (f) handleUploadB(f);
      });
    } else {
      console.warn('[Partner B] upload input not found (#uploadSurveyB or [data-upload-b]).');
    }
  });
})();
  </script>
<script>
(function(){
  const ROOT = document.querySelector('#pdf-container');
  if (!ROOT) return;

  function norm(s){
    return String(s||'')
      .replace(/[\u2018\u2019\u2032]/g,"'")
      .replace(/[\u201C\u201D\u2033]/g,'"')
      .replace(/[\u2013\u2014]/g,'-')
      .replace(/\u2026/g,'')
      .replace(/\s*\.\.\.\s*$/,'')
      .replace(/\s+/g,' ')
      .trim()
      .toLowerCase();
  }

  function annotateRows(){
    ROOT.querySelectorAll('table tbody tr').forEach(tr=>{
      if ((tr.getAttribute('data-key')||'').trim()) return;
      const first = tr.querySelector('td:first-child, th:first-child');
      const label =
        tr.getAttribute('data-full') || tr.getAttribute('data-label') ||
        (first && (first.getAttribute('data-full') || first.getAttribute('data-label'))) ||
        tr.getAttribute('title') || tr.getAttribute('aria-label') ||
        (first && (first.getAttribute('title') || first.getAttribute('aria-label'))) ||
        (first ? first.textContent : '');
      tr.setAttribute('data-key', norm(label));
    });
  }

  function tagColumns(){
    ROOT.querySelectorAll('table').forEach(table=>{
      const ths = Array.from(table.querySelectorAll('thead th'));
      if (!ths.length) return;
      const idxA = ths.findIndex(th => norm(th.textContent) === 'partner a');
      const idxB = ths.findIndex(th => norm(th.textContent) === 'partner b');
      if (idxA >= 0) table.querySelectorAll(`tbody tr`).forEach(tr=>{
        const td = tr.children[idxA]; if (td) td.classList.add('pa');
      });
      if (idxB >= 0) table.querySelectorAll(`tbody tr`).forEach(tr=>{
        const td = tr.children[idxB]; if (td) td.classList.add('pb');
      });
    });
  }

  function buildLookup(json){
    function flattenSurvey(j){
      if (!j || typeof j!=='object' || !j.survey) return j;
      const out = {};
      Object.values(j.survey).forEach(sec=>{
        ['Giving','Receiving','General'].forEach(b=>{
          (Array.isArray(sec?.[b])?sec[b]:[]).forEach(it=>{
            const k = it?.name ?? it?.label ?? it?.id;
            const v = it?.rating ?? it?.score ?? it?.value;
            if (k!=null && Number.isFinite(+v)) out[k] = Math.max(out[k]??-Infinity, +v);
          });
        });
      });
      return out;
    }
    const flat = flattenSurvey(json) || json;
    const map = new Map();
    if (flat && typeof flat==='object' && !Array.isArray(flat) && !flat.items && !flat.survey){
      for (const [k,v] of Object.entries(flat)) map.set(norm(k), Number(v));
      return map;
    }
    const items = Array.isArray(flat?.items) ? flat.items : [];
    for (const it of items){
      const k = norm(it?.name ?? it?.label ?? it?.key ?? it?.id ?? '');
      const n = Number(it?.rating ?? it?.score ?? it?.value);
      if (k && Number.isFinite(n)) map.set(k, n);
    }
    return map;
  }

  function writePartner(label, json){
    const map = buildLookup(json);
    if (!map.size) return 0;
    const sel = label==='A' ? 'td.pa' : 'td.pb';
    let wrote = 0;
    ROOT.querySelectorAll('table tbody tr').forEach(tr=>{
      const key = tr.getAttribute('data-key') || tr.getAttribute('data-id') || '';
      const val = map.get(norm(key));
      if (val==null) return;
      const td = tr.querySelector(sel);
      if (!td) return;
      if (!td.textContent || /^\s*[-‚Äì‚Äî]?\s*$/.test(td.textContent)){
        td.textContent = String(val);
        wrote++;
      }
    });
    return wrote;
  }

  function refill(){
    annotateRows();
    tagColumns();
    let w = 0;
    if (window.partnerASurvey) w += writePartner('A', window.partnerASurvey);
    if (window.partnerBSurvey) w += writePartner('B', window.partnerBSurvey);
    if (typeof window.populateFlags === 'function') window.populateFlags();
    return w;
  }

  window.fillPartnerAAll = json => { window.partnerASurvey = json; annotateRows(); tagColumns(); return writePartner('A', json); };
  window.fillPartnerBAll = json => { window.partnerBSurvey = json; annotateRows(); tagColumns(); return writePartner('B', json); };

  window.__compatQuick = {
    refill,
    check(key){
      const k = norm(key);
      const tr = ROOT.querySelector(`tbody tr[data-key="${k}"]`);
      console.log('norm key:', k, 'row found?', !!tr, tr);
      return tr;
    }
  };

  annotateRows();
  tagColumns();
  setTimeout(refill, 100);

  document.addEventListener('change', (e)=>{
    if (e.target && (e.target.matches('#uploadSurveyA,[data-upload-a]') ||
                     e.target.matches('#uploadSurveyB,[data-upload-b]'))){
      setTimeout(refill, 150);
    }
  });
})();
</script>
</body>
</html>
