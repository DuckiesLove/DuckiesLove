<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Kill-switch for legacy Partner-B bootstrap that caused "freeze after first upload" -->
  <script>
    // Hard disable any code path that auto-fills Partner B from internal JSON.
    // This must be loaded before every other script.
    window.TK_DISABLE_BOOTSTRAP_B = true;
    console.info('[compat] kill-switch enabled');
    // one-time guard so labels/overrides merge only once per load
    window._tkLabelsMerged = false;
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>See Our Compatibility</title>
  <style>
    /* Kill any category dock/panel overlays without layout shift */
    #tkDockCard,
    #categorySurveyPanel,
    aside.category-panel,
    .category-panel,
    [data-testid="select-categories-panel"],
    #tkOverlay,
    .tk-overlay {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }

    /* Ensure body isn't pushed for a removed dock */
    html.tk-dock body {
      margin-left: 0 !important;
    }
  </style>
  <script>
    (function killCategoryPanel() {
      const selectors = [
        '#tkDockCard',
        '#categorySurveyPanel',
        'aside.category-panel',
        '.category-panel',
        '[data-testid="select-categories-panel"]',
        '#tkOverlay',
        '.tk-overlay'
      ];

      window.__TK_DISABLE_PANEL__ = true;
      window.__TK_DISABLE_PORTAL__ = true;

      const purge = () => {
        document.documentElement.classList.remove('tk-dock');
        if (document.body) {
          document.body.style.marginLeft = '';
        }
        selectors.forEach((selector) => {
          document.querySelectorAll(selector).forEach((node) => node.remove());
        });
      };

      purge();

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', purge, { once: true });
      }

      const observer = new MutationObserver(purge);
      observer.observe(document.documentElement, { childList: true, subtree: true });
      setTimeout(() => observer.disconnect(), 4000);
    })();
  </script>
  <style id="tk-compat-center">
    /* Remove any panel/dock if an older script injected it */
    #tkDockCard,
    #categorySurveyPanel,
    .category-panel,
    .tk-overlay {
      display: none !important;
    }

    html,
    body {
      margin: 0;
    }

    body[style*="margin-left"] {
      margin-left: 0 !important;
    }

    /* Center the content column */
    .compat-wrap,
    .compat-container,
    .container,
    main,
    #app {
      box-sizing: border-box;
      max-width: 960px;
      width: min(960px, 92vw);
      margin-inline: auto;
      padding-inline: 16px;
    }

    .compat-wrap > *,
    .compat-container > *,
    .container > *,
    main > * {
      max-width: 100%;
    }
  </style>
  <script>
    (function () {
      // Nuke any leftover dock/overlay/panel on this page
      for (const sel of ['#tkDockCard', '.tk-overlay', '#categorySurveyPanel', '.category-panel']) {
        const n = document.querySelector(sel);
        if (n) n.remove();
      }

      try {
        document.body.style.marginLeft = '';
      } catch (err) {
        console.warn('[compat] unable to clear dock margin', err);
      }
    })();
  </script>
  <!-- Import theme and global layout styles -->
  <link rel="stylesheet" href="/css/theme.css" />
  <link rel="stylesheet" href="/css/global.css" />
  <link rel="stylesheet" href="/css/compat-table.css" />
  <link rel="stylesheet" href="/css/font-failopen.css">
  <link rel="stylesheet" href="/css/compatibility.css" />

  <style>
    /* --- Percent bar (Match %) --- */
    .pct {
      position: relative;
      width: 100%;
      height: 22px;
      border: 1px solid #3ddbf3;
      border-radius: 6px;
      background: rgba(61,219,243,0.08);
      overflow: hidden;
    }
    .pct-fill {
      position: absolute;
      inset: 0;
      width: 0%;
      background: linear-gradient(90deg, #18a0fb, #3df3c3);
      transition: width .35s ease;
    }
    .pct-text {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-variant-numeric: tabular-nums;
      font-weight: 600;
    }
    /* Friendly label text in first column (wrap nicely on small screens) */
    .tk-cat {
      white-space: normal;
      line-height: 1.2;
    }
    .tk-code {
      opacity: .5;
      font-size: .85em;
      margin-left: .4rem;
    }
  </style>
  <style>
    td.pct-cell .pct { position: relative; height: 1.1em; line-height: 1.1em; }
    td.pct-cell .pct .bar { position:absolute; left:0; top:0; bottom:0; width:0%;
                            background:rgba(0,255,255,0.25); border-radius:2px; }
    td.pct-cell .pct .txt { position:relative; display:block; text-align:center; }
    td.pct-cell { min-width:5rem; }
  </style>
  <style>
  #pdf-container {
    width: 100%;
    max-width: 100%;
  }
  table {
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    text-align: center;
    vertical-align: middle;
    padding: 6px;
  }
  th:first-child, td:first-child {
    text-align: left;
    padding-left: 10px;
  }
  </style>
  <style>
    .upload-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      margin-top: 3rem;
    }

    .upload-button {
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
    }

    .upload-button input[type="file"] {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .upload-button .upload-trigger {
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .upload-button .upload-trigger:focus-visible {
      outline: 2px solid rgba(61, 219, 243, 0.9);
      outline-offset: 2px;
    }

    .wide-button {
      min-width: 260px;
      max-width: 300px;
      width: 100%;
    }
    .export-tip {
      font-size: 0.9rem;
      margin: 0;
    }
  </style>
  <style>
    /* Keep rows from splitting in both web and print */
    .compat-section tr { break-inside: avoid; page-break-inside: avoid; }

    /* Make sure tables are fixed-width to avoid right-side cutoff */
    .compat-section table {
      width: 100% !important;
      table-layout: fixed !important;
      border-collapse: collapse !important;
    }

    /* Optional: make header clean (no decorative lines/boxes) */
    .section-title, .category-header, .compat-category {
      border: none !important;
      box-shadow: none !important;
      background: transparent !important;
    }
  </style>
  <style>
    /* Force LIGHT pdf colors by default; override via body[style] if you want dark */
    :root { --pdf-bg:#fff; --pdf-text:#000; }
    .pdf-export, #pdfWrapper, .pdf-container {
      background: var(--pdf-bg) !important;
      color: var(--pdf-text) !important;
    }
  </style>
  <style>
    /* optional polish to match your theme */
    .tk-compat th, .tk-compat td{
      border-bottom:1px solid #00e6ff33;
      padding:.55rem .8rem;
      vertical-align:middle;
    }
    .tk-compat td.ta-c{ text-align:center; }
  </style>
  <style>
  /* Small, unobtrusive subtitle under the category code */
  .tk-catwrap { display:flex; flex-direction:column; gap:2px; }
  .tk-catwrap .tk-code { font-weight:600; letter-spacing:0.02em; }
  .tk-catwrap .tk-sub  {
    font-weight:500; opacity:.78;
    font-size: clamp(11px,.9vw,13px);
    line-height:1.2;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    max-width: min(48vw, 780px);  /* fits your wide first column */
  }

  /* Match % meter (tuned for your dark theme) */
  .tk-meter {
    position: relative;
    height: 10px; min-width: 110px;
    background: rgba(0, 230, 255, .12);
    border-radius: 999px;
    outline: 1px solid rgba(0,230,255,.20);
    overflow: hidden;
  }
  .tk-meter > .tk-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg,
      rgba(0,230,255,.88), rgba(120,255,250,.95));
    box-shadow: 0 0 10px rgba(0,230,255,.35) inset;
    border-radius: inherit;
    transition: width .35s ease;
  }
  .tk-meter + .tk-pct {
    display:inline-block; min-width: 42px;
    font-weight:800; letter-spacing:.02em;
    margin-left:.5rem; opacity:.9;
  }

  /* Keep row height stable on narrow screens */
  @media (max-width: 720px){
    .tk-catwrap .tk-sub { max-width: 70vw; }
    .tk-meter { min-width: 80px; }
  }
  </style>
  <style>
  /* ====== Match % chip (compact, no layout shift) ====== */
  .tk-match-chip{
    display:inline-flex; flex-direction:column; align-items:center; gap:6px;
    min-width:70px; line-height:1; vertical-align:middle;
  }
  .tk-match-num{ font-weight:800; letter-spacing:.02em; }
  .tk-match-bar{
    position:relative; width:90px; height:7px; border-radius:999px;
    outline:1px solid rgba(0,230,255,.35);
    background:rgba(0,230,255,.10); overflow:hidden;
  }
  .tk-match-fill{
    display:block; height:100%; width:var(--w,0%);
    background:linear-gradient(90deg,#00e6ff,#3bffc4);
    border-radius:inherit; transition:width .25s ease;
  }
  /* Dim the bar if the value is “missing” on that row */
  .tk-match-chip[data-missing="1"] .tk-match-bar{ opacity:.38; }

  /* ====== Category main + tiny subline (summary) ====== */
  .tk-cat-wrap{ display:flex; flex-direction:column; gap:3px; }
  .tk-cat-main{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .tk-cat-sub{
    font-size:.82em; color:#9beff7; opacity:.78;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    max-width:48ch;  /* keep it subtle; doesn’t stretch your layout */
  }
  /* On narrow screens you can hide the subline if you want */
  @media (max-width: 680px){
    .tk-cat-sub{ display:none; }
  }
  </style>
  <style>
  /* Compatibility table progressive enhancement (fallback match bar + labels) */
  td.ksv-match { white-space: nowrap; }

  .ksv-matchwrap{
    display:flex; flex-direction:column; align-items:center; gap:.4rem;
    min-width:8rem;
  }
  .ksv-pct{
    font: 800 0.95rem/1.1 system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    letter-spacing:.02em; color:#d9ffff;
  }
  .ksv-bar{
    width:100%; height:6px; border-radius:999px;
    background: rgba(0,230,255,.12);
    outline: 1px solid rgba(0,230,255,.35);
    overflow:hidden;
  }
  .ksv-bar > i{
    display:block; height:100%; width:var(--w,0%);
    background: linear-gradient(90deg,#00e6ff 0%, #5fffd6 100%);
    box-shadow: 0 0 6px #00e6ff66 inset;
  }

  td.ksv-cat{
    word-break: break-word;
  }
  .ksv-cat .ksv-cat-text{
    display:inline;
  }
  </style>
</head>
<body class="theme-dark">
  <main class="compat-container">
    <div class="main-container themed compat-wrap">
    <h1 class="page-title">See Our Compatibility</h1>
    <div class="upload-container">
      <button class="themed-button wide-button" onclick="window.history.back()">← Back</button>

      <div class="upload-button">
        <input id="uploadSurveyA" type="file" accept="application/json" />
        <label
          for="uploadSurveyA"
          id="uploadYourSurvey"
          class="upload-trigger themed-button wide-button"
          data-upload-trigger="uploadSurveyA"
          role="button"
          aria-haspopup="dialog"
          tabindex="0"
        >
          Upload Your Survey
        </label>
      </div>

      <div class="upload-button">
        <input id="uploadSurveyB" type="file" accept="application/json" />
        <label
          for="uploadSurveyB"
          id="uploadPartnerSurvey"
          class="upload-trigger themed-button wide-button"
          data-upload-trigger="uploadSurveyB"
          role="button"
          aria-haspopup="dialog"
          tabindex="0"
        >
          Upload Partner’s Survey
        </label>
      </div>

      <button class="themed-button wide-button" id="downloadPdf" data-action="download-pdf" data-tk="download" disabled>Download PDF</button>
      <p id="exportTip" class="export-tip">Upload both surveys before exporting.</p>
    </div>

    <div id="comparisonResults">
      <p id="comparisonResult"></p>
      <div id="loading-spinner" class="loading-overlay"><div class="spinner"></div></div>
      <div id="pdf-container" class="compat-root" data-compat-root></div>
      <!-- === Compatibility results mount (add this to compatibility.html) === -->
      <section id="compatResults" style="margin-top:24px">
        <table id="compatTable" class="tk-compat compatTbl" style="width:100%; border-collapse:collapse">
          <thead>
            <tr>
              <th style="text-align:left; padding:.6rem .8rem; border-bottom:2px solid #00e6ff55">Category</th>
              <th style="text-align:center; padding:.6rem .8rem; border-bottom:2px solid #00e6ff55">Partner A</th>
              <th style="text-align:center; padding:.6rem .8rem; border-bottom:2px solid #00e6ff55">Match %</th>
              <th style="text-align:center; padding:.6rem .8rem; border-bottom:2px solid #00e6ff55">Partner B</th>
            </tr>
          </thead>
          <tbody id="tk-compat-body"></tbody>
        </table>
      </section>
      <table id="tk-unanswered" class="compatTable" style="margin-top:24px; width:100%; border-collapse:collapse">
        <thead>
          <tr>
            <th>Unanswered Categories (0 or blank)</th>
            <th>Partner A</th>
            <th>Partner B</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div class="print-footer"></div>
    </div>
    </div>
  </main>

  <script src="js/template-survey.js"></script>
  <!-- Label loader must be before the page script -->
  <script src="/js/tk-labels.js" defer></script>
  <script src="/js/compatibilityPage.js" defer></script>
  <script type="module">
    import { initTheme, applyThemeColors } from './js/theme.js';
    initTheme();
    window.applyThemeColors = applyThemeColors;
  </script>
  <!-- Safe session check script -->
  <script>
  /**
   * Safe session check:
   * - Silently ignores 404 / network errors (useful on static hosting & local previews)
   * - Only redirects on 401 Unauthorized
   * - Won’t throw or spam the console
   *
   * How to use:
   * 1) Paste this block.
   * 2) Delete the old:
   *      fetch("/check-session", { credentials: "include" })
   *        .then(res => { if (res.status === 401) window.location.href = "/token.html"; });
   * 3) Call safeCheckSession(); (or skip entirely if you don’t need auth)
   */

  (function(){
    function safeCheckSession(opts){
      const cfg = Object.assign({
        url: '/check-session',          // change if your API path differs
        redirectTo: '/token.html',      // where to send on 401
        credentials: 'include',         // send cookies if present
        log: false,                     // set true to log non-401 statuses
        skipHosts: undefined,           // overrideable allow list of static hosts
        skipHostSuffixes: undefined,    // overrideable suffix allow list (e.g. github.io)
        skipOnFileProtocol: true,       // skip when opened via file:// by default
        force: false                    // set true to bypass the skip guards
      }, (opts || {}));

      const host = (window.location && window.location.hostname || '').toLowerCase();
      const proto = (window.location && window.location.protocol) || '';

      const defaultHosts = ['talkkink.org', 'www.talkkink.org'];
      const defaultSuffixes = ['github.io'];
      const skipHosts = Array.isArray(cfg.skipHosts) && cfg.skipHosts.length ? cfg.skipHosts : defaultHosts;
      const skipSuffixes = Array.isArray(cfg.skipHostSuffixes) && cfg.skipHostSuffixes.length ? cfg.skipHostSuffixes : defaultSuffixes;

      const matchesHost = !!host && skipHosts.some(h => h && host === String(h).toLowerCase());
      const matchesSuffix = !!host && skipSuffixes.some(s => s && host.endsWith(String(s).toLowerCase()));
      const isFile = cfg.skipOnFileProtocol !== false && proto === 'file:';

      if (!cfg.force && (isFile || matchesHost || matchesSuffix)) {
        if (cfg.log) {
          console.info('[session] skipped check-session fetch for host:', host || '(unknown host)');
        }
        return;
      }

      try {
        fetch(cfg.url, { credentials: cfg.credentials })
          .then(res => {
            if (res.status === 401) {
              // Only redirect on explicit 401
              window.location.href = cfg.redirectTo;
              return;
            }
            // Silence 404s and other statuses unless logging is enabled
            if (cfg.log && res.status !== 204 && res.status !== 200) {
              console.info('[session] status:', res.status);
            }
          })
          .catch(() => {
            // Network error / CORS / offline — ignore quietly
          });
      } catch (_) {
        // Older browsers / unexpected errors — ignore
      }
    }

    // OPTIONAL: run automatically on load (safe even if endpoint doesn’t exist)
    document.addEventListener('DOMContentLoaded', function(){
      safeCheckSession();
    });

    // Expose if you want to call manually later
    window.safeCheckSession = safeCheckSession;
  })();
  </script>

  <script>
  // Progressive enhancement for fallback compatibility tables
  /* ========================================================================== */
  /*  Compatibility page helpers: progress bar + category summary (tooltip)     */
  /* ========================================================================== */

  /** Holds 1-line summaries for each category id. */
  let TK_CATEGORY_SUMMARY = Object.create(null);

  /**
   * Build summaries from your survey schema. We prefer:
   *   cat.short  >  cat.title  >  first question text  >  id
   * Call this once right after you’ve loaded kinks.json (same object you already
   * use to label things).
   */
  function tkBuildCategorySummaries(kinks) {
    try {
      const cats = kinks?.categories || kinks || {};
      Object.keys(cats).forEach(id => {
        const c = cats[id] || {};
        const firstQ = (c.questions && c.questions[0] && (c.questions[0].short || c.questions[0].title || c.questions[0].text)) || '';
        const raw = c.short || c.title || c.name || firstQ || id;
        TK_CATEGORY_SUMMARY[id] = String(raw).replace(/\s+/g,' ').trim();
      });
    } catch (e) {
      console.warn('[compat] Could not build category summaries:', e);
    }
  }

  /**
   * Create the Match % cell content. We keep your number and, when it’s numeric,
   * layer a subtle bar behind it (no layout change).
   */
  function tkMakePctCell(pct) {
    const td = document.createElement('td');
    td.className = 'tk-pct';
    const isNum = Number.isFinite(pct);
    const pctSafe = isNum ? Math.max(0, Math.min(100, Math.round(pct))) : null;

    const bar = document.createElement('div');
    bar.className = 'tk-pct__bar';
    bar.style.width = `${pctSafe ?? 0}%`;
    td.appendChild(bar);

    const span = document.createElement('span');
    span.textContent = pctSafe != null ? `${pctSafe}%` : '—';
    td.appendChild(span);
    return td;
  }

  /**
   * Make a Category cell that shows a zero-layout native tooltip on hover.
   * (No visible subtitle is inserted; your table stays exactly the same.)
   */
  function tkMakeCategoryCell(catId) {
    const td = document.createElement('td');
    td.className = 'cat';
    td.textContent = catId;
    if (TK_CATEGORY_SUMMARY[catId]) {
      td.title = TK_CATEGORY_SUMMARY[catId];
    }
    return td;
  }

  function tkAppendComparisonRow(tbody, catId, aVal, pct, bVal) {
    if (!tbody) return null;
    const tr = document.createElement('tr');

    const cTD = tkMakeCategoryCell(catId);

    const aTD = document.createElement('td');
    aTD.className = 'ta-c pa';
    aTD.setAttribute('data-partner-a', '');
    aTD.textContent = (Number.isFinite(aVal) ? aVal : '—');

    const pTD = tkMakePctCell(pct);
    pTD.classList.add('ta-c', 'match');

    const bTD = document.createElement('td');
    bTD.className = 'ta-c pb';
    bTD.setAttribute('data-partner-b', '');
    bTD.textContent = (Number.isFinite(bVal) ? bVal : '—');

    tr.append(cTD, aTD, pTD, bTD);
    tbody.appendChild(tr);
    return tr;
  }

  if (typeof window !== 'undefined') {
    window.tkBuildCategorySummaries = tkBuildCategorySummaries;
    window.tkMakePctCell = tkMakePctCell;
    window.tkMakeCategoryCell = tkMakeCategoryCell;
    window.tkAppendComparisonRow = tkAppendComparisonRow;
  }

  (function(){
    const META_URLS = [
      '/data/kinks.json',
      '/kinksurvey/data/kinks.json',
      '/kinksurvey/kinks.json',
      '/kinks.json',
      '/assets/kinks.json'
    ];

    let labelPromise = null;

    const norm = str => String(str || '').trim().toLowerCase();

    async function fetchFirst(urls){
      for (const url of urls){
        try {
          const res = await fetch(url, { cache: 'no-store' });
          if (!res || !res.ok) continue;
          const data = await res.json();
          if (data) {
            tkBuildCategorySummaries(data);
            return data;
          }
        } catch (_) {
          // ignore individual fetch failures
        }
      }
      return null;
    }

    function toLabelMap(meta){
      const map = new Map();
      const store = (key, label) => {
        if (!key) return;
        const cleanKey = String(key).trim();
        if (!cleanKey) return;
        const val = label || cleanKey;
        map.set(cleanKey, val);
        map.set(norm(cleanKey), val);
      };

      const cells = Array.isArray(meta?.cells) ? meta.cells : Array.isArray(meta) ? meta : [];
      cells.forEach(cell => {
        if (!cell || typeof cell !== 'object') return;
        const id = cell.id || cell.key || cell.slug;
        const label = cell.prompt || cell.label || cell.name || cell.title;
        store(id, label);
        if (Array.isArray(cell.aliases)) cell.aliases.forEach(alias => store(alias, label));
      });
      return map;
    }

    function loadLabels(){
      if (!labelPromise){
        labelPromise = fetchFirst(META_URLS).then(toLabelMap).catch(() => new Map());
      }
      return labelPromise;
    }

    function findIndexes(table){
      const headRow = table.tHead && table.tHead.rows && table.tHead.rows[0];
      if (!headRow) return { catIdx: 0, matchIdx: 2 };
      const cells = Array.from(headRow.cells || []);
      const texts = cells.map(th => norm(th.textContent));
      const catIdx = texts.findIndex(t => t && (t.startsWith('category') || t.includes('category')));
      const matchIdx = texts.findIndex(t => t && t.includes('match'));
      return {
        catIdx: catIdx >= 0 ? catIdx : 0,
        matchIdx: matchIdx >= 0 ? matchIdx : 2
      };
    }

    function summarizeLabel(label){
      if (!label) return '';
      let text = String(label).replace(/\s+/g, ' ');
      text = text.replace(/\s*\([^)]*\)\s*/g, ' ');
      text = text.replace(/^((do|does|did|would|could|are|is|i(?:'| a)m)\s+)/i, '');
      text = text.trim();
      if (text.length > 72) text = text.slice(0, 69).trimEnd() + '…';
      return text;
    }

    function applyMatchBars(table, matchIdx){
      if (matchIdx < 0) return;
      const bodies = table.tBodies ? Array.from(table.tBodies) : [];
      bodies.forEach(tbody => {
        Array.from(tbody.rows).forEach(row => {
          const td = row.cells && row.cells[matchIdx];
          if (!td || td.querySelector('.ksv-matchwrap')) return;
          const raw = (td.textContent || '').trim();
          const n = Number(raw.replace(/[^\d.]+/g, ''));
          const pct = Number.isFinite(n) ? Math.max(0, Math.min(100, n)) : null;

          td.classList.add('ksv-match');
          td.textContent = '';
          const wrap = document.createElement('div');
          wrap.className = 'ksv-matchwrap';

          const pctSpan = document.createElement('div');
          pctSpan.className = 'ksv-pct';
          pctSpan.textContent = pct === null ? '—' : `${pct}%`;

          const bar = document.createElement('div');
          bar.className = 'ksv-bar';
          const fill = document.createElement('i');
          if (pct !== null) fill.style.setProperty('--w', `${pct}%`);
          bar.appendChild(fill);

          wrap.appendChild(pctSpan);
          wrap.appendChild(bar);
          td.appendChild(wrap);
        });
      });
    }

    function lookupLabel(map, key, fallback){
      if (!key) return fallback;
      const clean = String(key).trim();
      if (!clean) return fallback;
      return map.get(clean) || map.get(norm(clean)) || fallback;
    }

    function collectRowKeys(row){
      const attrs = ['data-id', 'data-key', 'data-full', 'data-label'];
      for (const attr of attrs){
        const val = row.getAttribute && row.getAttribute(attr);
        if (val) return val;
      }
      return null;
    }

    function applyLabels(table, map, catIdx){
      if (catIdx < 0) return;
      const bodies = table.tBodies ? Array.from(table.tBodies) : [];
      bodies.forEach(tbody => {
        Array.from(tbody.rows).forEach(row => {
          const td = row.cells && row.cells[catIdx];
          if (!td || td.children.length) return;
          const raw = (td.textContent || '').trim();
          if (!raw) return;
          const key = collectRowKeys(row) || raw;
          const nice = lookupLabel(map, key, lookupLabel(map, raw, raw));
          if (!nice || nice === raw) return;
          td.classList.add('ksv-cat');
          td.textContent = '';
          const span = document.createElement('span');
          span.className = 'ksv-cat-text';
          span.textContent = summarizeLabel(nice);
          span.title = nice;
          td.appendChild(span);
        });
      });
    }

    function enhanceTable(table){
      if (!table || table.dataset.ksvEnhanced === 'done' || table.dataset.ksvEnhanced === 'skip') return;
      if (table.querySelector('.tk-match-chip') || table.querySelector('.tk-cat-wrap')) {
        table.dataset.ksvEnhanced = 'skip';
        return;
      }

      const { catIdx, matchIdx } = findIndexes(table);
      applyMatchBars(table, matchIdx);

      loadLabels().then(map => {
        if (!(map instanceof Map) || map.size === 0) return;
        applyLabels(table, map, catIdx);
      });

      table.dataset.ksvEnhanced = 'done';
    }

    window.tkEnhanceCompatTable = function(table){
      if (!table) table = document.querySelector('#pdf-container table, #compatResults table, table');
      if (!table) return;
      enhanceTable(table);
    };

    function init(){
      window.tkEnhanceCompatTable();
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init, { once: true });
    } else {
      init();
    }
  })();
  </script>

<script>
/* ==== COMPAT: Robust A/B Fill (markup-agnostic) ==== *
 * Supports three table shapes:
 *  1) Cells with data-partner-a / data-partner-b attributes             (preferred)
 *  2) Cells with .pa / .pb classes                                      (legacy)
 *  3) No markers, but THEAD headers literally "Partner A" / "Partner B" (auto-tag)
 *
 * Also:
 *  - Annotates rows with data-full (full visible label) and data-id (normalized key)
 *  - Matches JSON -> rows by data-id -> data-full -> visible text -> fuzzy overlap
 *  - Bootstraps a simple table if your container has 0 rows
 *  - Recomputes a Match % (assumes 1–5 scale)
 *
 * Requirements:
 *  - Your wrapper has data-compat-root OR you use #pdf-container
 *  - First column is the label cell (visible text)
 *  - Keep THEAD headers: Category | Partner A | Match | Partner B (lets us auto-tag A/B)
 */

(function(){
  /* ---------- normalizers ---------- */
  function norm(s){
    return String(s||'')
      .replace(/[\u2018\u2019\u2032]/g,"'")
      .replace(/[\u201C\u201D\u2033]/g,'"')
      .replace(/[\u2013\u2014]/g,'-')
      .replace(/\u2026/g,'')
      .replace(/[^\w\s'-]/g,' ')
      .replace(/\s+/g,' ')
      .trim().toLowerCase();
  }
  const toks = s => norm(s).split(' ').filter(Boolean);

  /* ---------- JSON → lookup ---------- */
  function toLookup(json){
    const map = new Map();
    if (!json || typeof json !== 'object') return map;

    // flat {key:value}
    if (!Array.isArray(json) && !json.items && !json.survey){
      for (const [k,v] of Object.entries(json)){
        const n = Number(v); if (Number.isFinite(n)) map.set(norm(k), n);
      }
      return map;
    }

    // items array
    if (Array.isArray(json.items)){
      for (const it of json.items){
        const k = norm(it?.name ?? it?.label ?? it?.key ?? it?.id ?? '');
        const n = Number(it?.rating ?? it?.score ?? it?.value);
        if (k && Number.isFinite(n)) map.set(k, n);
      }
      return map;
    }

    // nested survey export
    if (json.survey && typeof json.survey === 'object'){
      Object.values(json.survey).forEach(section=>{
        ['Giving','Receiving','General'].forEach(bucket=>{
          (Array.isArray(section?.[bucket])?section[bucket]:[]).forEach(it=>{
            const k = norm(it?.name ?? it?.label ?? it?.id ?? '');
            const n = Number(it?.rating ?? it?.score ?? it?.value);
            if (k && Number.isFinite(n)) map.set(k, Math.max(map.get(k)??-Infinity, n));
          });
        });
      });
    }
    return map;
  }

  /* ---------- DOM helpers ---------- */
  function getRoot(){
    return document.querySelector('[data-compat-root]') || document.querySelector('#pdf-container') || document.body;
  }

  // If no rows exist, create a simple "All" table from the union of JSON keys
  function bootstrapIfEmpty(root){
    const hasRows = root.querySelectorAll('tbody tr').length > 0;
    if (hasRows) return false;

    if (!window.TK_DISABLE_BOOTSTRAP_B && false) {
      // const aMap = toLookup(window.partnerASurvey || window.surveyA || {});
      // const bMap = toLookup(window.partnerBSurvey || window.surveyB || {});
      // const keys = new Set([...aMap.keys(), ...bMap.keys()]);
      // if (!keys.size) return false;
      //
      // const section = document.createElement('section'); section.className = 'compat-section';
      // const h2 = document.createElement('h2'); h2.className = 'section-title'; h2.textContent = 'All'; section.appendChild(h2);
      //
      // const table = document.createElement('table'); table.className = 'compat-table compatTbl';
      // const thead = document.createElement('thead'); const thr = document.createElement('tr');
      // ['Category','Partner A','Match','Partner B'].forEach(t=>{ const th=document.createElement('th'); th.textContent=t; thr.appendChild(th); });
      // thead.appendChild(thr);
      // const tbody = document.createElement('tbody');
      //
      // keys.forEach(k=>{
      //   const aVal = aMap.has(k) ? aMap.get(k) : null;
      //   const bVal = bMap.has(k) ? bMap.get(k) : null;
      //   const pct = (Number.isFinite(aVal) && Number.isFinite(bVal))
      //     ? Math.round((1 - Math.abs(aVal - bVal) / 5) * 100)
      //     : null;
      //   const tr = tkAppendComparisonRow(tbody, k, aVal, pct, bVal);
      //   if (tr) {
      //     tr.setAttribute('data-id', k);
      //     tr.setAttribute('data-full', k);
      //   }
      // });
      //
      // table.append(thead, tbody); section.appendChild(table);
      // root.innerHTML = ''; root.appendChild(section);
      // console.log(`[compat] bootstrapped ${keys.size} rows from JSON union.`);
      // return true;
    } else {
      console.info('[compat] legacy B bootstrap suppressed');
      return false;
    }
  }

  // Ensure each row has data-full and data-id
  function annotateRows(root){
    root.querySelectorAll('table tbody tr').forEach(tr=>{
      const first = tr.querySelector('td:first-child, th:first-child');
      const vis = first ? (first.textContent || '') : '';
      if (!tr.hasAttribute('data-full') && vis) tr.setAttribute('data-full', vis);
      if (!tr.hasAttribute('data-id')){
        const canon = norm(tr.getAttribute('data-full') || vis);
        if (canon) tr.setAttribute('data-id', canon);
      }
    });
  }

  // If there are no .pa/.pb markers, use THEAD headers to tag the columns
  function ensurePartnerMarkers(root){
    root.querySelectorAll('table').forEach(table=>{
      const thead = table.querySelector('thead tr'); if (!thead) return;
      const ths = Array.from(thead.children).map(th => norm(th.textContent));
      const idxA = ths.indexOf('partner a');
      const idxB = ths.indexOf('partner b');

      const tbody = table.querySelector('tbody'); if (!tbody) return;
      if (idxA >= 0 && !tbody.querySelector('td.pa, td[data-partner-a]')){
        tbody.querySelectorAll('tr').forEach(tr=>{ const td = tr.children[idxA]; if (td){ td.classList.add('pa'); td.setAttribute('data-partner-a',''); }});
      }
      if (idxB >= 0 && !tbody.querySelector('td.pb, td[data-partner-b]')){
        tbody.querySelectorAll('tr').forEach(tr=>{ const td = tr.children[idxB]; if (td){ td.classList.add('pb'); td.setAttribute('data-partner-b',''); }});
      }
    });
  }

  /* ---------- matching ---------- */
  function rowKeyBundle(tr){
    const id   = tr.getAttribute('data-id')   || '';
    const full = tr.getAttribute('data-full') || '';
    const vis  = tr.querySelector('td:first-child, th:first-child')?.textContent || '';
    return { kId: norm(id), kFull: norm(full), kVis: norm(vis) };
  }

  function pickValue(keys, lookup){
    // 1) exact id
    if (keys.kId && lookup.has(keys.kId)) return lookup.get(keys.kId);
    // 2) exact full
    if (keys.kFull && lookup.has(keys.kFull)) return lookup.get(keys.kFull);
    // 3) exact visible
    if (keys.kVis && lookup.has(keys.kVis)) return lookup.get(keys.kVis);
    // 4) contains (either direction)
    for (const [lk, val] of lookup.entries()){
      if (lk.includes(keys.kFull) || keys.kFull.includes(lk)) return val;
      if (lk.includes(keys.kVis)  || keys.kVis.includes(lk))  return val;
    }
    // 5) token overlap ≥60% or ≥4 shared tokens
    const tryKeys = [keys.kFull, keys.kVis].filter(Boolean);
    for (const rk of tryKeys){
      const rt = toks(rk); if (!rt.length) continue;
      for (const [lk, val] of lookup.entries()){
        const lt = toks(lk); if (!lt.length) continue;
        const set = new Set(lt);
        const shared = rt.filter(t=>set.has(t)).length;
        const overlap = Math.min(shared/rt.length, shared/lt.length);
        if (shared >= 4 || overlap >= 0.6) return val;
      }
    }
    return undefined;
  }

  /* ---------- fill + match ---------- */
  function fillColumn(root, selectorList, lookup){
    if (!lookup || !lookup.size) return 0;
    const rows = root.querySelectorAll('table tbody tr');
    let wrote = 0;
    rows.forEach(tr=>{
      const td = tr.querySelector(selectorList);
      if (!td) return;
      const current = (td.textContent || '').trim();
      if (current && !/^[-–—]$/.test(current)) return; // don't overwrite real values
      const val = pickValue(rowKeyBundle(tr), lookup);
      if (val == null) return;
      const renderScore = typeof window.tkRenderScoreCell === 'function'
        ? window.tkRenderScoreCell
        : v => (v === null || v === undefined || v === '' ? '—' : String(v));
      td.textContent = renderScore(val);
      wrote++;
    });
    return wrote;
  }

  function computeMatch(a, b){
    if (typeof window.tkRenderMatchCell === 'function') {
      return window.tkRenderMatchCell(a, b);
    }
    const calc = typeof window.tkMatchPercent === 'function'
      ? window.tkMatchPercent
      : (va, vb) => {
          const na = Number(va);
          const nb = Number(vb);
          if (!Number.isFinite(na) || !Number.isFinite(nb)) return null;
          if (na === 0 || nb === 0) return 0;
          const diff = Math.abs(na - nb);
          return Math.round((1 - diff / 5) * 100);
        };
    const pct = calc(a, b);
    if (pct === null) {
      return '<div class="tk-match-chip" data-missing="1" aria-label="No match data">—</div>';
    }
    return `
      <div class="tk-match-chip" role="img" aria-label="Match ${pct}%">
        <div class="tk-match-num">${pct}%</div>
        <div class="tk-match-bar" aria-hidden="true">
          <i class="tk-match-fill" style="--w:${pct}%"></i>
        </div>
      </div>
    `;
  }

  function recomputeMatches(root){
    root.querySelectorAll('table tbody tr').forEach(tr=>{
      const a = tr.querySelector('td[data-partner-a], td.pa')?.textContent;
      const b = tr.querySelector('td[data-partner-b], td.pb')?.textContent;
      const m = tr.querySelector('td[data-match]') || tr.children[2]; // assume 3rd col if standard
      if (m && m.tagName === 'TD') m.innerHTML = computeMatch(a, b);
    });
  }

  /* ---------- main entry ---------- */
  function runFill(){
    const root = getRoot();
    if (!root) return;

    // If empty, create a minimal table so we can fill something
    bootstrapIfEmpty(root);

    // Make keys discoverable & cells targetable
    annotateRows(root);
    ensurePartnerMarkers(root);

    const aMap = toLookup(window.partnerASurvey || window.surveyA || {});
    const bMap = toLookup(window.partnerBSurvey || window.surveyB || {});

    const wroteA = fillColumn(root, 'td[data-partner-a], td.pa', aMap);
    const wroteB = fillColumn(root, 'td[data-partner-b], td.pb', bMap);

    if (wroteA || wroteB) recomputeMatches(root);
    if (typeof window.populateFlags === 'function') window.populateFlags();

    console.log(`[compat] filled Partner A cells: ${wroteA}; Partner B cells: ${wroteB}`);
  }

  // Wire uploads (Partner A / Partner B)
  document.addEventListener('change', async e=>{
    if (!e.target) return;
    if (e.target.matches('#uploadSurveyA,[data-upload-a],#uploadSurveyB,[data-upload-b]')){
      // If your upload handlers already parse JSON and set window.partnerASurvey/window.partnerBSurvey,
      // runFill will use them. If not, attempt quick inline parsing:
      const f = e.target.files && e.target.files[0];
      if (f && (
        (e.target.matches('#uploadSurveyA,[data-upload-a]') && !window.partnerASurvey) ||
        (e.target.matches('#uploadSurveyB,[data-upload-b]') && !window.partnerBSurvey)
      )){
        try {
          const jsonText = await f.text();
          const parser = window.TK_LABELS?.parseSurveyJSON;
          const json = parser ? parser(jsonText) : JSON.parse(jsonText);
          if (e.target.matches('#uploadSurveyA,[data-upload-a]')) window.partnerASurvey = json;
          else window.partnerBSurvey = json;
        } catch {}
      }
      setTimeout(runFill, 150);
    }
  });

  // Expose manual trigger + run once
  window.__compatRunFill = runFill;
document.addEventListener('DOMContentLoaded', () => setTimeout(runFill, 250));
})();
</script>
<!--
Talk Kink • Compatibility Report — Dark-Mode PDF (all-black cells)
WHAT THIS DOES
• Loads jsPDF + AutoTable from CDN only if missing
• Finds your results table (#compatibilityTable, .results-table.compat, or first <table>)
• Uses the FIRST section header on the page (e.g., “Appearance Play”) as the left column label
• Exports a landscape A4 PDF with black background, white text, THICK white grid lines
• Ensures the on-screen scores transfer exactly (including 0). 0/blank are also listed at the end as “Unanswered”.
• Binds to #downloadBtn automatically, or call TKPDF_forceDark() from the console

HOW TO USE (Codex-ready steps)
1) Open compatibility.html
2) Paste this entire <script> block just before </body>
3) Ensure your results table is rendered in the DOM when the user clicks “Download PDF”
4) Click the button with id="downloadBtn" (or run TKPDF_forceDark() in the console)

RESULT
• A file named compatibility-blackedge.pdf is downloaded with:
  – main results table in dark theme
  – a second table “Unanswered (0 or blank)” listing any category Partner A or B didn’t answer
-->

<script>
(function () {
  const LOG = (...a) => console.log('[TK-PDF]', ...a);

  /* -------------------- loader -------------------- */
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      if (document.querySelector(`script[src="${src}"]`)) return resolve();
      const s = document.createElement('script');
      s.src = src;
      s.onload = resolve;
      s.onerror = () => reject(new Error('Failed to load ' + src));
      document.head.appendChild(s);
    });
  }
  async function ensureLibs() {
    if (!(window.jspdf && window.jspdf.jsPDF)) {
      await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js');
    }
    const hasAT =
      (window.jspdf && window.jspdf.jsPDF && window.jspdf.jsPDF.API && window.jspdf.jsPDF.API.autoTable);
    if (!hasAT) {
      await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.3/jspdf.plugin.autotable.min.js');
    }
  }

  /* -------------------- DOM helpers -------------------- */
  function findTable() {
    return (
      document.querySelector('#compatibilityTable') ||
      document.querySelector('.results-table.compat') ||
      document.querySelector('table')
    );
  }
  const tidy = (s) => (s || '').replace(/\s+/g, ' ').trim();

  // Extract first integer-like token (supports 0..5)
  function rawInt(v) {
    const m = String(v ?? '').match(/-?\d+/);
    if (!m) return null;
    const n = parseInt(m[0], 10);
    return Number.isFinite(n) ? n : null;
  }
  const isValidScore = (n) => n != null && Number.isInteger(n) && n >= 1 && n <= 5;
  const isZeroOrBlank = (raw) => raw == null || raw === 0;

  // Label cleanup: dedupe words, tiny fixes, rename "Cum" -> "Cum Play"
  function cleanLabel(s) {
    let t = tidy(s);
    t = t.replace(/\b([A-Za-z/’'-]+)\s*\1\b/g, '$1'); // e.g., "Blood Blood" -> "Blood"
    t = t.replace(/\bCum\b/g, 'Cum Play');
    return t;
  }

  /* -------------------- table parsing -------------------- */
  function extractRows(table) {
    const trs = [...table.querySelectorAll('tr')];
    const rows = [];     // main table rows
    const missing = [];  // [Category, missA, missB] for 0/blank
    let firstSectionHeader = 'Category';

    for (const tr of trs) {
      const tds = [...tr.querySelectorAll('td')];
      if (!tds.length) continue;

      const texts = tds.map(td => cleanLabel(td.textContent));

      // Section header detection: one <td> that spans the row (or others empty)
      if (tds.length === 1 || (texts[0] && texts.slice(1).every(x => !x))) {
        if (firstSectionHeader === 'Category') firstSectionHeader = texts[0];
        rows.push([{
          content: texts[0],
          colSpan: 4,
          styles: { fontStyle: 'bold', halign: 'left', fillColor: [0,0,0], textColor: [255,255,255] }
        }]);
        continue;
      }

      // Category text is first cell
      const category = cleanLabel(texts[0] || '—');

      // Pick Partner A = first numeric, Partner B = last numeric (from the row)
      const raws = texts.map(rawInt);
      const numIdx = raws.map((n, i) => (n !== null ? i : -1)).filter(i => i >= 0);
      const aRaw = numIdx.length ? raws[numIdx[0]] : null;
      const bRaw = numIdx.length ? raws[numIdx[numIdx.length - 1]] : null;

      // What to SHOW in the PDF:
      // - If it's 0, show "0" (to match the on-screen table)
      // - If 1..5, show the number
      // - Otherwise "—"
      const aShow = (aRaw === 0) ? '0' : (isValidScore(aRaw) ? String(aRaw) : '—');
      const bShow = (bRaw === 0) ? '0' : (isValidScore(bRaw) ? String(bRaw) : '—');

      // Match %: use present % cell if any; else compute only when both scores are valid (1..5)
      let matchCell = texts.find(c => /%$/.test(c)) || '—';
      if (matchCell === '—' && isValidScore(aRaw) && isValidScore(bRaw)) {
        const pct = Math.round(100 - (Math.abs(aRaw - bRaw) / 5) * 100);
        matchCell = `${Math.max(0, Math.min(100, pct))}%`;
      }

      // Missing (0 or blank) tracker
      const missA = isZeroOrBlank(aRaw);
      const missB = isZeroOrBlank(bRaw);
      if (missA || missB) {
        missing.push([category, missA ? '✖' : '—', missB ? '✖' : '—']);
      }

      // Push row (ALL BLACK cells w/ white text)
      rows.push([
        { content: category,  styles: { fillColor: [0,0,0], textColor: [255,255,255] } },
        { content: aShow,     styles: { fillColor: [0,0,0], textColor: [255,255,255] } },
        { content: matchCell, styles: { fillColor: [0,0,0], textColor: [255,255,255] } },
        { content: bShow,     styles: { fillColor: [0,0,0], textColor: [255,255,255] } },
      ]);
    }
    return { rows, missing, firstSectionHeader };
  }

  /* -------------------- PDF export -------------------- */
  async function TKPDF_export() {
    try {
      await ensureLibs();
      const { jsPDF } = window.jspdf;

      const table = findTable();
      if (!table) return alert('No table found on the page.');

      const { rows, missing, firstSectionHeader } = extractRows(table);

      const doc = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });
      const pageW = doc.internal.pageSize.getWidth();
      const pageH = doc.internal.pageSize.getHeight();
      const marginLR = 30;
      const usable = pageW - marginLR * 2;

      // Dark page painter (fixes "white boxes")
      const paintBg = () => { doc.setFillColor(0,0,0); doc.rect(0,0,pageW,pageH,'F'); doc.setTextColor(255,255,255); };

      paintBg();
      doc.setFontSize(24);
      doc.text('Talk Kink • Compatibility Report', pageW/2, 42, { align: 'center' });

      // Column widths (kept constant to avoid overflow warnings)
      const Awidth = 90, Mwidth = 110, Bwidth = 90;
      const CatWidth = usable - (Awidth + Mwidth + Bwidth);

      const originalAddPage = doc.addPage;
      doc.addPage = function patchedAddPage(...args) {
        const result = originalAddPage.apply(this, args);
        paintBg();
        return result;
      };

      try {
        doc.autoTable({
          head: [[firstSectionHeader, 'Partner A', 'Match %', 'Partner B']],
          body: rows,
          startY: 64,
          margin: { left: marginLR, right: marginLR },
          styles: {
            fontSize: 11,
            cellPadding: 6,
            textColor: [255,255,255],
            fillColor: [0,0,0],
            lineColor: [255,255,255],
            lineWidth: 1.2,
            halign: 'center',
            valign: 'middle',
            overflow: 'linebreak'
          },
          headStyles: {
            fillColor: [0,0,0],
            textColor: [255,255,255],
            fontStyle: 'bold',
            lineColor: [255,255,255],
            lineWidth: 1.4
          },
          columnStyles: {
            0: { cellWidth: CatWidth, halign: 'left' },
            1: { cellWidth: Awidth },
            2: { cellWidth: Mwidth },
            3: { cellWidth: Bwidth }
          },
          willDrawPage: paintBg
        });

        if (missing.length) {
          doc.autoTable({
            head: [['Unanswered Categories (0 or blank)', 'Partner A', 'Partner B']],
            body: missing.map(r => r.map(c => ({ content: c, styles: { fillColor: [0,0,0], textColor: [255,255,255] } }))),
            startY: (doc.lastAutoTable && doc.lastAutoTable.finalY ? doc.lastAutoTable.finalY : 64) + 20,
            margin: { left: marginLR, right: marginLR },
            styles: {
              fontSize: 11,
              cellPadding: 6,
              textColor: [255,255,255],
              fillColor: [0,0,0],
              lineColor: [255,255,255],
              lineWidth: 1.2
            },
            headStyles: { fillColor: [0,0,0], textColor: [255,255,255], fontStyle: 'bold' },
            columnStyles: { 0: { cellWidth: usable - 180 }, 1: { cellWidth: 90 }, 2: { cellWidth: 90 } },
            willDrawPage: paintBg
          });
        }
      } finally {
        doc.addPage = originalAddPage;
      }

      doc.save('compatibility-dark.pdf');
      LOG('Export complete');
    } catch (err) {
      console.error('[TK-PDF] Export failed:', err);
      alert('PDF export failed: ' + (err?.message || err));
    }
  }

  // Public + button binding
  window.TKPDF_forceDark = TKPDF_export;
  const btn = document.querySelector('#downloadBtn');
  if (btn) btn.addEventListener('click', (e) => { e.preventDefault(); TKPDF_export(); });
  LOG('Bound Download PDF');
})();
</script>


<!-- ===== TK Compatibility Page Hardening Patch (v2) — paste before </body> ===== -->

<!-- Fix PDF export: ensure jsPDF + autoTable are present BEFORE any export code runs -->
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.1/dist/jspdf.plugin.autotable.min.js" defer></script>
<script>
(function ensureJsPDF(){
  function ready(){
    if (window.jspdf && window.jspdf.jsPDF) {
      window.jsPDF = window.jspdf.jsPDF;
      try { new window.jsPDF({compress:false}); } catch(_) {}
    }
  }
  window.addEventListener('load', ready, {once:true});
  setTimeout(ready, 600);
})();
</script>

<script>
(function(){
  // ----------------- Tiny safe coercers -----------------
  const STR  = v => (v == null ? '' : (typeof v === 'string' ? v : String(v)));
  const TRIM = v => STR(v).trim();
  const NUM  = v => { const n = Number(v); return Number.isFinite(n) ? n : 0; };
  const OBJ  = v => v && typeof v === 'object' && !Array.isArray(v);

  // ----------------- Canonical survey shape -----------------
  function canonSurvey(raw){
    if (!raw || typeof raw !== 'object') throw new Error('bad survey');

    const meta = OBJ(raw.meta) ? raw.meta : {};
    const baseSite = TRIM(raw.site || meta.site || meta.origin);
    const baseGenerated = TRIM(raw.generatedAt || meta.generatedAt || meta.exportedAt || meta.timestamp);

    const finalize = (list) => {
      const answers = (Array.isArray(list) ? list : [])
        .filter(Boolean)
        .map(a => ({
          key   : TRIM(a?.key),
          label : TRIM(a?.label),
          rating: NUM(a?.rating)
        }));
      const answersByKey = Object.fromEntries(answers.map(a => [a.key, a.rating]));
      return {
        schema: 'tk-survey.v1',
        site: baseSite,
        generatedAt: baseGenerated,
        answers,
        answersByKey
      };
    };

    if (Array.isArray(raw.answers)) {
      return finalize(raw.answers);
    }

    if (OBJ(raw.answers)) {
      const mapped = Object.entries(raw.answers).map(([k, v]) => ({
        key: k,
        label: '',
        rating: v
      }));
      return finalize(mapped);
    }

    if (OBJ(raw.answersByKey)) {
      const mapped = Object.entries(raw.answersByKey).map(([k, v]) => ({
        key: k,
        label: '',
        rating: v
      }));
      return finalize(mapped);
    }

    if (Array.isArray(raw.categories)) {
      const flat = [];
      raw.categories.forEach(c => {
        (c?.questions || []).forEach(q => {
          flat.push({ key: q?.key || q?.id || q?.name,
                      label: q?.label || q?.text,
                      rating: q?.rating });
        });
      });
      return finalize(flat);
    }

    return finalize([]);
  }

  function sanitizeSurvey(sv){
    if (!sv || typeof sv !== 'object') return;
    sv.answers = (Array.isArray(sv.answers) ? sv.answers : [])
      .filter(Boolean)
      .map(a => ({ key: TRIM(a?.key), label: TRIM(a?.label), rating: NUM(a?.rating) }));
    sv.answersByKey = Object.fromEntries(sv.answers.map(a => [a.key, a.rating]));
  }

  function sanitizeUnionArray(arr){
    if (!Array.isArray(arr)) return arr;
    return arr.map(r => {
      if (!r || typeof r !== 'object') return r;
      r.key      = TRIM(r.key);
      r.label    = TRIM(r.label);
      r.group    = TRIM(r.group);
      r.category = TRIM(r.category);
      return r;
    });
  }

  // ----------------- Wrap JSON.parse (network & inline JSON) -----------------
  (function wrapJSONParse(){
    const _parse = JSON.parse;
    JSON.parse = function(str, reviver){
      const obj = _parse(str, reviver);
      try {
        if (obj && typeof obj === 'object') {
          // Detect & canonicalize surveys
          if (Array.isArray(obj.answers) || obj.answersByKey || Array.isArray(obj.categories)) {
            return canonSurvey(obj);
          }
          // Detect likely union data and sanitize labels/keys
          const union = (Array.isArray(obj.union) && obj.union) ||
                        (Array.isArray(obj.rows)  && obj.rows)  ||
                        (Array.isArray(obj.kinks) && obj.kinks);
          if (union) {
            union.splice(0, union.length, ...sanitizeUnionArray(union));
          }
        }
      } catch(e) { console.warn('[compat] JSON.parse patch fell back:', e); }
      return obj;
    };
  })();

  // ----------------- Hook FileReader so uploads are safe BEFORE site code runs -----------------
  (function patchFileReader(){
    const orig = FileReader.prototype.readAsText;
    FileReader.prototype.readAsText = function(blob){
      // Make sure our handler runs first (capture)
      const fix = (ev) => {
        try {
          const txt = String(ev.target.result || '');
          // If it looks like JSON, canonicalize and replace the result string itself.
          // This way, any subsequent "JSON.parse(e.target.result)" gets the safe shape.
          if (txt.trim().startsWith('{') || txt.trim().startsWith('[')) {
            let parsed = JSON.parse(txt);            // goes through our JSON.parse wrapper
            parsed = canonSurvey(parsed);            // belt-and-suspenders
            ev.target.result = JSON.stringify(parsed);
          }
        } catch (err) {
          console.warn('[compat] FileReader patch could not normalize upload:', err);
        }
      };
      this.addEventListener('load', fix, {once:true, capture:true});
      return orig.apply(this, arguments);
    };
  })();

  // ----------------- Ensure safe globals & wrap compute -----------------
  function ensureDefaults(){
    if (!window.SurveyA) window.SurveyA = { schema:'tk-survey.v1', answers:[], answersByKey:{} };
    if (!window.SurveyB) window.SurveyB = { schema:'tk-survey.v1', answers:[], answersByKey:{} };
    sanitizeSurvey(window.SurveyA);
    sanitizeSurvey(window.SurveyB);
  }

  function patchCompute(){
    ['calculateCompatibility','updateComparison','filterGeneralOptions'].forEach(name=>{
      const fn = window[name];
      if (typeof fn === 'function' && !fn.__tkSafe) {
        const wrapped = function(...args){
          try { ensureDefaults(); } catch(_) {}
          try { return fn.apply(this, args); }
          catch(e){
            console.error(`[compat] ${name} failed (guarded)`, e);
            // Keep the UI alive even if one pass failed
            return null;
          }
        };
        wrapped.__tkSafe = true;
        window[name] = wrapped;
      }
    });
  }

  // ----------------- Init -----------------
  function init(){
    ensureDefaults();
    patchCompute();
  }
  window.addEventListener('load', init, {once:true});
  setTimeout(init, 700);
  new MutationObserver(()=>{ patchCompute(); })
    .observe(document.documentElement, {childList:true, subtree:true});
})();
</script>
<!-- ===== /TK Compatibility Page Hardening Patch (v2) ===== -->

<!-- ---------- End Safe Bootstrap ---------- -->
<script>
// v2 fallback DISABLED — this path caused “freeze after upload A”
if (!window.TK_DISABLE_BOOTSTRAP_B && false) {
  // dead path kept for reference only
  // const rows = …;
  // fillPartnerB(rows);
  // console.info('[compat] bootstrapped 35 rows for B from JSON.');
} else {
  console.info('[compat] legacy B bootstrap suppressed (v2)');
}
</script>
<script>
/* ===== TK Compatibility: robust survey upload wiring =====
   Drop this ONCE at the very end of /compatibility.html (right before </body>).
   It stores uploads into window._tkCompat.A / .B and (re)computes the table. */

(function () {
  // ---------- helpers ----------
  const sTrim = v => (v == null ? '' : String(v)).trim();
  function clamp05(n){
    n = Number(n);
    if (!Number.isFinite(n)) return 0;
    if (n > 5 && n <= 10) return Math.max(0, Math.min(5, n / 2));
    return Math.max(0, Math.min(5, n));
  }

  function extractScore(raw){
    if (raw == null) return 0;
    if (typeof raw === 'object'){
      if (Array.isArray(raw)){
        const first = raw.find(v => v != null);
        return extractScore(first);
      }
      const keys = ['score','value','val','v','rank','answer','rating','points'];
      for (const key of keys){
        if (raw[key] != null) return extractScore(raw[key]);
      }
      return 0;
    }
    if (typeof raw === 'string'){
      const txt = raw.trim();
      if (!txt) return 0;
      if (/^\d+%$/.test(txt)){
        const pct = Number(txt.slice(0, -1));
        return Number.isFinite(pct) ? pct / 20 : 0;
      }
      if (/^\d+\s*\/\s*\d+$/.test(txt)){
        const [a, b] = txt.split('/').map(s => Number(s.trim()));
        if (Number.isFinite(a) && Number.isFinite(b) && b) return a * (5 / b);
      }
      const n = Number(txt);
      if (Number.isFinite(n)) return n;
      return 0;
    }
    if (typeof raw === 'number') return raw;
    return 0;
  }

  function normalizeSurvey(json){
    const map = new Map();
    const add = (id, val) => {
      const key = sTrim(id);
      if (!key) return;
      map.set(key, clamp05(val));
    };
    const fromArray = (arr, prefix='item') => {
      if (!Array.isArray(arr)) return;
      const base = sTrim(prefix) || 'item';
      arr.forEach((entry, idx) => {
        if (entry == null) return;
        let id = '';
        if (typeof entry === 'object' && !Array.isArray(entry)){
          id = entry.id ?? entry.key ?? entry.name ?? entry.label ?? entry.slug ?? '';
        }
        if (!id) id = `${base}_${idx + 1}`;
        add(id, extractScore(entry));
      });
    };

    if (!json) return {map,count:0};
    if (Array.isArray(json)){
      fromArray(json);
      return {map,count:map.size};
    }
    if (json.answers && typeof json.answers==='object' && !Array.isArray(json.answers)){
      for (const [k, v] of Object.entries(json.answers)) add(k, extractScore(v));
      return {map,count:map.size};
    }
    if (Array.isArray(json.answers)){
      fromArray(json.answers, 'answer');
      return {map,count:map.size};
    }
    if (Array.isArray(json.cells)){
      fromArray(json.cells, 'cell');
      return {map,count:map.size};
    }
    if (Array.isArray(json.rows)){
      fromArray(json.rows, 'row');
      return {map,count:map.size};
    }
    if (Array.isArray(json.data)){
      fromArray(json.data, 'data');
      return {map,count:map.size};
    }
    if (Array.isArray(json?.data?.cells)){
      fromArray(json.data.cells, 'cell');
      return {map,count:map.size};
    }
    if (json.map && typeof json.map === 'object'){
      for (const [k, v] of Object.entries(json.map)) add(k, extractScore(v));
      if (map.size) return {map,count:map.size};
    }

    if (json && typeof json === 'object'){
      for (const [k, v] of Object.entries(json)){
        if (/^(schema|meta|page|site|exportedAt)$/i.test(k)) continue;
        if (Array.isArray(v)){
          fromArray(v, k || 'item');
        } else if (v && typeof v === 'object' && !Array.isArray(v)){
          const id = sTrim(v.id ?? v.key ?? v.name ?? v.label ?? k);
          add(id || k, extractScore(v));
        } else {
          add(k, extractScore(v));
        }
      }
    }

    return {map,count:map.size};
  }

  // Keep a single global store
  window._tkCompat = window._tkCompat || { A:null, B:null };

  // ---------- recompute / render ----------
  function defaultRender(){
    const A = window._tkCompat.A?.map || new Map();
    const B = window._tkCompat.B?.map || new Map();
    const keys = new Set([...A.keys(), ...B.keys()]);
    const tbody = document.querySelector('#compatTable tbody') || document.querySelector('table tbody');

    if(!tbody){
      console.info('[compat] (no table tbody found) filled Partner A cells:',
                   [...A.values()].filter(v=>v!=null).length,
                   '; Partner B cells:',
                   [...B.values()].filter(v=>v!=null).length);
      return;
    }

    tbody.innerHTML = '';
    keys.forEach(k=>{
      const a = A.get(k), b = B.get(k);
      const match = (a==null || b==null) ? '—' : Math.round((1 - Math.abs(a-b)/5)*100);
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${k}</td>
                      <td class="ta-c">${a==null?'—':a}</td>
                      <td class="ta-c">${match}</td>
                      <td class="ta-c">${b==null?'—':b}</td>`;
      tbody.appendChild(tr);
    });

    console.info('[compat] filled Partner A cells:',
                 [...A.values()].filter(v=>v!=null).length,
                 '; Partner B cells:',
                 [...B.values()].filter(v=>v!=null).length);
  }

  function recompute(){
    // If your page already exposes a recompute hook, use it. Else do the default.
    if (typeof window._tkCompatRecompute === 'function') {
      try { window._tkCompatRecompute(); return; } catch(e){ console.warn(e); }
    }
    defaultRender();
  }

  // ---------- partner detection ----------
  let lastIntent = null;
  let lastIntentAt = 0;

  // Remember which upload button was clicked most recently
  document.addEventListener('click', (e)=>{
    const btn = e.target.closest('button,a,input[type="button"],input[type="submit"]');
    if(!btn) return;
    const txt = (btn.textContent || btn.value || '').toLowerCase();
    if(/partner.?s?\s+survey|partner\b/.test(txt)) { lastIntent = 'B'; lastIntentAt = Date.now(); }
    else if(/your\s+survey|upload\s+your|^back$/.test(txt)) { lastIntent = 'A'; lastIntentAt = Date.now(); }
  }, true);

  // Strong signal from input attributes
  function detectPartnerFromInput(input){
    const bag = [
      input.dataset?.partner,
      input.name, input.id,
      input.getAttribute('aria-label'),
      input.getAttribute('title')
    ].filter(Boolean).join(' ').toLowerCase();

    if(/\b(b|partner\s*b|survey\s*b|file\s*b)\b/.test(bag)) return 'B';
    if(/\b(a|partner\s*a|survey\s*a|file\s*a)\b/.test(bag)) return 'A';

    const lbl = input.closest('label')?.textContent?.toLowerCase() || '';
    const near = input.closest('form,section,div')?.textContent?.slice(0,200)?.toLowerCase() || '';
    const around = lbl + ' ' + near;
    if(/partner[^a-z]*b/.test(around)) return 'B';
    if(/your.*survey|partner[^a-z]*a/.test(around)) return 'A';
    return null;
  }

  // Fallback ordering across inputs
  const inputSeen = [];
  function fallbackSlotFor(input){
    if(!inputSeen.includes(input)) inputSeen.push(input);
    // first file input we ever see → A, second → B
    return inputSeen.indexOf(input) === 0 ? 'A' : 'B';
  }

  // ---------- wire uploads (single capture listener) ----------
  function wireUploads(){
    document.addEventListener('change', (e)=>{
      const el = e.target;
      if(!(el instanceof HTMLInputElement) || el.type !== 'file') return;
      const file = el.files && el.files[0];
      if(!file) return;

      // decide who
      let who = detectPartnerFromInput(el);
      if(!who && lastIntent && Date.now() - lastIntentAt < 8000) who = lastIntent; // use recent button click (8s window)
      if(!who) who = fallbackSlotFor(el);

      const reader = new FileReader();
      reader.onload = () => {
        try {
          const raw = String(reader.result || '');
          const clean = raw.replace(/^\uFEFF/, '').trim();
          const parser = window.TK_LABELS?.parseSurveyJSON;
          const json = parser ? parser(clean) : JSON.parse(clean);
          const norm = normalizeSurvey(json);
          window._tkCompat[who] = norm;
          console.info(`[compat] stored Survey ${who} with ${norm.count} answers`);
          recompute();
        } catch (err) {
          console.error('[compat] parse/normalize failed:', err);
          alert(`Invalid JSON for Survey ${who}. Please upload the unmodified JSON file exported from this site.`);
        }
      };
      reader.onerror = () => {
        alert(`Could not read file (${reader.error || 'unknown error'})`);
      };
      reader.readAsText(file);
      try { el.value = ''; } catch (_) {}
    }, true);

    // small visual centering helper
    const st = document.createElement('style');
    st.textContent = `.ta-c{text-align:center} table td,table th{vertical-align:middle}`;
    document.head.appendChild(st);
  }

  if(document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', wireUploads);
  } else {
    wireUploads();
  }
})();
</script>
<script>
(() => {
  /**
   * Compatibility table enhancer:
   *  1) Inserts a compact summary under each Category code (first column)
   *  2) Renders a percentage bar in the “Match %” column
   *
   * Notes:
   *  - If you expose an index like window.tkKinksIndex[code] = { short/name/label },
   *    that label is used. Otherwise a readable version of the code is derived.
   *  - If a numeric percent already exists in the “Match %” cell, it’s reused.
   *    Otherwise a visual percent is computed from the two 0–5 ratings.
   */

  // ---------- helpers ----------
  const $ = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

  // Friendly human label from code (fallback)
  const friendly = id => id
    .replace(/^cb[_-]/i, '')            // drop common prefix
    .replace(/[_-]+/g, ' ')
    .replace(/\b\w/g, m => m.toUpperCase());  // title-case

  // Try to read a short label from a global index; fallback to friendlyizer
  function getSummaryFor(id){
    const ix = window.tkKinksIndex || window.tkKinks || window.KINKS_INDEX;
    if (ix && ix[id]) {
      return ix[id].short || ix[id].name || ix[id].label || friendly(id);
    }
    return friendly(id);
  }

  // Compute a visual % if table hasn’t put one there. Based on 0–5 scale:
  // equal = 100%, 1 step apart = 80%, …, 5 apart = 0%.
  const visualPercent = (a, b) => {
    if (a == null || b == null || a === '' || b === '' || isNaN(a) || isNaN(b)) return null;
    const av = Number(a), bv = Number(b);
    if (!isFinite(av) || !isFinite(bv)) return null;
    const pct = Math.max(0, 100 - 20 * Math.abs(av - bv));
    return Math.round(pct);
  };

  const numInCell = td => {
    const t = (td?.textContent || '').trim();
    const n = Number(t);
    return Number.isFinite(n) ? n : null;
  };

  // ---------- find the compatibility table ----------
  const table = $$('table').find(t => {
    const ths = $$('thead th, tr:first-child th', t).map(th => (th.textContent||'').trim().toLowerCase());
    return ths.length >= 3 &&
           ths[0].startsWith('category') &&
           ths.some(h => h.includes('match')) &&
           ths.some(h => h.includes('partner a'));
  });
  if (!table) return;

  // Identify column indexes (fallbacks if head cells aren’t present)
  const headCells = $$('thead tr th', table);
  const getColIndex = (needle) => {
    const idx = headCells.findIndex(th => (th.textContent||'').toLowerCase().includes(needle));
    return idx >= 0 ? idx : null;
  };
  const colCategory = getColIndex('category') ?? 0;
  const colA        = getColIndex('partner a') ?? 1;
  const colMatch    = getColIndex('match') ?? 2;
  const colB        = getColIndex('partner b') ?? 3;

  // Process rows (supports tables without <tbody>)
  const rows = $$('tbody tr', table).length ? $$('tbody tr', table) : $$('tr', table).slice(1);

  rows.forEach(tr => {
    const tds = $$('td', tr);
    if (tds.length < Math.max(colB, colMatch, colCategory) + 1) return;

    // 1) Category subtitle
    const tdCat = tds[colCategory];
    const code  = (tdCat.textContent || '').trim();
    if (code) {
      tdCat.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.className = 'tk-catwrap';
      const codeEl = document.createElement('div');
      codeEl.className = 'tk-code';
      codeEl.textContent = code;
      const subEl = document.createElement('div');
      subEl.className = 'tk-sub';
      subEl.textContent = getSummaryFor(code);
      subEl.title = subEl.textContent; // full on hover
      wrap.append(codeEl, subEl);
      tdCat.append(wrap);
    }

    // 2) Match % meter
    const tdA = tds[colA], tdB = tds[colB], tdM = tds[colMatch];
    const aVal = numInCell(tdA), bVal = numInCell(tdB);

    // If a percent already exists, reuse it; else compute visual percent
    let pct = null;
    const existing = (tdM.textContent || '').trim();
    const existingNum = Number(existing.replace('%',''));
    if (Number.isFinite(existingNum)) {
      pct = Math.max(0, Math.min(100, Math.round(existingNum)));
    } else {
      pct = visualPercent(aVal, bVal);
    }

    tdM.innerHTML = '';
    if (pct == null) {
      tdM.textContent = '—';
    } else {
      const meter = document.createElement('div');
      meter.className = 'tk-meter';
      const fill = document.createElement('div');
      fill.className = 'tk-fill';
      fill.style.width = pct + '%';
      meter.appendChild(fill);

      const label = document.createElement('span');
      label.className = 'tk-pct';
      label.textContent = pct + '%';
      tdM.append(meter, label);
    }
  });
})();
</script>
<script>
(() => {
  const isNum = v => typeof v === 'number' && Number.isFinite(v);
  const clean = s => (s || '').toString().replace(/\s+/g, ' ').trim();
  const shortLabel = (s, max = 44) => {
    s = clean(s).replace(/[\u2013\u2014\-•]+/g, '-');
    if (s.length <= max) return s;
    const cut = s.slice(0, max).lastIndexOf(' ');
    return (cut > 24 ? s.slice(0, cut) : s.slice(0, max - 1)) + '…';
  };

  function pickStoredSurvey() {
    const keys = [
      'tk:compat:a',
      'tk:compat:b',
      'tk:survey:a',
      'tk:survey:b',
      'tk:compat:survey:a',
      'tk:compat:survey:b'
    ];
    const out = {};
    keys.forEach(k => {
      try {
        const v = localStorage.getItem(k);
        if (v) out[k] = JSON.parse(v);
      } catch (err) {
        console.warn('[compat] Failed to parse stored survey', k, err);
      }
    });
    return out;
  }

  function buildLabelMap(surv) {
    const map = {};
    if (!surv) return map;
    const pools = [
      surv.answers,
      surv.categories,
      surv.questions,
      surv.items,
      surv.data
    ].filter(Boolean);

    for (const arr of pools) {
      if (!Array.isArray(arr)) continue;
      for (const it of arr) {
        const id = it?.id || it?.key || it?.code || it?.slug;
        if (!id) continue;
        const title = it?.title || it?.label || it?.name || it?.question || it?.q || it?.text || it?.desc;
        if (title && !map[id]) map[id] = clean(title);
      }
    }

    (Array.isArray(surv.answers) ? surv.answers : []).forEach(a => {
      const id = a?.id;
      const t = a?.meta?.title || a?.meta?.label;
      if (id && t && !map[id]) map[id] = clean(t);
    });
    return map;
  }

  function matchPercent(a, b, max = 5) {
    if (!isNum(a) || !isNum(b)) return null;
    const diff = Math.abs(a - b);
    return Math.round((1 - diff / max) * 100);
  }

  function findCompatTable() {
    const tables = [...document.querySelectorAll('table')];
    return tables.find(t => {
      const hs = [...t.querySelectorAll('thead th, tr:first-child th')]
        .map(e => clean(e.textContent).toLowerCase());
      return hs.includes('category') && hs.includes('partner a') && hs.includes('partner b');
    });
  }

  function upgradeTable() {
    const table = findCompatTable();
    if (!table) return;

    const store = pickStoredSurvey();
    const maps = Object.values(store).map(buildLabelMap);
    const labelFor = (id) => {
      for (const m of maps) {
        if (m && m[id]) return m[id];
      }
      return null;
    };

    const rows = [...table.querySelectorAll('tbody tr')];
    rows.forEach(tr => {
      const tds = [...tr.children];
      if (tds.length < 4) return;

      const [tdCat, tdA, tdMatch, tdB] = tds;
      if (!tdCat.querySelector('.tk-cat, .tk-catwrap, .tk-cat-wrap')) {
        const idText = clean(tdCat.textContent);
        const full = labelFor(idText);
        if (full) {
          const short = shortLabel(full);
          tdCat.textContent = '';
          const span = document.createElement('span');
          span.className = 'tk-cat';
          span.textContent = short;
          span.setAttribute('data-full', '1');
          span.title = full;
          tdCat.appendChild(span);
        } else {
          tdCat.classList.add('tk-cat');
        }
      }

      if (tdMatch.querySelector('.tk-bar, .tk-match-chip, .tk-meter')) return;

      const existingMatch = tdMatch.textContent;
      const a = parseFloat(clean(tdA.textContent).replace(/[^\d.-]/g, ''));
      const b = parseFloat(clean(tdB.textContent).replace(/[^\d.-]/g, ''));
      const pct = matchPercent(a, b, 5);

      tdMatch.textContent = '';
      if (pct == null) {
        const fallback = clean(existingMatch);
        tdMatch.textContent = fallback || '—';
        return;
      }
      const bar = document.createElement('div');
      bar.className = 'tk-bar';
      bar.style.setProperty('--pct', pct + '%');

      const fill = document.createElement('i');
      const label = document.createElement('span');
      label.textContent = pct + '%';

      bar.appendChild(fill);
      bar.appendChild(label);
      tdMatch.appendChild(bar);
    });
  }

  const kick = () => requestAnimationFrame(() => setTimeout(upgradeTable, 60));
  window.addEventListener('load', kick);
  document.addEventListener('DOMContentLoaded', kick);
  window.addEventListener('tk:compat:rendered', upgradeTable);
})();
</script>
<script>
/* =========================================================================
   KSV COMPAT: accept same JSON for A & B, tolerant parsing, and
   hijack existing file-input listeners so legacy "invalid" alert can't fire.
   Paste once near </body> in compatibility.html.
   ======================================================================= */

/* Globals your existing code can consume */
window.ksvSurveyA = window.ksvSurveyA || null;
window.ksvSurveyB = window.ksvSurveyB || null;

/* ------ tolerant parser (handles BOM, different shapes) ------ */
function ksvParseSurveyJsonText(rawText, who) {
  if (typeof rawText !== 'string') return { ok:false, reason:'Internal: non-string' };
  const text = rawText.replace(/^\uFEFF/, '').trim();       // strip BOM
  let obj;
  try { obj = JSON.parse(text); }
  catch { return { ok:false, reason:'Not valid JSON' }; }

  const tidyKey = (value, fallbackIndex) => {
    if (typeof value === 'string' && value.trim()) return value.trim();
    if (typeof value === 'number' && Number.isFinite(value)) return String(value);
    return `item_${fallbackIndex + 1}`;
  };

  const extractValue = (raw) => {
    if (raw == null) return null;
    if (Array.isArray(raw)) {
      for (const entry of raw) {
        const v = extractValue(entry);
        if (v != null) return v;
      }
      return null;
    }
    if (typeof raw === 'object') {
      const keys = ['rating','value','score','answer','val','v','points','cells','selected','selectedValue','result'];
      for (const key of keys) {
        if (raw[key] != null) return extractValue(raw[key]);
      }
      return null;
    }
    if (typeof raw === 'string') {
      const trimmed = raw.trim();
      if (!trimmed) return null;
      if (/^\d+%$/.test(trimmed)) {
        const pct = Number(trimmed.slice(0, -1));
        if (Number.isFinite(pct)) return pct / 20;
      }
      if (/^\d+\s*\/\s*\d+$/.test(trimmed)) {
        const [a, b] = trimmed.split('/').map((s) => Number(s.trim()));
        if (Number.isFinite(a) && Number.isFinite(b) && b) return (a / b) * 5;
      }
      const asNum = Number(trimmed);
      return Number.isFinite(asNum) ? asNum : null;
    }
    if (typeof raw === 'number') return raw;
    return null;
  };

  const clamp05 = (value) => {
    const num = Number(value);
    if (!Number.isFinite(num)) return 0;
    if (num > 5 && num <= 10) return Math.max(0, Math.min(5, num / 2));
    return Math.max(0, Math.min(5, num));
  };

  const entries = [];
  const pushEntry = (key, value) => {
    const numeric = extractValue(value);
    if (numeric == null) return;
    const entryKey = tidyKey(key, entries.length);
    const safeValue = clamp05(numeric);
    entries.push([entryKey, safeValue]);
  };

  const fromArray = (arr) => {
    if (!Array.isArray(arr)) return;
    arr.forEach((entry, idx) => {
      if (entry == null) return;
      if (typeof entry === 'object' && !Array.isArray(entry)) {
        const key = entry.key ?? entry.id ?? entry.code ?? entry.slug ?? entry.name ?? entry.label ?? entry.question;
        pushEntry(key ?? `item_${idx + 1}`, entry);
      } else {
        pushEntry(`item_${idx + 1}`, entry);
      }
    });
  };

  const fromKeyMap = (maybeMap) => {
    if (!maybeMap || typeof maybeMap !== 'object' || Array.isArray(maybeMap)) return;
    const sorted = Object.entries(maybeMap).sort(([ak], [bk]) => {
      const na = Number(ak);
      const nb = Number(bk);
      const fa = Number.isFinite(na);
      const fb = Number.isFinite(nb);
      if (fa && fb) return na - nb;
      if (fa) return -1;
      if (fb) return 1;
      return String(ak).localeCompare(String(bk));
    });
    sorted.forEach(([key, value]) => pushEntry(key, value));
  };

  if (Array.isArray(obj?.answers)) fromArray(obj.answers);
  if (!entries.length && Array.isArray(obj)) fromArray(obj);
  if (!entries.length && Array.isArray(obj?.cells)) fromArray(obj.cells);
  if (!entries.length && Array.isArray(obj?.data?.cells)) fromArray(obj.data.cells);
  if (!entries.length) {
    fromKeyMap(obj?.answersByKey);
    fromKeyMap(obj?.data?.answersByKey);
    fromKeyMap(obj?.data?.ratings);
    fromKeyMap(obj?.data?.answers);
    fromKeyMap(obj?.map);
    fromKeyMap(obj?.data?.map);
  }

  if (!entries.length) return { ok:false, reason:'Missing answers/cells array' };

  const answers = {};
  const cells = [];
  entries.forEach(([key, value]) => {
    answers[key] = value;
    cells.push(value);
  });
  const answersByKey = Object.assign({}, answers);

  if (cells.length !== 35) return { ok:false, reason:`Expected 35 answers, got ${cells.length}` };

  console.log(`[compat] stored Survey ${who} with ${cells.length} answers`);
  return { ok:true, cells, survey: { answers, answersByKey } };
}

/* ------ file → text ------ */
function ksvReadFileAsText(file) {
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = () => resolve(String(fr.result || ''));
    fr.onerror = () => reject(fr.error || new Error('read failed'));
    fr.readAsText(file);
  });
}

/* ------ trigger your table refresh ------ */
function ksvRefreshUI(who) {
  // Call whichever hook exists in your page
  if (typeof window.ksvOnSurveyLoaded === 'function') {
    who && window.ksvOnSurveyLoaded(who, who === 'A' ? window.ksvSurveyA : window.ksvSurveyB);
  } else if (typeof window.updateComparison === 'function') {
    window.updateComparison();
  }
}

/* ------ core hijacker: capture file inputs and own the event ------ */
async function ksvHandleFileInput(ev) {
  const input = ev.target;
  if (!(input instanceof HTMLInputElement)) return;

  // Only handle JSON file pickers
  const isFile = input.type === 'file';
  const accept = (input.getAttribute('accept') || '').toLowerCase();
  if (!isFile || (!accept.includes('json') && !accept.includes('.json'))) return;

  // Stop legacy listeners from running
  ev.stopImmediatePropagation();
  ev.preventDefault();

  const file = input.files && input.files[0];
  if (!file) return;

  // Decide A or B. Heuristics: id/name contains 'b' → B, else
  // if A is empty → A; else if B empty → B; else default to A.
  const idn = ((input.id || '') + ' ' + (input.name || '')).toLowerCase();
  let who = idn.includes('partnerb') || idn.includes('surveyb') || idn.includes('uploadb') || /\b[b]\b/.test(idn)
            ? 'B'
            : idn.includes('partnera') || idn.includes('surveya') || idn.includes('uploada')
            ? 'A'
            : (Array.isArray(window.ksvSurveyA) ? (Array.isArray(window.ksvSurveyB) ? 'A' : 'B') : 'A');

  try {
    const text = await ksvReadFileAsText(file);
    const parsed = ksvParseSurveyJsonText(text, who);
    if (!parsed.ok) {
      alert(`Invalid JSON for Survey ${who}.\nReason: ${parsed.reason}\nPlease upload the unmodified JSON file exported from this site.`);
      console.warn(`[compat] Survey ${who} rejected: ${parsed.reason}`);
      return;
    }

    const surveyJson = parsed.survey || { answers: {} };
    let processed = null;
    try {
      if (typeof window.tkProcessSurvey === 'function') {
        processed = window.tkProcessSurvey(who, surveyJson);
      } else {
        const handler = who === 'A' ? window.processSurveyA : window.processSurveyB;
        processed = typeof handler === 'function' ? handler(surveyJson) : null;
      }
    } catch (err) {
      console.error(`[compat] Survey ${who} normalization failed`, err);
      alert(`Invalid JSON for Survey ${who}. Please upload the unmodified JSON file exported from this site.`);
      return;
    }

    if (!processed) {
      window._tkReady = window._tkReady || { A:false, B:false };
      window._tkReady[who] = false;
      console.warn(`[compat] Survey ${who} processor returned nothing`);
      return;
    }

    window._tkReady = window._tkReady || { A:false, B:false };
    window._tkReady[who] = true;

    if (who === 'A') window.ksvSurveyA = parsed.cells;
    if (who === 'B') window.ksvSurveyB = parsed.cells;

    console.log(`[compat] filled Partner ${who} cells: ${parsed.cells.length}`);
    if (typeof window.maybeUpdateComparison === 'function') {
      window.maybeUpdateComparison();
    }
    ksvRefreshUI(who);
  } finally {
    // Allow selecting the *same* file again (browsers suppress change otherwise)
    input.value = '';
  }
}

/* Attach capture listeners to any current or future file inputs */
function ksvBindAllFileInputs(root = document) {
  root.querySelectorAll('input[type="file"]').forEach((inp) => {
    if (!inp.__ksvHijacked) {
      inp.addEventListener('change', ksvHandleFileInput, true); // capture
      inp.__ksvHijacked = true;
    }
  });
}
ksvBindAllFileInputs(document);

/* Observe future additions (dialogs creating inputs late, etc.) */
const mo = new MutationObserver((muts) => {
  for (const m of muts) {
    m.addedNodes && m.addedNodes.forEach((n) => {
      if (n.nodeType === 1) ksvBindAllFileInputs(n);
    });
  }
});
mo.observe(document.documentElement, { childList: true, subtree: true });

/* Optional convenience: button to copy A → B for solo testing
   Add this in your HTML if you want:
   <button id="copyAtoB" class="themed-button">Use A for B</button>
*/
document.getElementById('copyAtoB')?.addEventListener('click', () => {
  if (!Array.isArray(window.ksvSurveyA) || window.ksvSurveyA.length !== 35) {
    alert('Load Survey A first, then copy it to B.'); return;
  }
  window.ksvSurveyB = [...window.ksvSurveyA];
  console.log('[compat] Partner B set from Partner A');
  ksvRefreshUI('B');
});
</script>
<!-- ===== TALK KINK — Compatibility labels + % bars (DOM & PDF) ===== -->
<script>
(function(){
  const CB_RE = /\bcb_[a-z0-9]{5}\b/i;
  const LABEL_SOURCES = ["/data/labels.json","/data/labels-overrides.json"];
  const KINKS_BANK_URL = "/data/kinks.json";
  const INLINE_LABELS = {};       // add hard overrides here if you like
  const LABELS = Object.create(null);
  const tidy = s => String(s ?? "").trim();

  async function fetchJSON(url){
    try{
      const r = await fetch(url, { cache: "no-store" });
      if (!r.ok) return null;
      const ct = r.headers.get("content-type") || "";
      const t  = await r.text();
      if (/html/i.test(ct) || /^\s*<!doctype/i.test(t)) return null;
      return JSON.parse(t);
    }catch{ return null; }
  }
  function addLabelMap(obj){
    if (!obj || typeof obj !== "object") return;
    for (const [k,v] of Object.entries(obj)) {
      if (CB_RE.test(k) && tidy(v)) LABELS[k.toLowerCase()] = tidy(v);
    }
  }
  async function loadLabels(){
    for (const u of LABEL_SOURCES){ const j = await fetchJSON(u); if (j) addLabelMap(j); }
    const bank = await fetchJSON(KINKS_BANK_URL);
    if (bank){
      const cats = Array.isArray(bank) ? bank
                : Object.entries(bank).map(([category,items])=>({category,items}));
      for (const c of cats){
        const items = Array.isArray(c.items)
          ? c.items
          : (c.items && typeof c.items === "object")
            ? Object.values(c.items)
            : [];
        for (const it of items){
          const key = tidy(it.id || it.key || ""); const label = tidy(it.label || it.text || it.name || "");
          if (CB_RE.test(key) && label) LABELS[key.toLowerCase()] = label;
        }
      }
    }
    addLabelMap(INLINE_LABELS);
  }

  function injectBarCSS(){
    if (document.getElementById("tk-pctbar-css")) return;
    const s = document.createElement("style");
    s.id = "tk-pctbar-css";
    s.textContent = `
      td.pct-cell{min-width:5.5rem}
      .pct{position:relative;height:1.15em;line-height:1.15em}
      .pct .bar{position:absolute;inset:0 auto 0 0;width:0;background:rgba(0,230,255,.25);border-radius:2px}
      .pct .txt{position:relative;display:block;text-align:center}
    `;
    document.head.appendChild(s);
  }
  function labelFor(code){ const k = code?.toLowerCase?.(); return (k && LABELS[k]) || code; }

  function findColIdxByHeader(table, includesText){
    const head = table.tHead || table.querySelector("thead");
    const row  = head ? head.rows[0] : table.rows[0];
    if (!row) return -1;
    for (let i=0;i<row.cells.length;i++){
      const txt = tidy(row.cells[i].textContent).toLowerCase();
      if (txt.includes(includesText)) return i;
    }
    return -1;
  }

  let compatObserver = null;
  let compatTimer = 0;
  let compatBusy = false;
  let compatRoot = null;

  function observerRoot(){
    if (compatRoot && compatRoot.isConnected) return compatRoot;
    compatRoot = document.querySelector("main") || document.body;
    return compatRoot;
  }

  function scheduleRelabel(){
    clearTimeout(compatTimer);
    compatTimer = window.setTimeout(() => {
      compatTimer = 0;
      relabelAndBars();
    }, 120);
  }

  function observe(){
    const root = observerRoot();
    if (!root) return;
    if (!compatObserver){
      compatObserver = new MutationObserver(() => {
        scheduleRelabel();
      });
    }
    compatObserver.observe(root, { childList:true, subtree:true });
  }

  function relabelAndBars(){
    if (compatBusy){
      scheduleRelabel();
      return;
    }
    compatBusy = true;
    clearTimeout(compatTimer);
    compatTimer = 0;
    try {
      if (compatObserver) compatObserver.disconnect();
      injectBarCSS();
      const tables = Array.from(document.querySelectorAll("table"));
      if (tables.length){
        let catCol=-1, pctCol=-1;
        for (const t of tables){
          if (catCol < 0) catCol = findColIdxByHeader(t, "category");
          if (pctCol < 0) pctCol = findColIdxByHeader(t, "match");
        }
        if (catCol < 0) catCol = 0;
        if (pctCol < 0) pctCol = 2;

        for (const tbl of tables){
          const body = tbl.tBodies[0] || tbl;
          Array.from(body.rows).forEach(tr=>{
            const c = tr.cells[catCol];
            if (c){
              const current = tidy(c.textContent);
              if (c.dataset.tkLabelValue !== current){
                const m = current.match(CB_RE);
                if (m){
                  const pretty = labelFor(m[0]);
                  if (pretty && pretty !== m[0]) c.textContent = pretty;
                }
                c.dataset.tkLabelValue = tidy(c.textContent);
              }
            }
            const p = tr.cells[pctCol];
            if (p){
              p.classList.add("pct-cell");
              const text = tidy(p.textContent);
              if (p.dataset.tkPctValue !== text){
                const m = text.match(/^(\d{1,3})%$/);
                if (m){
                  const pct = Math.max(0, Math.min(100, parseInt(m[1],10)));
                  const wrap = document.createElement("div");
                  wrap.className = "pct";
                  wrap.innerHTML = '<span class="bar" style="width:'+pct+'%"></span><span class="txt">'+text+'</span>';
                  p.innerHTML = "";
                  p.appendChild(wrap);
                } else {
                  p.innerHTML = '<span class="txt">'+text+'</span>';
                }
                p.dataset.tkPctValue = tidy(p.textContent);
              }
            }
          });
        }
      }
    } finally {
      compatBusy = false;
      observe();
    }
  }

  function patchAutoTableBars(){
    const JSPDF = window.jspdf && window.jspdf.jsPDF;
    if (!JSPDF) return;
    const proto = JSPDF.API;
    if (!proto || !proto.autoTable || proto.autoTable.__tkPatched) return;

    const orig = proto.autoTable;
    proto.autoTable = function(opts){
      const user = opts && opts.didDrawCell;
      const wrapped = Object.assign({}, opts, {
        didDrawCell: function(data){
          if (typeof user === "function") try{ user.call(this, data); }catch(e){}
          if (data.section === "body" && data.column.index === 2){
            const raw = String(data.cell.raw ?? "").trim();
            const m = raw.match(/^(\d{1,3})%$/);
            if (m){
              const pct = Math.max(0, Math.min(100, parseInt(m[1],10)));
              const pad = 1;
              const x = data.cell.x + pad;
              const y = data.cell.y + data.cell.height - 2.2;
              const w = Math.max(0, data.cell.width - pad*2) * (pct/100);
              this.setFillColor(0,230,255);
              this.rect(x, y, w, 1.8, "F");
            }
          }
        }
      });
      wrapped.__tkFromPatched = true;
      return orig.call(this, wrapped);
    };
    proto.autoTable.__tkPatched = true;
  }

  function wrapExporter(name){
    const fn = window[name];
    if (!fn || fn.__tkWrapped) return false;
    window[name] = async function(...args){
      await loadLabels();
      relabelAndBars();
      patchAutoTableBars();
      return await fn.apply(this, args);
    };
    window[name].__tkWrapped = true;
    return true;
  }

  function wrapKnownExporters(){
    ["TKPDF_export","exportCompatibilityPdf","downloadPdf","generatePdf","TKPDF_forceDark"].forEach(wrapExporter);
  }

  async function init(){
    await loadLabels();
    wrapKnownExporters();
    relabelAndBars();
  }
  (document.readyState === "loading")
    ? document.addEventListener("DOMContentLoaded", init, { once:true })
    : init();
})();
</script>
<!-- ===== /END TALK KINK patch ===== -->
<!-- ===== Paste EVERYTHING below near the end of compatibility.html (just before </body>) ===== -->

<!-- 1) PDF libraries (keep both) -->
<script defer src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js"></script>

<!-- 2) Optional style so the button looks disabled until both files are uploaded -->
<style>
  #downloadPdf[disabled] {
    opacity: .45;
    cursor: not-allowed;
    filter: grayscale(30%);
  }
</style>

<!-- 3) EXACT BEHAVIOR YOU ASKED FOR:
      • NO auto-downloads at all
      • Enable “Download PDF” only when BOTH surveys are present
      • Only download when the user clicks the button
      • Also blocks any leftover “auto-download” code that might still be on the page -->
<script>
(() => {
  /* -----------------------------------------------------------
   * CONFIG — adjust selectors if yours differ
   * --------------------------------------------------------- */
  const FILE_INPUT_SELECTORS = [
    '#surveyA', '#surveyB',           // common ids in your app
    '#surveyAInput', '#surveyBInput',
    '#fileA', '#fileB'
  ];
  const TABLE_CANDIDATES = [
    '#compat-table table', '#compatTable', '.compat-table table', 'table'
  ];
  const CONTAINER_CANDIDATES = ['#compat-table', '.compat-table', 'main', 'body'];
  const DOWNLOAD_BTN_ID = 'downloadPdf'; // give your button this id

  /* -----------------------------------------------------------
   * 0) HARD STOP any old “auto-download” scripts
   *    (monkey-patch jsPDF.save so it only runs after a user click)
   * --------------------------------------------------------- */
  window.__TK_PDF_CLICK_REQUIRED = true;       // require explicit click
  window.__TK_PDF_CLICK_OK = false;            // becomes true during the click only

  function getJsPDF() {
    return (window.jspdf && window.jspdf.jsPDF) || window.jsPDF || null;
  }
  function installSaveGuard() {
    try {
      const Ctor = getJsPDF();
      if (!Ctor || Ctor.prototype.__tkSaveWrapped) return;
      const origSave = Ctor.prototype.save;
      Ctor.prototype.save = function guardedSave() {
        if (window.__TK_PDF_CLICK_REQUIRED && !window.__TK_PDF_CLICK_OK) {
          console.warn('[TK-PDF] Blocked non-click PDF save (auto-download suppressed).');
          return;
        }
        return origSave.apply(this, arguments);
      };
      Ctor.prototype.__tkSaveWrapped = true;
      console.info('[TK-PDF] Save() guard installed');
    } catch (_) {}
  }
  // Try to install guard as libs load
  document.addEventListener('DOMContentLoaded', () => {
    installSaveGuard();
    const guardProbe = setInterval(() => {
      installSaveGuard();
      if (getJsPDF() && getJsPDF().prototype.__tkSaveWrapped) clearInterval(guardProbe);
    }, 200);
    setTimeout(() => clearInterval(guardProbe), 8000);
  });

  /* -----------------------------------------------------------
   * 1) Helpers
   * --------------------------------------------------------- */
  function findTable() {
    for (const sel of TABLE_CANDIDATES) {
      const t = document.querySelector(sel);
      if (t) return t;
    }
    return null;
  }
  function bothPartnersReady() {
    // Preferred: use live counts if your app exposes them (from your logs: aCells/bCells)
    if (window.tkCompat &&
        typeof tkCompat.aCells === 'number' &&
        typeof tkCompat.bCells === 'number') {
      return tkCompat.aCells > 0 && tkCompat.bCells > 0;
    }
    // Fallback: inspect table columns for any non-empty Partner A and B cells
    const table = findTable();
    if (!table) return false;
    const thead = table.querySelector('thead');
    const headers = thead ? Array.from(thead.querySelectorAll('th')).map(th => th.textContent.trim().toLowerCase()) : [];
    const aIdx = headers.findIndex(h => h.includes('partner a'));
    const bIdx = headers.findIndex(h => h.includes('partner b'));
    if (aIdx === -1 || bIdx === -1) return false;
    const rows = table.querySelectorAll('tbody tr');
    let haveA = false, haveB = false;
    for (const tr of rows) {
      const tds = tr.children;
      if (tds[aIdx] && tds[aIdx].textContent.trim() !== '') haveA = true;
      if (tds[bIdx] && tds[bIdx].textContent.trim() !== '') haveB = true;
      if (haveA && haveB) return true;
    }
    return false;
  }
  function setDownloadEnabled(enabled) {
    const btn = document.getElementById(DOWNLOAD_BTN_ID);
    if (!btn) return;
    btn.disabled = !enabled;
    btn.setAttribute('aria-disabled', String(!enabled));
    btn.title = enabled ? 'Download comparison PDF' : 'Upload both surveys to enable';
  }

  function getAutoTableRunner(doc) {
    if (doc && typeof doc.autoTable === 'function') {
      return (opts) => doc.autoTable(opts);
    }
    if (window.jspdf && typeof window.jspdf.autoTable === 'function') {
      return (opts) => window.jspdf.autoTable(doc, opts);
    }
    if (typeof window.autoTable === 'function') {
      return (opts) => window.autoTable(doc, opts);
    }
    return null;
  }

  /* -----------------------------------------------------------
   * 2) Exporter (runs ONLY when click flag is set)
   * --------------------------------------------------------- */
  function exportPDF() {
    const Ctor = getJsPDF();
    if (!Ctor) { alert('PDF library not loaded yet. Try again in a moment.'); return; }
    const table = findTable();
    if (!table) { alert('There is nothing to export yet.'); return; }

    const doc = new Ctor({ unit: 'pt', format: 'letter', compress: true, putOnlyUsedFonts: true });
    const autoTable = getAutoTableRunner(doc);
    if (!autoTable) { alert('AutoTable plugin missing.'); return; }

    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();
    const BLEED = 12;
    const paint = () => {
      doc.setFillColor(0, 0, 0);
      doc.rect(-BLEED, -BLEED, pageW + BLEED * 2, pageH + BLEED * 2, 'F');
    };

    const headers = Array.from(table.querySelectorAll('thead th')).map((th) => th.textContent.trim());
    const fallbackHeaders = ['Category', 'Partner A', 'Match %', 'Partner B'];
    const columns = (headers.length ? headers : fallbackHeaders).map((header, idx) => ({
      header: header || fallbackHeaders[idx] || `Col ${idx + 1}`,
      key: String(idx),
    }));

    const rows = Array.from(table.querySelectorAll('tbody tr')).map((tr) => {
      const cells = Array.from(tr.children).map((td) => td.textContent.trim());
      const record = {};
      cells.forEach((value, idx) => {
        record[String(idx)] = value || '—';
      });
      return record;
    });

    if (!rows.length) {
      alert('There are no rows to export yet.');
      return;
    }

    paint();
    doc.setTextColor(255, 255, 255);
    doc.setDrawColor(0, 0, 0);
    doc.setLineWidth(0);

    const head = [columns.map((c) => c.header)];
    const body = rows.map((row) => columns.map((c) => {
      const value = row[c.key];
      return value === undefined || value === null || value === '' ? '—' : String(value);
    }));
    const columnStyles = {};
    columns.forEach((_, idx) => {
      columnStyles[idx] = { halign: idx === 0 ? 'left' : 'center' };
    });

    autoTable({
      head,
      body,
      startY: -BLEED,
      startX: -BLEED,
      tableWidth: pageW + BLEED * 2,
      margin: { top: 0, right: 0, bottom: 0, left: 0 },
      theme: 'plain',
      horizontalPageBreak: true,
      styles: {
        font: 'helvetica',
        fontSize: 10,
        textColor: [255, 255, 255],
        cellPadding: 0,
        lineWidth: 0,
        fillColor: null,
        overflow: 'linebreak',
        minCellHeight: 14,
      },
      headStyles: {
        fontStyle: 'bold',
        textColor: [255, 255, 255],
        fillColor: null,
        cellPadding: 0,
        lineWidth: 0,
        minCellHeight: 16,
      },
      tableLineWidth: 0,
      tableLineColor: [0, 0, 0],
      columnStyles,
      didParseCell(data) {
        data.cell.styles.fillColor = null;
        data.cell.styles.lineWidth = 0;
        data.cell.styles.lineColor = [0, 0, 0];
      },
      didAddPage() {
        paint();
        doc.setTextColor(255, 255, 255);
        doc.setDrawColor(0, 0, 0);
        doc.setLineWidth(0);
      },
    });

    const filename = 'compatibility-blackedge.pdf';
    doc.save(filename);
    console.log('[TK-PDF] Manual export complete:', filename);
  }

  /* -----------------------------------------------------------
   * 3) Wire the button: only enabled when BOTH surveys are loaded.
   *    NO auto-download. Requires explicit user click.
   * --------------------------------------------------------- */
  function bindButton() {
    const btn = document.getElementById(DOWNLOAD_BTN_ID);
    if (!btn) return;

    if (!btn.dataset.bound) {
      btn.dataset.bound = '1';
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        if (!bothPartnersReady()) {
          alert('Please upload BOTH surveys first.');
          return;
        }
        // Allow save() during this user gesture only
        window.__TK_PDF_CLICK_OK = true;
        try { exportPDF(); }
        finally { window.__TK_PDF_CLICK_OK = false; }
      });
    }
  }

  /* -----------------------------------------------------------
   * 4) Keep the button’s enabled/disabled state in sync
   * --------------------------------------------------------- */
  function watchReadiness() {
    // Update once now
    setDownloadEnabled(bothPartnersReady());

    // Re-check on file input changes
    FILE_INPUT_SELECTORS.forEach(sel => {
      const el = document.querySelector(sel);
      if (el) el.addEventListener('change', () => setDownloadEnabled(bothPartnersReady()));
    });

    // Also watch DOM mutations where the comparison table renders
    const container = CONTAINER_CANDIDATES.map(s => document.querySelector(s)).find(Boolean) || document.body;
    const mo = new MutationObserver(() => setDownloadEnabled(bothPartnersReady()));
    mo.observe(container, { childList: true, subtree: true });

    // Light polling for 6s in case counts update without DOM changes
    const probe = setInterval(() => setDownloadEnabled(bothPartnersReady()), 300);
    setTimeout(() => clearInterval(probe), 6000);
  }

  /* -----------------------------------------------------------
   * 5) Init
   * --------------------------------------------------------- */
  document.addEventListener('DOMContentLoaded', () => {
    bindButton();
    watchReadiness();
  });
})();
</script>
<!-- ===== End paste ===== -->
<!-- ========== TK ONE-PASTE PATCH (for compatibility.html) ==========
     • Full-bleed black (no white margins) on screen & PDF
     • Replaces cb_* codes with human-readable Category names
     • Auto-loads names from /data/labels-overrides.json or kinks.json
     • Falls back to deriving names from the uploaded survey JSON(s)
     Paste this just before </body>.
==================================================================== -->

<style>
  /* Full-bleed black screen/print */
  @page { size: A4; margin: 0; }
  html, body {
    margin:0!important; padding:0!important;
    background:#000!important; color:#fff!important;
  }
  * { -webkit-print-color-adjust: exact!important; print-color-adjust: exact!important; }

  /* Let the report/table consume the whole page area */
  body, main, .compat, .compat-container, .report, .report-wrap, #app {
    background:#000!important; width:100vw; min-height:100vh;
  }

  /* Table visuals */
  table { width:100%; border-collapse:collapse!important; background:#000!important; }
  th, td {
    background:#000!important; color:#fff!important;
    border:1.4px solid #fff!important;
    padding:.65rem .8rem!important; line-height:1.3;
  }

  /* Optional: hide titles/banners so table fills PDF */
  .tk-pdf-header, .pdf-header, .compat-title,
  header[role="banner"], .page-title, .timestamp {
    display:none!important;
  }
</style>

<!-- Inline overrides: add any guaranteed id->label mappings here (optional) -->
<script id="tk-labels-embed" type="application/json">
{
  /* EXAMPLES — add as many as you want:
  "cb_e4bdv": "Dress partner’s outfit (directive/decision)",
  "cb_hhxwj": "Pick lingerie / base layers",
  "cb_a19jy": "Uniforms (school, military, nurse, etc.)",
  "cb_5gzwk": "Time-period dress-up",
  "cb_jmxxq": "Dollification / polished object aesthetics"
  */
}
</script>

<script>
(() => {
  const CODE_RX = /^cb_[a-z0-9]+$/i;
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const onReady = (fn) => (document.readyState!=='loading') ? fn() : document.addEventListener('DOMContentLoaded', fn, {once:true});

  async function fetchJSON(url){
    try { const r = await fetch(url, {cache:'no-store'}); return r.ok ? r.json() : null; }
    catch { return null; }
  }

  function collectPairsFromObjectish(obj, idKeys=['id','key','code'], textKeys=['text','label','name','title']){
    const out = {};
    const list = Array.isArray(obj) ? obj : (obj?.items || obj?.questions || obj?.kinks || obj?.data || obj?.categories || []);
    for (const it of list){
      if (!it || typeof it!=='object') continue;
      const id   = idKeys.map(k => (it[k]||'').toString().trim()).find(v => CODE_RX.test(v)) || '';
      const text = textKeys.map(k => (it[k]||'').toString().trim()).find(v => v) || '';
      if (CODE_RX.test(id) && text) out[id] = text;
    }
    return out;
  }

  async function deriveFromFileInput(inp){
    const f = inp?.files?.[0]; if(!f) return {};
    try{ const j = JSON.parse(await f.text()); return collectPairsFromObjectish(j); }
    catch { return {}; }
  }

  async function getLabelMap(){
    const map = {};

    // (a) Embedded inline overrides
    try {
      const emb = document.getElementById('tk-labels-embed');
      if (emb) Object.assign(map, JSON.parse(emb.textContent || '{}'));
    } catch {}

    // (b) Global objects if site exposes them
    if (window.tkLabels)          Object.assign(map, window.tkLabels);
    if (window.tkLabelsOverrides) Object.assign(map, window.tkLabelsOverrides);

    // (c) External sources (first one that yields content wins)
    const externalCandidates = [
      '/data/labels-overrides.json',      // your manual master table
      '/kinksurvey/data/kinks.json',      // canonical mapping (if deployed)
      '/data/kinks.json',                 // copy of canonical mapping
      '/template-survey.json'             // sometimes contains items/questions with text
    ];
    for (const url of externalCandidates){
      const j = await fetchJSON(url);
      if (j && typeof j === 'object'){
        const pairs = collectPairsFromObjectish(j);
        if (Object.keys(pairs).length){ Object.assign(map, pairs); break; }
      }
    }

    // (d) Last resort: derive from uploaded survey files already on the page
    const inputs = $$('input[type="file"]');
    for (const inp of inputs){
      const pairs = await deriveFromFileInput(inp);
      Object.assign(map, pairs);
    }

    return map;
  }

  function relabelCells(labelMap){
    if (!labelMap || !Object.keys(labelMap).length) return;
    const cells = $$('.compat table th, .compat table td, table th, table td');
    for (const cell of cells){
      const raw = (cell.textContent || '').trim();
      if (!CODE_RX.test(raw)) continue;
      let key = null;
      if (raw in labelMap) key = raw;
      else if (raw.toLowerCase() in labelMap) key = raw.toLowerCase();
      else if (raw.toUpperCase() in labelMap) key = raw.toUpperCase();
      if (key) cell.textContent = labelMap[key];
    }
  }

  function watchAndRelabel(labelMap){
    relabelCells(labelMap);
    const mo = new MutationObserver(() => relabelCells(labelMap));
    mo.observe(document.body, {subtree:true, childList:true, characterData:true});
  }

  // Ensure html2canvas uses a black background when screenshotting for PDF
  function patchHtml2Canvas(){
    if (!window.html2canvas) return;
    const orig = window.html2canvas;
    window.html2canvas = (node, opts={}) => {
      return orig(node, Object.assign({ background:'#000', scale:Math.min(2, window.devicePixelRatio||1), useCORS:true }, opts));
    };
  }

  // When a new file is uploaded, attempt to enrich the labels again
  function wireFileInputs(labelMap){
    $$('input[type="file"]').forEach(inp => {
      inp.addEventListener('change', async () => {
        const newer = await getLabelMap();
        Object.assign(labelMap, newer);
        relabelCells(labelMap);
        updateLabelBox(labelMap);
      });
    });
  }

  function ensureLabelBox(){
    let host = document.getElementById('tk-label-map-box');
    if (!host) {
      host = document.createElement('details');
      host.id = 'tk-label-map-box';
      host.open = false;
      Object.assign(host.style, {
        position: 'fixed',
        bottom: '16px',
        right: '16px',
        maxWidth: 'min(480px, 90vw)',
        maxHeight: '60vh',
        padding: '12px',
        border: '1px solid rgba(255,255,255,0.4)',
        background: 'rgba(0,0,0,0.85)',
        color: '#fff',
        font: '13px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',
        zIndex: '9999',
        borderRadius: '8px',
        boxShadow: '0 8px 24px rgba(0,0,0,0.35)'
      });

      const summary = document.createElement('summary');
      summary.textContent = 'Label map';
      Object.assign(summary.style, {
        cursor: 'pointer',
        fontWeight: '600',
        marginBottom: '8px'
      });
      host.appendChild(summary);

      const pre = document.createElement('pre');
      Object.assign(pre.style, {
        margin: '0',
        padding: '0',
        whiteSpace: 'pre-wrap',
        wordBreak: 'break-word',
        overflow: 'auto'
      });
      host.appendChild(pre);

      document.body.appendChild(host);
    }
    return host;
  }

  function updateLabelBox(labelMap){
    if (!labelMap || !Object.keys(labelMap).length) return;
    const host = ensureLabelBox();
    const pre = host.querySelector('pre');
    if (!pre) return;
    const ordered = Object.keys(labelMap)
      .sort((a, b) => a.localeCompare(b))
      .reduce((acc, key) => {
        acc[key] = labelMap[key];
        return acc;
      }, {});
    pre.textContent = JSON.stringify(ordered, null, 2);
  }

  onReady(async () => {
    patchHtml2Canvas();
    const labels = await getLabelMap();
    watchAndRelabel(labels);
    wireFileInputs(labels);
    updateLabelBox(labels);
  });
})();
</script>
<!-- ======================== /TK ONE-PASTE PATCH ======================== -->
  <script>
  (async () => {
    const clean = s => String(s||'').normalize('NFKC').replace(/[\u200B-\u200D\uFEFF]/g,'').trim();
    const keyVars = k => { const b=clean(k).toLowerCase(); return [b, b.replace(/^cb_/,'')]; };
    const pretty  = s => clean(s).replace(/^cb_/i,'').replace(/[_-]+/g,' ')
                       .replace(/\b([a-z])([a-z]*)/gi,(_,a,b)=>a.toUpperCase()+b.toLowerCase());
    const need=(ok,src)=> ok?Promise.resolve():new Promise((res,rej)=>{const s=document.createElement('script');s.src=src;s.onload=res;s.onerror=rej;document.head.appendChild(s);});
    const fetchJSON = async u => { try{ const r=await fetch(u,{cache:'no-store'}); return r.ok?r.json():null; }catch{return null;} };
    const normalizeAny = (input)=>{ const out={}, put=(k,v)=>{ const val=clean(v)||clean(k); keyVars(k).forEach(kk=>{ if(kk) out[kk]=val; }); };
      if(!input) return out;
      if(Array.isArray(input)){ for(const it of input){ if(Array.isArray(it)&&it.length>=2){ put(it[0],it[1]); continue; }
        if(it&&typeof it==='object'){ const k=it.code??it.id??it.key??it.slug??it.name??it.kink??it.value;
          const v=it.title??it.label??it.display??it.name??it.text??it.pretty??it.kink??it.value; if(k!=null) put(k,v??k);} } return out; }
      for(const [k,v] of Object.entries(input)){ if(v&&typeof v==='object'){ put(k, v.title??v.label??v.name??v.display??v.text??v.pretty??k);} else put(k,v); }
      return out;
    };

    await need(window.jspdf && window.jspdf.jsPDF,"https://cdn.jsdelivr.net/npm/jspdf@2.5.2/dist/jspdf.umd.min.js");
    await need(window.jspdf && window.jspdf.jsPDF?.prototype?.autoTable,"https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.3/dist/jspdf.plugin.autotable.min.js");

    let raw=null;
    if(typeof window.buildLabelMapSafely==='function'){ try{ raw=await window.buildLabelMapSafely(); }catch{} }
    if(!raw){ const [base,over]=await Promise.all([fetchJSON('/data/kinks.json'), fetchJSON('/data/labels-overrides.json')]); raw={...(base||{}),...(over||{}),...(window.tkLabels||{})}; }
    const MAP=normalizeAny(raw);

    function readTable(){
      const tbl=document.querySelector('table'); if(!tbl) throw new Error('No <table> found');
      const head=[...tbl.querySelectorAll('thead th')].map(th=>clean(th.textContent))||['Category','Partner A','Match %','Partner B'];
      const rows=[...tbl.querySelectorAll('tbody tr')].map(tr=>[...tr.children].map(td=>clean(td.textContent)));
      return {head,rows};
    }

    function exportPDF(){
      const {head,rows}=readTable();
      const body=rows.map(r=>{
        let label=null; for(const kv of keyVars(r[0])) if(MAP[kv]){ label=MAP[kv]; break; }
        r[0]=label || pretty(r[0]);
        for(let i=0;i<r.length;i++) if(r[i]===''||r[i]==='—') r[i]=' ';
        return r;
      });

      const { jsPDF }=window.jspdf;
      const doc=new jsPDF({unit:'pt',format:'letter',compress:true,putOnlyUsedFonts:true});
      const W=doc.internal.pageSize.getWidth(), H=doc.internal.pageSize.getHeight();
      doc.setFillColor(0,0,0); doc.rect(0,0,W,H,'F'); doc.setTextColor(255,255,255);

      const OUTER=40, GRID=[160,160,160], OUTLINE=[200,200,200], OUTLINE_W=1.6;
      const tableWidth=W-OUTER*2;
      const col={
        0:{cellWidth:tableWidth*0.40,halign:'left'},
        1:{cellWidth:tableWidth*0.20,halign:'center'},
        2:{cellWidth:tableWidth*0.20,halign:'center'},
        3:{cellWidth:tableWidth*0.20,halign:'center'}
      };

      doc.autoTable({
        head:[head], body, theme:'grid',
        margin:{top:OUTER,right:OUTER,bottom:OUTER,left:OUTER},
        tableWidth,
        styles:{font:'helvetica',fontSize:13,textColor:[255,255,255],fillColor:null,cellPadding:12,lineWidth:0.7,lineColor:GRID,minCellHeight:24},
        headStyles:{fontStyle:'bold',textColor:[255,255,255],fillColor:null,lineWidth:0.9,lineColor:GRID},
        tableLineWidth:0.9, tableLineColor:GRID,
        columnStyles:col,
        didAddPage(){doc.setFillColor(0,0,0);doc.rect(0,0,W,H,'F');doc.setTextColor(255,255,255);}
      });

      const topY=OUTER, botY=doc.lastAutoTable.finalY, leftX=OUTER, height=Math.max(0,botY-topY);
      doc.setLineWidth(OUTLINE_W); doc.setDrawColor(...OUTLINE); doc.rect(leftX, topY, tableWidth, height, 'S');
      doc.save('compatibility-black-grid-NAMES.pdf');
    }

    function hijack(root=document){
      const cand=[...root.querySelectorAll('a,button,[role="button"],input[type="button"],input[type="submit"]')];
      for(const el of cand){
        const txt=(el.textContent||el.value||'').toLowerCase();
        const href=(el.getAttribute('href')||'').toLowerCase();
        if(!(/pdf|export|download|save|print/.test(txt+href)||/\.pdf\b/.test(href))) continue;
        const clone=el.cloneNode(true);
        el.replaceWith(clone);
        clone.addEventListener('click', e=>{
          e.preventDefault(); e.stopImmediatePropagation(); e.stopPropagation();
          exportPDF();
        }, {capture:true});
      }
    }
    hijack();
    new MutationObserver(()=>hijack()).observe(document.documentElement,{childList:true,subtree:true});

    document.addEventListener('click', e=>{
      const el=e.target.closest('a,button,[role="button"],input[type="button"],input[type="submit"]');
      if(!el) return;
      const txt=(el.textContent||el.value||'').toLowerCase();
      const href=(el.getAttribute('href')||'').toLowerCase();
      if(/pdf|export|download|save|print/.test(txt+href)||/\.pdf\b/.test(href)){
        e.preventDefault(); e.stopImmediatePropagation(); e.stopPropagation();
        exportPDF();
      }
    }, true);

    (function addButton(){
      if (document.getElementById('tk-pdf-btn')) return;
      const b=document.createElement('button'); b.id='tk-pdf-btn';
      Object.assign(b.style,{position:'fixed',right:'18px',bottom:'18px',zIndex:2147483647,padding:'10px 14px',
        borderRadius:'10px',border:'1px solid #aaa',background:'#111',color:'#fff',font:'14px/1 system-ui, sans-serif',
        boxShadow:'0 2px 10px rgba(0,0,0,.4)',cursor:'pointer'});
      b.textContent='Download PDF';
      b.addEventListener('click',e=>{e.preventDefault();e.stopImmediatePropagation();exportPDF();},{capture:true});
      document.body.appendChild(b);
      window.addEventListener('keydown',e=>{ if(e.shiftKey&&(e.key==='D'||e.key==='d')){ e.preventDefault(); exportPDF(); } },true);
    })();

    window.tk = Object.assign(window.tk||{}, { export: exportPDF });
    console.log('[tk] hijacker armed — click your Download PDF and it will use the new exporter.');
  })();
  </script>
  <script src="/js/tk-data-loader.js"></script>
  <script src="/js/tk-labels.js"></script>
  <script src="/js/compatibilityLabels.js" defer></script>
  <script src="/js/pdfDownload.js" defer></script>
<!--
===============================================================================
TALK KINK – ONE-PASTE FIX
===============================================================================
WHAT THIS DOES
1) Fixes “Start Survey” not responding / frozen dialog.
2) Shows a category picker with your current dark look (non-intrusive CSS).
3) Loads all categories from /data/kinks.json (+ optional /data/labels-overrides.json).
4) Saves the chosen categories and launches the survey (or emits an event your
   runner can catch).
5) Exposes window.__TK_LABELS so your Compatibility/PDF code can print human
   names instead of cb_* codes.

HOW TO USE (ONE STEP)
Paste this entire block before </body> on BOTH:
  • /kinksurvey/ (or the page with the Start Survey button)
  • /compatibility.html (so the PDF can resolve names)

BUTTON HOOK
Your Start button must have id="startSurveyBtn" OR attribute data-tk-start-survey.
Example: <a id="startSurveyBtn" class="themed-button">Start Survey</a>

SURVEY HANDOFF (optional)
If you have a custom runner, listen once for:
  document.addEventListener('tk:start-survey', (e) => {
    window.__TK_SURVEY_STARTED = true; // prevent fallback navigation
    const cats = e.detail.includeCategories; // array of IDs
    // ...start your survey with `cats`
  });

FALLBACK
If no listener starts the survey, the code navigates to /kinksurvey/?run=1&cats=…
after 120ms so users always proceed.

PDF NAMES
On the PDF page, after this block, you can do:
  const nameFor = id => (window.__TK_LABELS||{})[id] || id;

===============================================================================
-->

<!--
================================================================================
TALK KINK – “START SURVEY” ALWAYS WORKS + NAMES FOR PDF
One paste. Put this block **right before `</body>`** on BOTH pages:
  • /kinksurvey/ (landing with the big Start Survey button)
  • /compatibility.html (so PDFs can use human names)

WHAT THIS FIXES
- Some themes/links didn’t match the earlier hook → clicking “Start Survey”
  did nothing. This version:
  1) Hooks **#startSurveyBtn** or **[data-tk-start-survey]** if present.
  2) If not found, it **auto-detects** any <a>/<button> whose **text is “Start Survey”**,
     or whose **href ends with “/kinksurvey/”** and wires it.
  3) Also adds a **document-level (capture)** click hijacker so even nested
     elements or overlays won’t swallow the click.
  4) If all else fails, it **auto-opens the picker on page load** (or when
     `?start=1` or `#survey` is present).

- Exposes **window.__TK_LABELS** (code → human name) for the PDF.
  Use: `const nameFor = id => (window.__TK_LABELS||{})[id] || id;`

HOW SURVEY LAUNCHES
- When the user presses “Start Survey” in the modal, we:
  1) Save the chosen category IDs to `localStorage.__TK_SELECTED_CATEGORIES`.
  2) Dispatch `document` event: **'tk:start-survey'** with `{ includeCategories }`.
     If your runner starts the survey, set `window.__TK_SURVEY_STARTED = true`.
  3) Fallback after 120ms: navigate to `/kinksurvey/?run=1&cats=...`

NO VISUAL TAKEOVER
- Panel CSS is minimal and respects your dark theme.
================================================================================
-->

<style>
  #categorySurveyPanel { position:fixed; inset:0; display:none; z-index:9999;
    background:rgba(0,0,0,.65); backdrop-filter:blur(2px); }
  #categorySurveyPanel.visible { display:block; }
  #categorySurveyPanel .panel { position:absolute; inset:6% 6% auto 6%;
    max-height:88vh; overflow:auto; padding:24px; border:2px solid var(--teal,#00e5ff);
    border-radius:16px; background:#000; color:#fff; box-shadow:0 12px 40px rgba(0,0,0,.6); }
  #categoryChecklist { display:grid; gap:10px; grid-template-columns:1fr; }
  #categoryChecklist label { display:flex; align-items:center; gap:10px;
    padding:10px 12px; border:1px solid #2a2a2a; border-radius:12px; background:#090909; }
  #categoryChecklist input[type="checkbox"] { width:18px; height:18px; }
  .themed-button { cursor:pointer; }
</style>

<aside id="categorySurveyPanel" role="dialog" aria-label="Category selection"
       aria-modal="true" aria-hidden="true"
       data-testid="select-categories-panel">
  <div class="panel">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <h2 style="margin:0">Select categories</h2>
      <button id="btnClosePanel" class="themed-button" aria-label="Close">Close ✕</button>
    </div>

    <div style="display:flex;gap:12px;align-items:center;margin:6px 0 14px">
      <button id="btnSelectAll"   class="themed-button">Select All</button>
      <button id="btnDeselectAll" class="themed-button">Deselect All</button>
      <span id="selectedCountBadge" style="opacity:.7">0 selected / 0 total</span>
    </div>

    <div id="categoryChecklist" aria-live="polite" aria-busy="true"></div>

    <div style="margin-top:16px;display:flex;gap:12px">
      <button id="beginSurveyFromPanel" class="themed-button">Start Survey</button>
    </div>
  </div>
</aside>

<script>
/* ------------------------------- helpers ---------------------------------- */
const tkLog = (...a)=>console.log('[TK]', ...a);

 /* --------------------------- state + data plumbing ------------------------ */
 const LS_KEY = '__TK_SELECTED_CATEGORIES';

 function tkNormalizeItems(raw){
   if (!raw) return [];
   // Try to normalize a few likely shapes
   if (Array.isArray(raw)) {
     return raw.map(x => ({
       id: String(x.id ?? x.ID ?? x.value ?? x.slug ?? x.code ?? x.name).trim(),
       name: String(x.name ?? x.title ?? x.label ?? x.slug ?? x.code ?? x.id).trim()
     })).filter(x => x.id && x.name);
   }
   if (raw.categories && Array.isArray(raw.categories)) return tkNormalizeItems(raw.categories);
   if (raw.cats && Array.isArray(raw.cats))             return tkNormalizeItems(raw.cats);
   return [];
 }

 async function tkGetCategories(){
   // Prefer site globals if present
   try {
     if (typeof window.tkLoadKinkData === 'function') {
       const data = await window.tkLoadKinkData();
       const cats = tkNormalizeItems(data?.categories ?? data?.cats ?? data?.kinks?.categories);
       if (cats.length) return cats;
     }
   } catch(e){ tkLog('tkLoadKinkData error', e); }

   // Fallback to any hydrated globals the site left around
   const guesses = [
     window.__TK_KINK_DATA,
     window.__TK_DATA,
     window.__KINKS__,
   ].filter(Boolean);
   for (const g of guesses) {
     const cats = tkNormalizeItems(g);
     if (cats.length) return cats;
   }

   // Last resort: empty list (UI will still render)
   return [];
 }

 function loadSelection(){
   try { return JSON.parse(localStorage.getItem(LS_KEY) || '[]'); }
   catch{ return []; }
 }
 function saveSelection(ids){
   try { localStorage.setItem(LS_KEY, JSON.stringify(Array.from(new Set(ids)))); } catch {}
 }

 /* ------------------------------ UI wiring -------------------------------- */
 function qs(sel,root=document){ return root.querySelector(sel); }
 function qsa(sel,root=document){ return Array.from(root.querySelectorAll(sel)); }

 function setDocked(docked){
   document.body.classList.toggle('tk-docked', !!docked);
   const wrap = qs('#categorySurveyPanel');
   wrap?.classList.toggle('visible', !!docked);
   if (wrap) wrap.setAttribute('aria-hidden', docked ? 'false' : 'true');
 }

 function updateBadge(){
   const total = qsa('input[type="checkbox"]', qs('#categoryChecklist')).length;
   const selected = qsa('input[type="checkbox"]:checked', qs('#categoryChecklist')).length;
   const badge = qs('#selectedCountBadge');
   if (badge) badge.textContent = `${selected} selected / ${total} total`;
 }

 function renderCategories(cats){
   const list = qs('#categoryChecklist');
   if (!list) return;
   list.setAttribute('aria-busy','true');
   list.innerHTML = '';

   const chosen = new Set(loadSelection());
   const frag = document.createDocumentFragment();
   for (const c of cats) {
     const id = `cat_${c.id.replace(/[^a-z0-9_-]/gi,'_')}`;
     const label = document.createElement('label');
     label.setAttribute('for', id);
     label.innerHTML = `
       <input id="${id}" type="checkbox" value="${c.id}">
       <span>${c.name}</span>
     `;
     const checkbox = label.querySelector('input');
     checkbox.checked = chosen.has(c.id);
     checkbox.addEventListener('change', () => {
       const ids = qsa('input[type="checkbox"]:checked', list).map(n => n.value);
       saveSelection(ids);
       updateBadge();
     });
     frag.appendChild(label);
   }
   list.appendChild(frag);
   list.setAttribute('aria-busy','false');
   updateBadge();
 }

 function wireControls(){
   const list = qs('#categoryChecklist');
   const btnAll  = qs('#btnSelectAll');
   const btnNone = qs('#btnDeselectAll');
   const btnClose= qs('#btnClosePanel');
   const btnStart= qs('#beginSurveyFromPanel');

   btnAll?.addEventListener('click', () => {
     qsa('input[type="checkbox"]', list).forEach(n => n.checked = true);
     saveSelection(qsa('input[type="checkbox"]', list).map(n=>n.value));
     updateBadge();
   });
   btnNone?.addEventListener('click', () => {
     qsa('input[type="checkbox"]', list).forEach(n => n.checked = false);
     saveSelection([]);
     updateBadge();
   });
   btnClose?.addEventListener('click', () => setDocked(false));

   btnStart?.addEventListener('click', () => {
     const ids = loadSelection();
     // 1) persist
     saveSelection(ids);
     // 2) broadcast intent
     const ev = new CustomEvent('tk:start-survey', { detail: { includeCategories: ids } });
     document.dispatchEvent(ev);
     // if a runner starts the survey, it should set this:
     setTimeout(() => {
       if (!window.__TK_SURVEY_STARTED) {
         // 3) fallback navigation
         const u = new URL('/kinksurvey/', location.origin);
         u.searchParams.set('run','1');
         if (ids.length) u.searchParams.set('cats', ids.join(','));
         location.assign(u.toString());
       }
     }, 120);
   });
 }

 /* ------------------------------ bootstrap -------------------------------- */
 (async function initCategoryPanel(){
   // Ensure docking CSS exists (margin shift for right content)
   const extraCSS = `
     body.tk-docked{ margin-left: clamp(360px, 32vw, 520px) !important; transition: margin-left .15s ease; }
     #categorySurveyPanel .panel{
       position: fixed !important;
       top: 88px !important;
       left: 24px !important;
       right: auto !important;
       bottom: 24px !important;
       width: clamp(360px, 30vw, 500px) !important;
       height: calc(100vh - 112px) !important;
     }
     /* Hide any legacy “Start Survey” buttons elsewhere to make the panel authoritative */
     .start-survey, [data-role="start-survey"], .btn-start { display:none !important; }
   `;
   const s = document.createElement('style'); s.textContent = extraCSS; document.head.appendChild(s);

   // Load and render categories
   const cats = await tkGetCategories();
   renderCategories(cats);
   wireControls();

   // Lock panel open on first paint
   setDocked(true);
   tkLog('Loaded', cats.length, 'categories; UI wired.');
 })();
 </script>

<!-- end TK panel block -->

<style>
/* keep styles close for maintainability; this block ensures docking works on any page */
body.tk-docked{ margin-left: clamp(360px, 32vw, 520px) !important; }
</style>
function tkNormalizeOverrides(raw){
  // Accept a mapping {id:name} or array of {id,name}/{code,label}
  if (!raw) return {};
  if (Array.isArray(raw)){
    const map = {};
    for (const r of raw){
      const id = r.id || r.code || r.key;
      const nm = r.name || r.label || r.title;
      if (id && nm) map[id] = nm;
    }
    return map;
  }
  if (typeof raw === 'object') return raw;
  return {};
}

async function tkFetchJSON(url){
  const r = await fetch(url, {cache:'no-store'});
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

/* ----------------------------- robust loader ------------------------------ */
async function tkLoadKinkData(){
  if (window.__TK_DATA) return window.__TK_DATA;

  const now = Date.now();
  const candidates = [
    `/data/kinks.json?v=${now}`,
    `/data/categories.json?v=${now}`,      // optional fallback
  ];

  let items = [];
  let lastErr;
  for (const url of candidates){
    try{
      const raw = await tkFetchJSON(url);
      items = tkNormalizeItems(raw);
      if (items && items.length) { tkLog(`loaded ${items.length} raw items from`, url); break; }
    }catch(e){ lastErr = e; }
  }
  if (!items || !items.length){
    tkLog('no items available', lastErr || '');
    items = []; // continue gracefully
  }

  // Overrides (optional)
  let overridesMap = {};
  try{
    const rawOver = await tkFetchJSON(`/data/labels-overrides.json?v=${now}`);
    overridesMap = tkNormalizeOverrides(rawOver);
  }catch{}

  // Build labels map
  const labelsMap = {};
  for (const it of items){
    const id = it?.id ?? it?.code ?? it?.key ?? null;
    if (!id) continue;
    const baseName = it?.name ?? it?.label ?? it?.title ?? id;
    labelsMap[id] = (overridesMap[id] || baseName).toString().trim();
  }

  window.__TK_DATA   = { items, labelsMap };
  window.__TK_LABELS = labelsMap;     // expose for PDF
  return window.__TK_DATA;
}

/* ------------------------ modal + “Start Survey” wiring ------------------- */
(function tkSurveyInit(){
  const $  = (s,r=document)=>r.querySelector(s);
  const $$ = (s,r=document)=>Array.from(r.querySelectorAll(s));

  const panel = $('#categorySurveyPanel');
  const list  = $('#categoryChecklist');
  const badge = $('#selectedCountBadge');
  const btnClose = $('#btnClosePanel');
  const btnAll   = $('#btnSelectAll');
  const btnNone  = $('#btnDeselectAll');
  const btnGo    = $('#beginSurveyFromPanel');

  if (!panel || !list || !btnGo){ console.warn('[TK] panel skeleton missing'); return; }

  let ALL_IDS = [];
  let selected = new Set();

  const nameFor = id => (window.__TK_LABELS && window.__TK_LABELS[id]) || id;

  function updateBadge(){ badge.textContent = `${selected.size} selected / ${ALL_IDS.length} total`; }
  function open(){ panel.classList.add('visible'); panel.setAttribute('aria-hidden','false'); (btnClose||panel).focus({preventScroll:true}); }
  function close(){ panel.classList.remove('visible'); panel.setAttribute('aria-hidden','true'); }

  function render(){
    const f = document.createDocumentFragment();
    if (!ALL_IDS.length){
      const p = document.createElement('p');
      p.style.opacity = .8;
      p.textContent = 'Dataset unavailable. Please try again shortly.';
      f.append(p);
    }else{
      for (const id of ALL_IDS){
        const L = document.createElement('label');
        const cb = document.createElement('input');
        cb.type='checkbox'; cb.value=id; cb.checked=selected.has(id);
        cb.addEventListener('change',()=>{ cb.checked?selected.add(id):selected.delete(id); updateBadge(); });
        const t = document.createElement('span'); t.textContent = nameFor(id);
        L.append(cb,t); f.append(L);
      }
    }
    list.replaceChildren(f);
    list.setAttribute('aria-busy','false');
    updateBadge();
  }

  async function prepareAndOpen(){
    try{
      list.setAttribute('aria-busy','true');
      const { items } = await tkLoadKinkData();               // never throws fatally
      ALL_IDS = (items||[]).map(it=>it.id||it.code||it.key).filter(Boolean);
      const saved = JSON.parse(localStorage.getItem('__TK_SELECTED_CATEGORIES')||'[]');
      selected = new Set(saved.length ? saved : ALL_IDS);     // default to all when present
      render();
      open();
    }catch(e){
      console.error('[TK] data load failed', e);
      ALL_IDS = [];
      selected = new Set();
      render();
      open();
    }
  }

  // Wire explicit IDs/attributes first
  function wireKnown(){
    let n = 0;
    for (const el of $$('#startSurveyBtn, [data-tk-start-survey]')){
      if (el.__tkWired) continue;
      el.__tkWired = true;
      el.addEventListener('click', (ev)=>{ ev.preventDefault(); ev.stopPropagation(); prepareAndOpen(); }, {capture:true});
      n++;
    }
    return n;
  }

  // Heuristic wiring (text/href)
  function wireHeuristic(){
    let n = 0;
    for (const el of $$('a,button')){
      if (el.__tkWired) continue;
      const txt = (el.textContent||'').trim().toLowerCase();
      const href = (el.getAttribute('href')||'').toLowerCase();
      if (/start\s*survey/.test(txt) || /\/kinksurvey\/?$/.test(href)){
        el.__tkWired = true;
        el.addEventListener('click', (ev)=>{ ev.preventDefault(); ev.stopPropagation(); prepareAndOpen(); }, {capture:true});
        n++;
      }
    }
    return n;
  }

  // Global capture guard so nested elements can’t swallow the click
  document.addEventListener('click', (ev)=>{
    const t = ev.target.closest('a,button,[role="button"]');
    if (!t || t.__tkWired) return;
    const txt = (t.textContent||'').toLowerCase();
    const href = (t.getAttribute('href')||'').toLowerCase();
    if (/start\s*survey/.test(txt) || /\/kinksurvey\/?$/.test(href)){
      ev.preventDefault(); ev.stopPropagation();
      prepareAndOpen();
    }
  }, true);

  // Wire now + after small delay for late UI
  const wired0 = wireKnown() + wireHeuristic();
  setTimeout(()=>{ wireKnown(); wireHeuristic(); }, 250);

  // Panel controls
  btnClose && btnClose.addEventListener('click', close);
  btnAll   && btnAll.addEventListener('click', ()=>{ selected = new Set(ALL_IDS); render(); });
  btnNone  && btnNone.addEventListener('click', ()=>{ selected = new Set(); render(); });

  btnGo.addEventListener('click', ()=>{
    const choice = Array.from(selected);
    localStorage.setItem('__TK_SELECTED_CATEGORIES', JSON.stringify(choice));
    const evt = new CustomEvent('tk:start-survey', { detail: { includeCategories: choice }});
    document.dispatchEvent(evt);
    // If your runner sets this to true we won’t navigate
    setTimeout(()=>{
      if (!window.__TK_SURVEY_STARTED){
        const qs = new URLSearchParams({ run:'1', cats: choice.join(',') });
        location.href = `/kinksurvey/?${qs}`;
      }
    }, 120);
  });

  // Auto-open if hinted via URL or if no button was wired
  if (/[#?](survey|start=1)/i.test(location.href) || wired0 === 0){
    setTimeout(prepareAndOpen, 60);
  }
})();

/* ---------------------------- PDF name helper ------------------------------
Anywhere on the compatibility/PDF page, call:
  const nameFor = id => (window.__TK_LABELS||{})[id] || id;

If __TK_LABELS isn’t ready yet on that page, preload:
  (async()=>{ if(!window.__TK_LABELS){ const d=await tkLoadKinkData(); window.__TK_LABELS=d.labelsMap; }})();
---------------------------------------------------------------------------- */
</script>
<script>
(function () {
  /* Guard: install once */
  if (window.__tkPortalInstalled) return;
  window.__tkPortalInstalled = true;

  const Z = 2147483000; // max-ish z-index so we're always above everything.

  /* 1) Find the existing panel (your drawer) */
  const panel = document.querySelector('#categorySurveyPanel, .category-panel');
  if (!panel) {
    console.warn('[TK] No panel found (#categorySurveyPanel or .category-panel).');
    return;
  }

  /* 2) Create scrim and portal wrapper that sit at the top of the page stack */
  const scrim = Object.assign(document.createElement('div'), { id: 'tkScrim' });
  Object.assign(scrim.style, {
    position: 'fixed', inset: '0', background: 'rgba(0,0,0,.6)',
    display: 'none', opacity: '0', transition: 'opacity .18s ease', zIndex: Z, pointerEvents: 'none'
  });

  const portal = Object.assign(document.createElement('div'), { id: 'tkPortal' });
  Object.assign(portal.style, { position: 'fixed', inset: '0', display: 'none', zIndex: Z + 1, pointerEvents: 'none' });

  const shell = Object.assign(document.createElement('div'), { className: 'tk-shell' });
  Object.assign(shell.style, {
    position: 'fixed', left: '50%', top: '50%', transform: 'translate(-50%, -50%)',
    maxHeight: '85vh', width: 'min(980px, 92vw)',
    background: 'rgba(10,10,10,.97)', border: '1px solid #00f0ff', borderRadius: '12px',
    boxShadow: '0 24px 64px rgba(0,0,0,.55)', overflow: 'auto', pointerEvents: 'auto', padding: '16px'
  });

  document.body.appendChild(scrim);
  document.body.appendChild(portal);
  portal.appendChild(shell);

  /* 3) Remember original location so we can restore on close */
  const origParent = panel.parentNode;
  const origNext = panel.nextSibling;

  /* 4) Neutralize common hiding mechanisms on the panel itself */
  ['hidden', 'inert', 'aria-hidden'].forEach(a => { try { panel.removeAttribute(a); } catch {} });
  try { panel.classList.remove('hidden','is-hidden','closed','tk-hidden','tk-closed'); } catch {}
  Object.assign(panel.style, {
    display: 'block', visibility: 'visible', opacity: '1', filter: 'none', transform: 'none'
  });

  /* 5) Mount/unmount helpers */
  function mountPanel(){
    // Pull into portal and ensure it can't be 0x0
    shell.appendChild(panel);
    if (panel.getBoundingClientRect().height < 40) {
      panel.style.minHeight = '240px';   // safety so you see something
    }
  }
  function unmountPanel(){
    if (!origParent) return;
    if (origNext) origParent.insertBefore(panel, origNext);
    else origParent.appendChild(panel);
  }

  /* 6) Open/close controls */
  function open(){
    mountPanel();
    scrim.style.display = 'block';
    portal.style.display = 'block';
    requestAnimationFrame(() => { scrim.style.opacity = '1'; scrim.style.pointerEvents = 'auto'; });
    document.documentElement.style.overflow = 'hidden';
    console.log('[TK] Panel opened (portal mode).');
  }
  function close(){
    scrim.style.opacity = '0';
    scrim.style.pointerEvents = 'none';
    setTimeout(() => {
      scrim.style.display = 'none';
      portal.style.display = 'none';
      document.documentElement.style.overflow = '';
      unmountPanel();
      console.log('[TK] Panel closed (restored to original DOM).');
    }, 180);
  }
  scrim.addEventListener('click', close, { passive: true });

  /* 7) Public probes (handy in console) */
  window.tkOpenPanel = open;
  window.tkClosePanel = close;
  window.tkProbe = function(){
    const r = panel.getBoundingClientRect();
    console.table([
      { key: 'panel',   present: !!panel,   w: Math.round(r.width), h: Math.round(r.height),
        inPortal: panel.parentNode === shell },
      { key: 'overlay', present: true,      visible: scrim.style.display !== 'none' }
    ]);
    return { rect: r, inPortal: panel.parentNode === shell };
  };

  /* 8) Wire your Start buttons */
  const startSelectors = [
    '#startSurveyBtn', '#startSurvey', '.start-survey-btn',
    'button.themed-button.start-survey-btn', 'a[href="#start"]'
  ].join(',');
  document.querySelectorAll(startSelectors).forEach(btn => {
    btn.addEventListener('click', e => { e.preventDefault(); open(); }, { passive: false });
  });

  console.log('[TK] Portal installed. Click “Start Survey”, or run tkOpenPanel().');
})();
</script>
</body>
</html>
