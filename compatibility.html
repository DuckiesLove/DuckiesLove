<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Kill-switch for legacy Partner-B bootstrap that caused "freeze after first upload" -->
  <script>
    // Hard disable any code path that auto-fills Partner B from internal JSON.
    // This must be loaded before every other script.
    window.TK_DISABLE_BOOTSTRAP_B = true;
    console.info('[compat] kill-switch enabled');
    // one-time guard so labels/overrides merge only once per load
    window._tkLabelsMerged = false;
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>See Our Compatibility</title>
  <style>
    /* Kill any category dock/panel overlays without layout shift */
    #tkDockCard,
    #categorySurveyPanel,
    aside.category-panel,
    .category-panel,
    [data-testid="select-categories-panel"],
    #tkOverlay,
    .tk-overlay {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }

    /* Ensure body isn't pushed for a removed dock */
    html.tk-dock body {
      margin-left: 0 !important;
    }
  </style>
  <script>
    (function killCategoryPanel() {
      const selectors = [
        '#tkDockCard',
        '#categorySurveyPanel',
        'aside.category-panel',
        '.category-panel',
        '[data-testid="select-categories-panel"]',
        '#tkOverlay',
        '.tk-overlay'
      ];

      window.__TK_DISABLE_PANEL__ = true;
      window.__TK_DISABLE_PORTAL__ = true;

      const purge = () => {
        document.documentElement.classList.remove('tk-dock');
        if (document.body) {
          document.body.style.marginLeft = '';
        }
        selectors.forEach((selector) => {
          document.querySelectorAll(selector).forEach((node) => node.remove());
        });
      };

      purge();

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', purge, { once: true });
      }

      const observer = new MutationObserver(purge);
      observer.observe(document.documentElement, { childList: true, subtree: true });
      setTimeout(() => observer.disconnect(), 4000);
    })();
  </script>
  <!-- COMPAT PAGE: recentre layout + neutralize any dock margin -->
  <style id="compat-centering">
    :root {
      --tk-dock-width: 0px !important;
    }

    html,
    body {
      margin: 0;
    }

    .compat-page,
    .compat-wrapper,
    #compatRoot,
    main,
    .page,
    .container {
      max-width: 960px;
      margin: 0 auto !important;
      padding: 40px 16px;
    }

    .compat-buttons,
    .compat-actions {
      display: flex;
      flex-direction: column;
      gap: 24px;
      align-items: center;
    }

    .compat-buttons .themed-button,
    .compat-actions .themed-button,
    .themed-button.compat {
      width: min(680px, 90vw);
    }
  </style>

  <script>
    (function () {
      try {
        if (document.body) {
          document.body.style.marginLeft = '0px';
        }
        document.documentElement.style.setProperty('--tk-dock-width', '0px');

        const host = document.querySelector(
          '#compatRoot, .compat-page, .compat-wrapper, main, .page, .container'
        );

        if (host) {
          Object.assign(host.style, {
            maxWidth: '960px',
            margin: '0 auto',
            padding: '40px 16px'
          });
        }

        document.querySelectorAll('.themed-button').forEach((btn) => {
          Object.assign(btn.style, {
            width: 'min(680px, 90vw)',
            margin: '0 auto',
            display: 'block'
          });
        });
      } catch (err) {
        console.warn('[compat] unable to apply centering overrides', err);
      }
    })();
  </script>
  <style id="tk-compat-center">
    /* Remove any panel/dock if an older script injected it */
    #tkDockCard,
    #categorySurveyPanel,
    .category-panel,
    .tk-overlay {
      display: none !important;
    }

    html,
    body {
      margin: 0;
    }

    body[style*="margin-left"] {
      margin-left: 0 !important;
    }

    /* Center the content column */
    .compat-wrap,
    .compat-container,
    .container,
    main,
    #app {
      box-sizing: border-box;
      max-width: 960px;
      width: min(960px, 92vw);
      margin-inline: auto;
      padding-inline: 16px;
    }

    .compat-wrap > *,
    .compat-container > *,
    .container > *,
    main > * {
      max-width: 100%;
    }
  </style>
  <script>
    (function () {
      const clearDock = () => {
        // Nuke any leftover dock/overlay/panel on this page
        for (const sel of ['#tkDockCard', '.tk-overlay', '#categorySurveyPanel', '.category-panel']) {
          const n = document.querySelector(sel);
          if (n) n.remove();
        }

        const body = document.body;
        if (body) {
          body.style.marginLeft = '';
        }

        const dock = document.querySelector('#compat-dock');
        if (dock) {
          dock.style.removeProperty('margin-bottom');
        }
      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', clearDock, { once: true });
      } else {
        clearDock();
      }
    })();
  </script>
  <!-- Import theme and global layout styles -->
  <link rel="stylesheet" href="/css/theme.css" />
  <link rel="stylesheet" href="/css/global.css" />
  <link rel="stylesheet" href="/css/compat-table.css" />
  <link rel="stylesheet" href="/css/font-failopen.css">
  <link rel="stylesheet" href="/css/compatibility.css" />
  <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg" />

  <style>
    /* --- Percent bar (Match %) --- */
    .pct {
      position: relative;
      width: 100%;
      height: 22px;
      border: 1px solid #3ddbf3;
      border-radius: 6px;
      background: rgba(61,219,243,0.08);
      overflow: hidden;
    }
    .pct-fill {
      position: absolute;
      inset: 0;
      width: 0%;
      background: linear-gradient(90deg, #18a0fb, #3df3c3);
      transition: width .35s ease;
    }
    .pct-text {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-variant-numeric: tabular-nums;
      font-weight: 600;
    }
    /* Friendly label text in first column (wrap nicely on small screens) */
    .tk-cat {
      white-space: normal;
      line-height: 1.2;
    }
    .tk-code {
      opacity: .5;
      font-size: .85em;
      margin-left: .4rem;
    }
  </style>
  <style>
    td.pct-cell .pct { position: relative; height: 1.1em; line-height: 1.1em; }
    td.pct-cell .pct .bar { position:absolute; left:0; top:0; bottom:0; width:0%;
                            background:rgba(0,255,255,0.25); border-radius:2px; }
    td.pct-cell .pct .txt { position:relative; display:block; text-align:center; }
    td.pct-cell { min-width:5rem; }
  </style>
  <style>
  #pdf-container {
    width: 100%;
    max-width: 100%;
  }
  table {
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    text-align: center;
    vertical-align: middle;
    padding: 6px;
  }
  th:first-child, td:first-child {
    text-align: left;
    padding-left: 10px;
  }
  </style>
  <style>
    .upload-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      margin-top: 3rem;
    }

    .upload-button {
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
    }

    .upload-button input[type="file"] {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .upload-button .upload-trigger {
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .upload-button .upload-trigger:focus-visible {
      outline: 2px solid rgba(61, 219, 243, 0.9);
      outline-offset: 2px;
    }

    .wide-button {
      min-width: 260px;
      max-width: 300px;
      width: 100%;
    }
    .export-tip {
      font-size: 0.9rem;
      margin: 0;
    }
  </style>
  <style>
    /* Keep rows from splitting in both web and print */
    .compat-section tr { break-inside: avoid; page-break-inside: avoid; }

    /* Make sure tables are fixed-width to avoid right-side cutoff */
    .compat-section table {
      width: 100% !important;
      table-layout: fixed !important;
      border-collapse: collapse !important;
    }

    /* Optional: make header clean (no decorative lines/boxes) */
    .section-title, .category-header, .compat-category {
      border: none !important;
      box-shadow: none !important;
      background: transparent !important;
    }
  </style>
  <style>
    /* Force LIGHT pdf colors by default; override via body[style] if you want dark */
    :root { --pdf-bg:#fff; --pdf-text:#000; }
    .pdf-export, #pdfWrapper, .pdf-container {
      background: var(--pdf-bg) !important;
      color: var(--pdf-text) !important;
    }
  </style>
  <style>
    /* optional polish to match your theme */
    .tk-compat th, .tk-compat td{
      border-bottom:1px solid #00e6ff33;
      padding:.55rem .8rem;
      vertical-align:middle;
    }
    .tk-compat td.ta-c{ text-align:center; }
  </style>
  <style>
  /* Small, unobtrusive subtitle under the category code */
  .tk-catwrap { display:flex; flex-direction:column; gap:2px; }
  .tk-catwrap .tk-code { font-weight:600; letter-spacing:0.02em; }
  .tk-catwrap .tk-sub  {
    font-weight:500; opacity:.78;
    font-size: clamp(11px,.9vw,13px);
    line-height:1.2;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    max-width: min(48vw, 780px);  /* fits your wide first column */
  }

  /* Match % meter (tuned for your dark theme) */
  .tk-meter {
    position: relative;
    height: 10px; min-width: 110px;
    background: rgba(0, 230, 255, .12);
    border-radius: 999px;
    outline: 1px solid rgba(0,230,255,.20);
    overflow: hidden;
  }
  .tk-meter > .tk-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg,
      rgba(0,230,255,.88), rgba(120,255,250,.95));
    box-shadow: 0 0 10px rgba(0,230,255,.35) inset;
    border-radius: inherit;
    transition: width .35s ease;
  }
  .tk-meter + .tk-pct {
    display:inline-block; min-width: 42px;
    font-weight:800; letter-spacing:.02em;
    margin-left:.5rem; opacity:.9;
  }

  /* Keep row height stable on narrow screens */
  @media (max-width: 720px){
    .tk-catwrap .tk-sub { max-width: 70vw; }
    .tk-meter { min-width: 80px; }
  }
  </style>
  <style>
  /* ====== Match % chip (compact, no layout shift) ====== */
  .tk-match-chip{
    display:inline-flex; flex-direction:column; align-items:center; gap:6px;
    min-width:70px; line-height:1; vertical-align:middle;
  }
  .tk-match-num{ font-weight:800; letter-spacing:.02em; }
  .tk-match-bar{
    position:relative; width:90px; height:7px; border-radius:999px;
    outline:1px solid rgba(0,230,255,.35);
    background:rgba(0,230,255,.10); overflow:hidden;
  }
  .tk-match-fill{
    display:block; height:100%; width:var(--w,0%);
    background:linear-gradient(90deg,#00e6ff,#3bffc4);
    border-radius:inherit; transition:width .25s ease;
  }
  /* Dim the bar if the value is ‚Äúmissing‚Äù on that row */
  .tk-match-chip[data-missing="1"] .tk-match-bar{ opacity:.38; }

  /* ====== Category main + tiny subline (summary) ====== */
  .tk-cat-wrap{ display:flex; flex-direction:column; gap:3px; }
  .tk-cat-main{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .tk-cat-sub{
    font-size:.82em; color:#9beff7; opacity:.78;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    max-width:48ch;  /* keep it subtle; doesn‚Äôt stretch your layout */
  }
  /* On narrow screens you can hide the subline if you want */
  @media (max-width: 680px){
    .tk-cat-sub{ display:none; }
  }
  </style>
  <style>
  /* Compatibility table progressive enhancement (fallback match bar + labels) */
  td.ksv-match { white-space: nowrap; }

  .ksv-matchwrap{
    display:flex; flex-direction:column; align-items:center; gap:.4rem;
    min-width:8rem;
  }
  .ksv-pct{
    font: 800 0.95rem/1.1 system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    letter-spacing:.02em; color:#d9ffff;
  }
  .ksv-bar{
    width:100%; height:6px; border-radius:999px;
    background: rgba(0,230,255,.12);
    outline: 1px solid rgba(0,230,255,.35);
    overflow:hidden;
  }
  .ksv-bar > i{
    display:block; height:100%; width:var(--w,0%);
    background: linear-gradient(90deg,#00e6ff 0%, #5fffd6 100%);
    box-shadow: 0 0 6px #00e6ff66 inset;
  }

  .tk-upload-messages {
    display: grid;
    gap: 0.35rem;
    margin: 0.75rem auto 0;
    max-width: 32rem;
  }

  .tk-upload-status {
    font: 500 0.92rem/1.35 "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    color: #c9f4ff;
    text-align: center;
    padding: 0.45rem 0.75rem;
    background: rgba(0, 230, 255, 0.08);
    border: 1px solid rgba(0, 230, 255, 0.18);
    border-radius: 0.75rem;
    margin: 0;
  }

  .tk-upload-status[data-state="info"] {
    color: #c9f4ff;
  }

  .tk-upload-status[data-state="success"] {
    color: #9fffd6;
    background: rgba(53, 255, 197, 0.08);
    border-color: rgba(105, 255, 213, 0.25);
  }

  .tk-upload-status[data-state="error"] {
    color: #ffc1ce;
    background: rgba(255, 70, 102, 0.07);
    border-color: rgba(255, 102, 133, 0.2);
  }

  .tk-consent-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(4, 16, 28, 0.82);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    padding: 1.5rem;
  }

  .tk-consent-card {
    background: #04111c;
    border: 1px solid rgba(0, 230, 255, 0.25);
    box-shadow: 0 24px 60px rgba(0, 0, 0, 0.45);
    border-radius: 1rem;
    padding: 1.65rem;
    max-width: min(34rem, 100%);
    color: #f2fbff;
  }

  .tk-consent-card h2 {
    font: 700 1.2rem/1.3 "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    margin: 0 0 0.75rem;
  }

  .tk-consent-card p {
    margin: 0 0 1.25rem;
    font: 500 0.98rem/1.6 "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    color: #c8e9ff;
  }

  .tk-consent-actions {
    display: flex;
    justify-content: flex-end;
    gap: 0.75rem;
  }

  .tk-btn.tk-btn-secondary {
    background: rgba(0, 230, 255, 0.08);
  }

  .tk-btn.tk-btn-secondary:hover {
    background: rgba(0, 230, 255, 0.14);
  }

  .tk-consent-backdrop[hidden] {
    display: none;
  }

  td.ksv-cat{
    word-break: break-word;
  }
  .ksv-cat .ksv-cat-text{
    display:inline;
  }
  </style>

  <link rel="stylesheet" href="/assets/css/comparison.css" />
</head>
<body data-page="compat">
  <main class="tk-landing">
    <h1 class="tk-title">TalkKink Compatibility</h1>

    <div class="tk-menu">
      <label id="yourBtn" for="yourFile" class="tk-btn">Upload Your Survey</label>
      <label id="partnerBtn" for="partnerFile" class="tk-btn">Upload Partner‚Äôs Survey</label>
      <button id="downloadBtn" class="tk-btn" disabled>Download PDF</button>
    </div>

    <div class="tk-upload-messages" aria-live="polite" aria-atomic="true">
      <p id="yourStatus" class="tk-upload-status" role="status" hidden></p>
      <p id="partnerStatus" class="tk-upload-status" role="status" hidden></p>
    </div>

        <a href="https://talkkink.org/KinkSurveyPage/index.html" class="tk-btn back">‚Üê Back</a>

    <input id="yourFile" type="file" accept="application/json" hidden />
    <input id="partnerFile" type="file" accept="application/json" hidden />

  <script>
    (function () {
      const PARTNER_INPUT_SEL = '#partnerFile';
      const CONSENT_KEY = 'tk.partnerConsent.v1';

      const partnerInput = document.querySelector(PARTNER_INPUT_SEL);
      if (!partnerInput) return;

      let passthroughOnce = false;

      document.addEventListener(
        'change',
        async (ev) => {
          const t = ev.target;
          if (!(t instanceof HTMLInputElement) || t !== partnerInput) return;

          if (passthroughOnce) return;

          try {
            if (sessionStorage.getItem(CONSENT_KEY) === '1') return;
          } catch (err) {
            console.warn('[compat] unable to read consent flag', err);
          }

          ev.stopImmediatePropagation();
          ev.stopPropagation();

          const ok = await requestPartnerConsentDialog();
          if (!ok) {
            t.value = '';
            return;
          }

          try {
            sessionStorage.setItem(CONSENT_KEY, '1');
          } catch (err) {
            console.warn('[compat] unable to persist consent flag', err);
          }

          passthroughOnce = true;
          setTimeout(() => {
            t.dispatchEvent(new Event('change', { bubbles: true }));
            passthroughOnce = false;
          }, 0);
        },
        true
      );

      async function requestPartnerConsentDialog() {
        return confirm(
          'Before importing a partner‚Äôs survey, confirm you have their explicit consent to upload and compare their responses here.\n\n' +
            'Click ‚ÄúOK‚Äù to confirm consent and continue, or ‚ÄúCancel‚Äù to stop.'
        );
      }

      window.tkResetPartnerConsent = function () {
        try {
          sessionStorage.removeItem(CONSENT_KEY);
        } catch (err) {
          console.warn('[compat] unable to reset consent flag', err);
        }
        console.info('[compat] partner consent reset for this tab.');
      };
    })();
  </script>
  </main>

  <script>
    function ksvParseSurveyJsonText(jsonText, partner = 'A') {
      const fail = (reason) => ({ ok: false, reason, cells: [], survey: null });
      if (typeof jsonText !== 'string') return fail('No JSON payload provided');

      let payload;
      try {
        payload = JSON.parse(jsonText);
      } catch (err) {
        return fail('Invalid JSON');
      }

      const answers = {};
      const answersByKey = {};
      let maxIndex = 0;

      const clamp = (value) => {
        const n = Number(value);
        if (!Number.isFinite(n)) return 0;
        if (n < 0) return 0;
        if (n > 5) return 5;
        return Math.round(n);
      };

      const toRating = (value) => {
        if (value == null || value === '') return 0;
        if (typeof value === 'number' && Number.isFinite(value)) return clamp(value);
        if (typeof value === 'string') {
          const trimmed = value.trim();
          if (!trimmed) return 0;
          const match = trimmed.match(/-?\d+(?:\.\d+)?/);
          if (match) return clamp(Number(match[0]));
        }
        return 0;
      };

      const applyRating = (index, value) => {
        const idx = Number(index);
        if (!Number.isFinite(idx) || idx <= 0) return;
        const normalized = toRating(value);
        const key = String(idx);
        answersByKey[key] = normalized;
        if (idx > maxIndex) maxIndex = idx;
      };

      const absorbArray = (arr) => {
        if (!Array.isArray(arr)) return;
        arr.forEach((value, i) => applyRating(i + 1, value));
      };

      const absorbObject = (obj) => {
        if (!obj || typeof obj !== 'object') return;
        Object.keys(obj)
          .sort((a, b) => Number(a) - Number(b))
          .forEach((key) => applyRating(key, obj[key]));
      };

      if (Array.isArray(payload)) {
        absorbArray(payload);
      } else if (payload && typeof payload === 'object') {
        absorbArray(payload.cells);
        absorbArray(payload.answers);
        absorbObject(payload.answersByKey);
        absorbObject(payload.answersById);
        absorbObject(payload.ratings);
      } else {
        return fail('Unsupported survey payload');
      }

      if (!maxIndex) {
        return fail('No survey answers found');
      }

      for (let i = 1; i <= maxIndex; i += 1) {
        const key = String(i);
        const rating = Object.prototype.hasOwnProperty.call(answersByKey, key)
          ? answersByKey[key]
          : 0;
        answers[key] = rating;
        answersByKey[key] = rating;
      }

      const cells = Array.from({ length: maxIndex }, (_, i) => answersByKey[String(i + 1)] ?? 0);
      return { ok:true, cells, survey: { answers, answersByKey } };
}

    window.ksvParseSurveyJsonText = ksvParseSurveyJsonText;
  </script>

  <!-- ================== CODEX: Hard-intercept slow 'change' handler + Consent + Dark PDF ==================
       Paste this once near the END of compatibility.html (after your inputs/buttons).
       What this does:
         ‚Ä¢ Kills the long-running legacy 'change' handler by intercepting it in the CAPTURE phase and stopping propagation.
         ‚Ä¢ Shows a consent confirm for Partner uploads and adds the consent line to the ‚ÄúUploaded ‚úì‚Äù alert.
         ‚Ä¢ Defers all heavy work (JSON parse + PDF) off the 'change' event.
         ‚Ä¢ Generates a DARK, neon-themed PDF (A/B comparison or single) on the Download button.
       Assumed IDs:
         #yourBtn  -> #yourFile
         #partnerBtn -> #partnerFile
         #downloadBtn -> build PDF
  ======================================================================================================= -->
  <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js" crossorigin="anonymous"></script>
  <script>
    (function () {
      const $ = (selector, root = document) => root.querySelector(selector);
      const dispatch = (name, detail) => document.dispatchEvent(new CustomEvent(name, { detail }));

      window.__TK_FAST_UPLOADS__ = true;
      window.__TK_ALLOW_SINGLE_PDF__ = true;

      const PARTNER_CONSENT_KEY = 'tk.partnerConsent.v1';

      const getConsentFlag = () => {
        try {
          return sessionStorage.getItem(PARTNER_CONSENT_KEY) === '1';
        } catch (err) {
          console.warn('[compat] unable to access consent flag', err);
          return false;
        }
      };

      const setConsentFlag = () => {
        try {
          sessionStorage.setItem(PARTNER_CONSENT_KEY, '1');
        } catch (err) {
          console.warn('[compat] unable to persist consent flag', err);
        }
      };

      // --- Open hidden pickers ---
      $('#yourBtn')?.addEventListener('click', () => $('#yourFile')?.click());
      $('#partnerBtn')?.addEventListener('click', () => $('#partnerFile')?.click());

      // --- State ---
      let yourBlob = null;
      let partnerBlob = null;
      let yourJSON = null;
      let partnerJSON = null;

      const downloadBtn = $('#downloadBtn');
      const parseQueue = new Set();

      const statusEls = {
        self: $('#yourStatus'),
        partner: $('#partnerStatus')
      };

      const setStatus = (which, message, state = 'info') => {
        const el = statusEls[which];
        if (!el) return;
        if (!message) {
          el.textContent = '';
          el.hidden = true;
          el.removeAttribute('data-state');
          return;
        }
        el.textContent = message;
        el.dataset.state = state;
        el.hidden = false;
      };

      let consentUI = null;

      const clampScore = (value) => {
        const num = Number(value);
        if (!Number.isFinite(num)) return 0;
        if (num <= 0) return 0;
        if (num >= 5) return 5;
        return Math.round(num);
      };

      const ROLE_ALIASES = {
        giving: 'Giving',
        giver: 'Giving',
        dom: 'Dominant',
        dominant: 'Dominant',
        top: 'Dominant',
        receiving: 'Receiving',
        receiver: 'Receiving',
        sub: 'Submissive',
        submissive: 'Submissive',
        bottom: 'Submissive',
        switch: 'Switch',
        general: 'General',
        neutral: 'General'
      };

      const normalizeRole = (value) => {
        if (!value) return 'General';
        const key = String(value).trim().toLowerCase();
        return ROLE_ALIASES[key] || (key ? key[0].toUpperCase() + key.slice(1) : 'General');
      };

      const tidyLabel = (value, fallback) => {
        const str = String(value || '').replace(/\s+/g, ' ').trim();
        if (str) return str;
        return fallback ? String(fallback) : '';
      };

      function normalizeCompatPayload(raw, which) {
        if (!raw) return raw;

        if (Array.isArray(raw)) {
          const answers = raw.map((score, idx) => ({
            kinkId: `item-${idx + 1}`,
            side: 'general',
            score
          }));
          return normalizeCompatPayload({ answers }, which);
        }

        if (typeof raw !== 'object') return raw;

        const normalized = { ...raw };

        const responses = Array.isArray(normalized.responses)
          ? normalized.responses.map((entry, idx) => {
              if (!entry || typeof entry !== 'object') {
                return null;
              }
              const baseId = String(entry.id || `${which || 'A'}-${idx + 1}`);
              const role = normalizeRole(entry.role || entry.side || entry.channel);
              const rating = clampScore(entry.rating ?? entry.score ?? entry.value ?? 0);
              const prompt = tidyLabel(entry.prompt || entry.label || entry.title || entry.name || entry.question, baseId);
              const category = tidyLabel(
                entry.category || entry.categoryName || entry.group || entry.section,
                normalized.meta?.surveyTitle || ''
              );
              return {
                ...entry,
                id: baseId,
                role,
                rating,
                prompt,
                category
              };
            }).filter(Boolean)
          : [];

        normalized.responses = responses;

        const seenIds = new Set(responses.map((entry) => entry.id));
        const ensureAnswersArray = () => {
          const sources = [];
          if (Array.isArray(normalized.answers)) sources.push(normalized.answers);
          if (Array.isArray(normalized.survey?.answers)) sources.push(normalized.survey.answers);
          if (Array.isArray(normalized.survey?.responses)) sources.push(normalized.survey.responses);
          return sources.flat();
        };

        const candidates = ensureAnswersArray();

        candidates.forEach((answer, idx) => {
          if (!answer || typeof answer !== 'object') return;
          const kinkId = tidyLabel(
            answer.kinkId || answer.id || answer.key || answer.name || answer.questionId,
            `item-${idx + 1}`
          );
          const sideRaw = String(answer.side || answer.role || answer.channel || 'general');
          const role = normalizeRole(sideRaw);
          const score = clampScore(answer.score ?? answer.rating ?? answer.value ?? answer.answer ?? 0);
          const category = tidyLabel(
            answer.category || answer.categoryName || answer.group || answer.section || answer.categoryId,
            normalized.meta?.surveyTitle || ''
          );
          const prompt = tidyLabel(answer.title || answer.label || answer.prompt || answer.name || kinkId, kinkId);
          const idHint = tidyLabel(answer.id || '', kinkId);
          const baseId = idHint && idHint !== kinkId ? idHint : kinkId;
          const sideKey = sideRaw.trim().toLowerCase() || 'general';
          const composedId = baseId.toLowerCase().endsWith(`-${sideKey}`)
            ? baseId
            : `${baseId}-${sideKey}`;
          if (!seenIds.has(composedId)) {
            responses.push({
              id: composedId,
              kinkId,
              role,
              rating: score,
              category,
              prompt
            });
            seenIds.add(composedId);
          }
        });

        if (!normalized.answersById || typeof normalized.answersById !== 'object') {
          normalized.answersById = {};
        }

        responses.forEach((entry, idx) => {
          if (!entry || typeof entry !== 'object') return;
          const id = tidyLabel(entry.id, `${which || 'A'}-${idx + 1}`);
          const score = clampScore(entry.rating ?? entry.score ?? entry.value ?? 0);
          normalized.answersById[id] = score;
        });

        if (!normalized.answersByKey || typeof normalized.answersByKey !== 'object') {
          const map = {};
          responses.forEach((entry, idx) => {
            map[String(idx + 1)] = clampScore(entry.rating ?? entry.score ?? entry.value ?? 0);
          });
          if (Object.keys(map).length) normalized.answersByKey = map;
        }

        return normalized;
      }

      function ensureConsentUI() {
        if (consentUI) return consentUI;
        const overlay = document.createElement('div');
        overlay.className = 'tk-consent-backdrop';
        overlay.hidden = true;

        overlay.innerHTML = `
          <div class="tk-consent-card" role="dialog" aria-modal="true" aria-labelledby="tk-consent-title" aria-describedby="tk-consent-copy">
            <h2 id="tk-consent-title">Confirm partner consent</h2>
            <p id="tk-consent-copy">
              Before importing a partner‚Äôs survey, confirm you have their explicit permission to upload and compare
              their responses here.
            </p>
            <div class="tk-consent-actions">
              <button type="button" class="tk-btn tk-btn-secondary" data-action="cancel">Cancel</button>
              <button type="button" class="tk-btn" data-action="confirm">Yes, I have consent</button>
            </div>
          </div>
        `;

        document.body.appendChild(overlay);

        const card = overlay.querySelector('.tk-consent-card');
        const confirmBtn = overlay.querySelector('[data-action="confirm"]');
        const cancelBtn = overlay.querySelector('[data-action="cancel"]');

        card.tabIndex = -1;

        consentUI = { overlay, card, confirmBtn, cancelBtn };
        return consentUI;
      }

      function requestPartnerConsent() {
        const { overlay, card, confirmBtn, cancelBtn } = ensureConsentUI();
        overlay.hidden = false;

        const previousFocus = document.activeElement;

        return new Promise((resolve) => {
          const cleanup = (result) => {
            overlay.hidden = true;
            overlay.removeEventListener('click', onBackdrop);
            document.removeEventListener('keydown', onKeyDown, true);
            confirmBtn.removeEventListener('click', onConfirm);
            cancelBtn.removeEventListener('click', onCancel);
            if (previousFocus && typeof previousFocus.focus === 'function') {
              previousFocus.focus();
            }
            resolve(result);
          };

          const onConfirm = () => cleanup(true);
          const onCancel = () => cleanup(false);

          const onBackdrop = (event) => {
            if (event.target === overlay) {
              event.preventDefault();
              onCancel();
            }
          };

          const onKeyDown = (event) => {
            if (event.key === 'Escape') {
              event.preventDefault();
              onCancel();
            }
          };

          overlay.addEventListener('click', onBackdrop);
          document.addEventListener('keydown', onKeyDown, true);
          confirmBtn.addEventListener('click', onConfirm);
          cancelBtn.addEventListener('click', onCancel);

          requestAnimationFrame(() => {
            card.focus();
          });
        });
      }

      function resetSelection(which, { resetStatus = true } = {}) {
        if (which === 'self') {
          yourBlob = null;
          yourJSON = null;
        } else {
          partnerBlob = null;
          partnerJSON = null;
        }
        if (resetStatus) setStatus(which, '', '');
      }

      const allowSingle = Boolean(window.__TK_ALLOW_SINGLE_PDF__);

      function updateDownloadState() {
        if (!downloadBtn) return;
        const ready = allowSingle ? Boolean(yourJSON || partnerJSON) : Boolean(yourJSON && partnerJSON);
        downloadBtn.disabled = !ready;
      }

      async function parseAndCache(which) {
        const isSelf = which === 'self';
        const blob = isSelf ? yourBlob : partnerBlob;
        if (!blob) return null;

        if (isSelf ? yourJSON : partnerJSON) {
          return isSelf ? yourJSON : partnerJSON;
        }

        const text = await blob.text();
        let json;
        try {
          json = JSON.parse(text);
        } catch (err) {
          err.which = which;
          throw err;
        }

        json = normalizeCompatPayload(json, which);

        if (isSelf) {
          yourJSON = json;
          window.talkkinkMine = json;
          window.talkkinkSurvey = json;
        } else {
          partnerJSON = json;
          window.talkkinkPartner = json;
        }

        dispatch('compat:json-ready', {
          which,
          json,
          fileName: blob.name || ''
        });

        if (which === 'partner') {
          setStatus(which, 'Partner survey ready ‚úì ‚Äî consent recorded.', 'success');
        } else {
          setStatus(which, 'Your survey ready ‚úì', 'success');
        }

        updateDownloadState();
        return json;
      }

      function scheduleParse(which) {
        if (parseQueue.has(which)) return;
        parseQueue.add(which);
        setTimeout(async () => {
          parseQueue.delete(which);
          try {
            await parseAndCache(which);
          } catch (err) {
            console.error(err);
            const id = err?.which || which;
            resetSelection(id, { resetStatus: false });
            setStatus(id, 'Invalid file ‚Äî expected a TalkKink JSON export.', 'error');
            updateDownloadState();
            dispatch('compat:file-selected', { which: id, file: null });
          }
        }, 0);
      }

      document.addEventListener(
        'change',
        (ev) => {
          const target = ev.target;
          if (!target || !(target instanceof HTMLInputElement)) return;
          if (!target.matches('#yourFile, #partnerFile')) return;

          ev.stopImmediatePropagation();
          ev.stopPropagation();

          const which = target.id === 'partnerFile' ? 'partner' : 'self';
          const file = target.files && target.files[0];

          const run = async () => {
            if (!file) {
              target.value = '';
              resetSelection(which);
              updateDownloadState();
              dispatch('compat:file-selected', { which, file: null });
              return;
            }

            if (which === 'partner' && !getConsentFlag()) {
              setStatus(which, 'Awaiting partner consent‚Ä¶', 'info');
              const ok = await requestPartnerConsent();
              if (!ok) {
                target.value = '';
                resetSelection('partner');
                updateDownloadState();
                setStatus('partner', 'Upload canceled ‚Äî partner consent required.', 'info');
                dispatch('compat:file-selected', { which: 'partner', file: null });
                return;
              }
              setConsentFlag();
            }

            if (which === 'self') {
              yourBlob = file;
              yourJSON = null;
            } else {
              partnerBlob = file;
              partnerJSON = null;
            }

            const statusMessage =
              which === 'partner' ? 'Processing partner survey‚Ä¶' : 'Processing your survey‚Ä¶';
            setStatus(which, statusMessage, 'info');

            dispatch('compat:file-selected', { which, file });

            target.value = '';
            updateDownloadState();
            scheduleParse(which);
          };

          run().catch((error) => {
            console.error(error);
            resetSelection(which, { resetStatus: false });
            setStatus(which, 'Upload failed. Please try again.', 'error');
            updateDownloadState();
            dispatch('compat:file-selected', { which, file: null });
          });
        },
        true
      );

      if (downloadBtn) {
        const handleDownloadClick = async () => {
          try {
            await Promise.all([parseAndCache('self'), parseAndCache('partner')]);
            if (!yourJSON && !partnerJSON) {
              alert('Please upload at least one survey before downloading.');
              return;
            }
            await generateDarkPDF(yourJSON, partnerJSON);
          } catch (err) {
            console.error(err);
            const id = err?.which;
            if (id === 'self' || id === 'partner') {
              resetSelection(id);
              updateDownloadState();
              dispatch('compat:file-selected', { which: id, file: null });
            }
            alert('Sorry‚Äîcould not generate the PDF.');
          }
        };

        downloadBtn.addEventListener(
          'click',
          (event) => {
            event.stopImmediatePropagation();
            event.stopPropagation();
            event.preventDefault();
            handleDownloadClick();
          },
          true
        );
      }

      const cap = (s) => (s ? s[0].toUpperCase() + s.slice(1) : s);

      function rowsFromTalkKink(json) {
        if (!json) return [];

        const rows = [];
        const pushRow = (source, idx = 0) => {
          if (!source || typeof source !== 'object') return;
          const score = clampScore(source.score ?? source.rating ?? source.value ?? source.answer ?? 0);
          const label = tidyLabel(source.item || source.prompt || source.title || source.label || source.name || source.id, `Item ${idx + 1}`);
          const role = normalizeRole(source.role || source.side || source.channel || source.position);
          const category = tidyLabel(source.category || source.categoryName || source.group || source.section, 'Other');
          const kinkKey = tidyLabel(source.kinkId || source.id || label, label);
          rows.push({
            Category: category || 'Other',
            Item: cap(label),
            Role: role,
            Score: score,
            _key: `${kinkKey}|${role}`.toLowerCase()
          });
        };

        if (Array.isArray(json.responses) && json.responses.length) {
          json.responses.forEach((resp, idx) => pushRow(resp, idx));
        } else if (Array.isArray(json.answers) && json.answers.length) {
          json.answers.forEach((answer, idx) => pushRow(answer, idx));
        } else if (json.answersById && typeof json.answersById === 'object') {
          Object.entries(json.answersById).forEach(([id, score], idx) => {
            if (!id) return;
            const parts = String(id).split('-');
            const role = normalizeRole(parts.at(-1));
            const base = parts.slice(0, -1).join('-');
            const label = tidyLabel(
              parts
                .slice(2, -1)
                .join(' ')
                .replace(/\bTv\b/gi, 'TV'),
              `Item ${idx + 1}`
            );
            const category = tidyLabel(parts.slice(0, 2).join(' '), 'Other');
            rows.push({
              Category: category || 'Other',
              Item: cap(label),
              Role: role,
              Score: clampScore(score),
              _key: `${base}|${role}`.toLowerCase()
            });
          });
        }

        const deduped = Array.from(
          rows.reduce((map, row) => {
            if (!map.has(row._key)) map.set(row._key, row);
            return map;
          }, new Map()).values()
        );

        deduped.sort(
          (a, b) =>
            a.Category.localeCompare(b.Category) ||
            a.Role.localeCompare(b.Role) ||
            a.Item.localeCompare(b.Item)
        );

        return deduped;
      }

      async function generateDarkPDF(yourJSON, partnerJSON) {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ unit: 'pt', format: 'letter' });

        const W = doc.internal.pageSize.getWidth();
        const H = doc.internal.pageSize.getHeight();

        function paintPageChrome() {
          doc.setFillColor(10, 10, 12);
          doc.rect(0, 0, W, H, 'F');
          doc.setDrawColor(0, 255, 255);
          doc.setLineWidth(1);
          doc.line(48, 68, W - 48, 68);
          doc.setTextColor(255, 255, 255);
          doc.setFont('helvetica', 'bold');
          doc.setFontSize(18);
          doc.text('TalkKink Compatibility ‚Äî Printable Report', 48, 50);
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(10);
          doc.setTextColor(170, 200, 255);
          doc.text('Generated: ' + new Date().toLocaleString(), 48, 62);
        }
        paintPageChrome();

        const tableBase = {
          theme: 'grid',
          styles: {
            font: 'helvetica',
            fontSize: 10,
            cellPadding: 4,
            textColor: [235, 235, 242],
            lineColor: [60, 60, 78],
            lineWidth: 0.25,
            fillColor: [18, 18, 22]
          },
          alternateRowStyles: { fillColor: [26, 26, 32] },
          headStyles: { fillColor: [0, 0, 0], textColor: [0, 255, 255] },
          margin: { left: 48, right: 48 },
          didAddPage: () => paintPageChrome()
        };

        const rowsA = rowsFromTalkKink(yourJSON);
        const rowsB = rowsFromTalkKink(partnerJSON);
        const hasA = rowsA.length > 0;
        const hasB = rowsB.length > 0;

        let y = 90;

        if (hasA && hasB) {
          const cats = [...new Set([...rowsA, ...rowsB].map((r) => r.Category))];
          for (const cat of cats) {
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(13);
            doc.setTextColor(255, 255, 255);
            doc.text(cat, 48, y);
            y += 8;

            const body = buildComparisonBody(
              rowsA.filter((r) => r.Category === cat),
              rowsB.filter((r) => r.Category === cat)
            );

            doc.autoTable({
              ...tableBase,
              startY: y + 8,
              head: [['Role', 'Item', 'Partner A', 'Match', 'Flag', 'Partner B']],
              body,
              columnStyles: {
                0: { cellWidth: 70 },
                1: { cellWidth: 280 },
                2: { cellWidth: 60, halign: 'center' },
                3: { cellWidth: 60, halign: 'center' },
                4: { cellWidth: 40, halign: 'center' },
                5: { cellWidth: 60, halign: 'center' }
              }
            });
            y = doc.lastAutoTable.finalY + 16;
            if (y > H - 72) {
              doc.addPage();
              paintPageChrome();
              y = 90;
            }
          }
        } else {
          const rows = hasA ? rowsA : rowsB;
          const whose = hasA ? 'Partner A' : 'Partner';
          const cats = [...new Set(rows.map((r) => r.Category))];

          for (const cat of cats) {
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(13);
            doc.setTextColor(255, 255, 255);
            doc.text(`${cat} ‚Äî ${whose}`, 48, y);
            y += 8;

            const body = rows
              .filter((r) => r.Category === cat)
              .map((r) => [r.Role, r.Item, String(r.Score)]);
            doc.autoTable({
              ...tableBase,
              startY: y + 8,
              head: [['Role', 'Item', 'Score']],
              body,
              columnStyles: {
                0: { cellWidth: 90 },
                1: { cellWidth: 350 },
                2: { cellWidth: 60, halign: 'center' }
              }
            });
            y = doc.lastAutoTable.finalY + 16;
            if (y > H - 72) {
              doc.addPage();
              paintPageChrome();
              y = 90;
            }
          }
        }

        const name = hasA && hasB ? 'compatibility-pretty-dark.pdf' : 'partner-survey-pretty-dark.pdf';
        doc.save(name);
      }

      function buildComparisonBody(rowsA, rowsB) {
        const key = (r) => (r._key || `${r.Role}|${r.Item}`).toLowerCase();
        const mapA = Object.fromEntries(rowsA.map((r) => [key(r), r]));
        const mapB = Object.fromEntries(rowsB.map((r) => [key(r), r]));
        const keys = [...new Set([...Object.keys(mapA), ...Object.keys(mapB)])].sort();
        const body = [];
        for (const k of keys) {
          const a = mapA[k];
          const b = mapB[k];
          const role = a?.Role || b?.Role || '';
          const item = a?.Item || b?.Item || '';
          const aScore = Number.isFinite(a?.Score) ? a.Score : '';
          const bScore = Number.isFinite(b?.Score) ? b.Score : '';

          let match = '';
          let flag = '';
          if (a && b) {
            const diff = Math.abs(a.Score - b.Score);
            const pct = Math.round((1 - diff / 5) * 100);
            match = pct + '%';
            if (pct >= 90) flag = '‚≠ê';
            else if (pct <= 30) flag = 'üö©';
            if ((a?.Score === 5 && b?.Score < 5) || (b?.Score === 5 && a?.Score < 5)) {
              flag = flag ? flag + ' üü®' : 'üü®';
            }
          }
          body.push([role, item, String(aScore), match, flag, String(bScore)]);
        }
        return body;
      }
    })();
  </script>
    <script defer src="/assets/js/comparison.js"></script>
  <script defer>
    /**
     * Safely clear margin on the dock *only if it exists on this page*.
     * This replaces any previous null-unsafe code around lines ~188‚Äì192.
     */
    (function () {
      const SELECTOR = '#compat-dock, .compat-dock, [data-compat-dock]';

      function clearDockMarginSafe() {
        const el = document.querySelector(SELECTOR);
        if (!el) return;                  // No-op if the dock isn't present
        el.style.removeProperty('margin');
        el.style.removeProperty('margin-bottom');
      }

      // Run after DOM is parsed; also handle late mounts briefly
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', clearDockMarginSafe, { once: true });
      } else {
        queueMicrotask(clearDockMarginSafe);
      }
      const mo = new MutationObserver(() => {
        const el = document.querySelector(SELECTOR);
        if (el) { clearDockMarginSafe(); mo.disconnect(); }
      });
      mo.observe(document.documentElement, { childList: true, subtree: true });
      setTimeout(() => mo.disconnect(), 3000);
    })();
  </script>
</body>

</html>
