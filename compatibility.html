<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Kill-switch for legacy Partner-B bootstrap that caused "freeze after first upload" -->
  <script>
    // Hard disable any code path that auto-fills Partner B from internal JSON.
    // This must be loaded before every other script.
    window.TK_DISABLE_BOOTSTRAP_B = true;
    console.info('[compat] kill-switch enabled');
    // one-time guard so labels/overrides merge only once per load
    window._tkLabelsMerged = false;
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>See Our Compatibility</title>
  <style>
    /* Kill any category dock/panel overlays without layout shift */
    #tkDockCard,
    #categorySurveyPanel,
    aside.category-panel,
    .category-panel,
    [data-testid="select-categories-panel"],
    #tkOverlay,
    .tk-overlay {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }

    /* Ensure body isn't pushed for a removed dock */
    html.tk-dock body {
      margin-left: 0 !important;
    }
  </style>
  <script>
    (function killCategoryPanel() {
      const selectors = [
        '#tkDockCard',
        '#categorySurveyPanel',
        'aside.category-panel',
        '.category-panel',
        '[data-testid="select-categories-panel"]',
        '#tkOverlay',
        '.tk-overlay'
      ];

      window.__TK_DISABLE_PANEL__ = true;
      window.__TK_DISABLE_PORTAL__ = true;

      const purge = () => {
        document.documentElement.classList.remove('tk-dock');
        if (document.body) {
          document.body.style.marginLeft = '';
        }
        selectors.forEach((selector) => {
          document.querySelectorAll(selector).forEach((node) => node.remove());
        });
      };

      purge();

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', purge, { once: true });
      }

      const observer = new MutationObserver(purge);
      observer.observe(document.documentElement, { childList: true, subtree: true });
      setTimeout(() => observer.disconnect(), 4000);
    })();
  </script>
  <!-- COMPAT PAGE: recentre layout + neutralize any dock margin -->
  <style id="compat-centering">
    :root {
      --tk-dock-width: 0px !important;
    }

    html,
    body {
      margin: 0;
    }

    .compat-page,
    .compat-wrapper,
    #compatRoot,
    main,
    .page,
    .container {
      max-width: 960px;
      margin: 0 auto !important;
      padding: 40px 16px;
    }

    .compat-buttons,
    .compat-actions {
      display: flex;
      flex-direction: column;
      gap: 24px;
      align-items: center;
    }

    .compat-buttons .themed-button,
    .compat-actions .themed-button,
    .themed-button.compat {
      width: min(680px, 90vw);
    }
  </style>

  <script>
    (function () {
      try {
        if (document.body) {
          document.body.style.marginLeft = '0px';
        }
        document.documentElement.style.setProperty('--tk-dock-width', '0px');

        const host = document.querySelector(
          '#compatRoot, .compat-page, .compat-wrapper, main, .page, .container'
        );

        if (host) {
          Object.assign(host.style, {
            maxWidth: '960px',
            margin: '0 auto',
            padding: '40px 16px'
          });
        }

        document.querySelectorAll('.themed-button').forEach((btn) => {
          Object.assign(btn.style, {
            width: 'min(680px, 90vw)',
            margin: '0 auto',
            display: 'block'
          });
        });
      } catch (err) {
        console.warn('[compat] unable to apply centering overrides', err);
      }
    })();
  </script>
  <style id="tk-compat-center">
    /* Remove any panel/dock if an older script injected it */
    #tkDockCard,
    #categorySurveyPanel,
    .category-panel,
    .tk-overlay {
      display: none !important;
    }

    html,
    body {
      margin: 0;
    }

    body[style*="margin-left"] {
      margin-left: 0 !important;
    }

    /* Center the content column */
    .compat-wrap,
    .compat-container,
    .container,
    main,
    #app {
      box-sizing: border-box;
      max-width: 960px;
      width: min(960px, 92vw);
      margin-inline: auto;
      padding-inline: 16px;
    }

    .compat-wrap > *,
    .compat-container > *,
    .container > *,
    main > * {
      max-width: 100%;
    }
  </style>
  <script>
    (function () {
      const clearDock = () => {
        // Nuke any leftover dock/overlay/panel on this page
        for (const sel of ['#tkDockCard', '.tk-overlay', '#categorySurveyPanel', '.category-panel']) {
          const n = document.querySelector(sel);
          if (n) n.remove();
        }

        const body = document.body;
        if (body) {
          body.style.marginLeft = '';
        }

        const dock = document.querySelector('#compat-dock');
        if (dock) {
          dock.style.removeProperty('margin-bottom');
        }
      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', clearDock, { once: true });
      } else {
        clearDock();
      }
    })();
  </script>
  <!-- Import theme and global layout styles -->
  <link rel="stylesheet" href="/css/theme.css" />
  <link rel="stylesheet" href="/css/global.css" />
  <link rel="stylesheet" href="/css/compat-table.css" />
  <link rel="stylesheet" href="/css/font-failopen.css">
  <link rel="stylesheet" href="/css/compatibility.css" />
  <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg" />

  <style>
    /* --- Percent bar (Match %) --- */
    .pct {
      position: relative;
      width: 100%;
      height: 22px;
      border: 1px solid #3ddbf3;
      border-radius: 6px;
      background: rgba(61,219,243,0.08);
      overflow: hidden;
    }
    .pct-fill {
      position: absolute;
      inset: 0;
      width: 0%;
      background: linear-gradient(90deg, #18a0fb, #3df3c3);
      transition: width .35s ease;
    }
    .pct-text {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-variant-numeric: tabular-nums;
      font-weight: 600;
    }
    /* Friendly label text in first column (wrap nicely on small screens) */
    .tk-cat {
      white-space: normal;
      line-height: 1.2;
    }
    .tk-code {
      opacity: .5;
      font-size: .85em;
      margin-left: .4rem;
    }
  </style>
  <style>
    td.pct-cell .pct { position: relative; height: 1.1em; line-height: 1.1em; }
    td.pct-cell .pct .bar { position:absolute; left:0; top:0; bottom:0; width:0%;
                            background:rgba(0,255,255,0.25); border-radius:2px; }
    td.pct-cell .pct .txt { position:relative; display:block; text-align:center; }
    td.pct-cell { min-width:5rem; }
  </style>
  <style>
  #pdf-container {
    width: 100%;
    max-width: 100%;
  }
  table {
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    text-align: center;
    vertical-align: middle;
    padding: 6px;
  }
  th:first-child, td:first-child {
    text-align: left;
    padding-left: 10px;
  }
  </style>
  <style>
    .upload-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      margin-top: 3rem;
    }

    .upload-button {
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
    }

    .upload-button input[type="file"] {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .upload-button .upload-trigger {
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .upload-button .upload-trigger:focus-visible {
      outline: 2px solid rgba(61, 219, 243, 0.9);
      outline-offset: 2px;
    }

    .wide-button {
      min-width: 260px;
      max-width: 300px;
      width: 100%;
    }
    .export-tip {
      font-size: 0.9rem;
      margin: 0;
    }
  </style>
  <style>
    /* Keep rows from splitting in both web and print */
    .compat-section tr { break-inside: avoid; page-break-inside: avoid; }

    /* Make sure tables are fixed-width to avoid right-side cutoff */
    .compat-section table {
      width: 100% !important;
      table-layout: fixed !important;
      border-collapse: collapse !important;
    }

    /* Optional: make header clean (no decorative lines/boxes) */
    .section-title, .category-header, .compat-category {
      border: none !important;
      box-shadow: none !important;
      background: transparent !important;
    }
  </style>
  <style>
    /* Force LIGHT pdf colors by default; override via body[style] if you want dark */
    :root { --pdf-bg:#fff; --pdf-text:#000; }
    .pdf-export, #pdfWrapper, .pdf-container {
      background: var(--pdf-bg) !important;
      color: var(--pdf-text) !important;
    }
  </style>
  <style>
    /* optional polish to match your theme */
    .tk-compat th, .tk-compat td{
      border-bottom:1px solid #00e6ff33;
      padding:.55rem .8rem;
      vertical-align:middle;
    }
    .tk-compat td.ta-c{ text-align:center; }
  </style>
  <style>
  /* Small, unobtrusive subtitle under the category code */
  .tk-catwrap { display:flex; flex-direction:column; gap:2px; }
  .tk-catwrap .tk-code { font-weight:600; letter-spacing:0.02em; }
  .tk-catwrap .tk-sub  {
    font-weight:500; opacity:.78;
    font-size: clamp(11px,.9vw,13px);
    line-height:1.2;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    max-width: min(48vw, 780px);  /* fits your wide first column */
  }

  /* Match % meter (tuned for your dark theme) */
  .tk-meter {
    position: relative;
    height: 10px; min-width: 110px;
    background: rgba(0, 230, 255, .12);
    border-radius: 999px;
    outline: 1px solid rgba(0,230,255,.20);
    overflow: hidden;
  }
  .tk-meter > .tk-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg,
      rgba(0,230,255,.88), rgba(120,255,250,.95));
    box-shadow: 0 0 10px rgba(0,230,255,.35) inset;
    border-radius: inherit;
    transition: width .35s ease;
  }
  .tk-meter + .tk-pct {
    display:inline-block; min-width: 42px;
    font-weight:800; letter-spacing:.02em;
    margin-left:.5rem; opacity:.9;
  }

  /* Keep row height stable on narrow screens */
  @media (max-width: 720px){
    .tk-catwrap .tk-sub { max-width: 70vw; }
    .tk-meter { min-width: 80px; }
  }
  </style>
  <style>
  /* ====== Match % chip (compact, no layout shift) ====== */
  .tk-match-chip{
    display:inline-flex; flex-direction:column; align-items:center; gap:6px;
    min-width:70px; line-height:1; vertical-align:middle;
  }
  .tk-match-num{ font-weight:800; letter-spacing:.02em; }
  .tk-match-bar{
    position:relative; width:90px; height:7px; border-radius:999px;
    outline:1px solid rgba(0,230,255,.35);
    background:rgba(0,230,255,.10); overflow:hidden;
  }
  .tk-match-fill{
    display:block; height:100%; width:var(--w,0%);
    background:linear-gradient(90deg,#00e6ff,#3bffc4);
    border-radius:inherit; transition:width .25s ease;
  }
  /* Dim the bar if the value is ‚Äúmissing‚Äù on that row */
  .tk-match-chip[data-missing="1"] .tk-match-bar{ opacity:.38; }

  /* ====== Category main + tiny subline (summary) ====== */
  .tk-cat-wrap{ display:flex; flex-direction:column; gap:3px; }
  .tk-cat-main{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .tk-cat-sub{
    font-size:.82em; color:#9beff7; opacity:.78;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    max-width:48ch;  /* keep it subtle; doesn‚Äôt stretch your layout */
  }
  /* On narrow screens you can hide the subline if you want */
  @media (max-width: 680px){
    .tk-cat-sub{ display:none; }
  }
  </style>
  <style>
  /* Compatibility table progressive enhancement (fallback match bar + labels) */
  td.ksv-match { white-space: nowrap; }

  .ksv-matchwrap{
    display:flex; flex-direction:column; align-items:center; gap:.4rem;
    min-width:8rem;
  }
  .ksv-pct{
    font: 800 0.95rem/1.1 system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    letter-spacing:.02em; color:#d9ffff;
  }
  .ksv-bar{
    width:100%; height:6px; border-radius:999px;
    background: rgba(0,230,255,.12);
    outline: 1px solid rgba(0,230,255,.35);
    overflow:hidden;
  }
  .ksv-bar > i{
    display:block; height:100%; width:var(--w,0%);
    background: linear-gradient(90deg,#00e6ff 0%, #5fffd6 100%);
    box-shadow: 0 0 6px #00e6ff66 inset;
  }

  td.ksv-cat{
    word-break: break-word;
  }
  .ksv-cat .ksv-cat-text{
    display:inline;
  }
  </style>

  <link rel="stylesheet" href="/assets/css/comparison.css" />
</head>
<body data-page="compat">
  <main class="tk-landing">
    <h1 class="tk-title">TalkKink Compatibility</h1>

    <div class="tk-menu">
      <label id="yourBtn" for="yourFile" class="tk-btn">Upload Your Survey</label>
      <label id="partnerBtn" for="partnerFile" class="tk-btn">Upload Partner‚Äôs Survey</label>
      <button id="downloadBtn" class="tk-btn" disabled>Download PDF</button>
    </div>

        <a href="https://talkkink.org/KinkSurveyPage/index.html" class="tk-btn back">‚Üê Back</a>

    <input id="yourFile" type="file" accept="application/json" hidden />
    <input id="partnerFile" type="file" accept="application/json" hidden />
  </main>

  <script>
    function ksvParseSurveyJsonText(jsonText, partner = 'A') {
      const fail = (reason) => ({ ok: false, reason, cells: [], survey: null });
      if (typeof jsonText !== 'string') return fail('No JSON payload provided');

      let payload;
      try {
        payload = JSON.parse(jsonText);
      } catch (err) {
        return fail('Invalid JSON');
      }

      const answers = {};
      const answersByKey = {};
      let maxIndex = 0;

      const clamp = (value) => {
        const n = Number(value);
        if (!Number.isFinite(n)) return 0;
        if (n < 0) return 0;
        if (n > 5) return 5;
        return Math.round(n);
      };

      const toRating = (value) => {
        if (value == null || value === '') return 0;
        if (typeof value === 'number' && Number.isFinite(value)) return clamp(value);
        if (typeof value === 'string') {
          const trimmed = value.trim();
          if (!trimmed) return 0;
          const match = trimmed.match(/-?\d+(?:\.\d+)?/);
          if (match) return clamp(Number(match[0]));
        }
        return 0;
      };

      const applyRating = (index, value) => {
        const idx = Number(index);
        if (!Number.isFinite(idx) || idx <= 0) return;
        const normalized = toRating(value);
        const key = String(idx);
        answersByKey[key] = normalized;
        if (idx > maxIndex) maxIndex = idx;
      };

      const absorbArray = (arr) => {
        if (!Array.isArray(arr)) return;
        arr.forEach((value, i) => applyRating(i + 1, value));
      };

      const absorbObject = (obj) => {
        if (!obj || typeof obj !== 'object') return;
        Object.keys(obj)
          .sort((a, b) => Number(a) - Number(b))
          .forEach((key) => applyRating(key, obj[key]));
      };

      if (Array.isArray(payload)) {
        absorbArray(payload);
      } else if (payload && typeof payload === 'object') {
        absorbArray(payload.cells);
        absorbArray(payload.answers);
        absorbObject(payload.answersByKey);
        absorbObject(payload.answersById);
        absorbObject(payload.ratings);
      } else {
        return fail('Unsupported survey payload');
      }

      if (!maxIndex) {
        return fail('No survey answers found');
      }

      for (let i = 1; i <= maxIndex; i += 1) {
        const key = String(i);
        const rating = Object.prototype.hasOwnProperty.call(answersByKey, key)
          ? answersByKey[key]
          : 0;
        answers[key] = rating;
        answersByKey[key] = rating;
      }

      const cells = Array.from({ length: maxIndex }, (_, i) => answersByKey[String(i + 1)] ?? 0);
      return { ok:true, cells, survey: { answers, answersByKey } };
}

    window.ksvParseSurveyJsonText = ksvParseSurveyJsonText;
  </script>

    <script defer src="/assets/js/comparison.js"></script>
    <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js" crossorigin="anonymous"></script>

    <script>
      (function () {
        window.__TK_FAST_UPLOADS__ = true;

        const $ = (selector, root = document) => root.querySelector(selector);
        const dispatch = (name, detail) => {
          document.dispatchEvent(new CustomEvent(name, { detail }));
        };

        function hijackFileInput(id) {
          const el = document.getElementById(id);
          if (!el) return null;
          const clone = el.cloneNode(true);
          el.replaceWith(clone);
          return clone;
        }

        const yourInput = hijackFileInput('yourFile');
        const partnerInput = hijackFileInput('partnerFile');

        const yourBtn = $('#yourBtn');
        const partnerBtn = $('#partnerBtn');
        const downloadBtn = $('#downloadBtn');

        if (yourBtn && yourInput && yourBtn !== yourInput) {
          yourBtn.addEventListener('click', () => yourInput.click());
        }
        if (partnerBtn && partnerInput && partnerBtn !== partnerInput) {
          partnerBtn.addEventListener('click', () => partnerInput.click());
        }

        let yourBlob = null;
        let partnerBlob = null;
        let yourJSON = null;
        let partnerJSON = null;

        const parseQueue = new Set();

        const fileNameOf = (which) =>
          which === 'self' ? yourBlob?.name || '' : partnerBlob?.name || '';

        function updateDownloadState() {
          if (!downloadBtn) return;
          downloadBtn.disabled = !(yourJSON && partnerJSON);
        }

        async function ensureParsed(which) {
          await new Promise((resolve) => setTimeout(resolve, 0));
          if ((!which || which === 'self') && yourBlob && !yourJSON) {
            const text = await yourBlob.text();
            yourJSON = JSON.parse(text);
          }
          if ((!which || which === 'partner') && partnerBlob && !partnerJSON) {
            const text = await partnerBlob.text();
            partnerJSON = JSON.parse(text);
          }
        }

        function scheduleParse(which) {
          if (parseQueue.has(which)) return;
          if (which === 'self' && !yourBlob) return;
          if (which === 'partner' && !partnerBlob) return;
          parseQueue.add(which);
          setTimeout(async () => {
            parseQueue.delete(which);
            try {
              await ensureParsed(which);
              const json = which === 'self' ? yourJSON : partnerJSON;
              if (json) {
                if (which === 'self') {
                  window.talkkinkMine = json;
                  window.talkkinkSurvey = json;
                } else if (which === 'partner') {
                  window.talkkinkPartner = json;
                }
                dispatch('compat:json-ready', {
                  which,
                  json,
                  fileName: fileNameOf(which)
                });
              }
              updateDownloadState();
            } catch (err) {
              console.error(err);
              alert('Invalid file ‚Äî expected TalkKink JSON export.');
              if (which === 'self') {
                yourBlob = null;
                yourJSON = null;
              } else {
                partnerBlob = null;
                partnerJSON = null;
              }
              updateDownloadState();
              dispatch('compat:file-selected', { which, file: null });
            }
          }, 0);
        }

        if (yourInput) {
          yourInput.addEventListener('change', (ev) => {
            const file = ev.target?.files?.[0];
            if (!file) return;
            yourBlob = file;
            yourJSON = null;
            dispatch('compat:file-selected', { which: 'self', file });
            alert('Uploaded ‚úì');
            ev.target.value = '';
            updateDownloadState();
            scheduleParse('self');
          });
        }

        if (partnerInput) {
          partnerInput.addEventListener('change', (ev) => {
            const file = ev.target?.files?.[0];
            if (!file) return;
            const ok = confirm(
              'Before importing a partner‚Äôs survey, confirm you have their explicit consent to upload and compare their responses here.\n\n' +
                'Click ‚ÄúOK‚Äù to continue or ‚ÄúCancel‚Äù to stop.'
            );
            if (!ok) {
              ev.target.value = '';
              partnerBlob = null;
              partnerJSON = null;
              updateDownloadState();
              dispatch('compat:file-selected', { which: 'partner', file: null });
              return;
            }
            partnerBlob = file;
            partnerJSON = null;
            dispatch('compat:file-selected', { which: 'partner', file });
            alert('Uploaded ‚úì\n(You confirmed you have your partner‚Äôs explicit consent.)');
            ev.target.value = '';
            updateDownloadState();
            scheduleParse('partner');
          });
        }

        if (downloadBtn) {
          downloadBtn.addEventListener(
            'click',
            (event) => event.stopImmediatePropagation(),
            true
          );

          downloadBtn.addEventListener('click', async () => {
            try {
              await ensureParsed();
              if (!yourJSON && !partnerJSON) {
                alert('Please upload at least one survey before downloading.');
                return;
              }
              await generateDarkPDF(yourJSON, partnerJSON);
            } catch (err) {
              console.error(err);
              alert('Sorry‚Äîcould not generate the PDF.');
            }
          });
        }

        const cap = (s) => (s ? s[0].toUpperCase() + s.slice(1) : s);

        function rowsFromTalkKink(json) {
          if (!json) return [];
          const map = json.answersById || {};
          const out = [];
          for (const [id, score] of Object.entries(map)) {
            const parts = id.split('-');
            const role = parts.at(-1);
            const category = (parts[0] + ' ' + parts[1]).replace(/\b\w/g, (m) => m.toUpperCase());
            const item = parts
              .slice(2, -1)
              .join(' ')
              .replace(/\bTv\b/gi, 'TV')
              .replace(/\s+/g, ' ')
              .trim();
            out.push({ Category: category, Item: cap(item), Role: cap(role), Score: Number(score) });
          }
          out.sort(
            (a, b) =>
              a.Category.localeCompare(b.Category) ||
              a.Role.localeCompare(b.Role) ||
              a.Item.localeCompare(b.Item)
          );
          return out;
        }

        async function generateDarkPDF(yourJSON, partnerJSON) {
          const { jsPDF } = window.jspdf;
          const doc = new jsPDF({ unit: 'pt', format: 'letter' });

          const W = doc.internal.pageSize.getWidth();
          const H = doc.internal.pageSize.getHeight();

          function paintPageChrome() {
            doc.setFillColor(10, 10, 12);
            doc.rect(0, 0, W, H, 'F');
            doc.setDrawColor(0, 255, 255);
            doc.setLineWidth(1);
            doc.line(48, 68, W - 48, 68);
            doc.setTextColor(255, 255, 255);
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(18);
            doc.text('TalkKink Compatibility ‚Äî Printable Report', 48, 50);
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(10);
            doc.setTextColor(170, 200, 255);
            doc.text('Generated: ' + new Date().toLocaleString(), 48, 62);
          }
          paintPageChrome();

          const tableBase = {
            theme: 'grid',
            styles: {
              font: 'helvetica',
              fontSize: 10,
              cellPadding: 4,
              textColor: [235, 235, 242],
              lineColor: [60, 60, 78],
              lineWidth: 0.25,
              fillColor: [18, 18, 22]
            },
            alternateRowStyles: { fillColor: [26, 26, 32] },
            headStyles: { fillColor: [0, 0, 0], textColor: [0, 255, 255] },
            margin: { left: 48, right: 48 },
            didAddPage: () => paintPageChrome()
          };

          const rowsA = rowsFromTalkKink(yourJSON);
          const rowsB = rowsFromTalkKink(partnerJSON);
          const hasA = rowsA.length > 0;
          const hasB = rowsB.length > 0;

          let y = 90;

          if (hasA && hasB) {
            const cats = [...new Set([...rowsA, ...rowsB].map((r) => r.Category))];
            for (const cat of cats) {
              doc.setFont('helvetica', 'bold');
              doc.setFontSize(13);
              doc.setTextColor(255, 255, 255);
              doc.text(cat, 48, y);
              y += 8;

              const body = buildComparisonBody(
                rowsA.filter((r) => r.Category === cat),
                rowsB.filter((r) => r.Category === cat)
              );

              doc.autoTable({
                ...tableBase,
                startY: y + 8,
                head: [['Role', 'Item', 'Partner A', 'Match', 'Flag', 'Partner B']],
                body,
                columnStyles: {
                  0: { cellWidth: 70 },
                  1: { cellWidth: 280 },
                  2: { cellWidth: 60, halign: 'center' },
                  3: { cellWidth: 60, halign: 'center' },
                  4: { cellWidth: 40, halign: 'center' },
                  5: { cellWidth: 60, halign: 'center' }
                }
              });
              y = doc.lastAutoTable.finalY + 16;
              if (y > H - 72) {
                doc.addPage();
                paintPageChrome();
                y = 90;
              }
            }
          } else {
            const rows = hasA ? rowsA : rowsB;
            const whose = hasA ? 'Partner A' : 'Partner';
            const cats = [...new Set(rows.map((r) => r.Category))];

            for (const cat of cats) {
              doc.setFont('helvetica', 'bold');
              doc.setFontSize(13);
              doc.setTextColor(255, 255, 255);
              doc.text(`${cat} ‚Äî ${whose}`, 48, y);
              y += 8;

              const body = rows
                .filter((r) => r.Category === cat)
                .map((r) => [r.Role, r.Item, String(r.Score)]);
              doc.autoTable({
                ...tableBase,
                startY: y + 8,
                head: [['Role', 'Item', 'Score']],
                body,
                columnStyles: {
                  0: { cellWidth: 90 },
                  1: { cellWidth: 350 },
                  2: { cellWidth: 60, halign: 'center' }
                }
              });
              y = doc.lastAutoTable.finalY + 16;
              if (y > H - 72) {
                doc.addPage();
                paintPageChrome();
                y = 90;
              }
            }
          }

          const name = hasA && hasB ? 'compatibility-pretty-dark.pdf' : 'partner-survey-pretty-dark.pdf';
          doc.save(name);
        }

        function buildComparisonBody(rowsA, rowsB) {
          const key = (r) => `${r.Role}|${r.Item}`.toLowerCase();
          const mapA = Object.fromEntries(rowsA.map((r) => [key(r), r]));
          const mapB = Object.fromEntries(rowsB.map((r) => [key(r), r]));
          const keys = [...new Set([...Object.keys(mapA), ...Object.keys(mapB)])].sort();
          const body = [];
          for (const k of keys) {
            const a = mapA[k];
            const b = mapB[k];
            const role = a?.Role || b?.Role || '';
            const item = a?.Item || b?.Item || '';
            const aScore = Number.isFinite(a?.Score) ? a.Score : '';
            const bScore = Number.isFinite(b?.Score) ? b.Score : '';

            let match = '';
            let flag = '';
            if (a && b) {
              const diff = Math.abs(a.Score - b.Score);
              const pct = Math.round((1 - diff / 5) * 100);
              match = pct + '%';
              if (pct >= 90) flag = '‚≠ê';
              else if (pct <= 30) flag = 'üö©';
              if ((a?.Score === 5 && b?.Score < 5) || (b?.Score === 5 && a?.Score < 5)) {
                flag = flag ? flag + ' üü®' : 'üü®';
              }
            }
            body.push([role, item, String(aScore), match, flag, String(bScore)]);
          }
          return body;
        }
      })();
    </script>
  <script defer>
    /**
     * Safely clear margin on the dock *only if it exists on this page*.
     * This replaces any previous null-unsafe code around lines ~188‚Äì192.
     */
    (function () {
      const SELECTOR = '#compat-dock, .compat-dock, [data-compat-dock]';

      function clearDockMarginSafe() {
        const el = document.querySelector(SELECTOR);
        if (!el) return;                  // No-op if the dock isn't present
        el.style.removeProperty('margin');
        el.style.removeProperty('margin-bottom');
      }

      // Run after DOM is parsed; also handle late mounts briefly
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', clearDockMarginSafe, { once: true });
      } else {
        queueMicrotask(clearDockMarginSafe);
      }
      const mo = new MutationObserver(() => {
        const el = document.querySelector(SELECTOR);
        if (el) { clearDockMarginSafe(); mo.disconnect(); }
      });
      mo.observe(document.documentElement, { childList: true, subtree: true });
      setTimeout(() => mo.disconnect(), 3000);
    })();
  </script>
</body>

</html>
