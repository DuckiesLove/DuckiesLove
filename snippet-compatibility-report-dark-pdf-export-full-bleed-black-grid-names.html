<!-- === Full-Bleed Black PDF + Full Grid + Label Mapping === -->
<script>
(function(){
  /* ===== Library loader ===== */
  const need = (p) => !p;
  const load = (src) => new Promise((resolve, reject) => {
    const el = document.createElement('script');
    el.src = src;
    el.onload = resolve;
    el.onerror = reject;
    document.head.appendChild(el);
  });

  async function ensurePDFLibraries(){
    if (need(window.jspdf)) await load('https://cdn.jsdelivr.net/npm/jspdf@2.5.2/dist/jspdf.umd.min.js');
    if (!window.jspdf || !window.jspdf.jsPDF){
      alert('jsPDF failed to load');
      throw new Error('jsPDF failed to load');
    }
    if (!window.jspdf.jsPDF.prototype.autoTable){
      await load('https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.3/dist/jspdf.plugin.autotable.min.js');
    }
  }

  /* ===== Normalisers ===== */
  const clean = (s) => String(s||'').normalize('NFKC').replace(/[\u200B-\u200D\uFEFF]/g,'').trim();

  const keyVariants = (value) => {
    const source = clean(value);
    const match = source.match(/\bcb_[a-z0-9_]+\b/i);
    const base = (match ? match[0] : source).toLowerCase();
    return [base, base.startsWith('cb_') ? base.slice(3) : base];
  };

  const fallbackTitle = (code) => String(code||'')
    .replace(/^cb_/i,'')
    .replace(/[_-]+/g,' ')
    .replace(/\b([a-z])([a-z]*)/gi, (_, a, b) => a.toUpperCase() + b.toLowerCase())
    .trim();

  const normMap = (src) => {
    const out = {};
    const put = (key, value) => {
      if (key == null) return;
      const raw = clean(key);
      if (!raw) return;
      const normKey = raw.toLowerCase();
      const normValue = (value == null || clean(value) === '') ? raw : String(value);
      out[normKey] = normValue;
      if (normKey.startsWith('cb_')) out[normKey.slice(3)] = normValue;
    };
    if (Array.isArray(src)){
      for (const [key, value] of src) put(key, value);
    } else {
      for (const [key, value] of Object.entries(src||{})) put(key, value);
    }
    return out;
  };

  async function getLabelMap(){
    if (typeof window.buildLabelMapSafely === 'function'){
      try {
        return normMap(await window.buildLabelMapSafely());
      } catch (err) {
        console.warn('[PDF] buildLabelMapSafely failed, falling back', err);
      }
    }
    const [base, overrides] = await Promise.all([
      fetch('/data/kinks.json').then(r => r.ok ? r.json() : {}).catch(() => ({})),
      fetch('/data/labels-overrides.json').then(r => r.ok ? r.json() : {}).catch(() => ({}))
    ]);
    let merged = { ...(base||{}), ...(overrides||{}) };
    if (window.tkLabels && typeof window.tkLabels === 'object') merged = { ...merged, ...window.tkLabels };
    return normMap(merged);
  }

  async function exportCompatPDF_BlackGridWithNames({
    filename = 'compatibility-blackgrid-names.pdf',
    blank = ' ',
    gridRGB = [150, 150, 150],
    outerMargin = 28,
    cellPadding = 10
  } = {}){
    await ensurePDFLibraries();

    const labelMap = await getLabelMap();

    const table = document.querySelector('table');
    if (!table){
      alert('No <table> found');
      return;
    }

    const headers = [...table.querySelectorAll('thead th')].map(th => th.textContent.trim());
    const rowsDom = [...table.querySelectorAll('tbody tr')];
    const columns = (headers.length ? headers : ['Category','Partner A','Match %','Partner B'])
      .map((header, index) => ({ header, dataKey: String(index) }));
    let rows = rowsDom.map(tr => [...tr.children].map(td => td.textContent.trim()));

    const beforeSample = rows.slice(0, 10).map(r => r[0]);
    const missing = new Set();
    rows = rows.map(row => {
      const variants = keyVariants(row[0]);
      let label = null;
      for (const key of variants){
        if (key && (key in labelMap)){ label = labelMap[key]; break; }
      }
      if (!label){
        missing.add(variants[0]);
        label = fallbackTitle(variants[0]);
      }
      row[0] = label || blank;
      for (let index = 0; index < row.length; index++) if (row[index] === '' || row[index] === '—') row[index] = blank;
      return row;
    });
    const afterSample = rows.slice(0, 10).map(r => r[0]);
    console.log('[PDF] First 10 codes BEFORE → AFTER:', beforeSample.map((before, i) => [before, '→', afterSample[i]]));
    if (missing.size) console.log('[PDF] Unmapped (fallback used, sample):', [...missing].filter(Boolean).slice(0, 20));

    const head = [columns.map(column => column.header)];
    const body = rows.map(row => columns.map((column, index) => row[index] ?? blank));

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit: 'pt', format: 'letter', compress: true, putOnlyUsedFonts: true });
    const width = doc.internal.pageSize.getWidth();
    const height = doc.internal.pageSize.getHeight();
    const paint = () => {
      doc.setFillColor(0, 0, 0);
      doc.rect(0, 0, width, height, 'F');
    };
    paint();
    doc.setTextColor(255, 255, 255);

    doc.autoTable({
      head,
      body,
      tableWidth: width - outerMargin * 2,
      margin: { top: outerMargin, right: outerMargin, bottom: outerMargin, left: outerMargin },
      theme: 'grid',
      horizontalPageBreak: true,
      styles: {
        font: 'helvetica',
        fontSize: 12,
        textColor: [255, 255, 255],
        cellPadding,
        fillColor: null,
        lineWidth: 0.6,
        lineColor: gridRGB,
        overflow: 'linebreak',
        minCellHeight: 22,
      },
      headStyles: {
        fontStyle: 'bold',
        textColor: [255, 255, 255],
        fillColor: null,
        lineWidth: 0.8,
        lineColor: gridRGB,
      },
      tableLineWidth: 0.8,
      tableLineColor: gridRGB,
      columnStyles: {
        0: { halign: 'left' },
        1: { halign: 'center' },
        2: { halign: 'center' },
        3: { halign: 'center' },
      },
      didAddPage(){
        paint();
        doc.setTextColor(255, 255, 255);
      }
    });

    doc.save(filename);
    console.log('[PDF] Exported compatibility-blackgrid-names.pdf');
  }

  function wireButton(){
    const btn = [...document.querySelectorAll('a,button,input[type="button"],input[type="submit"]')]
      .find(el => /download pdf/i.test((el.textContent || el.value || '').trim()));
    if (btn){
      btn.onclick = null;
      btn.removeAttribute('href');
      btn.addEventListener('click', (event) => {
        event.preventDefault();
        event.stopImmediatePropagation();
        exportCompatPDF_BlackGridWithNames();
      }, { capture: true });
      console.log('[tk] Download PDF → exportCompatPDF_BlackGridWithNames');
    } else {
      console.warn('[tk] Download PDF button not found; call exportCompatPDF_BlackGridWithNames() manually.');
    }
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', wireButton);
  else wireButton();

  window.exportCompatPDF_BlackGridWithNames = exportCompatPDF_BlackGridWithNames;
})();
</script>
