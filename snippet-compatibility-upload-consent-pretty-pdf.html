<!-- ================= CODEX DROP-IN: Fast Upload + Consent + Pretty PDF ================= -->
<input id="yourFile"    type="file" accept="application/json" style="display:none" />
<input id="partnerFile" type="file" accept="application/json" style="display:none" />

<button id="yourBtn"    type="button">Upload Your Survey</button>
<button id="partnerBtn" type="button">Upload Partner‚Äôs Survey</button>
<button id="downloadBtn" type="button">Download PDF</button>

<script>
(function () {
  const $ = (s, r=document) => r.querySelector(s);

  const yourBtn      = $('#yourBtn');
  const partnerBtn   = $('#partnerBtn');
  const downloadBtn  = $('#downloadBtn');
  const yourInput    = $('#yourFile');
  const partnerInput = $('#partnerFile');

  // State to hold the selected files / parsed JSON
  let yourBlob = null;
  let partnerBlob = null;
  let yourJSON = null;
  let partnerJSON = null;

  // Remember partner consent per tab so we only ask once
  const CONSENT_KEY = 'tk.partnerConsent.v1';

  // 1. Always clear the input BEFORE opening picker.
  //    This fixes "I had to upload twice because picking same file didn't trigger change."
  function openPicker(inputEl) {
    if (!inputEl) return;
    inputEl.value = ''; // force change event even if it's the same file name
    inputEl.click();
  }

  yourBtn    && yourBtn.addEventListener('click',   () => openPicker(yourInput));
  partnerBtn && partnerBtn.addEventListener('click',() => openPicker(partnerInput));

  // 2. HARD BLOCK legacy slow/bubbled listeners so they never run.
  //    We do this for BOTH inputs, but we handle consent logic ourselves below.
  document.addEventListener('change', (ev) => {
    const t = ev.target;
    if (!(t instanceof HTMLInputElement)) return;
    if (t !== yourInput && t !== partnerInput) return;

    // stop any old attached change handlers so we don't double-run
    ev.stopImmediatePropagation();
    ev.stopPropagation();
    // Don't preventDefault; we still want the file to be there for us.
  }, true); // capture=true so we block before old handlers fire

  // 3. Our *own* lightweight change handlers (no re-dispatch, no second pick)

  if (yourInput) {
    yourInput.addEventListener('change', async (ev) => {
      const file = ev.target?.files?.[0];
      if (!file) return;

      // stash file once
      yourBlob = file;

      // lightweight UI notify - replace with toast() if you wired that already
      if (window.tkNotifyYourReady) {
        tkNotifyYourReady(); // shows "Your survey ready ‚úì"
      } else {
        console.info('[compat] Your survey ready ‚úì');
      }

      // DO NOT parse JSON here; we do that later when building the PDF
      // DO NOT re-dispatch the event
    });
  }

  if (partnerInput) {
    partnerInput.addEventListener('change', async (ev) => {
      const file = ev.target?.files?.[0];
      if (!file) return;

      // If we haven't gotten consent this tab, ask now
      if (!sessionStorage.getItem(CONSENT_KEY)) {
        const ok = confirm(
          'Before importing a partner‚Äôs survey, confirm you have their explicit consent to upload and compare their responses here.\n\n' +
          'Click ‚ÄúOK‚Äù to confirm consent and continue, or ‚ÄúCancel‚Äù to stop.'
        );

        if (!ok) {
          // User said no: wipe file so they have to pick again later.
          ev.target.value = '';
          return;
        }

        // User said yes: remember so we will NOT ask them again this tab.
        sessionStorage.setItem(CONSENT_KEY, '1');
      }

      // stash file once
      partnerBlob = file;

      // lightweight UI notify - replace with tkNotifyPartnerReady() for your toast line
      if (window.tkNotifyPartnerReady) {
        tkNotifyPartnerReady(); // "Partner survey ready ‚úì ‚Äî consent recorded."
      } else {
        console.info('[compat] Partner survey ready ‚úì ‚Äî consent recorded.');
      }

      // Again, no re-dispatch, no second upload
    });
  }

  // 4. PDF generation hook
  //    - load libs on demand,
  //    - parse yourBlob/partnerBlob lazily,
  //    - generate your dark PDF.
  //    This is the same logic we've been building, but self-contained.

  let libsReady = false;

  async function loadLibsOnce() {
    if (libsReady && window.jspdf && window.jspdf.jsPDF && window.jspdf_autotable) return;
    async function load(src) {
      return new Promise((res, rej) => {
        const s = document.createElement('script');
        s.src = src;
        s.onload = res;
        s.onerror = rej;
        document.head.appendChild(s);
      });
    }
    try {
      if (!window.jspdf) await load('https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js');
      if (!window.jspdf_autotable) await load('https://unpkg.com/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js');
      libsReady = true;
    } catch {
      // fallback CDNs
      if (!window.jspdf) await load('https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js');
      if (!window.jspdf_autotable) await load('https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js');
      libsReady = true;
    }
  }

  async function ensureParsed() {
    // Parse only when we actually need it
    await Promise.resolve(); // microtask yield
    if (yourBlob && !yourJSON) {
      yourJSON = JSON.parse(await yourBlob.text());
    }
    if (partnerBlob && !partnerJSON) {
      partnerJSON = JSON.parse(await partnerBlob.text());
    }
  }

  downloadBtn && downloadBtn.addEventListener('click', async () => {
    try {
      await loadLibsOnce();
      await ensureParsed();

      if (!yourJSON && !partnerJSON) {
        alert('Load at least one survey first (yours or partner).');
        return;
      }

      await generateDarkPDF(yourJSON, partnerJSON);
    } catch (err) {
      console.error(err);
      alert('Could not generate the PDF. Please try again.');
    }
  });

  // --- Helpers to normalize survey data and build the dark PDF ---

  function rowsFromTalkKink(json) {
    if (!json) return [];
    const map = json.answersById || {};
    const out = [];
    for (const [id, score] of Object.entries(map)) {
      // example id: behavioral-play-assigning-corner-time-or-time-outs-giving
      const parts = id.split('-');
      const role = parts.at(-1); // giving | receiving | general
      const category = (parts[0] + ' ' + parts[1]).replace(/\b\w/g, m => m.toUpperCase());
      const item = parts
        .slice(2, -1)
        .join(' ')
        .replace(/\bTv\b/gi, 'TV')
        .replace(/\s+/g, ' ')
        .trim();
      out.push({
        Category: category,
        Item: item.charAt(0).toUpperCase() + item.slice(1),
        Role: role.charAt(0).toUpperCase() + role.slice(1),
        Score: Number(score)
      });
    }
    out.sort((a,b) =>
      a.Category.localeCompare(b.Category) ||
      a.Role.localeCompare(b.Role) ||
      a.Item.localeCompare(b.Item)
    );
    return out;
  }

  async function generateDarkPDF(yourJSON, partnerJSON) {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit:'pt', format:'letter' });

    const W = doc.internal.pageSize.getWidth();
    const H = doc.internal.pageSize.getHeight();

    function paintPageChrome() {
      // black bg
      doc.setFillColor(10,10,12);
      doc.rect(0,0,W,H,'F');

      // cyan header rule
      doc.setDrawColor(0,255,255);
      doc.setLineWidth(1);
      doc.line(48,68,W-48,68);

      // header text
      doc.setTextColor(255,255,255);
      doc.setFont('helvetica','bold');
      doc.setFontSize(20);
      doc.text('TalkKink Compatibility ‚Äî Printable Report', 48, 50);

      doc.setFont('helvetica','normal');
      doc.setFontSize(10);
      doc.setTextColor(170,200,255);
      doc.text('Generated: ' + new Date().toLocaleString(), 48, 62);
    }
    paintPageChrome();

    const CYAN = [0,255,255];
    const BODY_BG_1 = [8,8,10];
    const BODY_BG_2 = [13,13,17];
    const GRID = [30,30,38];
    const WHITE = [255,255,255];

    const tableStyles = {
      theme: 'grid',
      styles: {
        font: 'helvetica',
        fontSize: 10,
        cellPadding: 4,
        textColor: WHITE,
        lineColor: GRID,
        lineWidth: 0.25,
        fillColor: BODY_BG_1
      },
      alternateRowStyles: { fillColor: BODY_BG_2 },
      headStyles: { fillColor: [0,0,0], textColor: CYAN, lineColor: GRID, lineWidth: 0.25, fontStyle: 'bold' },
      margin: { left: 48, right: 48 },
      didAddPage: () => paintPageChrome()
    };

    const A = rowsFromTalkKink(yourJSON);
    const B = rowsFromTalkKink(partnerJSON);
    const hasA = A.length > 0;
    const hasB = B.length > 0;
    let y = 90;

    if (hasA && hasB) {
      const cats = [...new Set([...A, ...B].map(r => r.Category))];
      for (const cat of cats) {
        doc.setFont('helvetica','bold');
        doc.setFontSize(16);
        doc.setTextColor(WHITE);
        doc.text(cat, 48, y);
        y += 12;

        const body = buildAB(A.filter(r => r.Category === cat), B.filter(r => r.Category === cat));

        doc.autoTable({
          ...tableStyles,
          startY: y + 8,
          head: [['Role', 'Item', 'Partner A', 'Match', 'Flag', 'Partner B']],
          body,
          columnStyles: {
            0:{ cellWidth:70 },
            1:{ cellWidth:280 },
            2:{ cellWidth:60, halign:'center' },
            3:{ cellWidth:60, halign:'center' },
            4:{ cellWidth:40, halign:'center' },
            5:{ cellWidth:60, halign:'center' }
          }
        });

        y = doc.lastAutoTable.finalY + 16;
        if (y > H - 72) {
          doc.addPage();
          paintPageChrome();
          y = 90;
        }
      }
    } else {
      const rows = hasA ? A : B;
      const who  = hasA ? 'Partner A' : 'Partner';
      const cats = [...new Set(rows.map(r => r.Category))];

      for (const cat of cats) {
        doc.setFont('helvetica','bold');
        doc.setFontSize(16);
        doc.setTextColor(WHITE);
        doc.text(`${cat} ‚Äî ${who}`, 48, y);
        y += 12;

        const body = rows
          .filter(r => r.Category === cat)
          .map(r => [r.Role, r.Item, String(r.Score)]);

        doc.autoTable({
          ...tableStyles,
          startY: y + 8,
          head: [['Role', 'Item', 'Score']],
          body,
          columnStyles: {
            0:{ cellWidth:90 },
            1:{ cellWidth:350 },
            2:{ cellWidth:60, halign:'center' }
          }
        });

        y = doc.lastAutoTable.finalY + 16;
        if (y > H - 72) {
          doc.addPage();
          paintPageChrome();
          y = 90;
        }
      }
    }

    const filename = (hasA && hasB)
      ? 'compatibility-pretty-dark.pdf'
      : 'partner-survey-pretty-dark.pdf';

    doc.save(filename);
  }

  function buildAB(A, B) {
    // match rows by Role+Item so they line up even if one side is missing
    const keyOf = r => `${r.Role}|${r.Item}`.toLowerCase();
    const aMap = Object.fromEntries(A.map(r => [keyOf(r), r]));
    const bMap = Object.fromEntries(B.map(r => [keyOf(r), r]));
    const keys = [...new Set([...Object.keys(aMap), ...Object.keys(bMap)])].sort();
    const out = [];
    for (const k of keys) {
      const a = aMap[k];
      const b = bMap[k];
      const role = a?.Role || b?.Role || '';
      const item = a?.Item || b?.Item || '';
      const aScore = Number.isFinite(a?.Score) ? a.Score : '';
      const bScore = Number.isFinite(b?.Score) ? b.Score : '';

      let match = '';
      let flag  = '';
      if (a && b) {
        const pct = Math.round((1 - Math.abs(a.Score - b.Score)/5) * 100);
        match = pct + '%';

        if (pct >= 90) {
          flag = '‚≠ê';
        } else if (pct <= 30) {
          flag = 'üö©';
        }
        if (
          (a.Score === 5 && b.Score < 5) ||
          (b.Score === 5 && a.Score < 5)
        ) {
          flag = flag ? flag + ' üü®' : 'üü®';
        }
      }

      out.push([role, item, String(aScore), match, flag, String(bScore)]);
    }
    return out;
  }

  // optional helper to wipe consent so you can test again without closing the tab
  window.tkResetPartnerConsent = () => {
    sessionStorage.removeItem(CONSENT_KEY);
    console.info('[compat] Partner consent reset for this tab.');
  };
})();
</script>
<!-- =============================================================================== -->
