<!-- ================= CODEX DROP-IN: Fast Upload + Consent + Pretty PDF ================= -->
<input id="yourFile"    type="file" accept="application/json" style="display:none" />
<input id="partnerFile" type="file" accept="application/json" style="display:none" />

<button id="yourBtn"    type="button">Upload Your Survey</button>
<button id="partnerBtn" type="button">Upload Partner’s Survey</button>
<button id="downloadBtn" type="button">Download PDF</button>

<script>
(function () {
  const $ = (s, r=document) => r.querySelector(s);

  const yourBtn      = $('#yourBtn');
  const partnerBtn   = $('#partnerBtn');
  const downloadBtn  = $('#downloadBtn');
  const yourInput    = $('#yourFile');
  const partnerInput = $('#partnerFile');

  // State to hold the selected files / parsed JSON
  let yourBlob = null;
  let partnerBlob = null;
  let yourJSON = null;
  let partnerJSON = null;

  // Remember partner consent per tab so we only ask once
  const CONSENT_KEY = 'tk.partnerConsent.v1';

  // 1. Always clear the input BEFORE opening picker.
  //    This fixes "I had to upload twice because picking same file didn't trigger change."
  function openPicker(inputEl) {
    if (!inputEl) return;
    inputEl.value = ''; // force change event even if it's the same file name
    inputEl.click();
  }

  yourBtn    && yourBtn.addEventListener('click',   () => openPicker(yourInput));
  partnerBtn && partnerBtn.addEventListener('click',() => openPicker(partnerInput));

  // 2. HARD BLOCK legacy slow/bubbled listeners so they never run.
  //    We do this for BOTH inputs, but we handle consent logic ourselves below.
  document.addEventListener('change', (ev) => {
    const t = ev.target;
    if (!(t instanceof HTMLInputElement)) return;
    if (t !== yourInput && t !== partnerInput) return;

    // stop any old attached change handlers so we don't double-run
    ev.stopImmediatePropagation();
    ev.stopPropagation();
    // Don't preventDefault; we still want the file to be there for us.
  }, true); // capture=true so we block before old handlers fire

  // 3. Our *own* lightweight change handlers (no re-dispatch, no second pick)

  if (yourInput) {
    yourInput.addEventListener('change', async (ev) => {
      const file = ev.target?.files?.[0];
      if (!file) return;

      // stash file once
      yourBlob = file;

      // lightweight UI notify - replace with toast() if you wired that already
      if (window.tkNotifyYourReady) {
        tkNotifyYourReady(); // shows "Your survey ready ✓"
      } else {
        console.info('[compat] Your survey ready ✓');
      }

      // DO NOT parse JSON here; we do that later when building the PDF
      // DO NOT re-dispatch the event
    });
  }

  if (partnerInput) {
    partnerInput.addEventListener('change', async (ev) => {
      const file = ev.target?.files?.[0];
      if (!file) return;

      // If we haven't gotten consent this tab, ask now
      if (!sessionStorage.getItem(CONSENT_KEY)) {
        const ok = confirm(
          'Before importing a partner’s survey, confirm you have their explicit consent to upload and compare their responses here.\n\n' +
          'Click “OK” to confirm consent and continue, or “Cancel” to stop.'
        );

        if (!ok) {
          // User said no: wipe file so they have to pick again later.
          ev.target.value = '';
          return;
        }

        // User said yes: remember so we will NOT ask them again this tab.
        sessionStorage.setItem(CONSENT_KEY, '1');
      }

      // stash file once
      partnerBlob = file;

      // lightweight UI notify - replace with tkNotifyPartnerReady() for your toast line
      if (window.tkNotifyPartnerReady) {
        tkNotifyPartnerReady(); // "Partner survey ready ✓ — consent recorded."
      } else {
        console.info('[compat] Partner survey ready ✓ — consent recorded.');
      }

      // Again, no re-dispatch, no second upload
    });
  }

  // 4. PDF generation hook
  //    - load libs on demand,
  //    - parse yourBlob/partnerBlob lazily,
  //    - generate your dark PDF.
  //    This is the same logic we've been building, but self-contained.

  let libsReady = false;

  async function loadLibsOnce() {
    if (libsReady && window.jspdf && window.jspdf.jsPDF && window.jspdf_autotable) return;
    async function load(src) {
      return new Promise((res, rej) => {
        const s = document.createElement('script');
        s.src = src;
        s.onload = res;
        s.onerror = rej;
        document.head.appendChild(s);
      });
    }
    try {
      if (!window.jspdf) await load('https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js');
      if (!window.jspdf_autotable) await load('https://unpkg.com/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js');
      libsReady = true;
    } catch {
      // fallback CDNs
      if (!window.jspdf) await load('https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js');
      if (!window.jspdf_autotable) await load('https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js');
      libsReady = true;
    }
  }

  async function ensureParsed() {
    // Parse only when we actually need it
    await Promise.resolve(); // microtask yield
    if (yourBlob && !yourJSON) {
      yourJSON = JSON.parse(await yourBlob.text());
    }
    if (partnerBlob && !partnerJSON) {
      partnerJSON = JSON.parse(await partnerBlob.text());
    }
  }

  downloadBtn && downloadBtn.addEventListener('click', async () => {
    try {
      await loadLibsOnce();
      await ensureParsed();

      if (!yourJSON && !partnerJSON) {
        alert('Load at least one survey first (yours or partner).');
        return;
      }

      await generateDarkPDF(yourJSON, partnerJSON);
    } catch (err) {
      console.error(err);
      alert('Could not generate the PDF. Please try again.');
    }
  });

  // --- Helpers to normalize survey data and build the dark PDF ---

  function rowsFromTalkKink(json) {
    if (!json) return [];
    const map = json.answersById || {};
    const out = [];
    for (const [id, score] of Object.entries(map)) {
      // example id: behavioral-play-assigning-corner-time-or-time-outs-giving
      const parts = id.split('-');
      const role = parts.at(-1); // giving | receiving | general
      const category = (parts[0] + ' ' + parts[1]).replace(/\b\w/g, m => m.toUpperCase());
      const item = parts
        .slice(2, -1)
        .join(' ')
        .replace(/\bTv\b/gi, 'TV')
        .replace(/\s+/g, ' ')
        .trim();
      out.push({
        Category: category,
        Item: item.charAt(0).toUpperCase() + item.slice(1),
        Role: role.charAt(0).toUpperCase() + role.slice(1),
        Score: Number(score)
      });
    }
    out.sort((a,b) =>
      a.Category.localeCompare(b.Category) ||
      a.Role.localeCompare(b.Role) ||
      a.Item.localeCompare(b.Item)
    );
    return out;
  }

  async function generateDarkPDF(yourJSON, partnerJSON) {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit: 'pt', format: 'letter' });

    const W = doc.internal.pageSize.getWidth();
    const H = doc.internal.pageSize.getHeight();

    const CONTENT_W = Math.min(680, W - 96);
    const ML = (W - CONTENT_W) / 2;
    const MR = ML;
    // Center X of the CONTENT block (use this for title, timestamp, section headings)
    const CX = ML + CONTENT_W / 2;
    const TITLE_Y = 64;
    const STAMP_Y = 82;
    const HEADER_RULE_Y = 92;
    const SECTION_Y = 118;
    const BODY_START_Y = 136;
    const generatedAt = new Date().toLocaleString();

    function paint() {
      // page background
      doc.setFillColor(10, 10, 12);
      doc.rect(0, 0, W, H, 'F');

      // Title (centered on CONTENT, not full page)
      doc.setTextColor(255, 255, 255);
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(26);
      doc.text('TalkKink — Partner Survey (Clean Report)', CX, TITLE_Y, { align: 'center' });

      // Timestamp (smaller, centered on CONTENT)
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(9);
      doc.setTextColor(170, 210, 255);
      doc.text('Generated: ' + generatedAt, CX, STAMP_Y, { align: 'center' });

      // Cyan rule under header, exactly width of CONTENT block
      doc.setDrawColor(0, 255, 255);
      if (typeof doc.setLineWidth === 'function') doc.setLineWidth(1);
      doc.line(ML, HEADER_RULE_Y, ML + CONTENT_W, HEADER_RULE_Y);

      // Section title
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(18);
      doc.setTextColor(255, 255, 255);
      doc.text('Partner Upload Snapshot', CX, SECTION_Y, { align: 'center' });
    }
    paint();

    // palette
    const CYAN = [0, 255, 255];
    const BODY1 = [8, 8, 10];
    const BODY2 = [13, 13, 17];
    const GRID = [30, 30, 38];
    const WHITE = [255, 255, 255];
    const GREEN = [0, 200, 140];
    const YELLOW = [255, 210, 70];
    const RED = [255, 86, 86];

    // table style
    const base = {
      theme: 'grid',
      tableWidth: CONTENT_W,
      margin: { left: ML, right: MR },
      styles: {
        font: 'helvetica',
        fontSize: 10,
        cellPadding: 4,
        textColor: WHITE,
        fillColor: BODY1,
        lineColor: GRID,
        lineWidth: 0.25
      },
      alternateRowStyles: { fillColor: BODY2 },
      headStyles: { fillColor: [0, 0, 0], textColor: CYAN, lineColor: GRID, lineWidth: 0.25, fontStyle: 'bold' },
      didAddPage: () => paint()
    };

    const A = rowsFromTalkKink(yourJSON);
    const B = rowsFromTalkKink(partnerJSON);

    const hasA = A.length > 0;
    const hasB = B.length > 0;

    let y = BODY_START_Y;
    const cat = (t) => {
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(16);
      doc.setTextColor(255, 255, 255);
      doc.text(t, CX, y, { align: 'center' });
      y += 12;
    };

    if (hasA && hasB) {
      const cats = [...new Set([...A, ...B].map((r) => r.Category))];
      for (const c of cats) {
        cat(c);
        const body = buildAB(
          A.filter((r) => r.Category === c),
          B.filter((r) => r.Category === c)
        );
        doc.autoTable({
          ...base,
          ...withFlagDotHooks('flag'),
          startY: y + 8,
          columns: [
            { header: 'Role', dataKey: 'role' },
            { header: 'Item', dataKey: 'item' },
            { header: 'Partner A', dataKey: 'a' },
            { header: 'Match', dataKey: 'match' },
            { header: 'Flag', dataKey: 'flag' },
            { header: 'Partner B', dataKey: 'b' }
          ],
          body,
          columnStyles: {
            role: { cellWidth: 80 },
            item: { cellWidth: CONTENT_W - (80 + 70 + 60 + 50 + 70) },
            a: { cellWidth: 70, halign: 'center' },
            match: { cellWidth: 60, halign: 'center' },
            flag: { cellWidth: 50, halign: 'left' },
            b: { cellWidth: 70, halign: 'center' }
          }
        });
        y = doc.lastAutoTable.finalY + 18;
        if (y > H - HEADER_RULE_Y) {
          doc.addPage();
          paint();
          y = BODY_START_Y;
        }
      }
    } else {
      const rows = hasA ? A : B;
      const who = hasA ? 'Partner A' : 'Partner';
      const cats = [...new Set(rows.map((r) => r.Category))];
      for (const c of cats) {
        cat(`${c} — ${who}`);
        const body = rows
          .filter((r) => r.Category === c)
          .map((r) => ({ role: r.Role, item: r.Item, score: String(r.Score) }));
        doc.autoTable({
          ...base,
          startY: y + 8,
          columns: [
            { header: 'Role', dataKey: 'role' },
            { header: 'Item', dataKey: 'item' },
            { header: 'Score', dataKey: 'score' }
          ],
          body,
          columnStyles: {
            role: { cellWidth: 100 },
            item: { cellWidth: CONTENT_W - (100 + 70) },
            score: { cellWidth: 70, halign: 'center' }
          }
        });
        y = doc.lastAutoTable.finalY + 18;
        if (y > H - HEADER_RULE_Y) {
          doc.addPage();
          paint();
          y = BODY_START_Y;
        }
      }
    }

    const name = hasA && hasB ? 'compatibility-pretty-dark.pdf' : 'partner-survey-pretty-dark.pdf';
    doc.save(name);

    function buildAB(Arows, Brows) {
      const key = (r) => `${r.Role}|${r.Item}`.toLowerCase();
      const aMap = Object.fromEntries(Arows.map((r) => [key(r), r]));
      const bMap = Object.fromEntries(Brows.map((r) => [key(r), r]));
      const keys = [...new Set([...Object.keys(aMap), ...Object.keys(bMap)])].sort();
      return keys.map((k) => {
        const a = aMap[k];
        const b = bMap[k];
        const role = a?.Role || b?.Role || '';
        const item = a?.Item || b?.Item || '';
        const aS = Number.isFinite(a?.Score) ? a.Score : null;
        const bS = Number.isFinite(b?.Score) ? b.Score : null;
        let pct = null;
        let flagColor = null;

        if (aS != null && bS != null) {
          pct = Math.round((1 - Math.abs(aS - bS) / 5) * 100);
          if (pct > 85) flagColor = GREEN;
          else if (pct >= 50) flagColor = YELLOW;
          else flagColor = RED;
        }
        return {
          role,
          item,
          a: aS == null ? '' : String(aS),
          match: pct == null ? '' : pct + '%',
          flag: '',
          flagColor,
          b: bS == null ? '' : String(bS)
        };
      });
    }

    function withFlagDotHooks(flagColKey) {
      return {
        didDrawCell(data) {
          if (data.section === 'body' && data.column.dataKey === flagColKey) {
            const color = data.row.raw.flagColor;
            if (!color) return;
            const { x, y, height } = data.cell;
            const cx = x + 10;
            const cy = y + height / 2;
            const r = 4;
            const [rC, gC, bC] = color;
            doc.setFillColor(rC, gC, bC);
            doc.circle(cx, cy, r, 'F');
            const baseFill = data.row.index % 2 === 0 ? BODY1 : BODY2;
            const [bR, bG, bB] = baseFill;
            doc.setFillColor(bR, bG, bB);
          }
        }
      };
    }
  }

  // optional helper to wipe consent so you can test again without closing the tab
  window.tkResetPartnerConsent = () => {
    sessionStorage.removeItem(CONSENT_KEY);
    console.info('[compat] Partner consent reset for this tab.');
  };
})();
</script>
<!-- =============================================================================== -->
