<!-- ================= CODEX DROP-IN: Fast Upload + Consent + Pretty PDF ================= -->
<input id="yourFile"    type="file" accept="application/json" style="display:none" />
<input id="partnerFile" type="file" accept="application/json" style="display:none" />

<button id="yourBtn"    type="button">Upload Your Survey</button>
<button id="partnerBtn" type="button">Upload Partnerâ€™s Survey</button>
<button id="downloadBtn" type="button">Download PDF</button>

<!-- jsPDF + autoTable -->
<script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js" crossorigin="anonymous"></script>
<script src="https://unpkg.com/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js" crossorigin="anonymous"></script>

<script>
(function () {
  const $ = (s, r=document) => r.querySelector(s);

  // Wire UI
  $('#yourBtn')?.addEventListener('click',   () => $('#yourFile').click());
  $('#partnerBtn')?.addEventListener('click',() => $('#partnerFile').click());

  // State (only store Files at change time â†’ fast handler)
  let yourFileBlob = null;
  let partnerFileBlob = null;
  let yourJSON = null;
  let partnerJSON = null;

  // ---- FAST change handlers: do nothing heavy here ----
  $('#yourFile')?.addEventListener('change', (ev) => {
    const f = ev.target?.files?.[0]; if (!f) return;
    yourFileBlob = f;          // store only
    alert('Uploaded âœ“');
    ev.target.value = '';
  });

  $('#partnerFile')?.addEventListener('change', (ev) => {
    const f = ev.target?.files?.[0]; if (!f) return;

    const ok = confirm(
      'Before importing a partnerâ€™s survey, confirm you have their explicit consent '+
      'to upload and compare their responses here.\n\nClick â€œOKâ€ to continue or â€œCancelâ€ to stop.'
    );
    if (!ok) { ev.target.value = ''; return; }

    partnerFileBlob = f;       // store only
    alert('Uploaded âœ“\n(You confirmed you have your partnerâ€™s explicit consent.)');
    ev.target.value = '';
  });

  // ---- Parse files lazily (after a tick / on demand) ----
  async function ensureParsed() {
    // Yield so we never block the change event: avoids "[Violation] 'change' handler took â€¦ms"
    await new Promise(r => setTimeout(r, 0));

    if (yourFileBlob && !yourJSON) {
      const text = await yourFileBlob.text();
      yourJSON = JSON.parse(text);
    }
    if (partnerFileBlob && !partnerJSON) {
      const text = await partnerFileBlob.text();
      partnerJSON = JSON.parse(text);
    }
  }

  // ---- Download pretty PDF (A/B or single) ----
  $('#downloadBtn')?.addEventListener('click', async () => {
    try {
      await ensureParsed();
      await generatePrettyPDF(yourJSON, partnerJSON);
    } catch (e) {
      console.error(e);
      alert('Sorryâ€”could not generate the PDF.');
    }
  });

  // ======= Parse TalkKink JSON -> rows =======
  function rowsFromTalkKink(json) {
    if (!json) return [];
    const map = json.answersById || {};
    const out = [];
    for (const [id, score] of Object.entries(map)) {
      // behavioral-play-assigning-corner-time-or-time-outs-giving
      const parts = id.split('-');
      const role = parts.at(-1); // giving|receiving|general
      const category = (parts[0] + ' ' + parts[1]).replace(/\b\w/g, m=>m.toUpperCase());
      const item = parts.slice(2, -1).join(' ')
        .replace(/\bTv\b/gi,'TV').replace(/\s+/g,' ').trim();
      out.push({ Category: category, Item: cap(item), Role: cap(role), Score: Number(score) });
    }
    out.sort((a,b)=> a.Category.localeCompare(b.Category) || a.Role.localeCompare(b.Role) || a.Item.localeCompare(b.Item));
    return out;
  }
  const cap = s => s ? s[0].toUpperCase() + s.slice(1) : s;

  // ======= Pretty PDF =======
  async function generatePrettyPDF(yourJSON, partnerJSON) {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit:'pt', format:'letter' });

    const rowsA = rowsFromTalkKink(yourJSON);
    const rowsB = rowsFromTalkKink(partnerJSON);
    const hasA = rowsA.length > 0, hasB = rowsB.length > 0;

    // Header bar
    const now = new Date().toLocaleString();
    doc.setFillColor(0,0,0); doc.rect(0,0,doc.internal.pageSize.getWidth(),64,'F');
    doc.setTextColor(0,255,255); doc.setFont('helvetica','bold'); doc.setFontSize(18);
    doc.text('TalkKink Compatibility â€” Printable Report', 48, 40);
    doc.setTextColor(220); doc.setFont('helvetica','normal'); doc.setFontSize(10);
    doc.text(`Generated: ${now}`, 48, 56);

    const yStart = 88; let y = yStart;

    if (hasA && hasB) {
      // A/B comparison with Match % and flags
      const cats = [...new Set([...rowsA, ...rowsB].map(r=>r.Category))];
      for (const cat of cats) {
        doc.setTextColor(0); doc.setFont('helvetica','bold'); doc.setFontSize(13);
        doc.text(cat, 48, y); y += 8;

        const body = buildComparisonBody(
          rowsA.filter(r=>r.Category===cat),
          rowsB.filter(r=>r.Category===cat)
        );

        doc.autoTable({
          startY: y + 8,
          margin: { left: 48, right: 48 },
          head: [['Role', 'Item', 'Partner A', 'Match', 'Flag', 'Partner B']],
          body,
          styles: { font:'helvetica', fontSize:10, cellPadding:4, overflow:'linebreak' },
          headStyles: { fillColor:[0,0,0], textColor:255 },
          alternateRowStyles: { fillColor:[245,245,245] },
          columnStyles: {
            0:{ cellWidth:70 }, 1:{ cellWidth:280 }, 2:{ cellWidth:60, halign:'center' },
            3:{ cellWidth:60, halign:'center' }, 4:{ cellWidth:40, halign:'center' },
            5:{ cellWidth:60, halign:'center' }
          }
        });
        y = doc.lastAutoTable.finalY + 16;
        if (y > doc.internal.pageSize.getHeight()-72) { doc.addPage(); y = yStart; }
      }
    } else {
      // Single survey pretty print
      const rows = hasA ? rowsA : rowsB;
      const whose = hasA ? 'Partner A' : 'Partner';
      const cats = [...new Set(rows.map(r=>r.Category))];

      for (const cat of cats) {
        doc.setTextColor(0); doc.setFont('helvetica','bold'); doc.setFontSize(13);
        doc.text(`${cat} â€” ${whose}`, 48, y); y += 8;

        const body = rows.filter(r=>r.Category===cat).map(r => [r.Role, r.Item, String(r.Score)]);
        doc.autoTable({
          startY: y + 8,
          margin: { left: 48, right: 48 },
          head: [['Role','Item','Score']],
          body,
          styles: { font:'helvetica', fontSize:10, cellPadding:4, overflow:'linebreak' },
          headStyles: { fillColor:[0,0,0], textColor:255 },
          alternateRowStyles: { fillColor:[245,245,245] },
          columnStyles: { 0:{cellWidth:90}, 1:{cellWidth:350}, 2:{cellWidth:60, halign:'center'} }
        });
        y = doc.lastAutoTable.finalY + 16;
        if (y > doc.internal.pageSize.getHeight()-72) { doc.addPage(); y = yStart; }
      }
    }

    const filename = (hasA && hasB) ? 'compatibility-pretty.pdf' : 'partner-survey-pretty.pdf';
    doc.save(filename);
  }

  function buildComparisonBody(rowsA, rowsB) {
    const key = r => `${r.Role}|${r.Item}`.toLowerCase();
    const mapA = Object.fromEntries(rowsA.map(r => [key(r), r]));
    const mapB = Object.fromEntries(rowsB.map(r => [key(r), r]));
    const keys = [...new Set([...Object.keys(mapA), ...Object.keys(mapB)])].sort();

    const body = [];
    for (const k of keys) {
      const a = mapA[k], b = mapB[k];
      const role = (a?.Role || b?.Role || '');
      const item = (a?.Item || b?.Item || '');
      const aScore = Number.isFinite(a?.Score) ? a.Score : '';
      const bScore = Number.isFinite(b?.Score) ? b.Score : '';

      let match = '', flag = '';
      if (a && b) {
        const diff = Math.abs(a.Score - b.Score);
        const pct = Math.round((1 - diff/5) * 100);
        match = pct + '%';
        if (pct >= 90) flag = 'â­';
        else if (pct <= 30) flag = 'ğŸš©';
        if ((a.Score === 5 && b.Score < 5) || (b.Score === 5 && a.Score < 5)) {
          flag = flag ? flag + ' ğŸŸ¨' : 'ğŸŸ¨';
        }
      }
      body.push([role, item, String(aScore), match, flag, String(bScore)]);
    }
    return body;
  }
})();
</script>
<!-- =============================================================================== -->
