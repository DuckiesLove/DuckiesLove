<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Talk Kink – Compatibility</title>
<style>
  :root{
    --bg:#f7f9fc; --fg:#152133; --muted:#5f6b7a; --line:#d5dce6; --accent:#2a7de1;
    --cell-pad:.9rem; --track:#e3e9f2;
  }
/* resolved: full-width black layout */
:root{
  --bg:#000;
  --fg:#fff;
  --muted:#94a3bb;
  --line:#1f2733;
  --track:#0f1720;
}

html,body{
  background:#000;          /* force pure black */
  color:var(--fg);
  margin:0;
  font:16px/1.4 system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
}

.wrap{
  width:100%;
  margin:0;
  padding:32px clamp(16px,4vw,48px);
  box-sizing:border-box;
}

/* optional: make print/PDF full-bleed too */
@page { margin:0; }
* { -webkit-print-color-adjust: exact; print-color-adjust: exact; }

  h1{font-weight:700;letter-spacing:.4px;margin:0 0 10px}
  .bar{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:12px 0 22px}
  .btn{
    background:transparent;border:2px solid var(--accent);color:var(--accent);
    padding:.55rem .9rem;border-radius:10px;cursor:pointer;font-weight:600
  }
  .btn:hover{background:rgba(42,125,225,.12)}
  .note{color:var(--muted);font-size:.9rem}
  .file{display:inline-block}
  table{width:100%;border-collapse:collapse;table-layout:fixed}
  thead th{
    text-align:center;font-weight:800;border:2px solid var(--line);
    padding:.85rem;background:var(--bg);position:sticky;top:0
  }
  tbody td{
    border:2px solid var(--line);padding:var(--cell-pad);vertical-align:middle
  }
  td.cat{width:56%;font-weight:600}
  td.num, th.num{text-align:center;width:14%}
  td.muted{color:var(--muted)}
  /* Subtle progress background – can remove if you want pure text */
  .pct-shell{height:12px;background:var(--track);border-radius:7px;overflow:hidden;border:1px solid var(--line)}
  .pct-bar{height:100%;background:var(--accent);width:0%}
  /* Print: preserve the on-screen colors in the PDF */
  @media print{
    html,body,.wrap,table,th,td{
      background:#000 !important;
      color:#fff !important;
    }
    body{-webkit-print-color-adjust:exact;print-color-adjust:exact}
    .wrap{padding:0 !important}
    .bar,.note{display:none}
    thead th{position:static}
  }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Compatibility</h1>

    <div class="bar">
      <label class="file btn">Load Survey A
        <input id="fileA" type="file" accept="application/json" hidden>
      </label>
      <label class="file btn">Load Survey B
        <input id="fileB" type="file" accept="application/json" hidden>
      </label>
      <button id="dl" class="btn">Download PDF</button>
      <button id="missingBtn" class="btn" title="Show any codes missing a label">Missing labels</button>
      <span class="note" id="status">Waiting for uploads…</span>
    </div>

    <table id="compat">
      <thead>
        <tr>
          <th class="cat">Category</th>
          <th class="num">Partner A</th>
          <th class="num">Match %</th>
          <th class="num">Partner B</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>

    <p class="note" style="margin-top:14px">
      Tip: If “Missing labels” shows anything, add those mappings to
      <code>/data/labels-overrides.json</code> so names render (the table will never show raw cb_ codes).
    </p>
  </div>

<script>
(() => {
  // --- data holders ---------------------------------------------------------
  let surveyA = null, surveyB = null;
  const LABELS = {};          // combined labels (overrides + base)
  const missing = new Set();  // codes that had no label

  // --- load label sources (overrides first) --------------------------------
  const labelSources = [
    "/data/labels-overrides.json", // your curated names win
    "/data/kinks.json"             // base map
  ];

  async function loadLabels() {
    for (const url of labelSources) {
      try {
        const res = await fetch(url, {cache:"no-store"});
        if (!res.ok) continue;
        const obj = await res.json();
        for (const [k,v] of Object.entries(obj)) {
          if (v && typeof v === "string") LABELS[k] = v.trim();
        }
      } catch { /* ignore */ }
    }
  }

  // --- pdf helpers ---------------------------------------------------------
  const scriptCache = new Map();

  function loadScript(src) {
    if (scriptCache.has(src)) return scriptCache.get(src);

    const existing = document.querySelector(`script[src="${src}"]`);
    if (existing) {
      const pending = new Promise((resolve, reject) => {
        const onLoad = () => { existing.removeEventListener("load", onLoad); existing.removeEventListener("error", onError); resolve(); };
        const onError = () => { existing.removeEventListener("load", onLoad); existing.removeEventListener("error", onError); reject(new Error("Failed to load " + src)); };
        existing.addEventListener("load", onLoad, { once:true });
        existing.addEventListener("error", onError, { once:true });
      });
      scriptCache.set(src, pending);
      return pending;
    }

    const s = document.createElement("script");
    s.src = src;
    s.async = true;

    const promise = new Promise((resolve, reject) => {
      s.onload = () => { s.onload = s.onerror = null; resolve(); };
      s.onerror = () => { s.onload = s.onerror = null; reject(new Error("Failed to load " + src)); };
    });

    scriptCache.set(src, promise);
    document.head.appendChild(s);
    return promise;
  }

  async function ensureLib(srcList, readyCheck, label) {
    const check = typeof readyCheck === "function" ? readyCheck : () => !!window[readyCheck];
    if (check()) return;

    let lastError = null;
    for (const src of srcList) {
      try {
        await loadScript(src);
      } catch (err) {
        lastError = err;
        console.warn("[PDF] loader failed", src, err);
        continue;
      }
      if (check()) return;
    }

    if (!check()) {
      throw lastError || new Error((label || "Library") + " failed to load");
    }
  }

  async function makeFullBleedPDF(){
    await ensureLib([
      "/js/vendor/jspdf.umd.min.js",
      "https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js",
      "https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
    ], () => window.jspdf && window.jspdf.jsPDF, "jsPDF");

    if (window.jspdf && window.jspdf.jsPDF && !window.jsPDF) {
      window.jsPDF = window.jspdf.jsPDF;
    }

    await ensureLib([
      "/js/vendor/html2canvas.min.js",
      "https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js",
      "https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"
    ], () => typeof window.html2canvas === "function", "html2canvas");

    const jsPDFCtor = window.jspdf?.jsPDF || window.jsPDF;
    const html2canvasFn = window.html2canvas;
    if (typeof jsPDFCtor !== "function" || typeof html2canvasFn !== "function") {
      throw new Error("PDF libraries missing");
    }

    const node = document.querySelector(".wrap") || document.body;
    if (!node) throw new Error("Nothing to capture");

    const prevHtmlBg = document.documentElement.style.backgroundColor;
    const prevBodyBg = document.body.style.backgroundColor;

    document.documentElement.style.backgroundColor = "#000";
    document.body.style.backgroundColor = "#000";

    if (document.fonts && document.fonts.ready) {
      try { await document.fonts.ready; } catch { /* ignore */ }
    }

    const bounds = node.getBoundingClientRect();
    const captureWidth = Math.ceil(Math.max(bounds.width, node.scrollWidth, node.offsetWidth || 0));
    const captureHeight = Math.ceil(Math.max(bounds.height, node.scrollHeight, node.offsetHeight || 0));

    const dpr = Math.min(window.devicePixelRatio || 1, 3);
    const scale = 2 * dpr;

    let canvas;
    try {
      canvas = await html2canvasFn(node, {
        backgroundColor: "#000",
        scale,
        useCORS: true,
        allowTaint: true,
        logging: false,
        width: captureWidth,
        height: captureHeight,
        windowWidth: captureWidth,
        windowHeight: captureHeight,
        scrollX: -window.scrollX,
        scrollY: -window.scrollY
      });
    } finally {
      document.documentElement.style.backgroundColor = prevHtmlBg || "";
      document.body.style.backgroundColor = prevBodyBg || "";
    }

    if (!canvas) throw new Error("Canvas capture failed");

    const imgData = canvas.toDataURL("image/png", 1.0);
    const pxToPt = 72 / 96;
    const pdfW = canvas.width * pxToPt;
    const pdfH = canvas.height * pxToPt;
    const orientation = (pdfW >= pdfH) ? "landscape" : "portrait";

    const pdf = new jsPDFCtor({
      orientation,
      unit: "pt",
      format: [pdfW, pdfH],
      compress: true,
      putOnlyUsedFonts: true
    });

    pdf.setFillColor(0, 0, 0);
    pdf.rect(0, 0, pdfW, pdfH, "F");
    pdf.addImage(imgData, "PNG", 0, 0, pdfW, pdfH, undefined, "FAST");
    pdf.save("compatibility.pdf");
  }
  window.makeFullBleedPDF = makeFullBleedPDF;

  // never expose cb_* in UI. If unknown -> "—" and remember for the side list.
  function prettyLabel(code) {
    const name = LABELS[code];
    if (name && name.trim()) return name.trim();
    missing.add(code);
    return "—";
  }

  // --- file helpers ---------------------------------------------------------
  function readJSON(file) {
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onerror = () => reject(new Error("Could not read file."));
      fr.onload = () => {
        try { resolve(JSON.parse(fr.result)); }
        catch(e){ reject(new Error("Invalid JSON.")); }
      };
      fr.readAsText(file);
    });
  }

  // find all category codes present in either survey (array of cb_* ids).
  function collectCategoryCodes(a, b) {
    const set = new Set();
    const push = obj => {
      if (!obj) return;
      // Accept both shapes: {answers:[{id,value}...]} or {…id:value…}
      if (Array.isArray(obj.answers)) {
        for (const row of obj.answers) if (row && row.id) set.add(row.id);
      } else {
        for (const k of Object.keys(obj)) if (k.startsWith("cb_")) set.add(k);
      }
    };
    push(a); push(b);
    return [...set];
  }

  // score helpers – you can swap this for your project’s real logic
  const valOf = (obj, id) => {
    if (!obj) return null;
    if (Array.isArray(obj.answers)) {
      const r = obj.answers.find(x => x.id === id);
      return r ? r.value ?? r.answer ?? null : null;
    }
    return obj[id] ?? null;
  };
  function matchPercent(aVal, bVal){
    if (aVal == null || bVal == null) return null;
    // Simple: identical = 100, else 0. Replace with your real formula if needed.
    return aVal === bVal ? 100 : 0;
  }

  // --- rendering ------------------------------------------------------------
  const tbody = document.getElementById("tbody");
  function render() {
    if (!surveyA && !surveyB) return;
    const codes = collectCategoryCodes(surveyA, surveyB);

    // Make rows (resolve names now so we can sort by them)
    const rows = codes.map(code => {
      const name = prettyLabel(code);
      const aVal = valOf(surveyA, code);
      const bVal = valOf(surveyB, code);
      const pct  = matchPercent(aVal, bVal);
      return { code, name, aVal, bVal, pct };
    });

    // Alphabetical by the display name (case-insensitive), keep blanks last.
    rows.sort((r1, r2) => {
      const n1 = r1.name === "—" ? "~~~" : r1.name.toLowerCase();
      const n2 = r2.name === "—" ? "~~~" : r2.name.toLowerCase();
      return n1.localeCompare(n2);
    });

    // Build table
    tbody.innerHTML = "";
    for (const r of rows) {
      const tr = document.createElement("tr");

      const tdCat = document.createElement("td");
      tdCat.className = "cat";
      tdCat.textContent = r.name;               // never show code
      tr.appendChild(tdCat);

      const tdA = document.createElement("td");
      tdA.className = "num";
      tdA.textContent = (r.aVal ?? "—");
      tr.appendChild(tdA);

      const tdPct = document.createElement("td");
      tdPct.className = "num";
      tdPct.innerHTML = r.pct == null
        ? "—"
        : `<div class="pct-shell"><div class="pct-bar" style="width:${r.pct}%"></div></div>`;
      tr.appendChild(tdPct);

      const tdB = document.createElement("td");
      tdB.className = "num";
      tdB.textContent = (r.bVal ?? "—");
      tr.appendChild(tdB);

      tbody.appendChild(tr);
    }

    // status
    const s = [];
    if (surveyA) s.push("A ✓"); else s.push("A —");
    if (surveyB) s.push("B ✓"); else s.push("B —");
    document.getElementById("status").textContent = `Loaded: ${s.join("  ·  ")}`;
  }

  // --- UI wiring ------------------------------------------------------------
  document.getElementById("fileA").addEventListener("change", async (e)=>{
    if (!e.target.files?.[0]) return;
    try {
      surveyA = await readJSON(e.target.files[0]);
      render();
    } catch(err){ alert("Survey A: " + err.message); }
    finally { e.target.value = ""; }
  });

  document.getElementById("fileB").addEventListener("change", async (e)=>{
    if (!e.target.files?.[0]) return;
    try {
      surveyB = await readJSON(e.target.files[0]);
      render();
    } catch(err){ alert("Survey B: " + err.message); }
    finally { e.target.value = ""; }
  });

  document.getElementById("missingBtn").addEventListener("click", ()=> {
    if (!missing.size) { alert("Great! No missing labels."); return; }
    const list = [...missing].sort().join("\n");
    alert("Add these to /data/labels-overrides.json:\n\n" + list);
  });

  // start
  loadLabels().then(render);
})();
</script>
<script type="module">
/* === Full-bleed PDF export: forcibly replace old window.print handler === */
document.addEventListener('DOMContentLoaded', () => {
  const btn = document.querySelector('#dl') || document.querySelector('[data-action="download"]');
  if (!btn) return;

  const clean = btn.cloneNode(true);
  clean.removeAttribute('onclick');
  btn.replaceWith(clean);

  clean.addEventListener('click', async (e) => {
    e.preventDefault();
    e.stopPropagation();
    try {
      if (typeof window.makeFullBleedPDF !== 'function') {
        throw new Error('makeFullBleedPDF not ready');
      }
      await window.makeFullBleedPDF();
    } catch (err) {
      console.error('[PDF] export failed:', err);
      alert('PDF export failed. See console for details.');
    }
  }, { passive: false });
});
</script>
<!--
===============================================================================
CODE START
===============================================================================
-->
<style>
  :root { --bg:#000; --fg:#fff; }
  html,body{
    background:#000; /* full black */
    color:var(--fg);
    margin:0;        /* remove white page gutters */
    font:16px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif
  }
  /* Make content span the full width while keeping some breathing room */
  .wrap{
    width:100%;
    margin:0;
    padding:32px clamp(16px,4vw,48px);
    box-sizing:border-box;
  }
  /* Dark table aesthetics to match your earlier look */
  table{background:#000;color:#fff;border-collapse:collapse;width:100%}
  th,td{border:1px solid #3a3a3a;padding:.8rem .9rem}
  thead th{background:#0e0e0e;font-weight:700}
</style>

<script type="module">
/* =============================================================================
 * 0) Small utilities
 * ========================================================================= */
const codeRe = /^cb_[a-z0-9]+$/i;
const debounce = (fn, ms=60) => { let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; };

/* =============================================================================
 * 1) On load: replace old print handler; wire our PDF export
 * ========================================================================= */
document.addEventListener('DOMContentLoaded', async () => {
  // Replace any existing print() handler on your Download button.
  const btn = document.querySelector('#dl') || document.querySelector('[data-action="download"]');
  if (btn) {
    const clone = btn.cloneNode(true);
    clone.removeAttribute('onclick');          // kill inline print
    btn.replaceWith(clone);
    clone.addEventListener('click', async (e) => {
      e.preventDefault(); e.stopPropagation();
      try { await makeFullBleedPDF(); } catch (err) {
        console.error('[PDF] export failed:', err);
        alert('PDF export failed. See console for details.');
      }
    }, { passive:false });
  }

  // Build label map and rewrite the category column now + on any updates.
  const labels = await buildLabelMapSafely();
  rewriteAllCategoryCells(labels);

  // When Survey A/B uploads finish, the table DOM changes—watch & rewrite.
  const target = document.querySelector('.wrap') || document.body;
  const ro = new MutationObserver(debounce(() => rewriteAllCategoryCells(labels), 50));
  ro.observe(target, { childList:true, subtree:true, characterData:true });
});

/* =============================================================================
 * 2) Label map sources (root-absolute for nested pages)
 *    - /data/kinks.json (recommended single source of truth)
 *    - /data/labels-overrides.json (optional, for patching gaps/custom text)
 *    - window.tkLabels (auto-merge if tk-labels.js provided it)
 * ========================================================================= */
async function buildLabelMapSafely() {
  const map = Object.create(null);
  const add = (code, val) => {
    const title = typeof val === 'string' ? val : (val?.title || val?.label || val?.name || val?.display || val?.text);
    if (code && title) map[String(code).toLowerCase()] = title;
  };

  const fetchJson = async (url) => {
    try { const r = await fetch(url, { credentials:'same-origin' }); if (r.ok) return r.json(); }
    catch(_){} return null;
  };

  // Pull from the site root so it works from /compatibility.html or nested pages.
  const kinks = await fetchJson('/data/kinks.json');
  if (kinks) {
    if (Array.isArray(kinks.items)) kinks.items.forEach(i => add(i.code||i.id, i));
    else if (typeof kinks === 'object') {
      for (const [k,v] of Object.entries(kinks)) add(k, v);
    }
  }

  const overrides = await fetchJson('/data/labels-overrides.json'); // optional
  if (overrides && typeof overrides === 'object') {
    for (const [k,v] of Object.entries(overrides)) add(k, v);
  }

  // Merge in window.tkLabels if tk-labels.js provided it.
  const tk = window.tkLabels;
  if (tk && typeof tk === 'object') {
    const src = tk.labels && typeof tk.labels === 'object' ? tk.labels : tk;
    for (const [k,v] of Object.entries(src)) add(k, v);
  }

  return map;
}

/* =============================================================================
 * 3) Rewrite the first cell of each row if it looks like a cb_* code
 * ========================================================================= */
function rewriteAllCategoryCells(labelMap) {
  if (!labelMap || !Object.keys(labelMap).length) return;

  const tables = document.querySelectorAll('table');
  tables.forEach(table => {
    // Prefer TBODY rows; else skip header row
    const rows = table.tBodies.length
      ? Array.from(table.tBodies).flatMap(tb => Array.from(tb.rows))
      : Array.from(table.rows).slice(1);

    rows.forEach(tr => {
      const firstCell = tr.querySelector('th, td');
      if (!firstCell) return;
      const raw = (firstCell.textContent || '').trim();
      if (codeRe.test(raw)) {
        const pretty = labelMap[raw.toLowerCase()];
        if (pretty) firstCell.textContent = pretty;
      }
    });
  });
}

/* =============================================================================
 * 4) Full-bleed PDF export (auto-download; no white margins)
 *    Local-first loader with CDN fallback for jspdf + html2canvas
 * ========================================================================= */
async function makeFullBleedPDF() {
  await ensureLib(['/js/vendor/jspdf.umd.min.js','https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js'], 'jspdf');
  await ensureLib(['/js/vendor/html2canvas.min.js','https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js'], 'html2canvas');

  const { jsPDF } = window.jspdf;
  const node = document.querySelector('.wrap') || document.body;

  // Guarantee deep black during capture; restore after.
  const prevHtmlBg = document.documentElement.style.backgroundColor;
  const prevBodyBg = document.body.style.backgroundColor;
  document.documentElement.style.backgroundColor = '#000';
  document.body.style.backgroundColor = '#000';

  if (document.fonts?.ready) { try { await document.fonts.ready; } catch {} }

  const dpr = Math.min(window.devicePixelRatio || 1, 3);
  const scale = 2 * dpr;
  const canvas = await window.html2canvas(node, {
    backgroundColor: '#000',
    scale,
    useCORS: true,
    allowTaint: true,
    logging: false,
    windowWidth: Math.max(document.documentElement.scrollWidth, document.body.scrollWidth),
    windowHeight: Math.max(document.documentElement.scrollHeight, document.body.scrollHeight),
  });

  const img = canvas.toDataURL('image/png', 1.0);
  const pxToPt = 72 / 96;
  const w = canvas.width * pxToPt;
  const h = canvas.height * pxToPt;

  const pdf = new jsPDF({
    orientation: (w >= h) ? 'landscape' : 'portrait',
    unit: 'pt',
    format: [w, h],
    compress: true,
    putOnlyUsedFonts: true,
  });

  // Paint the page black and draw the image edge-to-edge
  pdf.setFillColor(0,0,0);
  pdf.rect(0,0,w,h,'F');
  pdf.addImage(img, 'PNG', 0, 0, w, h, undefined, 'FAST');
  pdf.save('compatibility.pdf');

  document.documentElement.style.backgroundColor = prevHtmlBg || '';
  document.body.style.backgroundColor = prevBodyBg || '';
}

/* =============================================================================
 * 5) Script loader: try local file, then CDN
 * ========================================================================= */
function ensureLib(srcList, globalKey) {
  return new Promise((resolve, reject) => {
    if (window[globalKey]) return resolve();
    const tryNext = i => {
      if (i >= srcList.length) return reject(new Error(`Failed to load ${globalKey}`));
      const s = document.createElement('script');
      s.src = srcList[i];
      s.async = true;
      s.onload = () => resolve();
      s.onerror = () => { s.remove(); tryNext(i+1); };
      document.head.appendChild(s);
    };
    tryNext(0);
  });
}
</script>
<!--
===============================================================================
CODE END
===============================================================================
-->
<script>
/**
 * Full-bleed, all-black PDF export for the compatibility table.
 * - Replaces any existing window.print()/legacy exporters bound to #dl
 * - Fills the page background black, then draws the table with ZERO margins
 * - Forces the table to the page edges
 * - Optionally translates cb_* codes to labels via window.TK_LABELS (mapping)
 */
(() => {
  const CDN_JSPDF     = 'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js';
  const CDN_AUTOTABLE = 'https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js';

  // Attach once and neuter any previous click listeners that did window.print()
  document.addEventListener('DOMContentLoaded', () => {
    const btn = document.getElementById('dl');
    if (!btn) return;

    // remove any existing listeners by replacing the node with a clone
    const clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn);

    clone.addEventListener('click', async (ev) => {
      ev.preventDefault();
      try {
        await ensureLibs();
        await exportFullBleedPDF();
      } catch (err) {
        console.error('[PDF] Export failed:', err);
        alert('PDF export failed. See console for details.');
      }
    });
  });

  async function ensureLibs() {
    if (!(window.jspdf && window.jspdf.jsPDF)) {
      await loadScript(CDN_JSPDF);
    }

    // Some bundles expose jsPDF on window.jsPDF instead of window.jspdf.jsPDF
    if (!window.jsPDF && window.jspdf && window.jspdf.jsPDF) {
      window.jsPDF = window.jspdf.jsPDF;
    }

    const hasAutoTable = Boolean(
      (window.jspdf && window.jspdf.autoTable) ||
      (window.jspdf && window.jspdf.jsPDF && window.jspdf.jsPDF.API && window.jspdf.jsPDF.API.autoTable) ||
      (window.jsPDF && window.jsPDF.API && window.jsPDF.API.autoTable)
    );

    if (!hasAutoTable) {
      await loadScript(CDN_AUTOTABLE);
    }
  }

  function loadScript(src) {
    return new Promise((res, rej) => {
      const s = document.createElement('script');
      s.src = src;
      s.async = true;
      s.onload = res;
      s.onerror = () => rej(new Error('Failed to load ' + src));
      document.head.appendChild(s);
    });
  }

  function findCompatTable() {
    const isCompat = (t) => t && /Category/i.test(t.textContent) && /Partner A/i.test(t.textContent);
    let table = Array.from(document.querySelectorAll('.wrap table, main table, table')).find(isCompat);
    if (!table) table = document.querySelector('table');
    return table;
  }

  async function exportFullBleedPDF() {
    const { jsPDF } = window.jspdf;

    // Landscape A4. Change to "portrait" if you prefer.
    const pdf = new jsPDF({ unit: 'pt', format: 'a4', orientation: 'landscape' });
    const pageW = pdf.internal.pageSize.getWidth();
    const pageH = pdf.internal.pageSize.getHeight();

    const tableEl = findCompatTable();
    if (!tableEl) throw new Error('Compatibility table not found on the page.');

    // 1) Fill the ENTIRE page background in solid black (removes white gutters)
    pdf.setFillColor(0, 0, 0);
    pdf.rect(0, 0, pageW, pageH, 'F');

    // 2) Render the table with ZERO margins, spanning full page width
    //    And translate cb_* codes in first column if window.TK_LABELS is provided
    const LABELS = (window.TK_LABELS || {});
    const runAutoTable = (opts) => {
      if (typeof pdf.autoTable === 'function') return pdf.autoTable(opts);
      if (window.jspdf && typeof window.jspdf.autoTable === 'function') {
        return window.jspdf.autoTable(pdf, opts);
      }
      throw new Error('AutoTable not available');
    };

    runAutoTable({
      html: tableEl,
      theme: 'plain',
      useCss: false,

      // *** ZERO margins, start at 0, force width to page width ***
      margin: 0,
      startY: 0,
      tableWidth: pageW,

      // visual styles (dark rows / white text)
      styles: {
        cellPadding: 8,
        fillColor: [0, 0, 0],
        textColor: 255,
        lineColor: [64, 64, 64],
        lineWidth: 0.6,
        halign: 'left',
        valign: 'middle',
      },
      headStyles: {
        fillColor: [10, 10, 10],
        textColor: 255,
        fontStyle: 'bold',
      },
      alternateRowStyles: { fillColor: [18, 18, 18] },

      // Translate codes in the first column on the fly
      didParseCell: (data) => {
        if (data.section === 'body' && data.column.index === 0) {
          const raw = String((data.cell.text && data.cell.text[0]) || '');
          if (raw.startsWith('cb_')) {
            const pretty = LABELS[raw];
            if (pretty) data.cell.text = [pretty];
          }
        }
      },

      // Keep it clean: do not add headers/footers that would reintroduce margins
      didDrawPage: () => { /* no-op */ },
    });

    pdf.save('compatibility.pdf');
  }
})();
</script>
</body>
</html>
