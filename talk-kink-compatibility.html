<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>TalkKink Compatibility</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Your existing CSS / theme links stay as-is -->
  <style>
    /* keep your site styles; the following are only fallbacks */
    body { background:#000; color:#fff; font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .cta { display:block; width:420px; margin:18px auto; padding:18px 22px; text-align:center;
           border:2px solid rgba(0,255,255,.5); border-radius:14px; background:rgba(0,20,25,.35);
           box-shadow:0 0 18px rgba(0,200,255,.15) inset, 0 0 30px rgba(0,200,255,.2);
           color:#fff; text-decoration:none; font-weight:700; letter-spacing:.2px; }
    h1 { text-align:center; margin:48px 0 28px; font-size:52px; text-shadow:0 0 18px rgba(0,255,255,.35); }
  </style>
</head>
<body>
  <h1>TalkKink Compatibility</h1>

  <!-- Your real buttons can keep existing markup / classes; IDs are optional -->
  <button id="uploadMineBtn" class="cta">Upload Your Survey</button>
  <button id="uploadPartnerBtn" class="cta">Upload Partner’s Survey</button>
  <button id="downloadPdfBtn" class="cta">Download PDF</button>
  <a href="/KinkSurveyPage/" class="cta">← Back</a>

  <!-- ====== Standalone logic: remove theme-globals.js and pdfDownload.js includes ====== -->
  <script>
/* ---- 1) Remove the two problematic scripts if they’re on the page ---- */
(function killBadIncludes(){
  const sel = 'script[src*="theme-globals.js"],script[src*="pdfDownload.js"]';
  document.querySelectorAll(sel).forEach(node => {
    try {
      node.parentNode?.removeChild(node);
    } catch (_) {
      /* ignore */
    }
  });
})();

/* ---- 2) Null-guard for the “dock margin” style error ---- */
try {
  const dock = document.querySelector('[data-dock-margin]') ||
               document.getElementById('dock-margin') ||
               document.querySelector('.dock-margin');
  if (dock && dock.style) dock.style.margin = '';
} catch (_) {}

/* ---- 3) Minimal standalone PDF exporter (jsPDF via CDN) ---- */
(function () {
  const PAGE = { w: 612, h: 792 };
  const MARGIN = { t: 48, r: 40, b: 54, l: 40 };
  const LINE = 16;
  const COL_GAP = 18;
  const SELF_KEYS = ['talkkink:survey', 'talkkink:mine', 'tk_compat.self'];
  const PARTNER_KEYS = ['talkkink:partner', 'tk_compat.partner'];

  const nowStamp = () => {
    const d = new Date();
    const pad = (n) => String(n).padStart(2, '0');
    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
  };

  async function loadJsPDF() {
    if (window.jspdf?.jsPDF) return window.jspdf.jsPDF;
    await new Promise((res, rej) => {
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js';
      s.async = true;
      s.onload = res;
      s.onerror = () => rej(new Error('jsPDF load failed'));
      document.head.appendChild(s);
    });
    if (!(window.jspdf?.jsPDF)) throw new Error('jsPDF init failed');
    return window.jspdf.jsPDF;
  }

  function normalizeRating(value) {
    const num = Number(value);
    if (!Number.isFinite(num)) return 0;
    return Math.max(0, Math.min(5, Math.round(num)));
  }

  function normalizeRows(survey) {
    const rows = Array.isArray(survey?.responses) ? survey.responses : [];
    return rows.map((row, idx) => ({
      id: row.id ?? row.prompt ?? row.text ?? row.title ?? `item-${idx}`,
      prompt: row.prompt ?? row.text ?? row.title ?? row.label ?? row.question ?? row.id ?? '',
      category: row.category ?? row.categoryId ?? row.cat ?? row.section ?? 'Other',
      rating: normalizeRating(row.rating ?? row.score ?? row.value ?? row.answer ?? 0),
      index: row.index ?? row.order ?? row.position ?? idx
    }));
  }

  const groupByCategory = (survey) => {
    const grouped = new Map();
    normalizeRows(survey).forEach(row => {
      if (!grouped.has(row.category)) grouped.set(row.category, []);
      grouped.get(row.category).push(row);
    });
    for (const list of grouped.values()) {
      list.sort((a, b) => (a.index ?? 0) - (b.index ?? 0));
    }
    return grouped;
  };

  const summarize = (survey) => {
    const counts = [0, 0, 0, 0, 0, 0];
    normalizeRows(survey).forEach(row => {
      counts[row.rating] += 1;
    });
    return counts;
  };

  function addWrapText(doc, text, x, y, maxW, lh) {
    const words = String(text || '').split(/\s+/);
    let line = '';
    let cy = y;
    const width = (t) => doc.getTextWidth(t);
    words.forEach(word => {
      const test = line ? `${line} ${word}` : word;
      if (width(test) > maxW) {
        if (line) {
          doc.text(line, x, cy);
          cy += lh;
        }
        line = word;
      } else {
        line = test;
      }
    });
    if (line) {
      doc.text(line, x, cy);
      cy += lh;
    }
    return cy;
  }

  function header(doc, title, subtitle) {
    doc.setFillColor(0, 0, 0);
    doc.rect(0, 0, PAGE.w, PAGE.h, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(32);
    doc.text(title, PAGE.w / 2, MARGIN.t, { align: 'center', baseline: 'top' });
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(12);
    doc.text(subtitle, PAGE.w / 2, MARGIN.t + 28, { align: 'center', baseline: 'top' });
    return MARGIN.t + 42;
  }

  function addFooter(doc, page, total) {
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(9);
    doc.setTextColor(180, 180, 180);
    doc.text(`TalkKink • ${nowStamp()} • Page ${page}/${total}`, PAGE.w / 2, PAGE.h - MARGIN.b + 24, { align: 'center', baseline: 'bottom' });
  }

  function block(doc, cat, items, startY) {
    let cy = startY + 6;
    const x = MARGIN.l;
    const maxW = PAGE.w - MARGIN.l - MARGIN.r;
    if (cat) {
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(16);
      doc.setTextColor(255, 255, 255);
      cy = addWrapText(doc, cat, x, cy, maxW, LINE);
    }
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(11);
    doc.setTextColor(220, 220, 220);
    for (const row of items) {
      const chip = ` [${row.rating}] `;
      const bullet = '• ';
      const headW = doc.getTextWidth(bullet + chip);
      doc.text(bullet, x, cy);
      doc.setTextColor(140, 230, 255);
      doc.text(chip, x + doc.getTextWidth(bullet), cy);
      doc.setTextColor(220, 220, 220);
      const px = x + headW + 2;
      cy = addWrapText(doc, row.prompt || row.id, px, cy, maxW - headW - 4, LINE - 2) - 4;
      cy += 4;
      if (cy > PAGE.h - MARGIN.b - 40) {
        doc.addPage('letter', 'portrait');
        doc.setFillColor(0, 0, 0);
        doc.rect(0, 0, PAGE.w, PAGE.h, 'F');
        cy = MARGIN.t;
      }
    }
    doc.setDrawColor(60, 120, 140);
    doc.line(MARGIN.l, cy, PAGE.w - MARGIN.r, cy);
    return cy + 10;
  }

  function summary(doc, survey, label, startY) {
    const counts = summarize(survey);
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(14);
    doc.setTextColor(255, 255, 255);
    doc.text(`${label} — Rating Summary`, MARGIN.l, startY);
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(11);
    doc.setTextColor(200, 200, 200);
    doc.text(counts.map((count, rating) => `${rating}: ${count}`).join('    '), MARGIN.l, startY + LINE);
    return startY + LINE * 2;
  }

  function pickSources(opts = {}) {
    const out = { mine: opts.mine ?? null, partner: opts.partner ?? null };
    if (!out.mine) out.mine = window.talkkinkMine || window.talkkinkSurvey;
    if (!out.partner) out.partner = window.talkkinkPartner;
    try {
      if (!out.mine) {
        for (const key of SELF_KEYS) {
          const value = localStorage.getItem(key);
          if (value) { out.mine = JSON.parse(value); break; }
        }
      }
      if (!out.partner) {
        for (const key of PARTNER_KEYS) {
          const value = localStorage.getItem(key);
          if (value) { out.partner = JSON.parse(value); break; }
        }
      }
    } catch (_) {}
    return out;
  }

  async function buildPdf({ mine, partner, filename }) {
    const jsPDF = await loadJsPDF();
    const doc = new jsPDF({ unit: 'pt', format: 'letter', compress: true });
    const title = partner ? 'TalkKink Compatibility Report' : 'TalkKink Survey Export';
    const mineCats = mine?.meta?.selectedCategories?.join(', ') || 'All Categories';
    const partnerCats = partner?.meta?.selectedCategories?.join(', ') || 'All Categories';
    const subtitle = partner
      ? `Exported ${nowStamp()} • Mine: ${mineCats} • Partner: ${partnerCats}`
      : `Exported ${nowStamp()} • Selected: ${mineCats}`;

    let y = header(doc, title, subtitle);
    if (partner) {
      y = summary(doc, mine, 'Mine', y);
      y = summary(doc, partner, 'Partner', y) + 6;
    } else {
      y = summary(doc, mine, 'Summary', y) + 6;
    }

    const mineMap = groupByCategory(mine);
    const partnerMap = partner ? groupByCategory(partner) : null;

    for (const [cat, items] of mineMap.entries()) {
      if (y > PAGE.h - MARGIN.b - 120) {
        doc.addPage('letter', 'portrait');
        doc.setFillColor(0, 0, 0);
        doc.rect(0, 0, PAGE.w, PAGE.h, 'F');
        y = MARGIN.t;
      }

      if (partner && partnerMap) {
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(18);
        doc.setTextColor(255, 255, 255);
        y = addWrapText(doc, cat, MARGIN.l, y, PAGE.w - MARGIN.l - MARGIN.r, LINE) + 2;

        const colW = (PAGE.w - MARGIN.l - MARGIN.r - COL_GAP) / 2;
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(12);
        doc.text('Mine', MARGIN.l, y);
        const yL = block(doc, '', items, y + LINE - LINE);

        let yR = y;
        let xR = MARGIN.l + colW + COL_GAP;
        if (yR + 40 > PAGE.h - MARGIN.b) {
          doc.addPage('letter', 'portrait');
          doc.setFillColor(0, 0, 0);
          doc.rect(0, 0, PAGE.w, PAGE.h, 'F');
          yR = MARGIN.t;
        }
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(12);
        doc.text('Partner', xR, yR);
        yR += LINE;

        (function drawRight() {
          let cy = yR + 6;
          const maxW = colW;
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(11);
          doc.setTextColor(220, 220, 220);
          for (const row of partnerMap.get(cat) || []) {
            const chip = ` [${row.rating}] `;
            const bullet = '• ';
            const headW = doc.getTextWidth(bullet + chip);
            doc.text(bullet, xR, cy);
            doc.setTextColor(140, 230, 255);
            doc.text(chip, xR + doc.getTextWidth(bullet), cy);
            doc.setTextColor(220, 220, 220);
            const px = xR + headW + 2;
            cy = addWrapText(doc, row.prompt || row.id, px, cy, maxW - headW - 4, LINE - 2) - 4;
            cy += 4;
            if (cy > PAGE.h - MARGIN.b - 40) {
              doc.addPage('letter', 'portrait');
              doc.setFillColor(0, 0, 0);
              doc.rect(0, 0, PAGE.w, PAGE.h, 'F');
              cy = MARGIN.t;
            }
          }
          doc.setDrawColor(60, 120, 140);
          doc.line(xR, cy, xR + maxW, cy);
          yR = cy + 12;
        })();

        y = Math.max(yL, yR) + 10;
      } else {
        y = block(doc, cat, items, y);
      }
    }

    const total = doc.internal.getNumberOfPages();
    for (let i = 1; i <= total; i += 1) {
      doc.setPage(i);
      addFooter(doc, i, total);
    }
    doc.save(filename || (partner ? 'talkkink-compatibility-results.pdf' : 'talkkink-survey-results.pdf'));
  }

  window.TKPDF = window.TKPDF || {};
  window.TKPDF.download = (opts = {}) => {
    const { mine, partner } = pickSources(opts);
    if (!mine) {
      alert('Export unavailable: no survey data found.');
      return;
    }
    buildPdf({ mine, partner, filename: opts.filename }).catch(err => {
      console.error(err);
      alert('Export failed.');
    });
  };

  function attachUpload(btn, key, input) {
    if (!btn && !input) return;
    let fileInput = input || null;
    const created = !fileInput;
    if (!fileInput) {
      fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = 'application/json';
      fileInput.style.display = 'none';
      document.body.appendChild(fileInput);
    } else if (!fileInput.accept) {
      fileInput.accept = 'application/json';
    }

    const isLabelForInput = Boolean(btn && fileInput && btn.tagName === 'LABEL' && btn.htmlFor && fileInput.id && btn.htmlFor === fileInput.id);
    if (btn && !isLabelForInput && btn !== fileInput) {
      btn.addEventListener('click', () => fileInput.click());
    }

    fileInput.addEventListener('change', async () => {
      const file = fileInput.files?.[0];
      if (!file) return;
      try {
        const text = await file.text();
        const json = JSON.parse(text);
        localStorage.setItem(key, text);
        if (key === 'talkkink:mine') {
          window.talkkinkMine = json;
          window.talkkinkSurvey = json;
        }
        if (key === 'talkkink:partner') {
          window.talkkinkPartner = json;
        }
        alert('Uploaded ✓');
      } catch (err) {
        console.error(err);
        alert('Invalid file — expected TalkKink JSON export.');
      }
      if (created) {
        fileInput.value = '';
      }
    });
  }

  function findBtn(txt) {
    const needle = (txt || '').toLowerCase();
    return Array.from(document.querySelectorAll('button,a,[role="button"]')).find(el => (el.textContent || '').toLowerCase().includes(needle));
  }

  function bindUI() {
    const mineBtn = document.getElementById('uploadMineBtn') || findBtn('upload your survey');
    const partnerBtn = document.getElementById('uploadPartnerBtn') || findBtn('upload partner');
    const dlBtn = document.getElementById('downloadPdfBtn') || document.getElementById('btnDownloadPdf') || findBtn('download pdf');
    const mineInput = document.getElementById('fileA') || document.querySelector('[data-upload-input="mine"]');
    const partnerInput = document.getElementById('fileB') || document.querySelector('[data-upload-input="partner"]');
    attachUpload(mineBtn, 'talkkink:mine', mineInput);
    attachUpload(partnerBtn, 'talkkink:partner', partnerInput);
    if (dlBtn) {
      dlBtn.addEventListener('click', () => window.TKPDF.download());
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bindUI);
  } else {
    bindUI();
  }
})();
  </script>
</body>
</html>
