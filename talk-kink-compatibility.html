<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TalkKink Compatibility Survey</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Poppins:wght@600;700&display=swap">
<script type="module" src="/assets/js/compatPdf.js"></script>
<style>
  :root{
    --bg:#0a141c;            /* page background */
    --panel:#0c1d25;         /* table banding base */
    --row:#0c1f29;           /* row color */
    --row-alt:#0a1b23;       /* zebra */
    --ink:#e6feff;           /* main text */
    --ink-dim:#b8dfe0;
    --accent:#09e1ff;        /* teal glow */
    --grid:#0f4658;          /* table lines */
    --grid-strong:#0da6c5;   /* brighter dividers */
    --font-body:"Roboto","Inter","Segoe UI","Helvetica Neue",system-ui,-apple-system,sans-serif;
    --font-display:"Poppins","Poppins SemiBold","Inter",system-ui,-apple-system,sans-serif;
  }
  html,body{height:100%;}
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font-family: var(--font-body);
    font-feature-settings: "tnum";
    font-variant-numeric: tabular-nums;
    font-synthesis: none;
    text-rendering: optimizeLegibility;
  }
  .page{
    max-width:1120px;
    margin:28px auto 48px;
    padding:0 16px;
  }

  /* Centered, outlined headings (like before) */
  .title, .subtitle, .section {
    text-align:center;
    margin:0 auto;
    display:block;
    width:100%;
    color:var(--accent);
    font-family: var(--header-font, var(--font-display), 'Fredoka One', sans-serif);
  }
  .title{
    font-size:56px; line-height:1.05; font-weight:700; letter-spacing:.5px;
    color:var(--accent);
    /* outline with soft glow */
    text-shadow:
      0 0 0 var(--bg),
      0 0 18px rgba(0,231,255,.35),
      0 0 40px rgba(0,231,255,.25);
    -webkit-font-smoothing:antialiased;
  }
  .subtitle{
    margin-top:10px; font-size:20px; color:var(--ink-dim); font-weight:600;
    font-family: var(--font-body);
  }
  .hr { height:3px; background:var(--accent); margin:18px auto 14px; max-width:92%; opacity:.85; }

  .section{
    font-size:44px; font-weight:700; color:var(--accent); margin:12px 0 10px;
    text-shadow:
      0 0 0 var(--bg),
      0 0 14px rgba(0,231,255,.25),
      0 0 28px rgba(0,231,255,.18);
  }

  /* Table fills the page, no white boxes */
  .compat{
    width:100%; border-collapse:separate; border-spacing:0;
    background:transparent; table-layout:fixed;
    border:1px solid var(--grid-strong);
    box-shadow:0 0 0 1px rgba(13,166,197,.28), 0 18px 40px rgba(0,0,0,.45);
    border-radius:12px;
    overflow:hidden;
  }
  .compat col.label   { width:56%; }
  .compat col.a       { width:12%; }
  .compat col.match   { width:20%; }
  .compat col.b       { width:12%; }

  .compat thead th{
    position:sticky; top:0; z-index:1;
    background:linear-gradient(180deg, rgba(13,166,197,.32), rgba(13,166,197,.08) 90%);
    color:var(--accent); font-weight:800; font-size:20px; padding:14px 12px;
    border-bottom:2px solid var(--grid-strong);
    text-align:center;
    line-height:1.1;
    white-space:nowrap;
    font-variant-numeric:tabular-nums;
    font-feature-settings:'tnum';
    /* give the header the outlined look, too */
    text-shadow:
      0 0 0 var(--bg),
      0 0 12px rgba(0,231,255,.22);
  }
  .compat thead th:first-child{ text-align:left; }

  .compat tbody td{
    padding:14px 12px; font-size:19px; line-height:1.3; color:var(--ink);
    border-top:1px solid var(--grid);
    border-bottom:1px solid rgba(13,166,197,.16);
    background:var(--row);
    font-variant-numeric:tabular-nums;
    font-feature-settings:'tnum';
  }
  .compat tbody tr:nth-child(2n) td{ background:var(--row-alt); }
  .compat tbody td.label{ color:#8ed6e8; }
  .compat tbody td.num, .compat tbody td.match{
    text-align:center; white-space:nowrap;
  }
  .compat tbody td.match{
    color:var(--accent);
    font-weight:800;
    letter-spacing:.4px;
  }
  .compat tbody td.match .match-star{
    color:#ffc642;
    margin-left:6px;
    text-shadow:0 0 8px rgba(255,198,66,.45);
  }

  .sr-only{
    position:absolute;
    width:1px;
    height:1px;
    padding:0;
    margin:-1px;
    overflow:hidden;
    clip:rect(0, 0, 0, 0);
    white-space:nowrap;
    border:0;
  }

  /* Download button */
  .bar { display:flex; gap:12px; justify-content:center; margin:18px 0 6px; }
  .btn {
    appearance:none; border:none; border-radius:12px; padding:10px 16px;
    background:#0f1d22; color:var(--ink); font-weight:700; cursor:pointer;
    font-family: var(--font-display);
    box-shadow:0 0 0 1px rgba(0,231,255,.25), 0 6px 20px rgba(0,231,255,.12) inset;
  }
  .btn:hover{ box-shadow:0 0 0 1px rgba(0,231,255,.5), 0 0 18px rgba(0,231,255,.18) inset; }

  /* make sure the whole sheet breathes to edges on small screens */
  @media (max-width:880px){
    .title{ font-size:44px; }
    .section{ font-size:34px; }
    .compat thead th, .compat tbody td{ font-size:18px; }
    .compat col.label{ width:51%; }
    .compat col.match{ width:17%; }
  }
</style>
</head>
<body>
  <div class="page" id="app">
    <h1 class="title">TalkKink Compatibility Survey</h1>
    <p class="subtitle" id="ts">Generated: â€”</p>
    <div class="hr"></div>
    <h2 class="section">Behavioral Play</h2>

    <div class="bar"><button id="downloadBtn" class="btn">Download PDF</button></div>

    <table class="compat" id="compatTable" aria-label="Compatibility table">
      <colgroup>
        <col class="label"><!-- Kinks -->
        <col class="a">    <!-- Partner A -->
        <col class="match"><!-- Match -->
        <col class="b">    <!-- Partner B -->
      </colgroup>
      <thead>
        <tr>
          <th>Kinks</th>
          <th>Partner A</th>
          <th>Match</th>
          <th>Partner B</th>
        </tr>
      </thead>
      <tbody id="compatBody"><!-- rows injected --></tbody>
    </table>
  </div>

<script>
const TK_COMPAT_DEFAULT_TITLE = 'TalkKink Compatibility Survey';

function tkCompatSafeString(value) {
  if (value == null) return '';
  if (typeof value === 'string') return value.trim();
  if (typeof value === 'number' && Number.isFinite(value)) return String(value);
  if (value instanceof Date && !Number.isNaN(value.getTime())) return value.toISOString();
  try {
    return String(value).trim();
  } catch (err) {
    console.warn('[tk-compat-meta] Unable to stringify value', err);
    return '';
  }
}

function tkCompatFormatStamp(stamp) {
  const date = new Date(stamp);
  return `Generated: ${date.toLocaleString(undefined, {
    year: 'numeric', month: '2-digit', day: '2-digit',
    hour: '2-digit', minute: '2-digit', second: '2-digit',
  })}`;
}

function tkCompatExtractMeta(data) {
  if (!data || typeof data !== 'object') return null;

  const sources = [];
  if (data.meta && typeof data.meta === 'object') sources.push(data.meta);
  if (
    data.compat &&
    typeof data.compat === 'object' &&
    data.compat.meta &&
    typeof data.compat.meta === 'object'
  ) {
    sources.push(data.compat.meta);
  }
  sources.push(data);

  for (const source of sources) {
    if (!source || typeof source !== 'object') continue;

    const title = tkCompatSafeString(
      source.title ||
      source.surveyTitle ||
      data?.meta?.surveyTitle ||
      data?.title ||
      data?.surveyTitle ||
      ''
    );

    const stamp =
      source.exportedAt ||
      source.generatedAt ||
      source.timestamp ||
      source.stamp ||
      source.exported_at ||
      source.generated_at ||
      null;

    if (title || stamp) return { title, stamp };
  }

  return null;
}

function tkResolveCompatMeta() {
  const keys = ['tk_compat.self', 'tk_compat.partner', 'talkkinkMine', 'talkkinkSurvey'];
  const fallbackStamp = new Date().toISOString();
  const fallback = {
    title: TK_COMPAT_DEFAULT_TITLE,
    stamp: fallbackStamp,
    formattedStamp: tkCompatFormatStamp(fallbackStamp),
  };

  if (typeof localStorage === 'undefined') {
    return fallback;
  }

  for (const key of keys) {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) continue;
      const data = JSON.parse(raw);
      const resolved = tkCompatExtractMeta(data);
      if (resolved) {
        const stamp = resolved.stamp || fallbackStamp;
        const title = resolved.title || TK_COMPAT_DEFAULT_TITLE;
        return {
          title,
          stamp,
          formattedStamp: tkCompatFormatStamp(stamp),
        };
      }
    } catch (e) {
      console.warn('Could not parse localStorage key:', key, e);
    }
  }

  return fallback;
}

let TK_COMPAT_META = tkResolveCompatMeta();
if (typeof window !== 'undefined') {
  window.TK_COMPAT_META = TK_COMPAT_META;
}

function tkCompatPdfLabels(meta = TK_COMPAT_META) {
  const title = (meta && meta.title) || TK_COMPAT_DEFAULT_TITLE;
  const subtitle = title === TK_COMPAT_DEFAULT_TITLE
    ? 'Compatibility Report'
    : TK_COMPAT_DEFAULT_TITLE;

  return { title, subtitle };
}

function tkCompatBuildFileName(meta = TK_COMPAT_META) {
  const base = tkCompatSafeString(meta?.title) || 'TalkKink Compatibility';
  const safe = base
    .replace(/[^a-z0-9]+/gi, '_')
    .replace(/_+/g, '_')
    .replace(/^_+|_+$/g, '');
  return (safe || 'TalkKink_Compatibility') + '.pdf';
}

function tkApplyCompatMeta(meta = TK_COMPAT_META) {
  if (!meta) return;
  if (meta.title) {
    document.title = meta.title;
    const heading = document.querySelector('.title');
    if (heading) heading.textContent = meta.title;
  }
  const subtitle = document.querySelector('.subtitle');
  if (subtitle) {
    subtitle.textContent = meta.formattedStamp || tkCompatFormatStamp(meta.stamp);
  }
}

function tkInitCompatMeta() {
  TK_COMPAT_META = tkResolveCompatMeta();
  if (typeof window !== 'undefined') {
    window.TK_COMPAT_META = TK_COMPAT_META;
  }
  tkApplyCompatMeta(TK_COMPAT_META);
}

if (document.readyState === 'loading') {
  window.addEventListener('DOMContentLoaded', tkInitCompatMeta, { once: true });
} else {
  tkInitCompatMeta();
}

const FLAG_META = {
  green:  { emoji: "ðŸŸ©", label: "High match", color: "#18d69a" },
  yellow: { emoji: "ðŸŸ¨", label: "Needs discussion", color: "#ffcc00" },
  red:    { emoji: "ðŸŸ¥", label: "Conflict", color: "#ff4242" }
};

const FLAG_EMOJI_TO_STATUS = Object.fromEntries(
  Object.entries(FLAG_META).map(([status, meta]) => [meta.emoji, status])
);

Object.assign(FLAG_EMOJI_TO_STATUS, {
  "ðŸŸ¢": "green",
  "ðŸŸ¡": "yellow",
  "ðŸ”´": "red",
  "ðŸŸ ": "yellow"
});

function tkFlagFromScores(matchPct, aScore, bScore) {
  if (
    matchPct == null ||
    aScore == null ||
    bScore == null
  ) return "";

  const diff = Math.abs(aScore - bScore);

  if (
    matchPct <= 30 ||
    (aScore <= 1 && bScore >= 4) ||
    (bScore <= 1 && aScore >= 4)
  ) {
    return FLAG_META.red.emoji;
  }

  if (
    diff >= 3 ||
    (aScore === 5 && bScore <= 3) ||
    (bScore === 5 && aScore <= 3)
  ) {
    return FLAG_META.yellow.emoji;
  }

  if (matchPct >= 80) {
    return FLAG_META.green.emoji;
  }

  return "";
}

function tkNormalizeFlagStatus(value) {
  if (value == null) return null;
  if (typeof value === "number") {
    if (value >= 80) return "green";
    if (value >= 50) return "yellow";
    return "red";
  }

  const str = String(value).trim();
  if (!str) return null;

  if (FLAG_EMOJI_TO_STATUS[str]) return FLAG_EMOJI_TO_STATUS[str];

  const lower = str.toLowerCase();
  if (FLAG_META[lower]) return lower;
  if (/perfect|great|strong|aligned|excellent/.test(lower)) return "green";
  if (/warn|caution|mixed|medium|maybe/.test(lower)) return "yellow";
  if (/conflict|bad|low|danger|problem|issue|concern|poor/.test(lower)) return "red";

  return null;
}

function tkParseFlagColor(color) {
  if (!color) return null;
  if (Array.isArray(color)) {
    const [r, g, b] = color.map((n) => Math.max(0, Math.min(255, Number(n) || 0)));
    return `#${[r, g, b].map((n) => n.toString(16).padStart(2, "0")).join("")}`;
  }

  const str = String(color).trim();
  if (!str) return null;

  const hexMatch = str.match(/^#?([0-9a-f]{6})$/i);
  if (hexMatch) return `#${hexMatch[1].toLowerCase()}`;

  const rgbMatch = str.match(/rgb\s*\((\d+)[,\s]+(\d+)[,\s]+(\d+)/i);
  if (rgbMatch) {
    return `#${[rgbMatch[1], rgbMatch[2], rgbMatch[3]]
      .map((part) => Math.max(0, Math.min(255, Number(part) || 0)).toString(16).padStart(2, "0"))
      .join("")}`;
  }

  return null;
}

function tkGuessStatusFromColor(hex) {
  if (!hex) return null;
  const value = hex.replace("#", "");
  if (value.length !== 6) return null;

  const r = parseInt(value.slice(0, 2), 16);
  const g = parseInt(value.slice(2, 4), 16);
  const b = parseInt(value.slice(4, 6), 16);

  if (r > 210 && g < 140) return "red";
  if (r > 210 && g > 170 && b < 140) return "yellow";
  if (g > 170 && b > 110 && r < 150) return "green";

  return null;
}

function tkResolveFlagInfo(row = {}) {
  if (row.hasData === false) {
    return { emoji: "", status: null, color: null, matchPct: null, aScore: null, bScore: null };
  }

  const matchPct = Number.isFinite(row.matchPct)
    ? row.matchPct
    : tkParseMatchPercent(row.matchRaw);

  const aScore = Number.isFinite(row.aScore)
    ? row.aScore
    : tkParseScore(row.aDisplay ?? row.a ?? row.partnerA);

  const bScore = Number.isFinite(row.bScore)
    ? row.bScore
    : tkParseScore(row.bDisplay ?? row.b ?? row.partnerB);

  const rawFlag = row.flagEmoji ?? row.flagGlyph ?? row.flagRaw ?? row.flag ?? row.flagText ?? null;
  let status =
    tkNormalizeFlagStatus(row.flagStatus) ||
    tkNormalizeFlagStatus(rawFlag) ||
    tkNormalizeFlagStatus(row.flagLabel) ||
    null;

  let color =
    tkParseFlagColor(row.flagColor) ||
    tkParseFlagColor(row.flagColour) ||
    tkParseFlagColor(row.flagRGB) ||
    tkParseFlagColor(row.flagRgb) ||
    tkParseFlagColor(row.flagHex) ||
    null;

  if (!status && color) {
    status = tkGuessStatusFromColor(color);
  }

  let emoji = typeof rawFlag === "string" ? rawFlag.trim() : "";

  if (!status || !emoji || !FLAG_EMOJI_TO_STATUS[emoji]) {
    const computedEmoji = tkFlagFromScores(matchPct, aScore, bScore);
    if (computedEmoji) {
      if (!emoji) emoji = computedEmoji;
      if (!status) status = tkNormalizeFlagStatus(computedEmoji);
    }
  }

  if (status && (!emoji || !FLAG_EMOJI_TO_STATUS[emoji])) {
    emoji = FLAG_META[status]?.emoji || emoji;
  }

  if (status && !color) {
    color = FLAG_META[status]?.color || null;
  }

  return { emoji: emoji || "", status: status || null, color, matchPct, aScore, bScore };
}

function tkGetFlagSquare(row) {
  return tkResolveFlagInfo(row).emoji;
}

function tkCoerceNumber(value) {
  if (value === null || value === undefined) return null;
  if (typeof value === "number" && Number.isFinite(value)) return value;
  const trimmed = String(value).trim();
  if (!trimmed) return null;
  const direct = Number(trimmed);
  if (Number.isFinite(direct)) return direct;
  const numeric = Number(trimmed.replace(/[^0-9.+-]/g, ""));
  return Number.isFinite(numeric) ? numeric : null;
}

function tkParseScore(value) {
  const num = tkCoerceNumber(value);
  if (num == null) return null;
  if (!Number.isFinite(num)) return null;
  return Math.max(0, Math.min(5, num));
}

function tkParseMatchPercent(value) {
  const num = tkCoerceNumber(value);
  if (num == null) return null;
  if (!Number.isFinite(num)) return null;
  return Math.max(0, Math.min(100, num));
}

function tkFormatPercent(value) {
  if (!Number.isFinite(value)) return "";
  const clamped = Math.max(0, Math.min(100, value));
  const rounded = Number.isInteger(clamped) ? clamped : Number(clamped.toFixed(1));
  return `${rounded}%`;
}

function tkFormatScoreDisplay(value) {
  if (value === null || value === undefined) return "";
  const str = String(value).trim();
  return str;
}

function tkNormalizePercentText(value) {
  if (value == null) return "";
  let str = String(value).trim();
  if (!str) return "";
  if (str.includes("&")) {
    str = str.replace(/&(?=[0-9#%])/g, "");
  }
  return str.replace(/\s+/g, " ");
}

function tkFormatMatchDisplay(raw, parsed) {
  if (raw !== undefined && raw !== null) {
    const normalized = tkNormalizePercentText(raw);
    if (normalized) {
      const numeric = tkCoerceNumber(normalized);
      if (Number.isFinite(numeric)) return tkFormatPercent(numeric);
      if (/%/.test(normalized)) return normalized;
      if (Number.isFinite(parsed)) return tkFormatPercent(parsed);
      return normalized;
    }
  }
  if (Number.isFinite(parsed)) return tkFormatPercent(parsed);
  return "";
}

function tkDeriveMatchPercent(matchRaw, aScore, bScore) {
  const parsed = tkParseMatchPercent(matchRaw);
  if (Number.isFinite(parsed)) return parsed;
  if (Number.isFinite(aScore) && Number.isFinite(bScore)) {
    const diff = Math.min(5, Math.abs(aScore - bScore));
    return Math.max(0, Math.min(100, Math.round(100 - diff * 20)));
  }
  return null;
}

function tkNormalizeCompatRow(entry) {
  if (!entry) return null;

  let label;
  let labelShort;
  let aRaw;
  let bRaw;
  let matchRaw;
  let hasData;
  let flagRaw;
  let flagStatus;
  let flagColor;
  let flagHex;

  if (Array.isArray(entry)) {
    [label, aRaw, matchRaw, , bRaw] = entry;
  } else if (typeof entry === "object") {
    label = entry.label ?? entry.item ?? entry.title ?? "";
    labelShort = entry.labelShort ?? entry.shortLabel ?? entry.short ?? null;
    aRaw = entry.aScore ?? entry.a ?? entry.partnerA ?? entry.aValue ?? entry.a_score;
    bRaw = entry.bScore ?? entry.b ?? entry.partnerB ?? entry.bValue ?? entry.b_score;
    matchRaw = entry.matchPct ?? entry.match ?? entry.matchValue ?? entry.matchPercent ?? entry.matchPercentage ?? entry.matchScore;
    hasData = typeof entry.hasData === "boolean" ? entry.hasData : undefined;
    flagRaw = entry.flag ?? entry.flagGlyph ?? entry.flagEmoji ?? entry.flagText ?? entry.flagDisplay ?? null;
    flagStatus = entry.flagStatus ?? entry.flagLabel ?? entry.flagName ?? null;
    flagColor = entry.flagColor ?? entry.flagColour ?? entry.flagRGB ?? entry.flagRgb ?? null;
    flagHex = entry.flagHex ?? entry.flagColourHex ?? null;
  } else {
    return null;
  }

  const aScore = tkParseScore(aRaw);
  const bScore = tkParseScore(bRaw);
  const matchPct = tkDeriveMatchPercent(matchRaw, aScore, bScore);

  if (typeof hasData !== "boolean") {
    hasData = Number.isFinite(aScore) || Number.isFinite(bScore);
  }

  return {
    label: label ?? "",
    labelShort: labelShort || null,
    aScore,
    bScore,
    matchPct,
    matchRaw,
    aDisplay: tkFormatScoreDisplay(aRaw ?? aScore),
    bDisplay: tkFormatScoreDisplay(bRaw ?? bScore),
    matchDisplay: tkFormatMatchDisplay(matchRaw, matchPct),
    hasData,
    flagRaw,
    flagStatus,
    flagColor,
    flagHex,
  };
}

function tkBuildCompatRow(row) {
  const normalized = tkNormalizeCompatRow(row);
  if (!normalized) {
    return ["", "", "0%", ""];
  }

  const matchPct = Number.isFinite(normalized.matchPct)
    ? normalized.matchPct
    : tkParseMatchPercent(normalized.matchRaw);

  const aScore = Number.isFinite(normalized.aScore)
    ? normalized.aScore
    : tkParseScore(normalized.aDisplay);

  const bScore = Number.isFinite(normalized.bScore)
    ? normalized.bScore
    : tkParseScore(normalized.bDisplay);

  const label = normalized.labelShort || normalized.label || "";
  const matchText = normalized.matchDisplay ||
    (Number.isFinite(matchPct) ? tkFormatPercent(matchPct) : "0%");

  const toCell = (value) => (
    value === undefined || value === null ? "" : String(value)
  );

  const partnerA = normalized.aDisplay ?? (Number.isFinite(normalized.aScore) ? normalized.aScore : "");
  const partnerB = normalized.bDisplay ?? (Number.isFinite(normalized.bScore) ? normalized.bScore : "");

  return [
    toCell(label),
    toCell(partnerA),
    toCell(matchText || (Number.isFinite(matchPct) ? tkFormatPercent(matchPct) : "0%")),
    toCell(partnerB)
  ];
}

const TK_PDF_TITLE = "Talk Kink Compatibility Survey";

if (typeof window !== 'undefined') {
  window.tkFlagFromScores = tkFlagFromScores;
  window.tkGetFlagSquare = tkGetFlagSquare;
  window.tkResolveFlagInfo = tkResolveFlagInfo;
  window.tkBuildCompatRow = tkBuildCompatRow;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   One-time bootstrap (prevents â€œdouble loadingâ€)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
(() => {
  if (window.__TK_ONE_TIME_INIT__) return;  // hard lock
  window.__TK_ONE_TIME_INIT__ = true;

  /* Demo source (will be replaced if live globals/localStorage exist) */
  const TK_COMPAT_CACHE_VERSION = 'v3'; // bump when schema or fallback changes
  const LS_VERSION_KEY = 'talkkink:compatRows:ver';

  const noCache = /(^|[?&])nocache(=1|&|$)/.test(location.search);
  const storedVer = localStorage.getItem(LS_VERSION_KEY);

  if (noCache || storedVer !== TK_COMPAT_CACHE_VERSION){
    delete window.talkkinkCompatRows;
    ['talkkink:compatRows','talkkink:survey','talkkink:mine','talkkink:partner']
      .forEach(k => localStorage.removeItem(k));
    Object.keys(localStorage).forEach(k => {
      if (/^tk_compat\./.test(k)) localStorage.removeItem(k);
    });
    localStorage.setItem(LS_VERSION_KEY, TK_COMPAT_CACHE_VERSION);
  }

  const HARD_CODED_COMPAT_ROWS = [
    ['Giving: Assigning corner time or time-outs', 0, 100, '', 0],
    ['General: Attitude toward funishment vs serious correction', 3, 100, '', 3],
    ['Receiving: Being placed in the corner or given a time-out', 5, 100, '', 5],
    ['Receiving: Getting scolded or lectured for correction', 5, 100, '', 5],
    ['Receiving: Having privileges revoked (phone, TV)', 3, 100, '', 3],
    ['Giving: Lecturing or scolding to modify behavior', 4, 100, '', 4],
    ['Giving: Playful punishments that still reinforce rules', 3, 100, '', 3],
    ['General: Preferred style of discipline (strict vs lenient)', 4, 100, '', 4],
    ['Receiving: Playful \"f\" punishments for minor rule-breaking', 2, 100, '', 2],
    ['Giving: Removing privileges (phone, TV, sweets)', 2, 100, '', 2],
    ['General: Use of behavior contracts or rule agreements', 2, 100, '', 2],
    ['Giving: Writing lines or apology letters as correction', 1, 100, '', 1],
    ['Receiving: Writing lines or apology letters when misbehaving', 4, 100, '', 4],
  ];

  /* Source resolution: use live globals if present, else localStorage, else fallback */
  function pickRows(){
    if (Array.isArray(window.talkkinkCompatRows) && window.talkkinkCompatRows.length){
      return window.talkkinkCompatRows;
    }
    try{
      const cached = JSON.parse(localStorage.getItem('talkkink:compatRows') || 'null');
      if (Array.isArray(cached) && cached.length) return cached;
    }catch{}
    return HARD_CODED_COMPAT_ROWS;
  }

  /* Render into DOM (single-run; we clear body first to avoid doubles) */
  const TBODY = document.getElementById('compatBody');
  function renderTable(rows){
    TBODY.replaceChildren();
    const toText = (value) => (value === undefined || value === null ? '' : String(value));

    for (const row of rows){
      if (!row) continue;
      const tr = document.createElement('tr');
      const matchText = row.matchDisplay || tkFormatMatchDisplay(row.matchRaw, row.matchPct);
      const matchValue = tkParseMatchPercent(row.matchPct ?? matchText);
      const cells = [
        ['label', row.label],
        ['num',   row.aDisplay ?? (Number.isFinite(row.aScore) ? String(row.aScore) : '')],
        ['match', matchText],
        ['num',   row.bDisplay ?? (Number.isFinite(row.bScore) ? String(row.bScore) : '')],
      ];

      for (const [cls, value] of cells){
        const td = document.createElement('td');
        td.className = cls;
        td.textContent = toText(value);
        if (cls === 'match' && matchValue === 100) {
          const star = document.createElement('span');
          star.className = 'match-star';
          star.textContent = 'â˜…';
          td.appendChild(star);
        }
        tr.appendChild(td);
      }

      TBODY.appendChild(tr);
    }
  }

  function shareRowsWithPdf(rows){
    const notify = () => {
      if (window.TKCompatPDF && typeof window.TKCompatPDF.notifyRowsUpdated === 'function') {
        window.TKCompatPDF.notifyRowsUpdated(rows);
        return true;
      }
      return false;
    };

    if (notify()) return;
    let tries = 0;
    const id = setInterval(() => {
      tries += 1;
      if (notify() || tries >= 12) {
        clearInterval(id);
      }
    }, 250);
  }

  const compatRows = pickRows().map(tkNormalizeCompatRow).filter(Boolean);
  window.__tkCompatNormalizedRows = compatRows;

  try {
    window.talkkinkCompatRows = compatRows;
    localStorage.setItem('talkkink:compatRows', JSON.stringify(compatRows));
  } catch (err) {
    console.warn('[TK-compat] Unable to persist compatibility rows', err);
  }

  shareRowsWithPdf(compatRows);
  renderTable(compatRows);
})();

let tkJsPdfLoadPromise = null;

function tkIsJsPdfReady() {
  return !!(window.jspdf && window.jspdf.jsPDF && window.jspdf.jsPDF.API && window.jspdf.jsPDF.API.autoTable);
}

async function tkEnsureJsPDF() {
  if (tkIsJsPdfReady()) return;
  if (tkJsPdfLoadPromise) {
    await tkJsPdfLoadPromise;
    return;
  }

  const localScripts = [
    '/vendor/jspdf.umd.min.js',
    '/js/vendor/jspdf.umd.min.js',
    '/assets/js/vendor/jspdf.umd.min.js',
    '/vendor/jspdf.plugin.autotable.min.js',
    '/js/vendor/jspdf.plugin.autotable.min.js',
    '/assets/js/vendor/jspdf.plugin.autotable.min.js'
  ];
  const cdnScripts = [
    'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js',
    'https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js'
  ];

  const inject = (src) => new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = src;
    script.async = true;
    script.onload = resolve;
    script.onerror = (err) => reject(err || new Error('Failed to load ' + src));
    document.head.appendChild(script);
  });

  tkJsPdfLoadPromise = (async () => {
    for (const src of localScripts) {
      try {
        await inject(src);
      } catch (err) {
        console.warn('[TK] Failed to load local jsPDF asset:', src, err);
      }
    }

    if (!tkIsJsPdfReady()) {
      for (const src of cdnScripts) {
        try {
          await inject(src);
        } catch (err) {
          console.warn('[TK] Failed to load CDN jsPDF asset:', src, err);
        }
        if (tkIsJsPdfReady()) break;
      }
    }

    if (!tkIsJsPdfReady()) {
      throw new Error('jsPDF/AutoTable not available. Host local copies in /vendor or allow the CDN.');
    }
  })();

  try {
    await tkJsPdfLoadPromise;
  } catch (err) {
    tkJsPdfLoadPromise = null;
    throw err;
  }
}

function tkCollectCompatRowsForPdf() {
  let source = [];
  if (Array.isArray(window.talkkinkCompatRows) && window.talkkinkCompatRows.length) {
    source = window.talkkinkCompatRows;
  } else if (Array.isArray(window.__tkCompatNormalizedRows)) {
    source = window.__tkCompatNormalizedRows;
  }
  return source.map(tkNormalizeCompatRow).filter(Boolean);
}

function tkSplitCompatLabel(label) {
  if (!label) {
    return { category: 'Compatibility', text: '' };
  }

  const match = String(label).split(':');
  if (match.length < 2) {
    return { category: 'Compatibility', text: String(label).trim() };
  }

  const category = match.shift().trim() || 'Compatibility';
  const text = match.join(':').trim() || String(label).trim();
  return { category, text };
}

function tkFormatPdfScore(displayValue, scoreValue) {
  if (displayValue != null && displayValue !== '') {
    return String(displayValue);
  }
  if (Number.isFinite(scoreValue)) {
    return String(scoreValue);
  }
  return '';
}

function tkFormatPdfMatch(row) {
  if (Number.isFinite(row.matchPct)) {
    return `${Math.max(0, Math.min(100, Math.round(row.matchPct)))}%`;
  }

  const raw = row.matchDisplay ?? row.matchRaw ?? row.matchPct ?? row.match;
  if (raw == null) return 'â€”';

  if (typeof raw === 'number' && Number.isFinite(raw)) {
    return `${Math.max(0, Math.min(100, Math.round(raw)))}%`;
  }

  const text = String(raw).trim();
  if (!text) return 'â€”';

  const numeric = text.replace(/[^0-9]+/g, '');
  if (numeric) {
    const pct = Math.max(0, Math.min(100, Number.parseInt(numeric, 10)));
    return `${pct}%`;
  }

  return text;
}

function tkBuildPdfCategories(rows) {
  const grouped = new Map();

  rows.forEach((row) => {
    if (!row) return;

    const { category, text } = tkSplitCompatLabel(row.labelShort || row.label || '');
    if (!grouped.has(category)) {
      grouped.set(category, { category, items: [] });
    }

    grouped.get(category).items.push({
      label: text || row.label || 'â€”',
      partnerA: tkFormatPdfScore(row.aDisplay, row.aScore),
      partnerB: tkFormatPdfScore(row.bDisplay, row.bScore),
      match: tkFormatPdfMatch(row),
      scoreA: Number.isFinite(row.aScore) ? row.aScore : null,
      scoreB: Number.isFinite(row.bScore) ? row.bScore : null,
      matchPct: Number.isFinite(row.matchPct) ? row.matchPct : null,
    });
  });

  return Array.from(grouped.values());
}

async function tkGeneratePdfFromCategories(categories) {
  if (!categories.length) {
    throw new Error('No compatibility rows available');
  }

  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4' });
  const neonBlue = '#00FFFF';
  const bgColor = '#111111';
  const textColor = '#FFFFFF';
  const pageSize = () => ({
    width: doc.internal.pageSize.getWidth(),
    height: doc.internal.pageSize.getHeight(),
  });

  const paintBackground = () => {
    const { width, height } = pageSize();
    doc.setFillColor(bgColor);
    doc.rect(0, 0, width, height, 'F');
  };

  const originalAddPage = doc.addPage.bind(doc);
  doc.addPage = function addPageWithBg() {
    const result = originalAddPage();
    paintBackground();
    return result;
  };

  paintBackground();

  const flattenedRows = [];
  categories.forEach((category) => {
    if (!category || !Array.isArray(category.items)) return;
    const prefix = category.category || category.name || '';
    category.items.forEach((row) => {
      const baseLabel = row.label || 'â€”';
      flattenedRows.push({
        label: prefix ? `${prefix} â€” ${baseLabel}` : baseLabel,
        a: row.partnerA ?? '',
        b: row.partnerB ?? '',
        scoreA: Number.isFinite(row.scoreA) ? row.scoreA : null,
        scoreB: Number.isFinite(row.scoreB) ? row.scoreB : null,
        matchText: row.match ?? '',
        matchPct: Number.isFinite(row.matchPct) ? row.matchPct : null,
      });
    });
  });

  if (!flattenedRows.length) {
    throw new Error('No compatibility rows available');
  }

  const clampPercent = (value) => {
    if (!Number.isFinite(value)) return null;
    return Math.max(0, Math.min(100, Math.round(value)));
  };

  const deriveMatchPercent = (row) => {
    if (Number.isFinite(row.scoreA) && Number.isFinite(row.scoreB)) {
      return clampPercent(100 - Math.abs(row.scoreA - row.scoreB) * 20);
    }
    if (Number.isFinite(row.matchPct)) {
      return clampPercent(row.matchPct);
    }
    return clampPercent(tkParseMatchPercent(row.matchText));
  };

  const pdfRows = flattenedRows.map((row) => {
    const matchPercent = deriveMatchPercent(row);
    return [
      row.label,
      row.a || 'â€”',
      matchPercent != null ? `${matchPercent}%` : (row.matchText || 'â€”'),
      row.b || 'â€”',
    ];
  });

  const drawHeader = () => {
    const { width } = pageSize();
    const meta = TK_COMPAT_META || tkResolveCompatMeta();
    const { title: pdfTitle, subtitle: pdfSubtitle } = tkCompatPdfLabels(meta);
    doc.setTextColor(neonBlue);
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(26);
    doc.text(pdfTitle, width / 2, 60, { align: 'center' });

    doc.setFontSize(10);
    doc.text(meta.formattedStamp || tkCompatFormatStamp(meta.stamp), width / 2, 78, { align: 'center' });

    doc.setFontSize(22);
    doc.text(pdfSubtitle, width / 2, 110, { align: 'center' });
  };

  doc.autoTable({
    startY: 130,
    head: [['Kinks', 'Partner A', 'Match', 'Partner B']],
    body: pdfRows,
    styles: {
      fontSize: 10,
      cellPadding: 6,
      textColor,
      fillColor: '#1a1a1a',
      lineColor: neonBlue,
      lineWidth: 0.3,
      fontStyle: 'normal',
      halign: 'left',
    },
    headStyles: {
      fillColor: '#000000',
      textColor: neonBlue,
      fontStyle: 'bold',
      halign: 'left',
    },
    alternateRowStyles: {
      fillColor: '#191919',
    },
    columnStyles: {
      0: { cellWidth: 240 },
      1: { cellWidth: 80, halign: 'center' },
      2: { cellWidth: 80, halign: 'center' },
      3: { cellWidth: 80, halign: 'center' },
    },
    margin: { top: 130, left: 40, right: 40 },
    didDrawPage: () => {
      drawHeader();
    },
  });

  doc.save(tkCompatBuildFileName());
}

async function TKPDF_exportCompatibilitySingle() {
  try {
    await tkEnsureJsPDF();
  } catch (err) {
    console.error('jsPDF not loaded â€“ make sure jsPDF UMD is included before this file.', err);
    alert('PDF library not loaded; cannot export.');
    return;
  }

  if (!(window.jspdf && window.jspdf.jsPDF)) {
    console.error('jsPDF not loaded â€“ make sure jsPDF UMD is included before this file.');
    alert('PDF library not loaded; cannot export.');
    return;
  }
  if (!window.jspdf.jsPDF.API.autoTable) {
    console.error('autoTable plugin not loaded.');
    alert('autoTable plugin not loaded; cannot export.');
    return;
  }

  try {
    const compatRows = tkCollectCompatRowsForPdf();
    const categories = tkBuildPdfCategories(compatRows);
    await tkGeneratePdfFromCategories(categories);
  } catch (err) {
    console.error('[TKPDF] Failed to export compatibility report.', err);
    alert('PDF export failed. See console for details.');
  }
}

function tkBindCompatibilityDownload() {
  const btn = document.getElementById('downloadBtn') || document.getElementById('downloadPdfBtn');
  if (!btn) {
    console.warn('[TK] downloadBtn not found for compatibility export.');
    return;
  }

  btn.onclick = null;

  const parent = btn.parentNode;
  if (!parent) {
    console.warn('[TK] download button has no parent node; cannot rebind.');
    return;
  }

  const clone = btn.cloneNode(true);
  parent.replaceChild(clone, btn);

  clone.addEventListener('click', function (e) {
    e.preventDefault();
    e.stopPropagation();
    TKPDF_exportCompatibilitySingle();
  });

  console.log('[TK] Bound single compatibility PDF exporter to #downloadBtn');
}

if (typeof window !== 'undefined') {
  window.TKPDF_exportCompatibilitySingle = TKPDF_exportCompatibilitySingle;
  window.TKPDF_export = TKPDF_exportCompatibilitySingle;
  window.tkBindCompatibilityDownload = tkBindCompatibilityDownload;
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', tkBindCompatibilityDownload, { once: true });
} else {
  tkBindCompatibilityDownload();
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Defensive renderer hot-fix
   - prevents duplicate renders/tables
   - cleans up stray thead copies
   - normalises flag glyphs & column sizing
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
(() => {
  const HOTFIX_LOCK = '__TK_COMPAT_RENDER_LOCK__';
  if (window[HOTFIX_LOCK]) return;
  window[HOTFIX_LOCK] = true;

  const table = document.getElementById('compatTable');
  if (!table) return;

  const parser = new DOMParser();

  function decodeEntities(value){
    if (!value || !value.includes('&')) return value;
    let current = value;
    let previous;
    do {
      previous = current;
      current = parser.parseFromString(previous, 'text/html').documentElement
        .textContent;
    } while (current !== previous && current.includes('&'));
    return current.replace(/&+â€ /g, 'â€ ');
  }

  function purgeDuplicateTables(){
    const allTables = Array.from(document.querySelectorAll('table.compat'));
    const keep = allTables.find(t => t.id === 'compatTable') || allTables[0];
    allTables.forEach(t => {
      if (t !== keep) t.remove();
    });
    return keep;
  }

  function ensureSingleThead(tbl){
    const theads = Array.from(tbl.querySelectorAll('thead'));
    theads.slice(1).forEach(t => t.remove());
    const head = theads[0];
    if (!head) return;
    if (!head.querySelector('tr')) head.remove();
  }

  function retuneLayout(tbl){
    tbl.style.width = '100%';
    tbl.style.tableLayout = 'fixed';

    const headCells = tbl.querySelectorAll('thead th');
    headCells.forEach((th, idx) => {
      th.style.textAlign = idx === 0 ? 'left' : 'center';
      th.style.borderBottom = '1px solid var(--grid)';
      th.style.textShadow = '0 0 0 var(--bg), 0 0 12px rgba(0,231,255,.22)';
    });
  }

  function normaliseCells(tbl){
    const rows = tbl.querySelectorAll('tbody tr');
    rows.forEach(row => {
      const cells = row.querySelectorAll('td');
      if (!cells.length) return;

      const decodedCells = Array.from(cells, cell => decodeEntities(cell.textContent.trim()));
      const aScore = tkParseScore(decodedCells[1]);
      const bScore = tkParseScore(decodedCells[3]);
      const matchPct = tkParseMatchPercent(decodedCells[2]);

      cells.forEach((cell, idx) => {
        const decoded = decodedCells[idx] ?? '';
        cell.textContent = decoded;
        cell.style.background = '';
      });
    });
  }

  const activeTable = purgeDuplicateTables() || table;
  if (!activeTable) return;

  ensureSingleThead(activeTable);
  retuneLayout(activeTable);
  normaliseCells(activeTable);
})();

/* --------------------------------------------------------------
 * TalkKink compatibility overrides
 * - Remove the Flag column from the on-page comparison table.
 * - Stop the legacy PDF from firing so only the â€œwebâ€ PDF runs.
 *   (We re-wire the Download button to call TKCompatPDF only.)
 * -------------------------------------------------------------- */

(function () {
  /* Remove the "Flag" column from the DOM table
     (affects BOTH the on-page view and any PDF that clones the table). */
  function removeFlagColumn() {
    // Adjust selector if your comparison table has a specific id
    const table =
      document.querySelector('#compatTable') ||
      document.querySelector('#comparisonTable') ||
      document.querySelector('table');

    if (!table) {
      console.warn('[TK-compat] No compatibility table found to strip Flag column.');
      return;
    }

    const headRow = table.querySelector('thead tr');
    if (!headRow) return;

    const headCells = Array.from(headRow.cells);
    const flagIndex = headCells.findIndex(th =>
      th.textContent.trim().toLowerCase() === 'flag'
    );
    if (flagIndex === -1) {
      // Already removed, nothing to do
      return;
    }

    // Delete the "Flag" cell from every row (header + body + footer)
    Array.from(table.rows).forEach(row => {
      if (row.cells[flagIndex]) {
        row.deleteCell(flagIndex);
      }
    });

    console.info('[TK-compat] Removed Flag column from compatibility table.');
  }

  /* Re-wire the Download button so ONLY the new TKCompatPDF exporter runs.
     This prevents the old legacy generator from opening a second PDF. */
  function rewireDownloadButton() {
    const btn = document.querySelector(
      '#downloadPdfBtn, #downloadBtn, [data-download-pdf]'
    );
    if (!btn) {
      console.warn('[TK-compat] No Download PDF button found to rewire.');
      return;
    }

    // Clone the button to strip inline onclick + legacy listeners
    const clone = btn.cloneNode(true);
    clone.removeAttribute('onclick');

    clone.addEventListener('click', function (e) {
      e.preventDefault();

      if (
        window.TKCompatPDF &&
        typeof window.TKCompatPDF.download === 'function'
      ) {
        window.TKCompatPDF.download();
        return;
      }

      console.warn(
        '[TK-compat] TKCompatPDF not available; Download button is now a no-op.'
      );
    });

    btn.parentNode.replaceChild(clone, btn);
    console.info('[TK-compat] Download button re-wired to TKCompatPDF only.');
  }

  /* Hard-disable any legacy global generator just in case something still calls it. */
  window.generateDarkPDF = function () {
    console.info('[TK-compat] Legacy generateDarkPDF is disabled on this page.');
    // No-op: old PDF should not run any more.
  };

  // Run once when the DOM is ready
  function init() {
    removeFlagColumn();
    rewireDownloadButton();
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init, { once: true });
  } else {
    init();
  }
})();
</script>
</body>
</html>
