<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>TalkKink Compatibility</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Your existing CSS / theme links stay as-is -->
  <style>
    /* keep your site styles; the following are only fallbacks */
    body { background:#000; color:#fff; font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .cta { display:block; width:420px; margin:18px auto; padding:18px 22px; text-align:center;
           border:2px solid rgba(0,255,255,.5); border-radius:14px; background:rgba(0,20,25,.35);
           box-shadow:0 0 18px rgba(0,200,255,.15) inset, 0 0 30px rgba(0,200,255,.2);
           color:#fff; text-decoration:none; font-weight:700; letter-spacing:.2px; }
    h1 { text-align:center; margin:48px 0 28px; font-size:52px; text-shadow:0 0 18px rgba(0,255,255,.35); }
  </style>
</head>
<body>
  <h1>TalkKink Compatibility</h1>

  <!-- Your real buttons can keep existing markup / classes; IDs are optional -->
  <button id="uploadMineBtn" class="cta">Upload Your Survey</button>
  <button id="uploadPartnerBtn" class="cta">Upload Partner’s Survey</button>
  <button id="downloadPdfBtn" class="cta">Download PDF</button>
  <a href="/KinkSurveyPage/" class="cta">← Back</a>

  <!-- ====== Standalone logic: remove theme-globals.js and pdfDownload.js includes ====== -->
  <script>
/* ---- 1) Remove the two problematic scripts if they’re on the page ---- */
(function killBadIncludes(){
  const sel = 'script[src*="theme-globals.js"],script[src*="pdfDownload.js"]';
  document.querySelectorAll(sel).forEach(node => {
    try {
      node.parentNode?.removeChild(node);
    } catch (_) {
      /* ignore */
    }
  });
})();

/* ---- 2) Null-guard for the “dock margin” style error ---- */
try {
  const dock = document.querySelector('[data-dock-margin]') ||
               document.getElementById('dock-margin') ||
               document.querySelector('.dock-margin');
  if (dock && dock.style) dock.style.margin = '';
} catch (_) {}

/* ---- 3) Minimal standalone PDF exporter (jsPDF via CDN) ---- */
(function () {
  const PAGE = { w: 612, h: 792 };
  const MARGIN = { t: 48, r: 40, b: 54, l: 40 };
  const LINE = 16;
  const COL_GAP = 18;
  const SELF_KEYS = ['talkkink:survey', 'talkkink:mine', 'tk_compat.self'];
  const PARTNER_KEYS = ['talkkink:partner', 'tk_compat.partner'];

  const nowStamp = () => {
    const d = new Date();
    const pad = (n) => String(n).padStart(2, '0');
    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
  };

  async function loadJsPDF() {
    if (window.jspdf?.jsPDF) return window.jspdf.jsPDF;
    await new Promise((res, rej) => {
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js';
      s.async = true;
      s.onload = res;
      s.onerror = () => rej(new Error('jsPDF load failed'));
      document.head.appendChild(s);
    });
    if (!(window.jspdf?.jsPDF)) throw new Error('jsPDF init failed');
    return window.jspdf.jsPDF;
  }

  function normalizeRating(value) {
    const num = Number(value);
    if (!Number.isFinite(num)) return 0;
    return Math.max(0, Math.min(5, Math.round(num)));
  }

  function normalizeRows(survey) {
    const rows = Array.isArray(survey?.responses) ? survey.responses : [];
    return rows.map((row, idx) => ({
      id: row.id ?? row.prompt ?? row.text ?? row.title ?? `item-${idx}`,
      prompt: row.prompt ?? row.text ?? row.title ?? row.label ?? row.question ?? row.id ?? '',
      category: row.category ?? row.categoryId ?? row.cat ?? row.section ?? 'Other',
      rating: normalizeRating(row.rating ?? row.score ?? row.value ?? row.answer ?? 0),
      index: row.index ?? row.order ?? row.position ?? idx
    }));
  }

  const groupByCategory = (survey) => {
    const grouped = new Map();
    normalizeRows(survey).forEach(row => {
      if (!grouped.has(row.category)) grouped.set(row.category, []);
      grouped.get(row.category).push(row);
    });
    for (const list of grouped.values()) {
      list.sort((a, b) => (a.index ?? 0) - (b.index ?? 0));
    }
    return grouped;
  };

  const summarize = (survey) => {
    const counts = [0, 0, 0, 0, 0, 0];
    normalizeRows(survey).forEach(row => {
      counts[row.rating] += 1;
    });
    return counts;
  };

  function addWrapText(doc, text, x, y, maxW, lh) {
    const words = String(text || '').split(/\s+/);
    let line = '';
    let cy = y;
    const width = (t) => doc.getTextWidth(t);
    words.forEach(word => {
      const test = line ? `${line} ${word}` : word;
      if (width(test) > maxW) {
        if (line) {
          doc.text(line, x, cy);
          cy += lh;
        }
        line = word;
      } else {
        line = test;
      }
    });
    if (line) {
      doc.text(line, x, cy);
      cy += lh;
    }
    return cy;
  }

  function header(doc, title, subtitle) {
    doc.setFillColor(0, 0, 0);
    doc.rect(0, 0, PAGE.w, PAGE.h, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(32);
    doc.text(title, PAGE.w / 2, MARGIN.t, { align: 'center', baseline: 'top' });
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(12);
    doc.text(subtitle, PAGE.w / 2, MARGIN.t + 28, { align: 'center', baseline: 'top' });
    return MARGIN.t + 42;
  }

  function addFooter(doc, page, total) {
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(9);
    doc.setTextColor(180, 180, 180);
    doc.text(`TalkKink • ${nowStamp()} • Page ${page}/${total}`, PAGE.w / 2, PAGE.h - MARGIN.b + 24, { align: 'center', baseline: 'bottom' });
  }

  function block(doc, cat, items, startY) {
    let cy = startY + 6;
    const x = MARGIN.l;
    const maxW = PAGE.w - MARGIN.l - MARGIN.r;
    if (cat) {
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(16);
      doc.setTextColor(255, 255, 255);
      cy = addWrapText(doc, cat, x, cy, maxW, LINE);
    }
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(11);
    doc.setTextColor(220, 220, 220);
    for (const row of items) {
      const chip = ` [${row.rating}] `;
      const bullet = '• ';
      const headW = doc.getTextWidth(bullet + chip);
      doc.text(bullet, x, cy);
      doc.setTextColor(140, 230, 255);
      doc.text(chip, x + doc.getTextWidth(bullet), cy);
      doc.setTextColor(220, 220, 220);
      const px = x + headW + 2;
      cy = addWrapText(doc, row.prompt || row.id, px, cy, maxW - headW - 4, LINE - 2) - 4;
      cy += 4;
      if (cy > PAGE.h - MARGIN.b - 40) {
        doc.addPage('letter', 'portrait');
        doc.setFillColor(0, 0, 0);
        doc.rect(0, 0, PAGE.w, PAGE.h, 'F');
        cy = MARGIN.t;
      }
    }
    doc.setDrawColor(60, 120, 140);
    doc.line(MARGIN.l, cy, PAGE.w - MARGIN.r, cy);
    return cy + 10;
  }

  function summary(doc, survey, label, startY) {
    const counts = summarize(survey);
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(14);
    doc.setTextColor(255, 255, 255);
    doc.text(`${label} — Rating Summary`, MARGIN.l, startY);
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(11);
    doc.setTextColor(200, 200, 200);
    doc.text(counts.map((count, rating) => `${rating}: ${count}`).join('    '), MARGIN.l, startY + LINE);
    return startY + LINE * 2;
  }

  function pickSources(opts = {}) {
    const out = { mine: opts.mine ?? null, partner: opts.partner ?? null };
    if (!out.mine) out.mine = window.talkkinkMine || window.talkkinkSurvey;
    if (!out.partner) out.partner = window.talkkinkPartner;
    try {
      if (!out.mine) {
        for (const key of SELF_KEYS) {
          const value = localStorage.getItem(key);
          if (value) { out.mine = JSON.parse(value); break; }
        }
      }
      if (!out.partner) {
        for (const key of PARTNER_KEYS) {
          const value = localStorage.getItem(key);
          if (value) { out.partner = JSON.parse(value); break; }
        }
      }
    } catch (_) {}
    return out;
  }

  async function buildPdf({ mine, partner, filename }) {
    const jsPDF = await loadJsPDF();
    const doc = new jsPDF({ unit: 'pt', format: 'letter', compress: true });
    const title = partner ? 'TalkKink Compatibility Report' : 'TalkKink Survey Export';
    const mineCats = mine?.meta?.selectedCategories?.join(', ') || 'All Categories';
    const partnerCats = partner?.meta?.selectedCategories?.join(', ') || 'All Categories';
    const subtitle = partner
      ? `Exported ${nowStamp()} • Mine: ${mineCats} • Partner: ${partnerCats}`
      : `Exported ${nowStamp()} • Selected: ${mineCats}`;

    let y = header(doc, title, subtitle);
    if (partner) {
      y = summary(doc, mine, 'Mine', y);
      y = summary(doc, partner, 'Partner', y) + 6;
    } else {
      y = summary(doc, mine, 'Summary', y) + 6;
    }

    const mineMap = groupByCategory(mine);
    const partnerMap = partner ? groupByCategory(partner) : null;

    for (const [cat, items] of mineMap.entries()) {
      if (y > PAGE.h - MARGIN.b - 120) {
        doc.addPage('letter', 'portrait');
        doc.setFillColor(0, 0, 0);
        doc.rect(0, 0, PAGE.w, PAGE.h, 'F');
        y = MARGIN.t;
      }

      if (partner && partnerMap) {
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(18);
        doc.setTextColor(255, 255, 255);
        y = addWrapText(doc, cat, MARGIN.l, y, PAGE.w - MARGIN.l - MARGIN.r, LINE) + 2;

        const colW = (PAGE.w - MARGIN.l - MARGIN.r - COL_GAP) / 2;
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(12);
        doc.text('Mine', MARGIN.l, y);
        const yL = block(doc, '', items, y + LINE - LINE);

        let yR = y;
        let xR = MARGIN.l + colW + COL_GAP;
        if (yR + 40 > PAGE.h - MARGIN.b) {
          doc.addPage('letter', 'portrait');
          doc.setFillColor(0, 0, 0);
          doc.rect(0, 0, PAGE.w, PAGE.h, 'F');
          yR = MARGIN.t;
        }
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(12);
        doc.text('Partner', xR, yR);
        yR += LINE;

        (function drawRight() {
          let cy = yR + 6;
          const maxW = colW;
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(11);
          doc.setTextColor(220, 220, 220);
          for (const row of partnerMap.get(cat) || []) {
            const chip = ` [${row.rating}] `;
            const bullet = '• ';
            const headW = doc.getTextWidth(bullet + chip);
            doc.text(bullet, xR, cy);
            doc.setTextColor(140, 230, 255);
            doc.text(chip, xR + doc.getTextWidth(bullet), cy);
            doc.setTextColor(220, 220, 220);
            const px = xR + headW + 2;
            cy = addWrapText(doc, row.prompt || row.id, px, cy, maxW - headW - 4, LINE - 2) - 4;
            cy += 4;
            if (cy > PAGE.h - MARGIN.b - 40) {
              doc.addPage('letter', 'portrait');
              doc.setFillColor(0, 0, 0);
              doc.rect(0, 0, PAGE.w, PAGE.h, 'F');
              cy = MARGIN.t;
            }
          }
          doc.setDrawColor(60, 120, 140);
          doc.line(xR, cy, xR + maxW, cy);
          yR = cy + 12;
        })();

        y = Math.max(yL, yR) + 10;
      } else {
        y = block(doc, cat, items, y);
      }
    }

    const total = doc.internal.getNumberOfPages();
    for (let i = 1; i <= total; i += 1) {
      doc.setPage(i);
      addFooter(doc, i, total);
    }
    doc.save(filename || (partner ? 'talkkink-compatibility-results.pdf' : 'talkkink-survey-results.pdf'));
  }

  window.TKPDF = window.TKPDF || {};
  window.TKPDF.download = (opts = {}) => {
    const { mine, partner } = pickSources(opts);
    if (!mine) {
      alert('Export unavailable: no survey data found.');
      return;
    }
    buildPdf({ mine, partner, filename: opts.filename }).catch(err => {
      console.error(err);
      alert('Export failed.');
    });
  };

  function attachUpload(btn, key, input) {
    if (!btn && !input) return;
    let fileInput = input || null;
    const created = !fileInput;
    if (!fileInput) {
      fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = 'application/json';
      fileInput.style.display = 'none';
      document.body.appendChild(fileInput);
    } else if (!fileInput.accept) {
      fileInput.accept = 'application/json';
    }

    if (key === 'talkkink:partner' && fileInput) {
      fileInput.setAttribute('data-partner-upload', '');
      if (!fileInput.id) fileInput.id = 'partnerFile';
    }

    const isLabelForInput = Boolean(btn && fileInput && btn.tagName === 'LABEL' && btn.htmlFor && fileInput.id && btn.htmlFor === fileInput.id);
    if (btn && !isLabelForInput && btn !== fileInput) {
      btn.addEventListener('click', () => fileInput.click());
    }

    fileInput.addEventListener('change', async () => {
      const file = fileInput.files?.[0];
      if (!file) return;
      try {
        const text = await file.text();
        const json = JSON.parse(text);
        localStorage.setItem(key, text);
        if (key === 'talkkink:mine') {
          window.talkkinkMine = json;
          window.talkkinkSurvey = json;
        }
        if (key === 'talkkink:partner') {
          window.talkkinkPartner = json;
        }
        alert('Uploaded ✓');
      } catch (err) {
        console.error(err);
        alert('Invalid file — expected TalkKink JSON export.');
      }
      if (created) {
        fileInput.value = '';
      }
    });
  }

  function findBtn(txt) {
    const needle = (txt || '').toLowerCase();
    return Array.from(document.querySelectorAll('button,a,[role="button"]')).find(el => (el.textContent || '').toLowerCase().includes(needle));
  }

  function bindUI() {
    const mineBtn = document.getElementById('uploadMineBtn') || findBtn('upload your survey');
    const partnerBtn = document.getElementById('uploadPartnerBtn') || findBtn('upload partner');
    const dlBtn = document.getElementById('downloadPdfBtn') || document.getElementById('btnDownloadPdf') || findBtn('download pdf');
    const mineInput = document.getElementById('fileA') || document.querySelector('[data-upload-input="mine"]');
    const partnerInput = document.getElementById('fileB') || document.querySelector('[data-upload-input="partner"]');
    attachUpload(mineBtn, 'talkkink:mine', mineInput);
    attachUpload(partnerBtn, 'talkkink:partner', partnerInput);
    if (dlBtn) {
      dlBtn.addEventListener('click', () => window.TKPDF.download());
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bindUI);
  } else {
    bindUI();
  }
})();
  </script>
<!-- ======================= CODEX DROP-IN: Partner Upload Consent + Clean PDF ======================= -->
<!-- Our upload buttons are defined above; this drop-in only contributes the consent UI + PDF helper. -->
<style>
  .tk-consent-backdrop{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);z-index:9999}
  .tk-consent-modal{width:min(560px,92vw);background:#0b0b0c;color:#e9e9ef;border:1px solid #2a2a35;border-radius:16px;padding:18px 18px 14px;box-shadow:0 12px 40px rgba(0,0,0,.6);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .tk-consent-modal h3{margin:0 0 6px 0;font-size:18px}
  .tk-consent-modal p{margin:6px 0 10px}
  .tk-consent-row{display:flex;gap:10px;align-items:flex-start;margin:10px 0 16px}
  .tk-consent-row input[type="checkbox"]{margin-top:2px;transform:scale(1.05)}
  .tk-consent-actions{display:flex;gap:10px;justify-content:flex-end}
  .tk-btn{padding:10px 14px;border-radius:12px;border:1px solid #3b3b49;background:#18181c;color:#fafafc;cursor:pointer}
  .tk-btn.primary{background:#2b64ff;border-color:#2b64ff}
  .tk-btn:disabled{opacity:.6;cursor:not-allowed}
  .tk-consent-small{opacity:.8}
  /* tiny consent banner after success */
  .tk-consent-banner{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:#0e2810;color:#d7f8dd;border:1px solid #2e6b33;border-radius:10px;padding:8px 12px;display:none;z-index:10000}
</style>

<div id="tk-consent" class="tk-consent-backdrop" aria-hidden="true">
  <div role="dialog" aria-modal="true" aria-labelledby="tk-consent-title" class="tk-consent-modal">
    <h3 id="tk-consent-title">Confirm Partner Consent</h3>
    <p>Before importing a partner’s survey, confirm you have their explicit consent to upload and compare their responses here.</p>
    <div class="tk-consent-row">
      <input id="tk-consent-checkbox" type="checkbox" />
      <label for="tk-consent-checkbox">
        I have my partner’s explicit permission to upload and process their survey responses on this site.
      </label>
    </div>
    <p class="tk-consent-small">If you do not have consent, click <b>Cancel</b>. You can delete uploaded data at any time.</p>
    <div class="tk-consent-actions">
      <button class="tk-btn" data-action="cancel">Cancel</button>
      <button class="tk-btn primary" data-action="continue" disabled>Continue</button>
    </div>
  </div>
</div>

<div id="tk-consent-banner" class="tk-consent-banner">✔ Partner consent confirmed. Processing file…</div>

<script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js" crossorigin="anonymous"></script>
<script src="https://unpkg.com/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js" crossorigin="anonymous"></script>

<script>
/* =============================== Partner Consent Gate =============================== */
(function () {
  const $ = (s, r=document) => r.querySelector(s);

  // Public API: await window.tkConfirmPartnerConsent()
  async function tkConfirmPartnerConsent() {
    const root = $("#tk-consent");
    if (!root) return true; // fail-open if modal missing

    const checkbox = $("#tk-consent-checkbox", root);
    const btnContinue = root.querySelector('[data-action="continue"]');
    const btnCancel   = root.querySelector('[data-action="cancel"]');

    // reset state
    checkbox.checked = false; btnContinue.disabled = true;

    const done = (()=>{ let resolve; const p=new Promise(r=>resolve=r); return {promise:p, resolve}; })();
    const onCheck = () => { btnContinue.disabled = !checkbox.checked; };
    const onCancel = () => cleanup(false);
    const onContinue = () => cleanup(true);

    checkbox.addEventListener('change', onCheck);
    btnCancel.addEventListener('click', onCancel);
    btnContinue.addEventListener('click', onContinue);

    show(root);

    function cleanup(val){
      hide(root);
      checkbox.removeEventListener('change', onCheck);
      btnCancel.removeEventListener('click', onCancel);
      btnContinue.removeEventListener('click', onContinue);
      done.resolve(val);
    }
    return done.promise;
  }
  window.tkConfirmPartnerConsent = tkConfirmPartnerConsent;

  const input = document.querySelector('input[data-partner-upload]') || document.querySelector('#partnerFile');

  if (input) {
    input.addEventListener('change', async (ev) => {
      const file = ev.target?.files?.[0];
      if (!file) return;

      const ok = await tkConfirmPartnerConsent();
      if (!ok) { ev.target.value = ''; return; }

      flashConsentBanner();

      try {
        const text = await file.text();
        const data = JSON.parse(text);
        const rows = extractRowsFromTalkKinkJSON(data); // {Category, Item, Role, Score}
        await generateCleanPartnerPDF(rows, data?.meta);
      } catch (err) {
        console.error('[talkkink] partner file processing error:', err);
        alert('Sorry—could not read that file. Is it a valid TalkKink survey JSON?');
      } finally {
        ev.target.value = '';
      }
    });
  }

  function show(el){ el.style.display='flex'; el.setAttribute('aria-hidden','false'); }
  function hide(el){ el.style.display='none'; el.setAttribute('aria-hidden','true'); }
  function flashConsentBanner() {
    const b = document.getElementById('tk-consent-banner'); if (!b) return;
    b.style.display='block'; setTimeout(()=>{ b.style.display='none'; }, 2500);
  }

  function extractRowsFromTalkKinkJSON(data){
    const map = data?.answersById || {};
    const rows = [];
    for (const [id, score] of Object.entries(map)) {
      const parts = id.split('-');
      const role  = parts[parts.length - 1];                     // giving | receiving | general
      const category = (parts[0] + ' ' + parts[1]).replace(/\b\w/g, m=>m.toUpperCase());
      const item = parts.slice(2, -1).join(' ')
        .replace(/\bTv\b/gi, 'TV')
        .replace(/\s+/g,' ')
        .trim();
      rows.push({ Category: category, Item: capFirst(item), Role: capFirst(role), Score: Number(score) });
    }
    rows.sort((a,b)=> a.Category.localeCompare(b.Category) || a.Role.localeCompare(b.Role) || a.Item.localeCompare(b.Item));
    return rows;
  }
  function capFirst(s){ return s ? s.charAt(0).toUpperCase() + s.slice(1) : s; }

  async function generateCleanPartnerPDF(rows, meta){
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit:'pt', format:'letter' });

    const title = 'TalkKink — Partner Survey (Clean Report)';
    const date  = new Date().toLocaleString();

    doc.setFont('helvetica','bold'); doc.setFontSize(16);
    doc.text(title, 48, 56);
    doc.setFont('helvetica','normal'); doc.setFontSize(10);
    doc.text(`Generated: ${date}`, 48, 72);

    if (meta?.categories?.length) {
      doc.text(`Categories in file: ${meta.categories.join(', ')}`, 48, 88);
    }

    let y = 110;
    const categories = [...new Set(rows.map(r=>r.Category))];

    for (const cat of categories) {
      doc.setFont('helvetica','bold'); doc.setFontSize(13);
      doc.text(cat, 48, y); y += 8;

      const body = rows.filter(r=>r.Category===cat).map(r => [r.Role, r.Item, String(r.Score)]);
      doc.autoTable({
        startY: y + 8,
        margin: { left: 48, right: 48 },
        head: [['Role', 'Item', 'Score']],
        body,
        styles: { font: 'helvetica', fontSize: 10, cellPadding: 4, overflow: 'linebreak' },
        headStyles: { fillColor: [0,0,0], textColor: 255 },
        alternateRowStyles: { fillColor: [245,245,245] },
        columnStyles: { 0: { cellWidth: 90 }, 1: { cellWidth: 360 }, 2: { cellWidth: 60, halign: 'center' } }
      });
      y = doc.lastAutoTable.finalY + 14;
      if (y > doc.internal.pageSize.getHeight() - 72) {
        doc.addPage(); y = 56;
      }
    }

    const filename = 'partner-survey-clean.pdf';
    doc.save(filename);
  }
})();
</script>
</body>
</html>
