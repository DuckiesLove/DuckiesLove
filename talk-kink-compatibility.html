<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Talk Kink – Compatibility</title>
<style>
  :root{
    --bg:#f7f9fc; --fg:#152133; --muted:#5f6b7a; --line:#d5dce6; --accent:#2a7de1;
    --cell-pad:.9rem; --track:#e3e9f2;
  }
/* resolved: full-width black layout */
:root{
  --bg:#000;
  --fg:#fff;
  --muted:#94a3bb;
  --line:#1f2733;
  --track:#0f1720;
}

html,body{
  background:#000;          /* force pure black */
  color:var(--fg);
  margin:0;
  font:16px/1.4 system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
}

.wrap{
  width:100%;
  margin:0;
  padding:32px clamp(16px,4vw,48px);
  box-sizing:border-box;
}

/* optional: make print/PDF full-bleed too */
@page { margin:0; }
* { -webkit-print-color-adjust: exact; print-color-adjust: exact; }

  h1{font-weight:700;letter-spacing:.4px;margin:0 0 10px}
  .bar{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:12px 0 22px}
  .btn{
    background:transparent;border:2px solid var(--accent);color:var(--accent);
    padding:.55rem .9rem;border-radius:10px;cursor:pointer;font-weight:600
  }
  .btn:hover{background:rgba(42,125,225,.12)}
  .note{color:var(--muted);font-size:.9rem}
  .file{display:inline-block}
  table{width:100%;border-collapse:collapse;table-layout:fixed}
  thead th{
    text-align:center;font-weight:800;border:2px solid var(--line);
    padding:.85rem;background:var(--bg);position:sticky;top:0
  }
  tbody td{
    border:2px solid var(--line);padding:var(--cell-pad);vertical-align:middle
  }
  td.cat{width:56%;font-weight:600}
  td.num, th.num{text-align:center;width:14%}
  td.muted{color:var(--muted)}
  /* Subtle progress background – can remove if you want pure text */
  .pct-shell{height:12px;background:var(--track);border-radius:7px;overflow:hidden;border:1px solid var(--line)}
  .pct-bar{height:100%;background:var(--accent);width:0%}
  /* Print: preserve the on-screen colors in the PDF */
  @media print{
    html,body,.wrap,table,th,td{
      background:#000 !important;
      color:#fff !important;
    }
    body{-webkit-print-color-adjust:exact;print-color-adjust:exact}
    .wrap{padding:0 !important}
    .bar,.note{display:none}
    thead th{position:static}
  }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Compatibility</h1>

    <div class="bar">
      <label class="file btn">Load Survey A
        <input id="fileA" type="file" accept="application/json" hidden>
      </label>
      <label class="file btn">Load Survey B
        <input id="fileB" type="file" accept="application/json" hidden>
      </label>
      <button id="dl" class="btn">Download PDF</button>
      <button id="missingBtn" class="btn" title="Show any codes missing a label">Missing labels</button>
      <span class="note" id="status">Waiting for uploads…</span>
    </div>

    <table id="compat">
      <thead>
        <tr>
          <th class="cat">Category</th>
          <th class="num">Partner A</th>
          <th class="num">Match %</th>
          <th class="num">Partner B</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>

    <p class="note" style="margin-top:14px">
      Tip: If “Missing labels” shows anything, add those mappings to
      <code>/data/labels-overrides.json</code> so names render (the table will never show raw cb_ codes).
    </p>
  </div>

<script>
(() => {
  // --- data holders ---------------------------------------------------------
  let surveyA = null, surveyB = null;
  const LABELS = {};          // combined labels (overrides + base)
  const missing = new Set();  // codes that had no label

  // --- load label sources (overrides first) --------------------------------
  const labelSources = [
    "/data/labels-overrides.json", // your curated names win
    "/data/kinks.json"             // base map
  ];

  async function loadLabels() {
    for (const url of labelSources) {
      try {
        const res = await fetch(url, {cache:"no-store"});
        if (!res.ok) continue;
        const obj = await res.json();
        for (const [k,v] of Object.entries(obj)) {
          if (v && typeof v === "string") LABELS[k] = v.trim();
        }
      } catch { /* ignore */ }
    }
  }

  // --- pdf helpers ---------------------------------------------------------
  const scriptCache = new Map();

  function loadScript(src) {
    if (scriptCache.has(src)) return scriptCache.get(src);

    const existing = document.querySelector(`script[src="${src}"]`);
    if (existing) {
      const pending = new Promise((resolve, reject) => {
        const onLoad = () => { existing.removeEventListener("load", onLoad); existing.removeEventListener("error", onError); resolve(); };
        const onError = () => { existing.removeEventListener("load", onLoad); existing.removeEventListener("error", onError); reject(new Error("Failed to load " + src)); };
        existing.addEventListener("load", onLoad, { once:true });
        existing.addEventListener("error", onError, { once:true });
      });
      scriptCache.set(src, pending);
      return pending;
    }

    const s = document.createElement("script");
    s.src = src;
    s.async = true;

    const promise = new Promise((resolve, reject) => {
      s.onload = () => { s.onload = s.onerror = null; resolve(); };
      s.onerror = () => { s.onload = s.onerror = null; reject(new Error("Failed to load " + src)); };
    });

    scriptCache.set(src, promise);
    document.head.appendChild(s);
    return promise;
  }

  async function ensureLib(srcList, readyCheck, label) {
    const check = typeof readyCheck === "function" ? readyCheck : () => !!window[readyCheck];
    if (check()) return;

    let lastError = null;
    for (const src of srcList) {
      try {
        await loadScript(src);
      } catch (err) {
        lastError = err;
        console.warn("[PDF] loader failed", src, err);
        continue;
      }
      if (check()) return;
    }

    if (!check()) {
      throw lastError || new Error((label || "Library") + " failed to load");
    }
  }

  async function makeFullBleedPDF(){
    await ensureLib([
      "/js/vendor/jspdf.umd.min.js",
      "https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js",
      "https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
    ], () => window.jspdf && window.jspdf.jsPDF, "jsPDF");

    if (window.jspdf && window.jspdf.jsPDF) {
      window.jsPDF = window.jspdf.jsPDF;
    }

    await ensureLib([
      "/js/vendor/html2canvas.min.js",
      "https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js",
      "https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"
    ], () => typeof window.html2canvas === "function", "html2canvas");

    const jsPDFCtor = window.jspdf?.jsPDF;
    const html2canvasFn = window.html2canvas;
    if (!jsPDFCtor || !html2canvasFn) throw new Error("PDF libraries missing");

    const node = document.querySelector(".wrap") || document.body;
    const prevHtmlBg = document.documentElement.style.backgroundColor;
    const prevBodyBg = document.body.style.backgroundColor;

    document.documentElement.style.backgroundColor = "#000";
    document.body.style.backgroundColor = "#000";

    if (document.fonts && document.fonts.ready) {
      try { await document.fonts.ready; } catch { /* ignore */ }
    }

    const dpr = Math.min(window.devicePixelRatio || 1, 3);
    const scale = 2 * dpr;

    let canvas;
    try {
      canvas = await html2canvasFn(node, {
        backgroundColor: "#000",
        scale,
        useCORS: true,
        allowTaint: true,
        logging: false,
        windowWidth: Math.max(
          document.documentElement.scrollWidth,
          document.body.scrollWidth
        ),
        windowHeight: Math.max(
          document.documentElement.scrollHeight,
          document.body.scrollHeight
        )
      });
    } finally {
      document.documentElement.style.backgroundColor = prevHtmlBg || "";
      document.body.style.backgroundColor = prevBodyBg || "";
    }

    if (!canvas) throw new Error("Canvas capture failed");

    const imgData = canvas.toDataURL("image/png", 1.0);
    const pxToPt = 72 / 96;
    const pdfW = canvas.width * pxToPt;
    const pdfH = canvas.height * pxToPt;

    const pdf = new jsPDFCtor({
      orientation: (pdfW >= pdfH) ? "landscape" : "portrait",
      unit: "pt",
      format: [pdfW, pdfH],
      compress: true,
      putOnlyUsedFonts: true
    });

    pdf.setFillColor(0, 0, 0);
    pdf.rect(0, 0, pdfW, pdfH, "F");
    pdf.addImage(imgData, "PNG", 0, 0, pdfW, pdfH, undefined, "FAST");
    pdf.save("compatibility.pdf");
  }
  window.makeFullBleedPDF = makeFullBleedPDF;

  // never expose cb_* in UI. If unknown -> "—" and remember for the side list.
  function prettyLabel(code) {
    const name = LABELS[code];
    if (name && name.trim()) return name.trim();
    missing.add(code);
    return "—";
  }

  // --- file helpers ---------------------------------------------------------
  function readJSON(file) {
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onerror = () => reject(new Error("Could not read file."));
      fr.onload = () => {
        try { resolve(JSON.parse(fr.result)); }
        catch(e){ reject(new Error("Invalid JSON.")); }
      };
      fr.readAsText(file);
    });
  }

  // find all category codes present in either survey (array of cb_* ids).
  function collectCategoryCodes(a, b) {
    const set = new Set();
    const push = obj => {
      if (!obj) return;
      // Accept both shapes: {answers:[{id,value}...]} or {…id:value…}
      if (Array.isArray(obj.answers)) {
        for (const row of obj.answers) if (row && row.id) set.add(row.id);
      } else {
        for (const k of Object.keys(obj)) if (k.startsWith("cb_")) set.add(k);
      }
    };
    push(a); push(b);
    return [...set];
  }

  // score helpers – you can swap this for your project’s real logic
  const valOf = (obj, id) => {
    if (!obj) return null;
    if (Array.isArray(obj.answers)) {
      const r = obj.answers.find(x => x.id === id);
      return r ? r.value ?? r.answer ?? null : null;
    }
    return obj[id] ?? null;
  };
  function matchPercent(aVal, bVal){
    if (aVal == null || bVal == null) return null;
    // Simple: identical = 100, else 0. Replace with your real formula if needed.
    return aVal === bVal ? 100 : 0;
  }

  // --- rendering ------------------------------------------------------------
  const tbody = document.getElementById("tbody");
  function render() {
    if (!surveyA && !surveyB) return;
    const codes = collectCategoryCodes(surveyA, surveyB);

    // Make rows (resolve names now so we can sort by them)
    const rows = codes.map(code => {
      const name = prettyLabel(code);
      const aVal = valOf(surveyA, code);
      const bVal = valOf(surveyB, code);
      const pct  = matchPercent(aVal, bVal);
      return { code, name, aVal, bVal, pct };
    });

    // Alphabetical by the display name (case-insensitive), keep blanks last.
    rows.sort((r1, r2) => {
      const n1 = r1.name === "—" ? "~~~" : r1.name.toLowerCase();
      const n2 = r2.name === "—" ? "~~~" : r2.name.toLowerCase();
      return n1.localeCompare(n2);
    });

    // Build table
    tbody.innerHTML = "";
    for (const r of rows) {
      const tr = document.createElement("tr");

      const tdCat = document.createElement("td");
      tdCat.className = "cat";
      tdCat.textContent = r.name;               // never show code
      tr.appendChild(tdCat);

      const tdA = document.createElement("td");
      tdA.className = "num";
      tdA.textContent = (r.aVal ?? "—");
      tr.appendChild(tdA);

      const tdPct = document.createElement("td");
      tdPct.className = "num";
      tdPct.innerHTML = r.pct == null
        ? "—"
        : `<div class="pct-shell"><div class="pct-bar" style="width:${r.pct}%"></div></div>`;
      tr.appendChild(tdPct);

      const tdB = document.createElement("td");
      tdB.className = "num";
      tdB.textContent = (r.bVal ?? "—");
      tr.appendChild(tdB);

      tbody.appendChild(tr);
    }

    // status
    const s = [];
    if (surveyA) s.push("A ✓"); else s.push("A —");
    if (surveyB) s.push("B ✓"); else s.push("B —");
    document.getElementById("status").textContent = `Loaded: ${s.join("  ·  ")}`;
  }

  // --- UI wiring ------------------------------------------------------------
  document.getElementById("fileA").addEventListener("change", async (e)=>{
    if (!e.target.files?.[0]) return;
    try {
      surveyA = await readJSON(e.target.files[0]);
      render();
    } catch(err){ alert("Survey A: " + err.message); }
    finally { e.target.value = ""; }
  });

  document.getElementById("fileB").addEventListener("change", async (e)=>{
    if (!e.target.files?.[0]) return;
    try {
      surveyB = await readJSON(e.target.files[0]);
      render();
    } catch(err){ alert("Survey B: " + err.message); }
    finally { e.target.value = ""; }
  });

  document.getElementById("missingBtn").addEventListener("click", ()=> {
    if (!missing.size) { alert("Great! No missing labels."); return; }
    const list = [...missing].sort().join("\n");
    alert("Add these to /data/labels-overrides.json:\n\n" + list);
  });

  // start
  loadLabels().then(render);
})();
</script>
<script type="module">
/* === Full-bleed PDF export: forcibly replace old window.print handler === */
document.addEventListener('DOMContentLoaded', () => {
  const btn = document.querySelector('#dl') || document.querySelector('[data-action="download"]');
  if (!btn) return;

  const clean = btn.cloneNode(true);
  clean.removeAttribute('onclick');
  btn.replaceWith(clean);

  clean.addEventListener('click', async (e) => {
    e.preventDefault();
    e.stopPropagation();
    try {
      if (typeof window.makeFullBleedPDF !== 'function') {
        throw new Error('makeFullBleedPDF not ready');
      }
      await window.makeFullBleedPDF();
    } catch (err) {
      console.error('[PDF] export failed:', err);
      alert('PDF export failed. See console for details.');
    }
  }, { passive: false });
});
</script>
</body>
</html>
