<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TalkKink Compatibility Survey</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Fredoka:wght@600;700&display=swap">
<script defer src="/assets/js/compatPdf.js"></script>
<style>
  :root{
    --bg:#0e0f11;            /* page background */
    --panel:#0b0c0d;         /* table banding base */
    --row:#111315;           /* row color */
    --row-alt:#0f1012;       /* zebra */
    --ink:#e6feff;           /* main text */
    --ink-dim:#b8dfe0;
    --accent:#00e7ff;        /* teal glow */
    --grid:#23292d;          /* table lines */
    --font-body:"Space Grotesk","Inter","Segoe UI","Helvetica Neue",system-ui,-apple-system,sans-serif;
    --font-display:"Fredoka","Fredoka One","Space Grotesk","Inter",system-ui,-apple-system,sans-serif;
  }
  html,body{height:100%;}
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font-family: var(--font-body);
    font-feature-settings: "tnum";
    font-variant-numeric: tabular-nums;
    font-synthesis: none;
    text-rendering: optimizeLegibility;
  }
  .page{
    max-width:1120px;
    margin:28px auto 48px;
    padding:0 16px;
  }

  /* Centered, outlined headings (like before) */
  .title, .subtitle, .section {
    text-align:center;
    margin:0;
  }
  .title, .section { font-family: var(--font-display); }
  .title{
    font-size:56px; line-height:1.05; font-weight:700; letter-spacing:.5px;
    color:var(--accent);
    /* outline with soft glow */
    text-shadow:
      0 0 0 var(--bg),
      0 0 18px rgba(0,231,255,.35),
      0 0 40px rgba(0,231,255,.25);
    -webkit-font-smoothing:antialiased;
  }
  .subtitle{
    margin-top:10px; font-size:20px; color:var(--ink-dim); font-weight:600;
    font-family: var(--font-body);
  }
  .hr { height:3px; background:var(--accent); margin:18px auto 14px; max-width:92%; opacity:.85; }

  .section{
    font-size:44px; font-weight:700; color:var(--accent); margin:12px 0 10px;
    text-shadow:
      0 0 0 var(--bg),
      0 0 14px rgba(0,231,255,.25),
      0 0 28px rgba(0,231,255,.18);
  }

  /* Table fills the page, no white boxes */
  .compat{
    width:100%; border-collapse:separate; border-spacing:0;
    background:transparent; table-layout:fixed;
  }
  .compat col.label   { width:56%; }
  .compat col.a       { width:12%; }
  .compat col.match   { width:20%; }
  .compat col.b       { width:12%; }

  .compat thead th{
    position:sticky; top:0; z-index:1;
    background:#0f1215;
    color:var(--accent); font-weight:800; font-size:20px; padding:14px 12px;
    border-bottom:1px solid var(--grid);
    text-align:center;
    line-height:1.1;
    white-space:nowrap;
    font-variant-numeric:tabular-nums;
    font-feature-settings:'tnum';
    /* give the header the outlined look, too */
    text-shadow:
      0 0 0 var(--bg),
      0 0 12px rgba(0,231,255,.22);
  }
  .compat thead th:first-child{ text-align:left; }

  .compat tbody td{
    padding:14px 12px; font-size:19px; line-height:1.3; color:var(--ink);
    border-bottom:1px solid #151a1e; background:var(--row);
    font-variant-numeric:tabular-nums;
    font-feature-settings:'tnum';
  }
  .compat tbody tr:nth-child(2n) td{ background:var(--row-alt); }
  .compat tbody td.label{ color:var(--ink); }
  .compat tbody td.num, .compat tbody td.match{
    text-align:center; white-space:nowrap;
  }

  .sr-only{
    position:absolute;
    width:1px;
    height:1px;
    padding:0;
    margin:-1px;
    overflow:hidden;
    clip:rect(0, 0, 0, 0);
    white-space:nowrap;
    border:0;
  }

  /* Download button */
  .bar { display:flex; gap:12px; justify-content:center; margin:18px 0 6px; }
  .btn {
    appearance:none; border:none; border-radius:12px; padding:10px 16px;
    background:#0f1d22; color:var(--ink); font-weight:700; cursor:pointer;
    font-family: var(--font-display);
    box-shadow:0 0 0 1px rgba(0,231,255,.25), 0 6px 20px rgba(0,231,255,.12) inset;
  }
  .btn:hover{ box-shadow:0 0 0 1px rgba(0,231,255,.5), 0 0 18px rgba(0,231,255,.18) inset; }

  /* make sure the whole sheet breathes to edges on small screens */
  @media (max-width:880px){
    .title{ font-size:44px; }
    .section{ font-size:34px; }
    .compat thead th, .compat tbody td{ font-size:18px; }
    .compat col.label{ width:51%; }
    .compat col.match{ width:17%; }
  }
</style>
</head>
<body>
  <div class="page" id="app">
    <h1 class="title">TalkKink Compatibility Survey</h1>
    <p class="subtitle" id="ts">Generated: ‚Äî</p>
    <div class="hr"></div>
    <h2 class="section">Behavioral Play</h2>

    <div class="bar"><button id="downloadBtn" class="btn">Download PDF</button></div>

    <table class="compat" id="compatTable" aria-label="Compatibility table">
      <colgroup>
        <col class="label"><!-- Kinks -->
        <col class="a">    <!-- Partner A -->
        <col class="match"><!-- Match -->
        <col class="b">    <!-- Partner B -->
      </colgroup>
      <thead>
        <tr>
          <th>Kinks</th>
          <th>Partner A</th>
          <th>Match</th>
          <th>Partner B</th>
        </tr>
      </thead>
      <tbody id="compatBody"><!-- rows injected --></tbody>
    </table>
  </div>

<script>
const TK_COMPAT_DEFAULT_TITLE = 'TalkKink Compatibility Survey';

function tkCompatSafeString(value) {
  if (value == null) return '';
  if (typeof value === 'string') return value.trim();
  if (typeof value === 'number' && Number.isFinite(value)) return String(value);
  if (value instanceof Date && !Number.isNaN(value.getTime())) return value.toISOString();
  try {
    return String(value).trim();
  } catch (err) {
    console.warn('[tk-compat-meta] Unable to stringify value', err);
    return '';
  }
}

function tkCompatPickFirst(values) {
  for (const value of values) {
    if (Array.isArray(value)) {
      const nested = tkCompatPickFirst(value);
      if (nested) return nested;
      continue;
    }
    const str = tkCompatSafeString(value);
    if (str) return str;
  }
  return '';
}

function tkCompatTryParseDate(value) {
  if (value instanceof Date && !Number.isNaN(value.getTime())) return value;
  if (typeof value === 'number' && Number.isFinite(value)) {
    const fromNum = new Date(value);
    if (!Number.isNaN(fromNum.getTime())) return fromNum;
  }
  const text = tkCompatSafeString(value);
  if (!text) return null;
  const normalized = text.replace(/^generated:\s*/i, '').trim();
  if (!normalized) return null;
  const parsed = new Date(normalized);
  return Number.isNaN(parsed.getTime()) ? null : parsed;
}

function tkCompatFormatStamp(rawStamp, fallbackDate = new Date()) {
  const parsed = tkCompatTryParseDate(rawStamp);
  if (parsed) {
    return `Generated: ${parsed.toLocaleString()}`;
  }
  const text = tkCompatSafeString(rawStamp);
  if (text) {
    return /^generated:/i.test(text) ? text : `Generated: ${text}`;
  }
  const fallback = fallbackDate instanceof Date ? fallbackDate : new Date();
  return `Generated: ${fallback.toLocaleString()}`;
}

function tkCompatReadJson(key) {
  if (!key || typeof localStorage === 'undefined') return null;
  try {
    const raw = localStorage.getItem(key);
    if (!raw) return null;
    return JSON.parse(raw);
  } catch (err) {
    console.warn('[tk-compat-meta] Failed to read', key, err);
    return null;
  }
}

function tkCompatLoadPayload(sequence) {
  for (const getter of sequence) {
    try {
      const value = getter();
      if (value) return value;
    } catch (err) {
      console.warn('[tk-compat-meta] Source error', err);
    }
  }
  return null;
}

function tkCompatExtractMeta(payload) {
  if (!payload || typeof payload !== 'object') return null;
  const meta = typeof payload.meta === 'object' ? payload.meta : {};
  const source = typeof payload.source === 'object' ? payload.source : {};
  const context = typeof payload.context === 'object' ? payload.context : {};

  const title = tkCompatPickFirst([
    meta.surveyTitle,
    meta.title,
    meta.name,
    payload.title,
    payload.name,
    source.title,
    source.name,
    context.title,
    context.name,
  ]);

  const exportedAt = tkCompatPickFirst([
    meta.exportedAt,
    payload.exportedAt,
    meta.generatedAt,
    payload.generatedAt,
    meta.timestamp,
    payload.timestamp,
    source.generatedAt,
    context.generatedAt,
  ]);

  const stamp = tkCompatPickFirst([meta.stamp, payload.stamp]);

  return { title, exportedAt, stamp };
}

function tkResolveCompatMeta() {
  const fallbackDate = new Date();
  const selfPayload = tkCompatLoadPayload([
    () => (typeof window !== 'undefined' ? window.talkkinkMine : null),
    () => (typeof window !== 'undefined' ? window.talkkinkSurvey : null),
    () => tkCompatReadJson('tk_compat.self'),
    () => tkCompatReadJson('talkkink:mine'),
    () => tkCompatReadJson('talkkink:survey'),
  ]);
  const partnerPayload = tkCompatLoadPayload([
    () => (typeof window !== 'undefined' ? window.talkkinkPartner : null),
    () => tkCompatReadJson('tk_compat.partner'),
    () => tkCompatReadJson('talkkink:partner'),
  ]);

  const selfMeta = tkCompatExtractMeta(selfPayload);
  const partnerMeta = tkCompatExtractMeta(partnerPayload);

  const title = tkCompatPickFirst([
    selfMeta?.title,
    partnerMeta?.title,
  ]) || TK_COMPAT_DEFAULT_TITLE;

  const stampRaw = tkCompatPickFirst([
    selfMeta?.stamp,
    partnerMeta?.stamp,
    selfMeta?.exportedAt,
    partnerMeta?.exportedAt,
  ]);

  const generatedStamp = tkCompatFormatStamp(stampRaw, fallbackDate);

  return {
    title,
    generatedStamp,
    timestamp: tkCompatTryParseDate(stampRaw),
    sources: { self: selfMeta, partner: partnerMeta },
  };
}

const TK_COMPAT_META = tkResolveCompatMeta();
if (typeof window !== 'undefined') {
  window.TK_COMPAT_META = TK_COMPAT_META;
}

const TK_COMPAT_PDF_TITLE = (TK_COMPAT_META && TK_COMPAT_META.title) || TK_COMPAT_DEFAULT_TITLE;
const TK_COMPAT_PDF_SUBTITLE = TK_COMPAT_PDF_TITLE === TK_COMPAT_DEFAULT_TITLE
  ? 'Compatibility Report'
  : TK_COMPAT_DEFAULT_TITLE;

function tkCompatBuildFileName(meta = TK_COMPAT_META) {
  const base = tkCompatSafeString(meta?.title) || 'TalkKink Compatibility';
  const safe = base
    .replace(/[^a-z0-9]+/gi, '_')
    .replace(/_+/g, '_')
    .replace(/^_+|_+$/g, '');
  return (safe || 'TalkKink_Compatibility') + '.pdf';
}

function tkApplyCompatMeta(meta = TK_COMPAT_META) {
  if (!meta) return;
  if (meta.title) {
    document.title = meta.title;
    const heading = document.querySelector('.title');
    if (heading) heading.textContent = meta.title;
  }
  const subtitle = document.getElementById('ts');
  if (subtitle) {
    subtitle.textContent = meta.generatedStamp || tkCompatFormatStamp();
  }
}

tkApplyCompatMeta();

const FLAG_META = {
  green:  { emoji: "üü©", label: "High match", color: "#18d69a" },
  yellow: { emoji: "üü®", label: "Needs discussion", color: "#ffcc00" },
  red:    { emoji: "üü•", label: "Conflict", color: "#ff4242" }
};

const FLAG_EMOJI_TO_STATUS = Object.fromEntries(
  Object.entries(FLAG_META).map(([status, meta]) => [meta.emoji, status])
);

Object.assign(FLAG_EMOJI_TO_STATUS, {
  "üü¢": "green",
  "üü°": "yellow",
  "üî¥": "red",
  "üü†": "yellow"
});

function tkFlagFromScores(matchPct, aScore, bScore) {
  if (
    matchPct == null ||
    aScore == null ||
    bScore == null
  ) return "";

  const diff = Math.abs(aScore - bScore);

  if (
    matchPct <= 30 ||
    (aScore <= 1 && bScore >= 4) ||
    (bScore <= 1 && aScore >= 4)
  ) {
    return FLAG_META.red.emoji;
  }

  if (
    diff >= 3 ||
    (aScore === 5 && bScore <= 3) ||
    (bScore === 5 && aScore <= 3)
  ) {
    return FLAG_META.yellow.emoji;
  }

  if (matchPct >= 80) {
    return FLAG_META.green.emoji;
  }

  return "";
}

function tkNormalizeFlagStatus(value) {
  if (value == null) return null;
  if (typeof value === "number") {
    if (value >= 80) return "green";
    if (value >= 50) return "yellow";
    return "red";
  }

  const str = String(value).trim();
  if (!str) return null;

  if (FLAG_EMOJI_TO_STATUS[str]) return FLAG_EMOJI_TO_STATUS[str];

  const lower = str.toLowerCase();
  if (FLAG_META[lower]) return lower;
  if (/perfect|great|strong|aligned|excellent/.test(lower)) return "green";
  if (/warn|caution|mixed|medium|maybe/.test(lower)) return "yellow";
  if (/conflict|bad|low|danger|problem|issue|concern|poor/.test(lower)) return "red";

  return null;
}

function tkParseFlagColor(color) {
  if (!color) return null;
  if (Array.isArray(color)) {
    const [r, g, b] = color.map((n) => Math.max(0, Math.min(255, Number(n) || 0)));
    return `#${[r, g, b].map((n) => n.toString(16).padStart(2, "0")).join("")}`;
  }

  const str = String(color).trim();
  if (!str) return null;

  const hexMatch = str.match(/^#?([0-9a-f]{6})$/i);
  if (hexMatch) return `#${hexMatch[1].toLowerCase()}`;

  const rgbMatch = str.match(/rgb\s*\((\d+)[,\s]+(\d+)[,\s]+(\d+)/i);
  if (rgbMatch) {
    return `#${[rgbMatch[1], rgbMatch[2], rgbMatch[3]]
      .map((part) => Math.max(0, Math.min(255, Number(part) || 0)).toString(16).padStart(2, "0"))
      .join("")}`;
  }

  return null;
}

function tkGuessStatusFromColor(hex) {
  if (!hex) return null;
  const value = hex.replace("#", "");
  if (value.length !== 6) return null;

  const r = parseInt(value.slice(0, 2), 16);
  const g = parseInt(value.slice(2, 4), 16);
  const b = parseInt(value.slice(4, 6), 16);

  if (r > 210 && g < 140) return "red";
  if (r > 210 && g > 170 && b < 140) return "yellow";
  if (g > 170 && b > 110 && r < 150) return "green";

  return null;
}

function tkResolveFlagInfo(row = {}) {
  if (row.hasData === false) {
    return { emoji: "", status: null, color: null, matchPct: null, aScore: null, bScore: null };
  }

  const matchPct = Number.isFinite(row.matchPct)
    ? row.matchPct
    : tkParseMatchPercent(row.matchRaw);

  const aScore = Number.isFinite(row.aScore)
    ? row.aScore
    : tkParseScore(row.aDisplay ?? row.a ?? row.partnerA);

  const bScore = Number.isFinite(row.bScore)
    ? row.bScore
    : tkParseScore(row.bDisplay ?? row.b ?? row.partnerB);

  const rawFlag = row.flagEmoji ?? row.flagGlyph ?? row.flagRaw ?? row.flag ?? row.flagText ?? null;
  let status =
    tkNormalizeFlagStatus(row.flagStatus) ||
    tkNormalizeFlagStatus(rawFlag) ||
    tkNormalizeFlagStatus(row.flagLabel) ||
    null;

  let color =
    tkParseFlagColor(row.flagColor) ||
    tkParseFlagColor(row.flagColour) ||
    tkParseFlagColor(row.flagRGB) ||
    tkParseFlagColor(row.flagRgb) ||
    tkParseFlagColor(row.flagHex) ||
    null;

  if (!status && color) {
    status = tkGuessStatusFromColor(color);
  }

  let emoji = typeof rawFlag === "string" ? rawFlag.trim() : "";

  if (!status || !emoji || !FLAG_EMOJI_TO_STATUS[emoji]) {
    const computedEmoji = tkFlagFromScores(matchPct, aScore, bScore);
    if (computedEmoji) {
      if (!emoji) emoji = computedEmoji;
      if (!status) status = tkNormalizeFlagStatus(computedEmoji);
    }
  }

  if (status && (!emoji || !FLAG_EMOJI_TO_STATUS[emoji])) {
    emoji = FLAG_META[status]?.emoji || emoji;
  }

  if (status && !color) {
    color = FLAG_META[status]?.color || null;
  }

  return { emoji: emoji || "", status: status || null, color, matchPct, aScore, bScore };
}

function tkGetFlagSquare(row) {
  return tkResolveFlagInfo(row).emoji;
}

function tkCoerceNumber(value) {
  if (value === null || value === undefined) return null;
  if (typeof value === "number" && Number.isFinite(value)) return value;
  const trimmed = String(value).trim();
  if (!trimmed) return null;
  const direct = Number(trimmed);
  if (Number.isFinite(direct)) return direct;
  const numeric = Number(trimmed.replace(/[^0-9.+-]/g, ""));
  return Number.isFinite(numeric) ? numeric : null;
}

function tkParseScore(value) {
  const num = tkCoerceNumber(value);
  if (num == null) return null;
  if (!Number.isFinite(num)) return null;
  return Math.max(0, Math.min(5, num));
}

function tkParseMatchPercent(value) {
  const num = tkCoerceNumber(value);
  if (num == null) return null;
  if (!Number.isFinite(num)) return null;
  return Math.max(0, Math.min(100, num));
}

function tkFormatPercent(value) {
  if (!Number.isFinite(value)) return "";
  const clamped = Math.max(0, Math.min(100, value));
  const rounded = Number.isInteger(clamped) ? clamped : Number(clamped.toFixed(1));
  return `${rounded}%`;
}

function tkFormatScoreDisplay(value) {
  if (value === null || value === undefined) return "";
  const str = String(value).trim();
  return str;
}

function tkNormalizePercentText(value) {
  if (value == null) return "";
  let str = String(value).trim();
  if (!str) return "";
  if (str.includes("&")) {
    str = str.replace(/&(?=[0-9#%])/g, "");
  }
  return str.replace(/\s+/g, " ");
}

function tkFormatMatchDisplay(raw, parsed) {
  if (raw !== undefined && raw !== null) {
    const normalized = tkNormalizePercentText(raw);
    if (normalized) {
      const numeric = tkCoerceNumber(normalized);
      if (Number.isFinite(numeric)) return tkFormatPercent(numeric);
      if (/%/.test(normalized)) return normalized;
      if (Number.isFinite(parsed)) return tkFormatPercent(parsed);
      return normalized;
    }
  }
  if (Number.isFinite(parsed)) return tkFormatPercent(parsed);
  return "";
}

function tkNormalizeCompatRow(entry) {
  if (!entry) return null;

  let label;
  let labelShort;
  let aRaw;
  let bRaw;
  let matchRaw;
  let hasData;
  let flagRaw;
  let flagStatus;
  let flagColor;
  let flagHex;

  if (Array.isArray(entry)) {
    [label, aRaw, matchRaw, , bRaw] = entry;
  } else if (typeof entry === "object") {
    label = entry.label ?? entry.item ?? entry.title ?? "";
    labelShort = entry.labelShort ?? entry.shortLabel ?? entry.short ?? null;
    aRaw = entry.aScore ?? entry.a ?? entry.partnerA ?? entry.aValue ?? entry.a_score;
    bRaw = entry.bScore ?? entry.b ?? entry.partnerB ?? entry.bValue ?? entry.b_score;
    matchRaw = entry.matchPct ?? entry.match ?? entry.matchValue ?? entry.matchPercent ?? entry.matchPercentage ?? entry.matchScore;
    hasData = typeof entry.hasData === "boolean" ? entry.hasData : undefined;
    flagRaw = entry.flag ?? entry.flagGlyph ?? entry.flagEmoji ?? entry.flagText ?? entry.flagDisplay ?? null;
    flagStatus = entry.flagStatus ?? entry.flagLabel ?? entry.flagName ?? null;
    flagColor = entry.flagColor ?? entry.flagColour ?? entry.flagRGB ?? entry.flagRgb ?? null;
    flagHex = entry.flagHex ?? entry.flagColourHex ?? null;
  } else {
    return null;
  }

  const aScore = tkParseScore(aRaw);
  const bScore = tkParseScore(bRaw);
  const matchPct = tkParseMatchPercent(matchRaw);

  if (typeof hasData !== "boolean") {
    hasData = Number.isFinite(aScore) || Number.isFinite(bScore);
  }

  return {
    label: label ?? "",
    labelShort: labelShort || null,
    aScore,
    bScore,
    matchPct,
    matchRaw,
    aDisplay: tkFormatScoreDisplay(aRaw ?? aScore),
    bDisplay: tkFormatScoreDisplay(bRaw ?? bScore),
    matchDisplay: tkFormatMatchDisplay(matchRaw, matchPct),
    hasData,
    flagRaw,
    flagStatus,
    flagColor,
    flagHex,
  };
}

function tkBuildCompatRow(row) {
  const normalized = tkNormalizeCompatRow(row);
  if (!normalized) {
    return ["", "", "0%", ""];
  }

  const matchPct = Number.isFinite(normalized.matchPct)
    ? normalized.matchPct
    : tkParseMatchPercent(normalized.matchRaw);

  const aScore = Number.isFinite(normalized.aScore)
    ? normalized.aScore
    : tkParseScore(normalized.aDisplay);

  const bScore = Number.isFinite(normalized.bScore)
    ? normalized.bScore
    : tkParseScore(normalized.bDisplay);

  const label = normalized.labelShort || normalized.label || "";
  const matchText = normalized.matchDisplay ||
    (Number.isFinite(matchPct) ? tkFormatPercent(matchPct) : "0%");

  const toCell = (value) => (
    value === undefined || value === null ? "" : String(value)
  );

  const partnerA = normalized.aDisplay ?? (Number.isFinite(normalized.aScore) ? normalized.aScore : "");
  const partnerB = normalized.bDisplay ?? (Number.isFinite(normalized.bScore) ? normalized.bScore : "");

  return [
    toCell(label),
    toCell(partnerA),
    toCell(matchText || (Number.isFinite(matchPct) ? tkFormatPercent(matchPct) : "0%")),
    toCell(partnerB)
  ];
}

const TK_PDF_TITLE = "Talk Kink Compatibility Survey";

if (typeof window !== 'undefined') {
  window.tkFlagFromScores = tkFlagFromScores;
  window.tkGetFlagSquare = tkGetFlagSquare;
  window.tkResolveFlagInfo = tkResolveFlagInfo;
  window.tkBuildCompatRow = tkBuildCompatRow;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   One-time bootstrap (prevents ‚Äúdouble loading‚Äù)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
(() => {
  if (window.__TK_ONE_TIME_INIT__) return;  // hard lock
  window.__TK_ONE_TIME_INIT__ = true;

  /* Demo source (will be replaced if live globals/localStorage exist) */
  const TK_COMPAT_CACHE_VERSION = 'v3'; // bump when schema or fallback changes
  const LS_VERSION_KEY = 'talkkink:compatRows:ver';

  const noCache = /(^|[?&])nocache(=1|&|$)/.test(location.search);
  const storedVer = localStorage.getItem(LS_VERSION_KEY);

  if (noCache || storedVer !== TK_COMPAT_CACHE_VERSION){
    delete window.talkkinkCompatRows;
    ['talkkink:compatRows','talkkink:survey','talkkink:mine','talkkink:partner']
      .forEach(k => localStorage.removeItem(k));
    Object.keys(localStorage).forEach(k => {
      if (/^tk_compat\./.test(k)) localStorage.removeItem(k);
    });
    localStorage.setItem(LS_VERSION_KEY, TK_COMPAT_CACHE_VERSION);
  }

  const HARD_CODED_COMPAT_ROWS = [
    ['Giving: Assigning corner time or time-outs', 0, 100, '', 0],
    ['General: Attitude toward funishment vs serious correction', 3, 100, '', 3],
    ['Receiving: Being placed in the corner or given a time-out', 5, 100, '', 5],
    ['Receiving: Getting scolded or lectured for correction', 5, 100, '', 5],
    ['Receiving: Having privileges revoked (phone, TV)', 3, 100, '', 3],
    ['Giving: Lecturing or scolding to modify behavior', 4, 100, '', 4],
    ['Giving: Playful punishments that still reinforce rules', 3, 100, '', 3],
    ['General: Preferred style of discipline (strict vs lenient)', 4, 100, '', 4],
    ['Receiving: Playful \"f\" punishments for minor rule-breaking', 2, 100, '', 2],
    ['Giving: Removing privileges (phone, TV, sweets)', 2, 100, '', 2],
    ['General: Use of behavior contracts or rule agreements', 2, 100, '', 2],
    ['Giving: Writing lines or apology letters as correction', 1, 100, '', 1],
    ['Receiving: Writing lines or apology letters when misbehaving', 4, 100, '', 4],
  ];

  /* Source resolution: use live globals if present, else localStorage, else fallback */
  function pickRows(){
    if (Array.isArray(window.talkkinkCompatRows) && window.talkkinkCompatRows.length){
      return window.talkkinkCompatRows;
    }
    try{
      const cached = JSON.parse(localStorage.getItem('talkkink:compatRows') || 'null');
      if (Array.isArray(cached) && cached.length) return cached;
    }catch{}
    return HARD_CODED_COMPAT_ROWS;
  }

  /* Render into DOM (single-run; we clear body first to avoid doubles) */
  const TBODY = document.getElementById('compatBody');
  function renderTable(rows){
    TBODY.replaceChildren();
    const toText = (value) => (value === undefined || value === null ? '' : String(value));

    for (const row of rows){
      if (!row) continue;
      const tr = document.createElement('tr');
      const matchText = row.matchDisplay || tkFormatMatchDisplay(row.matchRaw, row.matchPct);
      const cells = [
        ['label', row.label],
        ['num',   row.aDisplay ?? (Number.isFinite(row.aScore) ? String(row.aScore) : '')],
        ['match', matchText],
        ['num',   row.bDisplay ?? (Number.isFinite(row.bScore) ? String(row.bScore) : '')],
      ];

      for (const [cls, value] of cells){
        const td = document.createElement('td');
        td.className = cls;
        td.textContent = toText(value);
        tr.appendChild(td);
      }

      TBODY.appendChild(tr);
    }
  }

  function shareRowsWithPdf(rows){
    const notify = () => {
      if (window.TKCompatPDF && typeof window.TKCompatPDF.notifyRowsUpdated === 'function') {
        window.TKCompatPDF.notifyRowsUpdated(rows);
        return true;
      }
      return false;
    };

    if (notify()) return;
    let tries = 0;
    const id = setInterval(() => {
      tries += 1;
      if (notify() || tries >= 12) {
        clearInterval(id);
      }
    }, 250);
  }

  const compatRows = pickRows().map(tkNormalizeCompatRow).filter(Boolean);
  window.__tkCompatNormalizedRows = compatRows;

  try {
    window.talkkinkCompatRows = compatRows;
    localStorage.setItem('talkkink:compatRows', JSON.stringify(compatRows));
  } catch (err) {
    console.warn('[TK-compat] Unable to persist compatibility rows', err);
  }

  shareRowsWithPdf(compatRows);
  renderTable(compatRows);
})();

let tkJsPdfLoadPromise = null;

function tkIsJsPdfReady() {
  return !!(window.jspdf && window.jspdf.jsPDF && window.jspdf.jsPDF.API && window.jspdf.jsPDF.API.autoTable);
}

async function tkEnsureJsPDF() {
  if (tkIsJsPdfReady()) return;
  if (tkJsPdfLoadPromise) {
    await tkJsPdfLoadPromise;
    return;
  }

  const localScripts = [
    '/vendor/jspdf.umd.min.js',
    '/js/vendor/jspdf.umd.min.js',
    '/assets/js/vendor/jspdf.umd.min.js',
    '/vendor/jspdf.plugin.autotable.min.js',
    '/js/vendor/jspdf.plugin.autotable.min.js',
    '/assets/js/vendor/jspdf.plugin.autotable.min.js'
  ];
  const cdnScripts = [
    'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js',
    'https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js'
  ];

  const inject = (src) => new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = src;
    script.async = true;
    script.onload = resolve;
    script.onerror = (err) => reject(err || new Error('Failed to load ' + src));
    document.head.appendChild(script);
  });

  tkJsPdfLoadPromise = (async () => {
    for (const src of localScripts) {
      try {
        await inject(src);
      } catch (err) {
        console.warn('[TK] Failed to load local jsPDF asset:', src, err);
      }
    }

    if (!tkIsJsPdfReady()) {
      for (const src of cdnScripts) {
        try {
          await inject(src);
        } catch (err) {
          console.warn('[TK] Failed to load CDN jsPDF asset:', src, err);
        }
        if (tkIsJsPdfReady()) break;
      }
    }

    if (!tkIsJsPdfReady()) {
      throw new Error('jsPDF/AutoTable not available. Host local copies in /vendor or allow the CDN.');
    }
  })();

  try {
    await tkJsPdfLoadPromise;
  } catch (err) {
    tkJsPdfLoadPromise = null;
    throw err;
  }
}

function tkCollectCompatRowsForPdf() {
  let source = [];
  if (Array.isArray(window.talkkinkCompatRows) && window.talkkinkCompatRows.length) {
    source = window.talkkinkCompatRows;
  } else if (Array.isArray(window.__tkCompatNormalizedRows)) {
    source = window.__tkCompatNormalizedRows;
  }
  return source.map(tkNormalizeCompatRow).filter(Boolean);
}

function tkSplitCompatLabel(label) {
  if (!label) {
    return { category: 'Compatibility', text: '' };
  }

  const match = String(label).split(':');
  if (match.length < 2) {
    return { category: 'Compatibility', text: String(label).trim() };
  }

  const category = match.shift().trim() || 'Compatibility';
  const text = match.join(':').trim() || String(label).trim();
  return { category, text };
}

function tkFormatPdfScore(displayValue, scoreValue) {
  if (displayValue != null && displayValue !== '') {
    return String(displayValue);
  }
  if (Number.isFinite(scoreValue)) {
    return String(scoreValue);
  }
  return '';
}

function tkFormatPdfMatch(row) {
  if (Number.isFinite(row.matchPct)) {
    return `${Math.max(0, Math.min(100, Math.round(row.matchPct)))}%`;
  }

  const raw = row.matchDisplay ?? row.matchRaw ?? row.matchPct ?? row.match;
  if (raw == null) return '‚Äî';

  if (typeof raw === 'number' && Number.isFinite(raw)) {
    return `${Math.max(0, Math.min(100, Math.round(raw)))}%`;
  }

  const text = String(raw).trim();
  if (!text) return '‚Äî';

  const numeric = text.replace(/[^0-9]+/g, '');
  if (numeric) {
    const pct = Math.max(0, Math.min(100, Number.parseInt(numeric, 10)));
    return `${pct}%`;
  }

  return text;
}

function tkBuildPdfCategories(rows) {
  const grouped = new Map();

  rows.forEach((row) => {
    if (!row) return;

    const { category, text } = tkSplitCompatLabel(row.labelShort || row.label || '');
    if (!grouped.has(category)) {
      grouped.set(category, { category, items: [] });
    }

    grouped.get(category).items.push({
      label: text || row.label || '‚Äî',
      partnerA: tkFormatPdfScore(row.aDisplay, row.aScore),
      partnerB: tkFormatPdfScore(row.bDisplay, row.bScore),
      match: tkFormatPdfMatch(row),
      scoreA: Number.isFinite(row.aScore) ? row.aScore : null,
      scoreB: Number.isFinite(row.bScore) ? row.bScore : null,
      matchPct: Number.isFinite(row.matchPct) ? row.matchPct : null,
    });
  });

  return Array.from(grouped.values());
}

async function tkGeneratePdfFromCategories(categories) {
  if (!categories.length) {
    throw new Error('No compatibility rows available');
  }

  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 40;
  const accent = [0, 224, 208];
  const background = [17, 17, 17];
  const tableFill = [17, 17, 17];
  const bodyText = [255, 255, 255];
  const lineColor = [51, 51, 51];
  const generatedAt = TK_COMPAT_META.generatedStamp;

  const flattenedRows = [];
  categories.forEach((category) => {
    if (!category || !Array.isArray(category.items)) return;
    const prefix = category.category || category.name || 'Compatibility';
    category.items.forEach((row) => {
      flattenedRows.push({
        item: prefix ? `${prefix} ‚Äî ${row.label || '‚Äî'}` : (row.label || '‚Äî'),
        partnerA: row.partnerA ?? '',
        partnerB: row.partnerB ?? '',
        scoreA: Number.isFinite(row.scoreA) ? row.scoreA : null,
        scoreB: Number.isFinite(row.scoreB) ? row.scoreB : null,
        matchText: row.match ?? '',
        matchPct: Number.isFinite(row.matchPct) ? row.matchPct : null,
      });
    });
  });

  if (!flattenedRows.length) {
    throw new Error('No compatibility rows available');
  }

  const clampPercent = (value) => {
    if (!Number.isFinite(value)) return null;
    return Math.max(0, Math.min(100, Math.round(value)));
  };

  const deriveMatchPercent = (row) => {
    if (Number.isFinite(row.scoreA) && Number.isFinite(row.scoreB)) {
      return clampPercent(100 - Math.abs(row.scoreA - row.scoreB) * 20);
    }
    if (Number.isFinite(row.matchPct)) {
      return clampPercent(row.matchPct);
    }
    return clampPercent(tkParseMatchPercent(row.matchText));
  };

  const getEmojiFlag = (matchPercent) => {
    if (!Number.isFinite(matchPercent)) return '';
    if (matchPercent >= 85) return '‚≠ê';
    if (matchPercent <= 30) return 'üö©';
    return '';
  };

  const pdfRows = flattenedRows.map((row) => {
    const matchPercent = deriveMatchPercent(row);
    return {
      item: row.item,
      partnerA: row.partnerA,
      match: matchPercent != null ? `${matchPercent}%` : (row.matchText || '‚Äî'),
      flag: getEmojiFlag(matchPercent),
      partnerB: row.partnerB,
    };
  });

  const tableWidth = pageWidth - margin * 2;
  const colWidths = {
    item: tableWidth * 0.45,
    partnerA: tableWidth * 0.12,
    match: tableWidth * 0.08,
    flag: tableWidth * 0.05,
    partnerB: tableWidth * 0.12,
  };

  const columns = [
    { header: 'Kinks', dataKey: 'item' },
    { header: 'Partner A', dataKey: 'partnerA' },
    { header: 'Match', dataKey: 'match' },
    { header: '', dataKey: 'flag' },
    { header: 'Partner B', dataKey: 'partnerB' },
  ];

  const drawPageFrame = () => {
    doc.setFillColor(...background);
    doc.rect(0, 0, pageWidth, pageHeight, 'F');

    doc.setFont('helvetica', 'bold');
    doc.setFontSize(28);
    doc.setTextColor(255, 255, 255);
    doc.text(TK_COMPAT_PDF_TITLE, pageWidth / 2, 50, { align: 'center' });

    doc.setFont('helvetica', 'normal');
    doc.setFontSize(12);
    doc.setTextColor(170, 170, 170);
    doc.text(generatedAt, pageWidth / 2, 70, { align: 'center' });

    doc.setDrawColor(...accent);
    doc.setLineWidth(2);
    doc.line(margin, 80, pageWidth - margin, 80);

    doc.setFont('helvetica', 'bold');
    doc.setFontSize(20);
    doc.setTextColor(255, 255, 255);
    doc.text(TK_COMPAT_PDF_SUBTITLE, pageWidth / 2, 110, { align: 'center' });
  };

  drawPageFrame();

  doc.autoTable({
    startY: 130,
    columns,
    body: pdfRows,
    theme: 'grid',
    styles: {
      font: 'helvetica',
      fontSize: 10,
      textColor: bodyText,
      cellPadding: 4,
      fillColor: tableFill,
      lineColor,
      lineWidth: 0.5,
      valign: 'middle',
    },
    columnStyles: {
      item: { cellWidth: colWidths.item, halign: 'left' },
      partnerA: { cellWidth: colWidths.partnerA, halign: 'center' },
      match: { cellWidth: colWidths.match, halign: 'center' },
      flag: { cellWidth: colWidths.flag, halign: 'center' },
      partnerB: { cellWidth: colWidths.partnerB, halign: 'center' },
    },
    headStyles: {
      fillColor: [17, 17, 17],
      textColor: accent,
      fontStyle: 'bold',
      halign: 'center',
    },
    margin: { top: 130, left: margin, right: margin },
    didDrawPage: () => {
      drawPageFrame();
    },
  });

  doc.save(tkCompatBuildFileName());
}

async function TKPDF_exportCompatibilitySingle() {
  try {
    await tkEnsureJsPDF();
  } catch (err) {
    console.error('jsPDF not loaded ‚Äì make sure jsPDF UMD is included before this file.', err);
    alert('PDF library not loaded; cannot export.');
    return;
  }

  if (!(window.jspdf && window.jspdf.jsPDF)) {
    console.error('jsPDF not loaded ‚Äì make sure jsPDF UMD is included before this file.');
    alert('PDF library not loaded; cannot export.');
    return;
  }
  if (!window.jspdf.jsPDF.API.autoTable) {
    console.error('autoTable plugin not loaded.');
    alert('autoTable plugin not loaded; cannot export.');
    return;
  }

  try {
    const compatRows = tkCollectCompatRowsForPdf();
    const categories = tkBuildPdfCategories(compatRows);
    await tkGeneratePdfFromCategories(categories);
  } catch (err) {
    console.error('[TKPDF] Failed to export compatibility report.', err);
    alert('PDF export failed. See console for details.');
  }
}

function tkBindCompatibilityDownload() {
  const btn = document.getElementById('downloadBtn') || document.getElementById('downloadPdfBtn');
  if (!btn) {
    console.warn('[TK] downloadBtn not found for compatibility export.');
    return;
  }

  btn.onclick = null;

  const parent = btn.parentNode;
  if (!parent) {
    console.warn('[TK] download button has no parent node; cannot rebind.');
    return;
  }

  const clone = btn.cloneNode(true);
  parent.replaceChild(clone, btn);

  clone.addEventListener('click', function (e) {
    e.preventDefault();
    e.stopPropagation();
    TKPDF_exportCompatibilitySingle();
  });

  console.log('[TK] Bound single compatibility PDF exporter to #downloadBtn');
}

if (typeof window !== 'undefined') {
  window.TKPDF_exportCompatibilitySingle = TKPDF_exportCompatibilitySingle;
  window.TKPDF_export = TKPDF_exportCompatibilitySingle;
  window.tkBindCompatibilityDownload = tkBindCompatibilityDownload;
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', tkBindCompatibilityDownload, { once: true });
} else {
  tkBindCompatibilityDownload();
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Defensive renderer hot-fix
   - prevents duplicate renders/tables
   - cleans up stray thead copies
   - normalises flag glyphs & column sizing
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
(() => {
  const HOTFIX_LOCK = '__TK_COMPAT_RENDER_LOCK__';
  if (window[HOTFIX_LOCK]) return;
  window[HOTFIX_LOCK] = true;

  const table = document.getElementById('compatTable');
  if (!table) return;

  const parser = new DOMParser();

  function decodeEntities(value){
    if (!value || !value.includes('&')) return value;
    let current = value;
    let previous;
    do {
      previous = current;
      current = parser.parseFromString(previous, 'text/html').documentElement
        .textContent;
    } while (current !== previous && current.includes('&'));
    return current.replace(/&+‚Ä†/g, '‚Ä†');
  }

  function purgeDuplicateTables(){
    const allTables = Array.from(document.querySelectorAll('table.compat'));
    const keep = allTables.find(t => t.id === 'compatTable') || allTables[0];
    allTables.forEach(t => {
      if (t !== keep) t.remove();
    });
    return keep;
  }

  function ensureSingleThead(tbl){
    const theads = Array.from(tbl.querySelectorAll('thead'));
    theads.slice(1).forEach(t => t.remove());
    const head = theads[0];
    if (!head) return;
    if (!head.querySelector('tr')) head.remove();
  }

  function retuneLayout(tbl){
    tbl.style.width = '100%';
    tbl.style.tableLayout = 'fixed';

    const headCells = tbl.querySelectorAll('thead th');
    headCells.forEach((th, idx) => {
      th.style.textAlign = idx === 0 ? 'left' : 'center';
      th.style.borderBottom = '1px solid var(--grid)';
      th.style.textShadow = '0 0 0 var(--bg), 0 0 12px rgba(0,231,255,.22)';
    });
  }

  function normaliseCells(tbl){
    const rows = tbl.querySelectorAll('tbody tr');
    rows.forEach(row => {
      const cells = row.querySelectorAll('td');
      if (!cells.length) return;

      const decodedCells = Array.from(cells, cell => decodeEntities(cell.textContent.trim()));
      const aScore = tkParseScore(decodedCells[1]);
      const bScore = tkParseScore(decodedCells[3]);
      const matchPct = tkParseMatchPercent(decodedCells[2]);

      cells.forEach((cell, idx) => {
        const decoded = decodedCells[idx] ?? '';
        cell.textContent = decoded;
        cell.style.background = '';
      });
    });
  }

  const activeTable = purgeDuplicateTables() || table;
  if (!activeTable) return;

  ensureSingleThead(activeTable);
  retuneLayout(activeTable);
  normaliseCells(activeTable);
})();

/* --------------------------------------------------------------
 * TalkKink compatibility overrides
 * - Remove the Flag column from the on-page comparison table.
 * - Stop the legacy PDF from firing so only the ‚Äúweb‚Äù PDF runs.
 *   (We re-wire the Download button to call TKCompatPDF only.)
 * -------------------------------------------------------------- */

(function () {
  /* Remove the "Flag" column from the DOM table
     (affects BOTH the on-page view and any PDF that clones the table). */
  function removeFlagColumn() {
    // Adjust selector if your comparison table has a specific id
    const table =
      document.querySelector('#compatTable') ||
      document.querySelector('#comparisonTable') ||
      document.querySelector('table');

    if (!table) {
      console.warn('[TK-compat] No compatibility table found to strip Flag column.');
      return;
    }

    const headRow = table.querySelector('thead tr');
    if (!headRow) return;

    const headCells = Array.from(headRow.cells);
    const flagIndex = headCells.findIndex(th =>
      th.textContent.trim().toLowerCase() === 'flag'
    );
    if (flagIndex === -1) {
      // Already removed, nothing to do
      return;
    }

    // Delete the "Flag" cell from every row (header + body + footer)
    Array.from(table.rows).forEach(row => {
      if (row.cells[flagIndex]) {
        row.deleteCell(flagIndex);
      }
    });

    console.info('[TK-compat] Removed Flag column from compatibility table.');
  }

  /* Re-wire the Download button so ONLY the new TKCompatPDF exporter runs.
     This prevents the old legacy generator from opening a second PDF. */
  function rewireDownloadButton() {
    const btn = document.querySelector(
      '#downloadPdfBtn, #downloadBtn, [data-download-pdf]'
    );
    if (!btn) {
      console.warn('[TK-compat] No Download PDF button found to rewire.');
      return;
    }

    // Clone the button to strip inline onclick + legacy listeners
    const clone = btn.cloneNode(true);
    clone.removeAttribute('onclick');

    clone.addEventListener('click', function (e) {
      e.preventDefault();

      if (
        window.TKCompatPDF &&
        typeof window.TKCompatPDF.download === 'function'
      ) {
        window.TKCompatPDF.download();
        return;
      }

      console.warn(
        '[TK-compat] TKCompatPDF not available; Download button is now a no-op.'
      );
    });

    btn.parentNode.replaceChild(clone, btn);
    console.info('[TK-compat] Download button re-wired to TKCompatPDF only.');
  }

  /* Hard-disable any legacy global generator just in case something still calls it. */
  window.generateDarkPDF = function () {
    console.info('[TK-compat] Legacy generateDarkPDF is disabled on this page.');
    // No-op: old PDF should not run any more.
  };

  // Run once when the DOM is ready
  function init() {
    removeFlagColumn();
    rewireDownloadButton();
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init, { once: true });
  } else {
    init();
  }
})();
</script>
</body>
</html>
