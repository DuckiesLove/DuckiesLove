<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TalkKink Compatibility</title>
<style>
  :root{
    --bg:#0e0f11;            /* page background */
    --panel:#0b0c0d;         /* table banding base */
    --row:#111315;           /* row color */
    --row-alt:#0f1012;       /* zebra */
    --ink:#e6feff;           /* main text */
    --ink-dim:#b8dfe0;
    --accent:#00e7ff;        /* teal glow */
    --grid:#23292d;          /* table lines */
  }
  html,body{height:100%;}
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
  }
  .page{
    max-width:1120px;
    margin:28px auto 48px;
    padding:0 16px;
  }

  /* Centered, outlined headings (like before) */
  .title, .subtitle, .section {
    text-align:center;
    margin:0;
  }
  .title{
    font-size:56px; line-height:1.05; font-weight:800; letter-spacing:.5px;
    color:var(--accent);
    /* outline with soft glow */
    text-shadow:
      0 0 0 var(--bg),
      0 0 18px rgba(0,231,255,.35),
      0 0 40px rgba(0,231,255,.25);
    -webkit-font-smoothing:antialiased;
  }
  .subtitle{
    margin-top:10px; font-size:20px; color:var(--ink-dim);
  }
  .hr { height:3px; background:var(--accent); margin:18px auto 14px; max-width:92%; opacity:.85; }

  .section{
    font-size:44px; font-weight:800; color:var(--accent); margin:12px 0 10px;
    text-shadow:
      0 0 0 var(--bg),
      0 0 14px rgba(0,231,255,.25),
      0 0 28px rgba(0,231,255,.18);
  }

  /* Table fills the page, no white boxes */
  .compat{
    width:100%; border-collapse:separate; border-spacing:0;
    background:transparent; table-layout:fixed;
  }
  .compat col.label   { width:53%; }
  .compat col.a       { width:12%; }
  .compat col.match   { width:16%; }
  .compat col.flag    { width:7%; }    /* give "Flag" breathing room */
  .compat col.b       { width:12%; }

  .compat thead th{
    position:sticky; top:0; z-index:1;
    background:#0f1215;
    color:var(--accent); font-weight:800; font-size:20px; padding:14px 12px;
    border-bottom:1px solid var(--grid);
    text-align:center;
    /* give the header the outlined look, too */
    text-shadow:
      0 0 0 var(--bg),
      0 0 12px rgba(0,231,255,.22);
  }
  .compat thead th:first-child{ text-align:left; }

  .compat tbody td{
    padding:14px 12px; font-size:19px; line-height:1.3; color:var(--ink);
    border-bottom:1px solid #151a1e; background:var(--row);
  }
  .compat tbody tr:nth-child(2n) td{ background:var(--row-alt); }
  .compat tbody td.label{ color:var(--ink); }
  .compat tbody td.num, .compat tbody td.match, .compat tbody td.flag{
    text-align:center; white-space:nowrap;
  }
  .compat tbody td.flag{
    text-align:center; letter-spacing:.5px; color:var(--ink-dim);
  }

  /* Download button */
  .bar { display:flex; gap:12px; justify-content:center; margin:18px 0 6px; }
  .btn {
    appearance:none; border:none; border-radius:12px; padding:10px 16px;
    background:#0f1d22; color:var(--ink); font-weight:700; cursor:pointer;
    box-shadow:0 0 0 1px rgba(0,231,255,.25), 0 6px 20px rgba(0,231,255,.12) inset;
  }
  .btn:hover{ box-shadow:0 0 0 1px rgba(0,231,255,.5), 0 0 18px rgba(0,231,255,.18) inset; }

  /* make sure the whole sheet breathes to edges on small screens */
  @media (max-width:880px){
    .title{ font-size:44px; }
    .section{ font-size:34px; }
    .compat thead th, .compat tbody td{ font-size:18px; }
    .compat col.label{ width:51%; }
    .compat col.match{ width:17%; }
    .compat col.flag { width:8%; }
  }
</style>
</head>
<body>
  <div class="page" id="app">
    <h1 class="title">TalkKink Compatibility</h1>
    <p class="subtitle" id="ts">Generated: â€”</p>
    <div class="hr"></div>
    <h2 class="section">Behavioral Play</h2>

    <div class="bar"><button id="downloadPdfBtn" class="btn">Download PDF</button></div>

    <table class="compat" id="compatTable" aria-label="Compatibility table">
      <colgroup>
        <col class="label"><!-- Item -->
        <col class="a">    <!-- Partner A -->
        <col class="match"><!-- Match -->
        <col class="flag"><!-- Flag -->
        <col class="b">    <!-- Partner B -->
      </colgroup>
      <thead>
        <tr>
          <th>Item</th>
          <th>Partner A</th>
          <th>Match</th>
          <th>Flag</th>
          <th>Partner B</th>
        </tr>
      </thead>
      <tbody id="compatBody"><!-- rows injected --></tbody>
    </table>
  </div>

<script>
const TK_FLAG_GREEN = "ðŸŸ©";
const TK_FLAG_YELLOW = "ðŸŸ¨";
const TK_FLAG_RED = "ðŸŸ¥";

function tkGetFlagSquare(row) {
  if (!row || !row.hasData) return "";

  const match = typeof row.matchPct === "number" ? row.matchPct : 0;
  const a = row.aScore;
  const b = row.bScore;
  if (a == null || b == null) return "";

  const diff = Math.abs(a - b);

  if (match <= 30 || (a <= 1 && b >= 4) || (b <= 1 && a >= 4)) {
    return TK_FLAG_RED;
  }

  if (diff >= 3 || (a === 5 && b <= 3) || (b === 5 && a <= 3)) {
    return TK_FLAG_YELLOW;
  }

  if (match >= 80) {
    return TK_FLAG_GREEN;
  }

  return "";
}

function tkCoerceNumber(value) {
  if (value === null || value === undefined) return null;
  if (typeof value === "number" && Number.isFinite(value)) return value;
  const trimmed = String(value).trim();
  if (!trimmed) return null;
  const direct = Number(trimmed);
  if (Number.isFinite(direct)) return direct;
  const numeric = Number(trimmed.replace(/[^0-9.+-]/g, ""));
  return Number.isFinite(numeric) ? numeric : null;
}

function tkParseScore(value) {
  const num = tkCoerceNumber(value);
  if (num == null) return null;
  if (!Number.isFinite(num)) return null;
  return Math.max(0, Math.min(5, num));
}

function tkParseMatchPercent(value) {
  const num = tkCoerceNumber(value);
  if (num == null) return null;
  if (!Number.isFinite(num)) return null;
  return Math.max(0, Math.min(100, num));
}

function tkFormatPercent(value) {
  if (!Number.isFinite(value)) return "";
  const clamped = Math.max(0, Math.min(100, value));
  const rounded = Number.isInteger(clamped) ? clamped : Number(clamped.toFixed(1));
  return `${rounded}%`;
}

function tkFormatScoreDisplay(value) {
  if (value === null || value === undefined) return "";
  const str = String(value).trim();
  return str;
}

function tkFormatMatchDisplay(raw, parsed) {
  if (raw !== undefined && raw !== null) {
    const rawStr = String(raw).trim();
    if (rawStr) {
      if (/%/.test(rawStr)) return rawStr;
      const numeric = tkCoerceNumber(rawStr);
      if (Number.isFinite(numeric)) return tkFormatPercent(numeric);
      if (Number.isFinite(parsed)) return tkFormatPercent(parsed);
      return rawStr;
    }
  }
  if (Number.isFinite(parsed)) return tkFormatPercent(parsed);
  return "";
}

function tkNormalizeCompatRow(entry) {
  if (!entry) return null;

  let label;
  let labelShort;
  let aRaw;
  let bRaw;
  let matchRaw;
  let hasData;

  if (Array.isArray(entry)) {
    [label, aRaw, matchRaw, , bRaw] = entry;
  } else if (typeof entry === "object") {
    label = entry.label ?? entry.item ?? entry.title ?? "";
    labelShort = entry.labelShort ?? entry.shortLabel ?? entry.short ?? null;
    aRaw = entry.aScore ?? entry.a ?? entry.partnerA ?? entry.aValue ?? entry.a_score;
    bRaw = entry.bScore ?? entry.b ?? entry.partnerB ?? entry.bValue ?? entry.b_score;
    matchRaw = entry.matchPct ?? entry.match ?? entry.matchValue ?? entry.matchPercent ?? entry.matchPercentage ?? entry.matchScore;
    hasData = typeof entry.hasData === "boolean" ? entry.hasData : undefined;
  } else {
    return null;
  }

  const aScore = tkParseScore(aRaw);
  const bScore = tkParseScore(bRaw);
  const matchPct = tkParseMatchPercent(matchRaw);

  if (typeof hasData !== "boolean") {
    hasData = Number.isFinite(aScore) || Number.isFinite(bScore);
  }

  return {
    label: label ?? "",
    labelShort: labelShort || null,
    aScore,
    bScore,
    matchPct,
    matchRaw,
    aDisplay: tkFormatScoreDisplay(aRaw ?? aScore),
    bDisplay: tkFormatScoreDisplay(bRaw ?? bScore),
    matchDisplay: tkFormatMatchDisplay(matchRaw, matchPct),
    hasData,
  };
}

const TK_PDF_TITLE = "Talk Kink Compatibility Survey";

if (typeof window !== 'undefined') {
  window.tkGetFlagSquare = tkGetFlagSquare;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   One-time bootstrap (prevents â€œdouble loadingâ€)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
(() => {
  if (window.__TK_ONE_TIME_INIT__) return;  // hard lock
  window.__TK_ONE_TIME_INIT__ = true;

  /* Timestamp */
  const ts = new Date();
  document.getElementById('ts').textContent =
    'Generated: ' + ts.toLocaleString();

  /* Demo source (will be replaced if live globals/localStorage exist) */
  const TK_COMPAT_CACHE_VERSION = 'v3'; // bump when schema or fallback changes
  const LS_VERSION_KEY = 'talkkink:compatRows:ver';

  const noCache = /(^|[?&])nocache(=1|&|$)/.test(location.search);
  const storedVer = localStorage.getItem(LS_VERSION_KEY);

  if (noCache || storedVer !== TK_COMPAT_CACHE_VERSION){
    delete window.talkkinkCompatRows;
    ['talkkink:compatRows','talkkink:survey','talkkink:mine','talkkink:partner']
      .forEach(k => localStorage.removeItem(k));
    Object.keys(localStorage).forEach(k => {
      if (/^tk_compat\./.test(k)) localStorage.removeItem(k);
    });
    localStorage.setItem(LS_VERSION_KEY, TK_COMPAT_CACHE_VERSION);
  }

  const HARD_CODED_COMPAT_ROWS = [
    ['Giving: Assigning corner time or time-outs', 0, 100, '', 0],
    ['General: Attitude toward funishment vs serious correction', 3, 100, '', 3],
    ['Receiving: Being placed in the corner or given a time-out', 5, 100, '', 5],
    ['Receiving: Getting scolded or lectured for correction', 5, 100, '', 5],
    ['Receiving: Having privileges revoked (phone, TV)', 3, 100, '', 3],
    ['Giving: Lecturing or scolding to modify behavior', 4, 100, '', 4],
    ['Giving: Playful punishments that still reinforce rules', 3, 100, '', 3],
    ['General: Preferred style of discipline (strict vs lenient)', 4, 100, '', 4],
    ['Receiving: Playful \"f\" punishments for minor rule-breaking', 2, 100, '', 2],
    ['Giving: Removing privileges (phone, TV, sweets)', 2, 100, '', 2],
    ['General: Use of behavior contracts or rule agreements', 2, 100, '', 2],
    ['Giving: Writing lines or apology letters as correction', 1, 100, '', 1],
    ['Receiving: Writing lines or apology letters when misbehaving', 4, 100, '', 4],
  ];

  /* Source resolution: use live globals if present, else localStorage, else fallback */
  function pickRows(){
    if (Array.isArray(window.talkkinkCompatRows) && window.talkkinkCompatRows.length){
      return window.talkkinkCompatRows;
    }
    try{
      const cached = JSON.parse(localStorage.getItem('talkkink:compatRows') || 'null');
      if (Array.isArray(cached) && cached.length) return cached;
    }catch{}
    return HARD_CODED_COMPAT_ROWS;
  }

  /* Render into DOM (single-run; we clear body first to avoid doubles) */
  const TBODY = document.getElementById('compatBody');
  function renderTable(rows){
    TBODY.replaceChildren();
    const toText = (value) => (value === undefined || value === null ? '' : String(value));

    for (const row of rows){
      if (!row) continue;
      const tr = document.createElement('tr');
      const flag = tkGetFlagSquare(row);
      const matchText = row.matchDisplay || tkFormatMatchDisplay(row.matchRaw, row.matchPct);
      const cells = [
        ['label', row.label],
        ['num',   row.aDisplay ?? (Number.isFinite(row.aScore) ? String(row.aScore) : '')],
        ['match', matchText],
        ['flag',  flag],
        ['num',   row.bDisplay ?? (Number.isFinite(row.bScore) ? String(row.bScore) : '')],
      ];

      for (const [cls, value] of cells){
        const td = document.createElement('td');
        td.className = cls;
        td.textContent = toText(value);
        tr.appendChild(td);
      }

      TBODY.appendChild(tr);
    }
  }

  const compatRows = pickRows().map(tkNormalizeCompatRow).filter(Boolean);
  renderTable(compatRows);

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     PDF EXPORT
     - Loads local vendor files first to dodge â€œTracking Prevention blockedâ€¦â€
     - Falls back to jsDelivr only if allowed in the browser
     - Keeps centered headings and gives them a crisp â€œoutlinedâ€ look.
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  async function loadJsPDF(){
    if (window.jspdf && window.jspdf.jsPDF && window.jspdf.jsPDF.API.autoTable) return;

    // prefer local copies to avoid third-party storage blocking
    const localScripts = [
      '/vendor/jspdf.umd.min.js',
      '/vendor/jspdf.plugin.autotable.min.js'
    ];
    const cdnScripts = [
      'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js',
      'https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js'
    ];

    async function inject(src){
      await new Promise((resolve,reject)=>{
        const s = document.createElement('script');
        s.src = src; s.async = true; s.onload = resolve; s.onerror = reject;
        document.head.appendChild(s);
      });
    }

    // try local
    try { for (const s of localScripts) await inject(s); }
    catch(e){ /* ignore; will try CDN */ }

    // if still not available, try CDN (may be blocked by Tracking Prevention)
    if (!(window.jspdf && window.jspdf.jsPDF)){
      try { for (const s of cdnScripts) await inject(s); }
      catch(e){ /* final failure handled below */ }
    }

    if (!(window.jspdf && window.jspdf.jsPDF && window.jspdf.jsPDF.API.autoTable)){
      throw new Error('jsPDF/AutoTable not available. Host local copies in /vendor or allow the CDN.');
    }
  }

  async function TKPDF_export(){
    await loadJsPDF();
    const { jsPDF } = window.jspdf;

    const doc = new jsPDF('landscape', 'pt', 'a4');
    const pageWidth = doc.internal.pageSize.getWidth();

    doc.setFont('helvetica', 'bold');
    doc.setFontSize(26);
    doc.text(TK_PDF_TITLE, pageWidth / 2, 60, { align: 'center' });

    doc.setFontSize(14);
    doc.setFont('helvetica', 'normal');
    const generatedAt = new Date().toLocaleString();
    doc.text(`Generated: ${generatedAt}`, pageWidth / 2, 82, { align: 'center' });

    const bodyRows = compatRows.map((row) => {
      const flag = tkGetFlagSquare(row);
      const matchText = row.matchDisplay || tkFormatMatchDisplay(row.matchRaw, row.matchPct);
      return [
        row.labelShort || row.label,
        row.aDisplay ?? (Number.isFinite(row.aScore) ? String(row.aScore) : ''),
        matchText,
        flag,
        row.bDisplay ?? (Number.isFinite(row.bScore) ? String(row.bScore) : ''),
      ].map((value) => (value === undefined || value === null ? '' : String(value)));
    });

    doc.autoTable({
      head: [["Item", "Partner A", "Match", "Flag", "Partner B"]],
      body: bodyRows,
      startY: 110,
      styles: {
        font: 'helvetica',
        fontSize: 10,
      },
      headStyles: {
        fillColor: [0, 255, 255],
        textColor: [0, 0, 0],
        halign: 'center',
      },
      columnStyles: {
        0: { cellWidth: 260 },
        1: { halign: 'center', cellWidth: 60 },
        2: { halign: 'center', cellWidth: 70 },
        3: { halign: 'center', cellWidth: 50 },
        4: { halign: 'center', cellWidth: 60 },
      },
    });

    doc.save('TalkKink-Compatibility-Report.pdf');
  }

  document.getElementById('downloadPdfBtn')?.addEventListener('click', TKPDF_export, { once:false });

  if (typeof window !== 'undefined') {
    window.TKPDF_export = TKPDF_export;
  }
})();

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Defensive renderer hot-fix
   - prevents duplicate renders/tables
   - cleans up stray thead copies
   - normalises flag glyphs & column sizing
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
(() => {
  const HOTFIX_LOCK = '__TK_COMPAT_RENDER_LOCK__';
  if (window[HOTFIX_LOCK]) return;
  window[HOTFIX_LOCK] = true;

  const table = document.getElementById('compatTable');
  if (!table) return;

  const parser = new DOMParser();

  function decodeEntities(value){
    if (!value || !value.includes('&')) return value;
    let current = value;
    let previous;
    do {
      previous = current;
      current = parser.parseFromString(previous, 'text/html').documentElement
        .textContent;
    } while (current !== previous && current.includes('&'));
    return current.replace(/&+â€ /g, 'â€ ');
  }

  function purgeDuplicateTables(){
    const allTables = Array.from(document.querySelectorAll('table.compat'));
    const keep = allTables.find(t => t.id === 'compatTable') || allTables[0];
    allTables.forEach(t => {
      if (t !== keep) t.remove();
    });
    return keep;
  }

  function ensureSingleThead(tbl){
    const theads = Array.from(tbl.querySelectorAll('thead'));
    theads.slice(1).forEach(t => t.remove());
    const head = theads[0];
    if (!head) return;
    if (!head.querySelector('tr')) head.remove();
  }

  function retuneLayout(tbl){
    tbl.style.width = '100%';
    tbl.style.tableLayout = 'fixed';

    const flagCol = tbl.querySelector('col.flag');
    if (flagCol) flagCol.style.width = '6%';

    const headCells = tbl.querySelectorAll('thead th');
    headCells.forEach((th, idx) => {
      th.style.textAlign = idx === 0 ? 'left' : 'center';
      th.style.borderBottom = '1px solid var(--grid)';
      th.style.textShadow = '0 0 0 var(--bg), 0 0 12px rgba(0,231,255,.22)';
    });
  }

  function normaliseCells(tbl){
    const rows = tbl.querySelectorAll('tbody tr');
    rows.forEach(row => {
      const cells = row.querySelectorAll('td');
      if (!cells.length) return;

      const decodedCells = Array.from(cells, cell => decodeEntities(cell.textContent.trim()));
      const aScore = tkParseScore(decodedCells[1]);
      const bScore = tkParseScore(decodedCells[4]);
      const matchPct = tkParseMatchPercent(decodedCells[2]);
      const rowData = {
        aScore,
        bScore,
        matchPct,
        hasData: Number.isFinite(aScore) || Number.isFinite(bScore),
      };
      const computedFlag = tkGetFlagSquare(rowData);

      cells.forEach((cell, idx) => {
        const decoded = decodedCells[idx] ?? '';
        if (idx === 3){
          const glyph = computedFlag || decoded.replace(/&+/g, '').trim();
          cell.textContent = glyph;
          cell.style.textAlign = 'center';
          cell.style.letterSpacing = '.5px';
        }else{
          cell.textContent = decoded;
        }
        cell.style.background = '';
      });
    });
  }

  const activeTable = purgeDuplicateTables() || table;
  if (!activeTable) return;

  ensureSingleThead(activeTable);
  retuneLayout(activeTable);
  normaliseCells(activeTable);
})();
</script>
</body>
</html>
