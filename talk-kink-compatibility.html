<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TalkKink Compatibility</title>
<style>
  :root{
    --bg:#0e0f11;            /* page background */
    --panel:#0b0c0d;         /* table banding base */
    --row:#111315;           /* row color */
    --row-alt:#0f1012;       /* zebra */
    --ink:#e6feff;           /* main text */
    --ink-dim:#b8dfe0;
    --accent:#00e7ff;        /* teal glow */
    --grid:#23292d;          /* table lines */
  }
  html,body{height:100%;}
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
  }
  .page{
    max-width:1120px;
    margin:28px auto 48px;
    padding:0 16px;
  }

  /* Centered, outlined headings (like before) */
  .title, .subtitle, .section {
    text-align:center;
    margin:0;
  }
  .title{
    font-size:56px; line-height:1.05; font-weight:800; letter-spacing:.5px;
    color:var(--accent);
    /* outline with soft glow */
    text-shadow:
      0 0 0 var(--bg),
      0 0 18px rgba(0,231,255,.35),
      0 0 40px rgba(0,231,255,.25);
    -webkit-font-smoothing:antialiased;
  }
  .subtitle{
    margin-top:10px; font-size:20px; color:var(--ink-dim);
  }
  .hr { height:3px; background:var(--accent); margin:18px auto 14px; max-width:92%; opacity:.85; }

  .section{
    font-size:44px; font-weight:800; color:var(--accent); margin:12px 0 10px;
    text-shadow:
      0 0 0 var(--bg),
      0 0 14px rgba(0,231,255,.25),
      0 0 28px rgba(0,231,255,.18);
  }

  /* Table fills the page, no white boxes */
  .compat{
    width:100%; border-collapse:separate; border-spacing:0;
    background:transparent; table-layout:fixed;
  }
  .compat col.label   { width:56%; }
  .compat col.a       { width:12%; }
  .compat col.match   { width:20%; }
  .compat col.b       { width:12%; }

  .compat thead th{
    position:sticky; top:0; z-index:1;
    background:#0f1215;
    color:var(--accent); font-weight:800; font-size:20px; padding:14px 12px;
    border-bottom:1px solid var(--grid);
    text-align:center;
    /* give the header the outlined look, too */
    text-shadow:
      0 0 0 var(--bg),
      0 0 12px rgba(0,231,255,.22);
  }
  .compat thead th:first-child{ text-align:left; }

  .compat tbody td{
    padding:14px 12px; font-size:19px; line-height:1.3; color:var(--ink);
    border-bottom:1px solid #151a1e; background:var(--row);
  }
  .compat tbody tr:nth-child(2n) td{ background:var(--row-alt); }
  .compat tbody td.label{ color:var(--ink); }
  .compat tbody td.num, .compat tbody td.match{
    text-align:center; white-space:nowrap;
  }

  .sr-only{
    position:absolute;
    width:1px;
    height:1px;
    padding:0;
    margin:-1px;
    overflow:hidden;
    clip:rect(0, 0, 0, 0);
    white-space:nowrap;
    border:0;
  }

  /* Download button */
  .bar { display:flex; gap:12px; justify-content:center; margin:18px 0 6px; }
  .btn {
    appearance:none; border:none; border-radius:12px; padding:10px 16px;
    background:#0f1d22; color:var(--ink); font-weight:700; cursor:pointer;
    box-shadow:0 0 0 1px rgba(0,231,255,.25), 0 6px 20px rgba(0,231,255,.12) inset;
  }
  .btn:hover{ box-shadow:0 0 0 1px rgba(0,231,255,.5), 0 0 18px rgba(0,231,255,.18) inset; }

  /* make sure the whole sheet breathes to edges on small screens */
  @media (max-width:880px){
    .title{ font-size:44px; }
    .section{ font-size:34px; }
    .compat thead th, .compat tbody td{ font-size:18px; }
    .compat col.label{ width:51%; }
    .compat col.match{ width:17%; }
  }
</style>
</head>
<body>
  <div class="page" id="app">
    <h1 class="title">TalkKink Compatibility</h1>
    <p class="subtitle" id="ts">Generated: â€”</p>
    <div class="hr"></div>
    <h2 class="section">Behavioral Play</h2>

    <div class="bar"><button id="downloadBtn" class="btn">Download PDF</button></div>

    <table class="compat" id="compatTable" aria-label="Compatibility table">
      <colgroup>
        <col class="label"><!-- Item -->
        <col class="a">    <!-- Partner A -->
        <col class="match"><!-- Match -->
        <col class="b">    <!-- Partner B -->
      </colgroup>
      <thead>
        <tr>
          <th>Item</th>
          <th>Partner A</th>
          <th>Match</th>
          <th>Partner B</th>
        </tr>
      </thead>
      <tbody id="compatBody"><!-- rows injected --></tbody>
    </table>
  </div>

<script>
const FLAG_META = {
  green:  { emoji: "ðŸŸ©", label: "High match", color: "#18d69a" },
  yellow: { emoji: "ðŸŸ¨", label: "Needs discussion", color: "#ffcc00" },
  red:    { emoji: "ðŸŸ¥", label: "Conflict", color: "#ff4242" }
};

const FLAG_EMOJI_TO_STATUS = Object.fromEntries(
  Object.entries(FLAG_META).map(([status, meta]) => [meta.emoji, status])
);

Object.assign(FLAG_EMOJI_TO_STATUS, {
  "ðŸŸ¢": "green",
  "ðŸŸ¡": "yellow",
  "ðŸ”´": "red",
  "ðŸŸ ": "yellow"
});

function tkFlagFromScores(matchPct, aScore, bScore) {
  if (
    matchPct == null ||
    aScore == null ||
    bScore == null
  ) return "";

  const diff = Math.abs(aScore - bScore);

  if (
    matchPct <= 30 ||
    (aScore <= 1 && bScore >= 4) ||
    (bScore <= 1 && aScore >= 4)
  ) {
    return FLAG_META.red.emoji;
  }

  if (
    diff >= 3 ||
    (aScore === 5 && bScore <= 3) ||
    (bScore === 5 && aScore <= 3)
  ) {
    return FLAG_META.yellow.emoji;
  }

  if (matchPct >= 80) {
    return FLAG_META.green.emoji;
  }

  return "";
}

function tkNormalizeFlagStatus(value) {
  if (value == null) return null;
  if (typeof value === "number") {
    if (value >= 80) return "green";
    if (value >= 50) return "yellow";
    return "red";
  }

  const str = String(value).trim();
  if (!str) return null;

  if (FLAG_EMOJI_TO_STATUS[str]) return FLAG_EMOJI_TO_STATUS[str];

  const lower = str.toLowerCase();
  if (FLAG_META[lower]) return lower;
  if (/perfect|great|strong|aligned|excellent/.test(lower)) return "green";
  if (/warn|caution|mixed|medium|maybe/.test(lower)) return "yellow";
  if (/conflict|bad|low|danger|problem|issue|concern|poor/.test(lower)) return "red";

  return null;
}

function tkParseFlagColor(color) {
  if (!color) return null;
  if (Array.isArray(color)) {
    const [r, g, b] = color.map((n) => Math.max(0, Math.min(255, Number(n) || 0)));
    return `#${[r, g, b].map((n) => n.toString(16).padStart(2, "0")).join("")}`;
  }

  const str = String(color).trim();
  if (!str) return null;

  const hexMatch = str.match(/^#?([0-9a-f]{6})$/i);
  if (hexMatch) return `#${hexMatch[1].toLowerCase()}`;

  const rgbMatch = str.match(/rgb\s*\((\d+)[,\s]+(\d+)[,\s]+(\d+)/i);
  if (rgbMatch) {
    return `#${[rgbMatch[1], rgbMatch[2], rgbMatch[3]]
      .map((part) => Math.max(0, Math.min(255, Number(part) || 0)).toString(16).padStart(2, "0"))
      .join("")}`;
  }

  return null;
}

function tkGuessStatusFromColor(hex) {
  if (!hex) return null;
  const value = hex.replace("#", "");
  if (value.length !== 6) return null;

  const r = parseInt(value.slice(0, 2), 16);
  const g = parseInt(value.slice(2, 4), 16);
  const b = parseInt(value.slice(4, 6), 16);

  if (r > 210 && g < 140) return "red";
  if (r > 210 && g > 170 && b < 140) return "yellow";
  if (g > 170 && b > 110 && r < 150) return "green";

  return null;
}

function tkResolveFlagInfo(row = {}) {
  if (row.hasData === false) {
    return { emoji: "", status: null, color: null, matchPct: null, aScore: null, bScore: null };
  }

  const matchPct = Number.isFinite(row.matchPct)
    ? row.matchPct
    : tkParseMatchPercent(row.matchRaw);

  const aScore = Number.isFinite(row.aScore)
    ? row.aScore
    : tkParseScore(row.aDisplay ?? row.a ?? row.partnerA);

  const bScore = Number.isFinite(row.bScore)
    ? row.bScore
    : tkParseScore(row.bDisplay ?? row.b ?? row.partnerB);

  const rawFlag = row.flagEmoji ?? row.flagGlyph ?? row.flagRaw ?? row.flag ?? row.flagText ?? null;
  let status =
    tkNormalizeFlagStatus(row.flagStatus) ||
    tkNormalizeFlagStatus(rawFlag) ||
    tkNormalizeFlagStatus(row.flagLabel) ||
    null;

  let color =
    tkParseFlagColor(row.flagColor) ||
    tkParseFlagColor(row.flagColour) ||
    tkParseFlagColor(row.flagRGB) ||
    tkParseFlagColor(row.flagRgb) ||
    tkParseFlagColor(row.flagHex) ||
    null;

  if (!status && color) {
    status = tkGuessStatusFromColor(color);
  }

  let emoji = typeof rawFlag === "string" ? rawFlag.trim() : "";

  if (!status || !emoji || !FLAG_EMOJI_TO_STATUS[emoji]) {
    const computedEmoji = tkFlagFromScores(matchPct, aScore, bScore);
    if (computedEmoji) {
      if (!emoji) emoji = computedEmoji;
      if (!status) status = tkNormalizeFlagStatus(computedEmoji);
    }
  }

  if (status && (!emoji || !FLAG_EMOJI_TO_STATUS[emoji])) {
    emoji = FLAG_META[status]?.emoji || emoji;
  }

  if (status && !color) {
    color = FLAG_META[status]?.color || null;
  }

  return { emoji: emoji || "", status: status || null, color, matchPct, aScore, bScore };
}

function tkGetFlagSquare(row) {
  return tkResolveFlagInfo(row).emoji;
}

function tkCoerceNumber(value) {
  if (value === null || value === undefined) return null;
  if (typeof value === "number" && Number.isFinite(value)) return value;
  const trimmed = String(value).trim();
  if (!trimmed) return null;
  const direct = Number(trimmed);
  if (Number.isFinite(direct)) return direct;
  const numeric = Number(trimmed.replace(/[^0-9.+-]/g, ""));
  return Number.isFinite(numeric) ? numeric : null;
}

function tkParseScore(value) {
  const num = tkCoerceNumber(value);
  if (num == null) return null;
  if (!Number.isFinite(num)) return null;
  return Math.max(0, Math.min(5, num));
}

function tkParseMatchPercent(value) {
  const num = tkCoerceNumber(value);
  if (num == null) return null;
  if (!Number.isFinite(num)) return null;
  return Math.max(0, Math.min(100, num));
}

function tkFormatPercent(value) {
  if (!Number.isFinite(value)) return "";
  const clamped = Math.max(0, Math.min(100, value));
  const rounded = Number.isInteger(clamped) ? clamped : Number(clamped.toFixed(1));
  return `${rounded}%`;
}

function tkFormatScoreDisplay(value) {
  if (value === null || value === undefined) return "";
  const str = String(value).trim();
  return str;
}

function tkNormalizePercentText(value) {
  if (value == null) return "";
  let str = String(value).trim();
  if (!str) return "";
  if (str.includes("&")) {
    str = str.replace(/&(?=[0-9#%])/g, "");
  }
  return str.replace(/\s+/g, " ");
}

function tkFormatMatchDisplay(raw, parsed) {
  if (raw !== undefined && raw !== null) {
    const normalized = tkNormalizePercentText(raw);
    if (normalized) {
      const numeric = tkCoerceNumber(normalized);
      if (Number.isFinite(numeric)) return tkFormatPercent(numeric);
      if (/%/.test(normalized)) return normalized;
      if (Number.isFinite(parsed)) return tkFormatPercent(parsed);
      return normalized;
    }
  }
  if (Number.isFinite(parsed)) return tkFormatPercent(parsed);
  return "";
}

function tkNormalizeCompatRow(entry) {
  if (!entry) return null;

  let label;
  let labelShort;
  let aRaw;
  let bRaw;
  let matchRaw;
  let hasData;
  let flagRaw;
  let flagStatus;
  let flagColor;
  let flagHex;

  if (Array.isArray(entry)) {
    [label, aRaw, matchRaw, , bRaw] = entry;
  } else if (typeof entry === "object") {
    label = entry.label ?? entry.item ?? entry.title ?? "";
    labelShort = entry.labelShort ?? entry.shortLabel ?? entry.short ?? null;
    aRaw = entry.aScore ?? entry.a ?? entry.partnerA ?? entry.aValue ?? entry.a_score;
    bRaw = entry.bScore ?? entry.b ?? entry.partnerB ?? entry.bValue ?? entry.b_score;
    matchRaw = entry.matchPct ?? entry.match ?? entry.matchValue ?? entry.matchPercent ?? entry.matchPercentage ?? entry.matchScore;
    hasData = typeof entry.hasData === "boolean" ? entry.hasData : undefined;
    flagRaw = entry.flag ?? entry.flagGlyph ?? entry.flagEmoji ?? entry.flagText ?? entry.flagDisplay ?? null;
    flagStatus = entry.flagStatus ?? entry.flagLabel ?? entry.flagName ?? null;
    flagColor = entry.flagColor ?? entry.flagColour ?? entry.flagRGB ?? entry.flagRgb ?? null;
    flagHex = entry.flagHex ?? entry.flagColourHex ?? null;
  } else {
    return null;
  }

  const aScore = tkParseScore(aRaw);
  const bScore = tkParseScore(bRaw);
  const matchPct = tkParseMatchPercent(matchRaw);

  if (typeof hasData !== "boolean") {
    hasData = Number.isFinite(aScore) || Number.isFinite(bScore);
  }

  return {
    label: label ?? "",
    labelShort: labelShort || null,
    aScore,
    bScore,
    matchPct,
    matchRaw,
    aDisplay: tkFormatScoreDisplay(aRaw ?? aScore),
    bDisplay: tkFormatScoreDisplay(bRaw ?? bScore),
    matchDisplay: tkFormatMatchDisplay(matchRaw, matchPct),
    hasData,
    flagRaw,
    flagStatus,
    flagColor,
    flagHex,
  };
}

function tkBuildCompatRow(row) {
  const normalized = tkNormalizeCompatRow(row);
  if (!normalized) {
    return ["", "", "0%", ""];
  }

  const matchPct = Number.isFinite(normalized.matchPct)
    ? normalized.matchPct
    : tkParseMatchPercent(normalized.matchRaw);

  const aScore = Number.isFinite(normalized.aScore)
    ? normalized.aScore
    : tkParseScore(normalized.aDisplay);

  const bScore = Number.isFinite(normalized.bScore)
    ? normalized.bScore
    : tkParseScore(normalized.bDisplay);

  const label = normalized.labelShort || normalized.label || "";
  const matchText = normalized.matchDisplay ||
    (Number.isFinite(matchPct) ? tkFormatPercent(matchPct) : "0%");

  const toCell = (value) => (
    value === undefined || value === null ? "" : String(value)
  );

  const partnerA = normalized.aDisplay ?? (Number.isFinite(normalized.aScore) ? normalized.aScore : "");
  const partnerB = normalized.bDisplay ?? (Number.isFinite(normalized.bScore) ? normalized.bScore : "");

  return [
    toCell(label),
    toCell(partnerA),
    toCell(matchText || (Number.isFinite(matchPct) ? tkFormatPercent(matchPct) : "0%")),
    toCell(partnerB)
  ];
}

const TK_PDF_TITLE = "Talk Kink Compatibility Survey";

if (typeof window !== 'undefined') {
  window.tkFlagFromScores = tkFlagFromScores;
  window.tkGetFlagSquare = tkGetFlagSquare;
  window.tkResolveFlagInfo = tkResolveFlagInfo;
  window.tkBuildCompatRow = tkBuildCompatRow;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   One-time bootstrap (prevents â€œdouble loadingâ€)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
(() => {
  if (window.__TK_ONE_TIME_INIT__) return;  // hard lock
  window.__TK_ONE_TIME_INIT__ = true;

  /* Timestamp */
  const ts = new Date();
  document.getElementById('ts').textContent =
    'Generated: ' + ts.toLocaleString();

  /* Demo source (will be replaced if live globals/localStorage exist) */
  const TK_COMPAT_CACHE_VERSION = 'v3'; // bump when schema or fallback changes
  const LS_VERSION_KEY = 'talkkink:compatRows:ver';

  const noCache = /(^|[?&])nocache(=1|&|$)/.test(location.search);
  const storedVer = localStorage.getItem(LS_VERSION_KEY);

  if (noCache || storedVer !== TK_COMPAT_CACHE_VERSION){
    delete window.talkkinkCompatRows;
    ['talkkink:compatRows','talkkink:survey','talkkink:mine','talkkink:partner']
      .forEach(k => localStorage.removeItem(k));
    Object.keys(localStorage).forEach(k => {
      if (/^tk_compat\./.test(k)) localStorage.removeItem(k);
    });
    localStorage.setItem(LS_VERSION_KEY, TK_COMPAT_CACHE_VERSION);
  }

  const HARD_CODED_COMPAT_ROWS = [
    ['Giving: Assigning corner time or time-outs', 0, 100, '', 0],
    ['General: Attitude toward funishment vs serious correction', 3, 100, '', 3],
    ['Receiving: Being placed in the corner or given a time-out', 5, 100, '', 5],
    ['Receiving: Getting scolded or lectured for correction', 5, 100, '', 5],
    ['Receiving: Having privileges revoked (phone, TV)', 3, 100, '', 3],
    ['Giving: Lecturing or scolding to modify behavior', 4, 100, '', 4],
    ['Giving: Playful punishments that still reinforce rules', 3, 100, '', 3],
    ['General: Preferred style of discipline (strict vs lenient)', 4, 100, '', 4],
    ['Receiving: Playful \"f\" punishments for minor rule-breaking', 2, 100, '', 2],
    ['Giving: Removing privileges (phone, TV, sweets)', 2, 100, '', 2],
    ['General: Use of behavior contracts or rule agreements', 2, 100, '', 2],
    ['Giving: Writing lines or apology letters as correction', 1, 100, '', 1],
    ['Receiving: Writing lines or apology letters when misbehaving', 4, 100, '', 4],
  ];

  /* Source resolution: use live globals if present, else localStorage, else fallback */
  function pickRows(){
    if (Array.isArray(window.talkkinkCompatRows) && window.talkkinkCompatRows.length){
      return window.talkkinkCompatRows;
    }
    try{
      const cached = JSON.parse(localStorage.getItem('talkkink:compatRows') || 'null');
      if (Array.isArray(cached) && cached.length) return cached;
    }catch{}
    return HARD_CODED_COMPAT_ROWS;
  }

  /* Render into DOM (single-run; we clear body first to avoid doubles) */
  const TBODY = document.getElementById('compatBody');
  function renderTable(rows){
    TBODY.replaceChildren();
    const toText = (value) => (value === undefined || value === null ? '' : String(value));

    for (const row of rows){
      if (!row) continue;
      const tr = document.createElement('tr');
      const matchText = row.matchDisplay || tkFormatMatchDisplay(row.matchRaw, row.matchPct);
      const cells = [
        ['label', row.label],
        ['num',   row.aDisplay ?? (Number.isFinite(row.aScore) ? String(row.aScore) : '')],
        ['match', matchText],
        ['num',   row.bDisplay ?? (Number.isFinite(row.bScore) ? String(row.bScore) : '')],
      ];

      for (const [cls, value] of cells){
        const td = document.createElement('td');
        td.className = cls;
        td.textContent = toText(value);
        tr.appendChild(td);
      }

      TBODY.appendChild(tr);
    }
  }

  const compatRows = pickRows().map(tkNormalizeCompatRow).filter(Boolean);
  window.__tkCompatNormalizedRows = compatRows;
  renderTable(compatRows);
})();

let tkJsPdfLoadPromise = null;

function tkIsJsPdfReady() {
  return !!(window.jspdf && window.jspdf.jsPDF && window.jspdf.jsPDF.API && window.jspdf.jsPDF.API.autoTable);
}

async function tkEnsureJsPDF() {
  if (tkIsJsPdfReady()) return;
  if (tkJsPdfLoadPromise) {
    await tkJsPdfLoadPromise;
    return;
  }

  const localScripts = [
    '/vendor/jspdf.umd.min.js',
    '/js/vendor/jspdf.umd.min.js',
    '/assets/js/vendor/jspdf.umd.min.js',
    '/vendor/jspdf.plugin.autotable.min.js',
    '/js/vendor/jspdf.plugin.autotable.min.js',
    '/assets/js/vendor/jspdf.plugin.autotable.min.js'
  ];
  const cdnScripts = [
    'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js',
    'https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js'
  ];

  const inject = (src) => new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = src;
    script.async = true;
    script.onload = resolve;
    script.onerror = (err) => reject(err || new Error('Failed to load ' + src));
    document.head.appendChild(script);
  });

  tkJsPdfLoadPromise = (async () => {
    for (const src of localScripts) {
      try {
        await inject(src);
      } catch (err) {
        console.warn('[TK] Failed to load local jsPDF asset:', src, err);
      }
    }

    if (!tkIsJsPdfReady()) {
      for (const src of cdnScripts) {
        try {
          await inject(src);
        } catch (err) {
          console.warn('[TK] Failed to load CDN jsPDF asset:', src, err);
        }
        if (tkIsJsPdfReady()) break;
      }
    }

    if (!tkIsJsPdfReady()) {
      throw new Error('jsPDF/AutoTable not available. Host local copies in /vendor or allow the CDN.');
    }
  })();

  try {
    await tkJsPdfLoadPromise;
  } catch (err) {
    tkJsPdfLoadPromise = null;
    throw err;
  }
}

function tkCollectCompatRowsForPdf() {
  let source = [];
  if (Array.isArray(window.talkkinkCompatRows) && window.talkkinkCompatRows.length) {
    source = window.talkkinkCompatRows;
  } else if (Array.isArray(window.__tkCompatNormalizedRows)) {
    source = window.__tkCompatNormalizedRows;
  }
  return source.map(tkNormalizeCompatRow).filter(Boolean);
}

function tkSplitCompatLabel(label) {
  if (!label) {
    return { category: 'Compatibility', text: '' };
  }

  const match = String(label).split(':');
  if (match.length < 2) {
    return { category: 'Compatibility', text: String(label).trim() };
  }

  const category = match.shift().trim() || 'Compatibility';
  const text = match.join(':').trim() || String(label).trim();
  return { category, text };
}

function tkFormatPdfScore(displayValue, scoreValue) {
  if (displayValue != null && displayValue !== '') {
    return String(displayValue);
  }
  if (Number.isFinite(scoreValue)) {
    return String(scoreValue);
  }
  return '';
}

function tkFormatPdfMatch(row) {
  if (Number.isFinite(row.matchPct)) {
    return `${Math.max(0, Math.min(100, Math.round(row.matchPct)))}%`;
  }

  const raw = row.matchDisplay ?? row.matchRaw ?? row.matchPct ?? row.match;
  if (raw == null) return 'â€”';

  if (typeof raw === 'number' && Number.isFinite(raw)) {
    return `${Math.max(0, Math.min(100, Math.round(raw)))}%`;
  }

  const text = String(raw).trim();
  if (!text) return 'â€”';

  const numeric = text.replace(/[^0-9]+/g, '');
  if (numeric) {
    const pct = Math.max(0, Math.min(100, Number.parseInt(numeric, 10)));
    return `${pct}%`;
  }

  return text;
}

function tkBuildPdfCategories(rows) {
  const grouped = new Map();

  rows.forEach((row) => {
    if (!row) return;

    const { category, text } = tkSplitCompatLabel(row.labelShort || row.label || '');
    if (!grouped.has(category)) {
      grouped.set(category, { category, items: [] });
    }

    grouped.get(category).items.push({
      label: text || row.label || 'â€”',
      partnerA: tkFormatPdfScore(row.aDisplay, row.aScore),
      partnerB: tkFormatPdfScore(row.bDisplay, row.bScore),
      match: tkFormatPdfMatch(row),
    });
  });

  return Array.from(grouped.values());
}

async function tkGeneratePdfFromCategories(categories) {
  if (!categories.length) {
    throw new Error('No compatibility rows available');
  }

  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4' });
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 40;
  const accent = [0, 240, 240];
  const background = [15, 15, 15];
  const bodyFill = [30, 30, 30];
  const bodyText = [255, 255, 255];
  const lineColor = [60, 60, 60];
  const generatedAt = `Generated: ${new Date().toLocaleString()}`;

  const surveyRows = categories.flatMap((category) => {
    if (!category || !Array.isArray(category.items)) return [];
    const label = category.category || 'Other';
    return category.items.map((row) => ({
      item: label ? `${label} â€” ${row.label || 'â€”'}` : (row.label || 'â€”'),
      partnerA: row.partnerA ?? '',
      match: row.match ?? '',
      partnerB: row.partnerB ?? '',
    }));
  });

  const drawPageFrame = () => {
    doc.setFillColor(...background);
    doc.rect(0, 0, pageWidth, pageHeight, 'F');

    doc.setFont('helvetica', 'bold');
    doc.setFontSize(28);
    doc.setTextColor(255, 255, 255);
    doc.text('TalkKink Compatibility Report', margin, 60);

    doc.setFont('helvetica', 'normal');
    doc.setFontSize(12);
    doc.setTextColor(204, 204, 204);
    doc.text(generatedAt, margin, 90);

    doc.setDrawColor(...accent);
    doc.setLineWidth(2);
    doc.line(margin, 105, pageWidth - margin, 105);
  };

  drawPageFrame();

  doc.autoTable({
    startY: 130,
    head: [[
      { content: 'Item', styles: { fillColor: [0, 0, 0], textColor: accent } },
      { content: 'Partner A', styles: { fillColor: [0, 0, 0], textColor: accent } },
      { content: 'Match', styles: { fillColor: [0, 0, 0], textColor: accent } },
      { content: 'Partner B', styles: { fillColor: [0, 0, 0], textColor: accent } },
    ]],
    body: surveyRows.map((row) => [
      row.item,
      row.partnerA,
      row.match,
      row.partnerB,
    ]),
    styles: {
      fontSize: 10,
      halign: 'left',
      valign: 'middle',
      cellPadding: 4,
      textColor: bodyText,
      fillColor: bodyFill,
      lineColor,
      lineWidth: 0.5,
      font: 'helvetica',
    },
    columnStyles: {
      0: { cellWidth: 250, halign: 'left' },
      1: { cellWidth: 70, halign: 'center' },
      2: { cellWidth: 80, halign: 'center' },
      3: { cellWidth: 70, halign: 'center' },
    },
    headStyles: {
      fillColor: [0, 0, 0],
      textColor: accent,
      fontStyle: 'bold',
    },
    margin: { left: margin, right: margin },
    theme: 'striped',
    didDrawPage: () => {
      drawPageFrame();
    },
  });

  doc.save('talkkink-compatibility.pdf');
}

async function TKPDF_exportCompatibilitySingle() {
  try {
    await tkEnsureJsPDF();
  } catch (err) {
    console.error('jsPDF not loaded â€“ make sure jsPDF UMD is included before this file.', err);
    alert('PDF library not loaded; cannot export.');
    return;
  }

  if (!(window.jspdf && window.jspdf.jsPDF)) {
    console.error('jsPDF not loaded â€“ make sure jsPDF UMD is included before this file.');
    alert('PDF library not loaded; cannot export.');
    return;
  }
  if (!window.jspdf.jsPDF.API.autoTable) {
    console.error('autoTable plugin not loaded.');
    alert('autoTable plugin not loaded; cannot export.');
    return;
  }

  try {
    const compatRows = tkCollectCompatRowsForPdf();
    const categories = tkBuildPdfCategories(compatRows);
    await tkGeneratePdfFromCategories(categories);
  } catch (err) {
    console.error('[TKPDF] Failed to export compatibility report.', err);
    alert('PDF export failed. See console for details.');
  }
}

function tkBindCompatibilityDownload() {
  const btn = document.getElementById('downloadBtn') || document.getElementById('downloadPdfBtn');
  if (!btn) {
    console.warn('[TK] downloadBtn not found for compatibility export.');
    return;
  }

  btn.onclick = null;

  const parent = btn.parentNode;
  if (!parent) {
    console.warn('[TK] download button has no parent node; cannot rebind.');
    return;
  }

  const clone = btn.cloneNode(true);
  parent.replaceChild(clone, btn);

  clone.addEventListener('click', function (e) {
    e.preventDefault();
    e.stopPropagation();
    TKPDF_exportCompatibilitySingle();
  });

  console.log('[TK] Bound single compatibility PDF exporter to #downloadBtn');
}

if (typeof window !== 'undefined') {
  window.TKPDF_exportCompatibilitySingle = TKPDF_exportCompatibilitySingle;
  window.TKPDF_export = TKPDF_exportCompatibilitySingle;
  window.tkBindCompatibilityDownload = tkBindCompatibilityDownload;
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', tkBindCompatibilityDownload, { once: true });
} else {
  tkBindCompatibilityDownload();
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Defensive renderer hot-fix
   - prevents duplicate renders/tables
   - cleans up stray thead copies
   - normalises flag glyphs & column sizing
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
(() => {
  const HOTFIX_LOCK = '__TK_COMPAT_RENDER_LOCK__';
  if (window[HOTFIX_LOCK]) return;
  window[HOTFIX_LOCK] = true;

  const table = document.getElementById('compatTable');
  if (!table) return;

  const parser = new DOMParser();

  function decodeEntities(value){
    if (!value || !value.includes('&')) return value;
    let current = value;
    let previous;
    do {
      previous = current;
      current = parser.parseFromString(previous, 'text/html').documentElement
        .textContent;
    } while (current !== previous && current.includes('&'));
    return current.replace(/&+â€ /g, 'â€ ');
  }

  function purgeDuplicateTables(){
    const allTables = Array.from(document.querySelectorAll('table.compat'));
    const keep = allTables.find(t => t.id === 'compatTable') || allTables[0];
    allTables.forEach(t => {
      if (t !== keep) t.remove();
    });
    return keep;
  }

  function ensureSingleThead(tbl){
    const theads = Array.from(tbl.querySelectorAll('thead'));
    theads.slice(1).forEach(t => t.remove());
    const head = theads[0];
    if (!head) return;
    if (!head.querySelector('tr')) head.remove();
  }

  function retuneLayout(tbl){
    tbl.style.width = '100%';
    tbl.style.tableLayout = 'fixed';

    const headCells = tbl.querySelectorAll('thead th');
    headCells.forEach((th, idx) => {
      th.style.textAlign = idx === 0 ? 'left' : 'center';
      th.style.borderBottom = '1px solid var(--grid)';
      th.style.textShadow = '0 0 0 var(--bg), 0 0 12px rgba(0,231,255,.22)';
    });
  }

  function normaliseCells(tbl){
    const rows = tbl.querySelectorAll('tbody tr');
    rows.forEach(row => {
      const cells = row.querySelectorAll('td');
      if (!cells.length) return;

      const decodedCells = Array.from(cells, cell => decodeEntities(cell.textContent.trim()));
      const aScore = tkParseScore(decodedCells[1]);
      const bScore = tkParseScore(decodedCells[3]);
      const matchPct = tkParseMatchPercent(decodedCells[2]);

      cells.forEach((cell, idx) => {
        const decoded = decodedCells[idx] ?? '';
        cell.textContent = decoded;
        cell.style.background = '';
      });
    });
  }

  const activeTable = purgeDuplicateTables() || table;
  if (!activeTable) return;

  ensureSingleThead(activeTable);
  retuneLayout(activeTable);
  normaliseCells(activeTable);
})();

/* --------------------------------------------------------------
 * TalkKink compatibility overrides
 * - Remove the Flag column from the on-page comparison table.
 * - Stop the legacy PDF from firing so only the â€œwebâ€ PDF runs.
 *   (We re-wire the Download button to call TKCompatPDF only.)
 * -------------------------------------------------------------- */

(function () {
  /* Remove the "Flag" column from the DOM table
     (affects BOTH the on-page view and any PDF that clones the table). */
  function removeFlagColumn() {
    // Adjust selector if your comparison table has a specific id
    const table =
      document.querySelector('#compatTable') ||
      document.querySelector('#comparisonTable') ||
      document.querySelector('table');

    if (!table) {
      console.warn('[TK-compat] No compatibility table found to strip Flag column.');
      return;
    }

    const headRow = table.querySelector('thead tr');
    if (!headRow) return;

    const headCells = Array.from(headRow.cells);
    const flagIndex = headCells.findIndex(th =>
      th.textContent.trim().toLowerCase() === 'flag'
    );
    if (flagIndex === -1) {
      // Already removed, nothing to do
      return;
    }

    // Delete the "Flag" cell from every row (header + body + footer)
    Array.from(table.rows).forEach(row => {
      if (row.cells[flagIndex]) {
        row.deleteCell(flagIndex);
      }
    });

    console.info('[TK-compat] Removed Flag column from compatibility table.');
  }

  /* Re-wire the Download button so ONLY the new TKCompatPDF exporter runs.
     This prevents the old legacy generator from opening a second PDF. */
  function rewireDownloadButton() {
    const btn = document.querySelector(
      '#downloadPdfBtn, #downloadBtn, [data-download-pdf]'
    );
    if (!btn) {
      console.warn('[TK-compat] No Download PDF button found to rewire.');
      return;
    }

    // Clone the button to strip inline onclick + legacy listeners
    const clone = btn.cloneNode(true);
    clone.removeAttribute('onclick');

    clone.addEventListener('click', function (e) {
      e.preventDefault();

      if (
        window.TKCompatPDF &&
        typeof window.TKCompatPDF.download === 'function'
      ) {
        window.TKCompatPDF.download();
        return;
      }

      console.warn(
        '[TK-compat] TKCompatPDF not available; Download button is now a no-op.'
      );
    });

    btn.parentNode.replaceChild(clone, btn);
    console.info('[TK-compat] Download button re-wired to TKCompatPDF only.');
  }

  /* Hard-disable any legacy global generator just in case something still calls it. */
  window.generateDarkPDF = function () {
    console.info('[TK-compat] Legacy generateDarkPDF is disabled on this page.');
    // No-op: old PDF should not run any more.
  };

  // Run once when the DOM is ready
  function init() {
    removeFlagColumn();
    rewireDownloadButton();
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init, { once: true });
  } else {
    init();
  }
})();
</script>
</body>
</html>
