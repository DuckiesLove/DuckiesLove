<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TalkKink Compatibility</title>
<style>
  :root{
    --bg:#0e0f11;            /* page background */
    --panel:#0b0c0d;         /* table banding base */
    --row:#111315;           /* row color */
    --row-alt:#0f1012;       /* zebra */
    --ink:#e6feff;           /* main text */
    --ink-dim:#b8dfe0;
    --accent:#00e7ff;        /* teal glow */
    --grid:#23292d;          /* table lines */
  }
  html,body{height:100%;}
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
  }
  .page{
    max-width:1120px;
    margin:28px auto 48px;
    padding:0 16px;
  }

  /* Centered, outlined headings (like before) */
  .title, .subtitle, .section {
    text-align:center;
    margin:0;
  }
  .title{
    font-size:56px; line-height:1.05; font-weight:800; letter-spacing:.5px;
    color:var(--accent);
    /* outline with soft glow */
    text-shadow:
      0 0 0 var(--bg),
      0 0 18px rgba(0,231,255,.35),
      0 0 40px rgba(0,231,255,.25);
    -webkit-font-smoothing:antialiased;
  }
  .subtitle{
    margin-top:10px; font-size:20px; color:var(--ink-dim);
  }
  .hr { height:3px; background:var(--accent); margin:18px auto 14px; max-width:92%; opacity:.85; }

  .section{
    font-size:44px; font-weight:800; color:var(--accent); margin:12px 0 10px;
    text-shadow:
      0 0 0 var(--bg),
      0 0 14px rgba(0,231,255,.25),
      0 0 28px rgba(0,231,255,.18);
  }

  /* Table fills the page, no white boxes */
  .compat{
    width:100%; border-collapse:separate; border-spacing:0;
    background:transparent; table-layout:fixed;
  }
  .compat col.label   { width:53%; }
  .compat col.a       { width:12%; }
  .compat col.match   { width:16%; }
  .compat col.flag    { width:7%; }    /* give "Flag" breathing room */
  .compat col.b       { width:12%; }

  .compat thead th{
    position:sticky; top:0; z-index:1;
    background:#0f1215;
    color:var(--accent); font-weight:800; font-size:20px; padding:14px 12px;
    border-bottom:1px solid var(--grid);
    text-align:center;
    /* give the header the outlined look, too */
    text-shadow:
      0 0 0 var(--bg),
      0 0 12px rgba(0,231,255,.22);
  }
  .compat thead th:first-child{ text-align:left; }

  .compat tbody td{
    padding:14px 12px; font-size:19px; line-height:1.3; color:var(--ink);
    border-bottom:1px solid #151a1e; background:var(--row);
  }
  .compat tbody tr:nth-child(2n) td{ background:var(--row-alt); }
  .compat tbody td.label{ color:var(--ink); }
  .compat tbody td.num, .compat tbody td.match, .compat tbody td.flag{
    text-align:center; white-space:nowrap;
  }
  .compat tbody td.flag{
    text-align:center; letter-spacing:.5px; color:var(--ink-dim);
  }

  .compat tbody td.flag{
    position:relative;
  }

  .flag-dot{
    --flag-square-size:18px;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    width:26px;
    height:26px;
    border-radius:8px;
    position:relative;
    color:var(--ink);
    font-size:14px;
    line-height:1;
  }

  .flag-dot::after{
    content:"";
    display:block;
    width:var(--flag-square-size);
    height:var(--flag-square-size);
    border-radius:6px;
    background:var(--flag-color, rgba(255,255,255,0.12));
    box-shadow:
      0 0 0 1px rgba(0,231,255,.35),
      0 0 16px rgba(0,231,255,.18);
    transition:transform .15s ease, box-shadow .2s ease;
  }

  .flag-dot[data-has-color="true"]{
    color:transparent;
    text-shadow:none;
  }

  .flag-dot[data-flag-status="green"]{ --flag-color:#18d69a; }
  .flag-dot[data-flag-status="yellow"]{ --flag-color:#ffcc00; }
  .flag-dot[data-flag-status="red"]{ --flag-color:#ff4242; }

  .flag-dot:hover::after{
    transform:scale(1.05);
    box-shadow:
      0 0 0 1px rgba(0,231,255,.6),
      0 0 22px rgba(0,231,255,.25);
  }

  .flag-dot:focus-visible{
    outline:2px solid var(--accent);
    outline-offset:2px;
  }

  .sr-only{
    position:absolute;
    width:1px;
    height:1px;
    padding:0;
    margin:-1px;
    overflow:hidden;
    clip:rect(0, 0, 0, 0);
    white-space:nowrap;
    border:0;
  }

  /* Download button */
  .bar { display:flex; gap:12px; justify-content:center; margin:18px 0 6px; }
  .btn {
    appearance:none; border:none; border-radius:12px; padding:10px 16px;
    background:#0f1d22; color:var(--ink); font-weight:700; cursor:pointer;
    box-shadow:0 0 0 1px rgba(0,231,255,.25), 0 6px 20px rgba(0,231,255,.12) inset;
  }
  .btn:hover{ box-shadow:0 0 0 1px rgba(0,231,255,.5), 0 0 18px rgba(0,231,255,.18) inset; }

  /* make sure the whole sheet breathes to edges on small screens */
  @media (max-width:880px){
    .title{ font-size:44px; }
    .section{ font-size:34px; }
    .compat thead th, .compat tbody td{ font-size:18px; }
    .compat col.label{ width:51%; }
    .compat col.match{ width:17%; }
    .compat col.flag { width:8%; }
  }
</style>
</head>
<body>
  <div class="page" id="app">
    <h1 class="title">TalkKink Compatibility</h1>
    <p class="subtitle" id="ts">Generated: â€”</p>
    <div class="hr"></div>
    <h2 class="section">Behavioral Play</h2>

    <div class="bar"><button id="downloadBtn" class="btn">Download PDF</button></div>

    <table class="compat" id="compatTable" aria-label="Compatibility table">
      <colgroup>
        <col class="label"><!-- Item -->
        <col class="a">    <!-- Partner A -->
        <col class="match"><!-- Match -->
        <col class="flag"><!-- Flag -->
        <col class="b">    <!-- Partner B -->
      </colgroup>
      <thead>
        <tr>
          <th>Item</th>
          <th>Partner A</th>
          <th>Match</th>
          <th>Flag</th>
          <th>Partner B</th>
        </tr>
      </thead>
      <tbody id="compatBody"><!-- rows injected --></tbody>
    </table>
  </div>

<script>
const FLAG_META = {
  green:  { emoji: "ðŸŸ©", label: "High match", color: "#18d69a" },
  yellow: { emoji: "ðŸŸ¨", label: "Needs discussion", color: "#ffcc00" },
  red:    { emoji: "ðŸŸ¥", label: "Conflict", color: "#ff4242" }
};

const FLAG_EMOJI_TO_STATUS = Object.fromEntries(
  Object.entries(FLAG_META).map(([status, meta]) => [meta.emoji, status])
);

Object.assign(FLAG_EMOJI_TO_STATUS, {
  "ðŸŸ¢": "green",
  "ðŸŸ¡": "yellow",
  "ðŸ”´": "red",
  "ðŸŸ ": "yellow"
});

function tkFlagFromScores(matchPct, aScore, bScore) {
  if (
    matchPct == null ||
    aScore == null ||
    bScore == null
  ) return "";

  const diff = Math.abs(aScore - bScore);

  if (
    matchPct <= 30 ||
    (aScore <= 1 && bScore >= 4) ||
    (bScore <= 1 && aScore >= 4)
  ) {
    return FLAG_META.red.emoji;
  }

  if (
    diff >= 3 ||
    (aScore === 5 && bScore <= 3) ||
    (bScore === 5 && aScore <= 3)
  ) {
    return FLAG_META.yellow.emoji;
  }

  if (matchPct >= 80) {
    return FLAG_META.green.emoji;
  }

  return "";
}

function tkNormalizeFlagStatus(value) {
  if (value == null) return null;
  if (typeof value === "number") {
    if (value >= 80) return "green";
    if (value >= 50) return "yellow";
    return "red";
  }

  const str = String(value).trim();
  if (!str) return null;

  if (FLAG_EMOJI_TO_STATUS[str]) return FLAG_EMOJI_TO_STATUS[str];

  const lower = str.toLowerCase();
  if (FLAG_META[lower]) return lower;
  if (/perfect|great|strong|aligned|excellent/.test(lower)) return "green";
  if (/warn|caution|mixed|medium|maybe/.test(lower)) return "yellow";
  if (/conflict|bad|low|danger|problem|issue|concern|poor/.test(lower)) return "red";

  return null;
}

function tkParseFlagColor(color) {
  if (!color) return null;
  if (Array.isArray(color)) {
    const [r, g, b] = color.map((n) => Math.max(0, Math.min(255, Number(n) || 0)));
    return `#${[r, g, b].map((n) => n.toString(16).padStart(2, "0")).join("")}`;
  }

  const str = String(color).trim();
  if (!str) return null;

  const hexMatch = str.match(/^#?([0-9a-f]{6})$/i);
  if (hexMatch) return `#${hexMatch[1].toLowerCase()}`;

  const rgbMatch = str.match(/rgb\s*\((\d+)[,\s]+(\d+)[,\s]+(\d+)/i);
  if (rgbMatch) {
    return `#${[rgbMatch[1], rgbMatch[2], rgbMatch[3]]
      .map((part) => Math.max(0, Math.min(255, Number(part) || 0)).toString(16).padStart(2, "0"))
      .join("")}`;
  }

  return null;
}

function tkGuessStatusFromColor(hex) {
  if (!hex) return null;
  const value = hex.replace("#", "");
  if (value.length !== 6) return null;

  const r = parseInt(value.slice(0, 2), 16);
  const g = parseInt(value.slice(2, 4), 16);
  const b = parseInt(value.slice(4, 6), 16);

  if (r > 210 && g < 140) return "red";
  if (r > 210 && g > 170 && b < 140) return "yellow";
  if (g > 170 && b > 110 && r < 150) return "green";

  return null;
}

function tkResolveFlagInfo(row = {}) {
  if (row.hasData === false) {
    return { emoji: "", status: null, color: null, matchPct: null, aScore: null, bScore: null };
  }

  const matchPct = Number.isFinite(row.matchPct)
    ? row.matchPct
    : tkParseMatchPercent(row.matchRaw);

  const aScore = Number.isFinite(row.aScore)
    ? row.aScore
    : tkParseScore(row.aDisplay ?? row.a ?? row.partnerA);

  const bScore = Number.isFinite(row.bScore)
    ? row.bScore
    : tkParseScore(row.bDisplay ?? row.b ?? row.partnerB);

  const rawFlag = row.flagEmoji ?? row.flagGlyph ?? row.flagRaw ?? row.flag ?? row.flagText ?? null;
  let status =
    tkNormalizeFlagStatus(row.flagStatus) ||
    tkNormalizeFlagStatus(rawFlag) ||
    tkNormalizeFlagStatus(row.flagLabel) ||
    null;

  let color =
    tkParseFlagColor(row.flagColor) ||
    tkParseFlagColor(row.flagColour) ||
    tkParseFlagColor(row.flagRGB) ||
    tkParseFlagColor(row.flagRgb) ||
    tkParseFlagColor(row.flagHex) ||
    null;

  if (!status && color) {
    status = tkGuessStatusFromColor(color);
  }

  let emoji = typeof rawFlag === "string" ? rawFlag.trim() : "";

  if (!status || !emoji || !FLAG_EMOJI_TO_STATUS[emoji]) {
    const computedEmoji = tkFlagFromScores(matchPct, aScore, bScore);
    if (computedEmoji) {
      if (!emoji) emoji = computedEmoji;
      if (!status) status = tkNormalizeFlagStatus(computedEmoji);
    }
  }

  if (status && (!emoji || !FLAG_EMOJI_TO_STATUS[emoji])) {
    emoji = FLAG_META[status]?.emoji || emoji;
  }

  if (status && !color) {
    color = FLAG_META[status]?.color || null;
  }

  return { emoji: emoji || "", status: status || null, color, matchPct, aScore, bScore };
}

function tkGetFlagSquare(row) {
  return tkResolveFlagInfo(row).emoji;
}

function tkCoerceNumber(value) {
  if (value === null || value === undefined) return null;
  if (typeof value === "number" && Number.isFinite(value)) return value;
  const trimmed = String(value).trim();
  if (!trimmed) return null;
  const direct = Number(trimmed);
  if (Number.isFinite(direct)) return direct;
  const numeric = Number(trimmed.replace(/[^0-9.+-]/g, ""));
  return Number.isFinite(numeric) ? numeric : null;
}

function tkParseScore(value) {
  const num = tkCoerceNumber(value);
  if (num == null) return null;
  if (!Number.isFinite(num)) return null;
  return Math.max(0, Math.min(5, num));
}

function tkParseMatchPercent(value) {
  const num = tkCoerceNumber(value);
  if (num == null) return null;
  if (!Number.isFinite(num)) return null;
  return Math.max(0, Math.min(100, num));
}

function tkFormatPercent(value) {
  if (!Number.isFinite(value)) return "";
  const clamped = Math.max(0, Math.min(100, value));
  const rounded = Number.isInteger(clamped) ? clamped : Number(clamped.toFixed(1));
  return `${rounded}%`;
}

function tkFormatScoreDisplay(value) {
  if (value === null || value === undefined) return "";
  const str = String(value).trim();
  return str;
}

function tkFormatMatchDisplay(raw, parsed) {
  if (raw !== undefined && raw !== null) {
    const rawStr = String(raw).trim();
    if (rawStr) {
      if (/%/.test(rawStr)) return rawStr;
      const numeric = tkCoerceNumber(rawStr);
      if (Number.isFinite(numeric)) return tkFormatPercent(numeric);
      if (Number.isFinite(parsed)) return tkFormatPercent(parsed);
      return rawStr;
    }
  }
  if (Number.isFinite(parsed)) return tkFormatPercent(parsed);
  return "";
}

function tkNormalizeCompatRow(entry) {
  if (!entry) return null;

  let label;
  let labelShort;
  let aRaw;
  let bRaw;
  let matchRaw;
  let hasData;
  let flagRaw;
  let flagStatus;
  let flagColor;
  let flagHex;

  if (Array.isArray(entry)) {
    [label, aRaw, matchRaw, , bRaw] = entry;
  } else if (typeof entry === "object") {
    label = entry.label ?? entry.item ?? entry.title ?? "";
    labelShort = entry.labelShort ?? entry.shortLabel ?? entry.short ?? null;
    aRaw = entry.aScore ?? entry.a ?? entry.partnerA ?? entry.aValue ?? entry.a_score;
    bRaw = entry.bScore ?? entry.b ?? entry.partnerB ?? entry.bValue ?? entry.b_score;
    matchRaw = entry.matchPct ?? entry.match ?? entry.matchValue ?? entry.matchPercent ?? entry.matchPercentage ?? entry.matchScore;
    hasData = typeof entry.hasData === "boolean" ? entry.hasData : undefined;
    flagRaw = entry.flag ?? entry.flagGlyph ?? entry.flagEmoji ?? entry.flagText ?? entry.flagDisplay ?? null;
    flagStatus = entry.flagStatus ?? entry.flagLabel ?? entry.flagName ?? null;
    flagColor = entry.flagColor ?? entry.flagColour ?? entry.flagRGB ?? entry.flagRgb ?? null;
    flagHex = entry.flagHex ?? entry.flagColourHex ?? null;
  } else {
    return null;
  }

  const aScore = tkParseScore(aRaw);
  const bScore = tkParseScore(bRaw);
  const matchPct = tkParseMatchPercent(matchRaw);

  if (typeof hasData !== "boolean") {
    hasData = Number.isFinite(aScore) || Number.isFinite(bScore);
  }

  return {
    label: label ?? "",
    labelShort: labelShort || null,
    aScore,
    bScore,
    matchPct,
    matchRaw,
    aDisplay: tkFormatScoreDisplay(aRaw ?? aScore),
    bDisplay: tkFormatScoreDisplay(bRaw ?? bScore),
    matchDisplay: tkFormatMatchDisplay(matchRaw, matchPct),
    hasData,
    flagRaw,
    flagStatus,
    flagColor,
    flagHex,
  };
}

function tkBuildCompatRow(row) {
  const normalized = tkNormalizeCompatRow(row);
  if (!normalized) {
    return ["", "", "0%", "", ""];
  }

  const matchPct = Number.isFinite(normalized.matchPct)
    ? normalized.matchPct
    : tkParseMatchPercent(normalized.matchRaw);

  const aScore = Number.isFinite(normalized.aScore)
    ? normalized.aScore
    : tkParseScore(normalized.aDisplay);

  const bScore = Number.isFinite(normalized.bScore)
    ? normalized.bScore
    : tkParseScore(normalized.bDisplay);

  const flagInfo = tkResolveFlagInfo({
    ...normalized,
    matchPct,
    aScore,
    bScore,
  });
  const flag = flagInfo.emoji;

  const label = normalized.labelShort || normalized.label || "";
  const matchText = normalized.matchDisplay ||
    (Number.isFinite(matchPct) ? tkFormatPercent(matchPct) : "0%");

  const toCell = (value) => (
    value === undefined || value === null ? "" : String(value)
  );

  const partnerA = normalized.aDisplay ?? (Number.isFinite(normalized.aScore) ? normalized.aScore : "");
  const partnerB = normalized.bDisplay ?? (Number.isFinite(normalized.bScore) ? normalized.bScore : "");

  return [
    toCell(label),
    toCell(partnerA),
    toCell(matchText || (Number.isFinite(matchPct) ? tkFormatPercent(matchPct) : "0%")),
    toCell(flag),
    toCell(partnerB)
  ];
}

const TK_PDF_TITLE = "Talk Kink Compatibility Survey";

if (typeof window !== 'undefined') {
  window.tkFlagFromScores = tkFlagFromScores;
  window.tkGetFlagSquare = tkGetFlagSquare;
  window.tkResolveFlagInfo = tkResolveFlagInfo;
  window.tkBuildCompatRow = tkBuildCompatRow;
  window.tkRenderFlagCell = tkRenderFlagCell;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   One-time bootstrap (prevents â€œdouble loadingâ€)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
(() => {
  if (window.__TK_ONE_TIME_INIT__) return;  // hard lock
  window.__TK_ONE_TIME_INIT__ = true;

  /* Timestamp */
  const ts = new Date();
  document.getElementById('ts').textContent =
    'Generated: ' + ts.toLocaleString();

  /* Demo source (will be replaced if live globals/localStorage exist) */
  const TK_COMPAT_CACHE_VERSION = 'v3'; // bump when schema or fallback changes
  const LS_VERSION_KEY = 'talkkink:compatRows:ver';

  const noCache = /(^|[?&])nocache(=1|&|$)/.test(location.search);
  const storedVer = localStorage.getItem(LS_VERSION_KEY);

  if (noCache || storedVer !== TK_COMPAT_CACHE_VERSION){
    delete window.talkkinkCompatRows;
    ['talkkink:compatRows','talkkink:survey','talkkink:mine','talkkink:partner']
      .forEach(k => localStorage.removeItem(k));
    Object.keys(localStorage).forEach(k => {
      if (/^tk_compat\./.test(k)) localStorage.removeItem(k);
    });
    localStorage.setItem(LS_VERSION_KEY, TK_COMPAT_CACHE_VERSION);
  }

  const HARD_CODED_COMPAT_ROWS = [
    ['Giving: Assigning corner time or time-outs', 0, 100, '', 0],
    ['General: Attitude toward funishment vs serious correction', 3, 100, '', 3],
    ['Receiving: Being placed in the corner or given a time-out', 5, 100, '', 5],
    ['Receiving: Getting scolded or lectured for correction', 5, 100, '', 5],
    ['Receiving: Having privileges revoked (phone, TV)', 3, 100, '', 3],
    ['Giving: Lecturing or scolding to modify behavior', 4, 100, '', 4],
    ['Giving: Playful punishments that still reinforce rules', 3, 100, '', 3],
    ['General: Preferred style of discipline (strict vs lenient)', 4, 100, '', 4],
    ['Receiving: Playful \"f\" punishments for minor rule-breaking', 2, 100, '', 2],
    ['Giving: Removing privileges (phone, TV, sweets)', 2, 100, '', 2],
    ['General: Use of behavior contracts or rule agreements', 2, 100, '', 2],
    ['Giving: Writing lines or apology letters as correction', 1, 100, '', 1],
    ['Receiving: Writing lines or apology letters when misbehaving', 4, 100, '', 4],
  ];

  /* Source resolution: use live globals if present, else localStorage, else fallback */
  function pickRows(){
    if (Array.isArray(window.talkkinkCompatRows) && window.talkkinkCompatRows.length){
      return window.talkkinkCompatRows;
    }
    try{
      const cached = JSON.parse(localStorage.getItem('talkkink:compatRows') || 'null');
      if (Array.isArray(cached) && cached.length) return cached;
    }catch{}
    return HARD_CODED_COMPAT_ROWS;
  }

  /* Render into DOM (single-run; we clear body first to avoid doubles) */
  const TBODY = document.getElementById('compatBody');
  const FLAG_LABEL_FALLBACK = {
    green: 'High match',
    yellow: 'Needs discussion',
    red: 'Conflict',
  };

  function tkDescribeFlag(info) {
    if (!info || !info.status) return 'No flag';
    const base = FLAG_META[info.status]?.label || FLAG_LABEL_FALLBACK[info.status] || 'Flagged item';
    if (Number.isFinite(info.matchPct)) {
      return `${base} (${tkFormatPercent(info.matchPct)})`;
    }
    return base;
  }

  function tkRenderFlagCell(td, info) {
    td.textContent = '';
    td.dataset.flagStatus = info?.status || '';
    td.removeAttribute('title');

    if (!info) return;

    const span = document.createElement('span');
    span.className = 'flag-dot';

    if (info.status) {
      span.dataset.flagStatus = info.status;
    }

    const resolvedColor = info.color || (info.status ? FLAG_META[info.status]?.color : null) || null;
    if (resolvedColor) {
      span.style.setProperty('--flag-color', resolvedColor);
    }
    span.dataset.hasColor = resolvedColor ? 'true' : 'false';
    span.dataset.flagEmoji = info.emoji || '';

    const description = tkDescribeFlag(info);
    const hasAccessibleLabel = Boolean(description || info.emoji);
    span.setAttribute('role', hasAccessibleLabel ? 'img' : 'presentation');
    if (description) {
      span.setAttribute('aria-label', description);
      span.title = description;
      td.title = description;
    } else if (info.emoji) {
      span.setAttribute('aria-label', info.emoji);
      td.title = info.emoji;
    } else {
      span.removeAttribute('aria-label');
      td.removeAttribute('title');
    }

    const hasColor = span.dataset.hasColor === 'true';

    if (hasColor) {
      const sr = document.createElement('span');
      sr.className = 'sr-only';
      sr.textContent = description || info.emoji || '';
      span.appendChild(sr);
    } else {
      let fallbackLabel = 'â€“';
      if (info.status) {
        const statusKey = String(info.status).toLowerCase();
        const mapped = { green: 'G', yellow: 'Y', red: 'R' }[statusKey];
        if (mapped) {
          fallbackLabel = mapped;
        } else if (statusKey) {
          fallbackLabel = statusKey.charAt(0).toUpperCase();
        }
      }
      span.textContent = fallbackLabel;
    }

    if (!span.childNodes.length && !span.textContent && description) {
      const sr = document.createElement('span');
      sr.className = 'sr-only';
      sr.textContent = description;
      span.appendChild(sr);
    }

    if (span.childNodes.length || span.textContent) {
      td.appendChild(span);
    }
  }

  function renderTable(rows){
    TBODY.replaceChildren();
    const toText = (value) => (value === undefined || value === null ? '' : String(value));

    for (const row of rows){
      if (!row) continue;
      const tr = document.createElement('tr');
      const flagInfo = tkResolveFlagInfo(row);
      const matchText = row.matchDisplay || tkFormatMatchDisplay(row.matchRaw, row.matchPct);
      const cells = [
        ['label', row.label],
        ['num',   row.aDisplay ?? (Number.isFinite(row.aScore) ? String(row.aScore) : '')],
        ['match', matchText],
        ['flag',  flagInfo],
        ['num',   row.bDisplay ?? (Number.isFinite(row.bScore) ? String(row.bScore) : '')],
      ];

      for (const [cls, value] of cells){
        const td = document.createElement('td');
        td.className = cls;
        if (cls === 'flag') {
          tkRenderFlagCell(td, value);
        } else {
          td.textContent = toText(value);
        }
        tr.appendChild(td);
      }

      TBODY.appendChild(tr);
    }
  }

  const compatRows = pickRows().map(tkNormalizeCompatRow).filter(Boolean);
  window.__tkCompatNormalizedRows = compatRows;
  renderTable(compatRows);
})();

let tkJsPdfLoadPromise = null;

function tkIsJsPdfReady() {
  return !!(window.jspdf && window.jspdf.jsPDF && window.jspdf.jsPDF.API && window.jspdf.jsPDF.API.autoTable);
}

async function tkEnsureJsPDF() {
  if (tkIsJsPdfReady()) return;
  if (tkJsPdfLoadPromise) {
    await tkJsPdfLoadPromise;
    return;
  }

  const localScripts = [
    '/vendor/jspdf.umd.min.js',
    '/vendor/jspdf.plugin.autotable.min.js'
  ];
  const cdnScripts = [
    'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js',
    'https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js'
  ];

  const inject = (src) => new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = src;
    script.async = true;
    script.onload = resolve;
    script.onerror = (err) => reject(err || new Error('Failed to load ' + src));
    document.head.appendChild(script);
  });

  tkJsPdfLoadPromise = (async () => {
    for (const src of localScripts) {
      try {
        await inject(src);
      } catch (err) {
        console.warn('[TK] Failed to load local jsPDF asset:', src, err);
      }
    }

    if (!tkIsJsPdfReady()) {
      for (const src of cdnScripts) {
        try {
          await inject(src);
        } catch (err) {
          console.warn('[TK] Failed to load CDN jsPDF asset:', src, err);
        }
        if (tkIsJsPdfReady()) break;
      }
    }

    if (!tkIsJsPdfReady()) {
      throw new Error('jsPDF/AutoTable not available. Host local copies in /vendor or allow the CDN.');
    }
  })();

  try {
    await tkJsPdfLoadPromise;
  } catch (err) {
    tkJsPdfLoadPromise = null;
    throw err;
  }
}

function tkCollectCompatRowsForPdf() {
  let source = [];
  if (Array.isArray(window.talkkinkCompatRows) && window.talkkinkCompatRows.length) {
    source = window.talkkinkCompatRows;
  } else if (Array.isArray(window.__tkCompatNormalizedRows)) {
    source = window.__tkCompatNormalizedRows;
  }
  return source.map(tkNormalizeCompatRow).filter(Boolean);
}

async function TKPDF_exportCompatibilitySingle() {
  try {
    await tkEnsureJsPDF();
  } catch (err) {
    console.error('jsPDF not loaded â€“ make sure jsPDF UMD is included before this file.', err);
    alert('PDF library not loaded; cannot export.');
    return;
  }

  if (!(window.jspdf && window.jspdf.jsPDF)) {
    console.error('jsPDF not loaded â€“ make sure jsPDF UMD is included before this file.');
    alert('PDF library not loaded; cannot export.');
    return;
  }
  if (!window.jspdf.jsPDF.API.autoTable) {
    console.error('autoTable plugin not loaded.');
    alert('autoTable plugin not loaded; cannot export.');
    return;
  }

  try {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('landscape', 'pt', 'a4');
    const pageWidth = doc.internal.pageSize.getWidth();

    doc.setFont('Helvetica', 'bold');
    doc.setFontSize(28);
    doc.text(TK_PDF_TITLE, pageWidth / 2, 60, { align: 'center' });

    doc.setFontSize(13);
    doc.setFont('Helvetica', 'normal');
    doc.text('Generated: ' + new Date().toLocaleString(), pageWidth / 2, 82, { align: 'center' });

    const compatRows = tkCollectCompatRowsForPdf();
    const body = compatRows.map(tkBuildCompatRow);

    doc.autoTable({
      head: [["Item", "Partner A", "Match", "Flag", "Partner B"]],
      body,
      startY: 110,
      styles: {
        font: 'helvetica',
        fontSize: 10,
        textColor: [255, 255, 255],
        fillColor: [16, 16, 16]
      },
      headStyles: {
        fillColor: [0, 255, 255],
        textColor: [0, 0, 0],
        halign: 'center'
      },
      columnStyles: {
        0: { cellWidth: 260 },
        1: { cellWidth: 70, halign: 'center' },
        2: { cellWidth: 70, halign: 'center' },
        3: { cellWidth: 50, halign: 'center' },
        4: { cellWidth: 70, halign: 'center' }
      },
      theme: 'grid',
      didDrawPage: function () {
        doc.setFillColor(16, 16, 16);
        doc.rect(0, 0, pageWidth, doc.internal.pageSize.getHeight(), 'F');
      }
    });

    doc.save('TalkKink-Compatibility-Report.pdf');
  } catch (err) {
    console.error('[TKPDF] Failed to export compatibility report.', err);
    alert('PDF export failed. See console for details.');
  }
}

function tkBindCompatibilityDownload() {
  const btn = document.getElementById('downloadBtn') || document.getElementById('downloadPdfBtn');
  if (!btn) {
    console.warn('[TK] downloadBtn not found for compatibility export.');
    return;
  }

  btn.onclick = null;

  const parent = btn.parentNode;
  if (!parent) {
    console.warn('[TK] download button has no parent node; cannot rebind.');
    return;
  }

  const clone = btn.cloneNode(true);
  parent.replaceChild(clone, btn);

  clone.addEventListener('click', function (e) {
    e.preventDefault();
    e.stopPropagation();
    TKPDF_exportCompatibilitySingle();
  });

  console.log('[TK] Bound single compatibility PDF exporter to #downloadBtn');
}

if (typeof window !== 'undefined') {
  window.TKPDF_exportCompatibilitySingle = TKPDF_exportCompatibilitySingle;
  window.TKPDF_export = TKPDF_exportCompatibilitySingle;
  window.tkBindCompatibilityDownload = tkBindCompatibilityDownload;
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', tkBindCompatibilityDownload, { once: true });
} else {
  tkBindCompatibilityDownload();
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Defensive renderer hot-fix
   - prevents duplicate renders/tables
   - cleans up stray thead copies
   - normalises flag glyphs & column sizing
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
(() => {
  const HOTFIX_LOCK = '__TK_COMPAT_RENDER_LOCK__';
  if (window[HOTFIX_LOCK]) return;
  window[HOTFIX_LOCK] = true;

  const table = document.getElementById('compatTable');
  if (!table) return;

  const parser = new DOMParser();

  function decodeEntities(value){
    if (!value || !value.includes('&')) return value;
    let current = value;
    let previous;
    do {
      previous = current;
      current = parser.parseFromString(previous, 'text/html').documentElement
        .textContent;
    } while (current !== previous && current.includes('&'));
    return current.replace(/&+â€ /g, 'â€ ');
  }

  function purgeDuplicateTables(){
    const allTables = Array.from(document.querySelectorAll('table.compat'));
    const keep = allTables.find(t => t.id === 'compatTable') || allTables[0];
    allTables.forEach(t => {
      if (t !== keep) t.remove();
    });
    return keep;
  }

  function ensureSingleThead(tbl){
    const theads = Array.from(tbl.querySelectorAll('thead'));
    theads.slice(1).forEach(t => t.remove());
    const head = theads[0];
    if (!head) return;
    if (!head.querySelector('tr')) head.remove();
  }

  function retuneLayout(tbl){
    tbl.style.width = '100%';
    tbl.style.tableLayout = 'fixed';

    const flagCol = tbl.querySelector('col.flag');
    if (flagCol) flagCol.style.width = '6%';

    const headCells = tbl.querySelectorAll('thead th');
    headCells.forEach((th, idx) => {
      th.style.textAlign = idx === 0 ? 'left' : 'center';
      th.style.borderBottom = '1px solid var(--grid)';
      th.style.textShadow = '0 0 0 var(--bg), 0 0 12px rgba(0,231,255,.22)';
    });
  }

  function normaliseCells(tbl){
    const rows = tbl.querySelectorAll('tbody tr');
    rows.forEach(row => {
      const cells = row.querySelectorAll('td');
      if (!cells.length) return;

      const decodedCells = Array.from(cells, cell => decodeEntities(cell.textContent.trim()));
      const aScore = tkParseScore(decodedCells[1]);
      const bScore = tkParseScore(decodedCells[4]);
      const matchPct = tkParseMatchPercent(decodedCells[2]);
      const flagCell = cells[3];
      const rawFlagText = decodedCells[3];
      const rowData = {
        aScore,
        bScore,
        matchPct,
        flagRaw: rawFlagText,
        flagStatus: flagCell?.dataset?.flagStatus || rawFlagText,
        hasData: Number.isFinite(aScore) || Number.isFinite(bScore),
      };
      const flagInfo = tkResolveFlagInfo(rowData);

      cells.forEach((cell, idx) => {
        const decoded = decodedCells[idx] ?? '';
        if (idx === 3){
          cell.classList.add('flag');
          if (typeof window.tkRenderFlagCell === 'function') {
            window.tkRenderFlagCell(cell, flagInfo);
          } else {
            const fallback = (flagInfo && flagInfo.emoji) || decoded.replace(/&+/g, '').trim();
            cell.textContent = fallback;
            cell.style.textAlign = 'center';
            cell.style.letterSpacing = '.5px';
          }
        }else{
          cell.textContent = decoded;
        }
        cell.style.background = '';
      });
    });
  }

  const activeTable = purgeDuplicateTables() || table;
  if (!activeTable) return;

  ensureSingleThead(activeTable);
  retuneLayout(activeTable);
  normaliseCells(activeTable);
})();
</script>
</body>
</html>
