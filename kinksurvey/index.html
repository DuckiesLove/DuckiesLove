<!doctype html>
<html lang="en" class="theme-dark">
  <head>
    <!-- ================== TK “BLACK SCREEN” LAST-RESORT PATCH ==================
    Put this block AT THE VERY TOP of /kinksurvey/index.html (right after <head>).
    It:
      • Forces the page visible immediately (kills prestart/overlay)
      • Nukes old Service Workers + Cache Storage once per tab session
      • Cache-busts all /kinksurvey/ JS/CSS/JSON and patches fetch to no-store
      • Adds a one-time “dead-man switch” reload if nothing renders in time
      • Keeps CTAs/panel from being re-hidden by legacy code
    =========================================================================== -->

    <noscript><style>body{background:#0b1418;color:#e7ffff;font:16px system-ui;padding:20px}</style>
    <p>JavaScript is disabled. Please enable it to load the Talk Kink Survey.</p></noscript>

    <style>
      /* Fail-open: never allow hidden page */
      html,body{background:#0b1418;min-height:100%}
      .tk-prestart, body.tk-prestart{opacity:1!important;visibility:visible!important}
      /* If something sets display:none on critical UI, revert it */
      #tkPortal, #categoryPanel, .category-panel, #ctaStack{display:revert!important;opacity:1!important;visibility:visible!important}
    </style>

    <script>
    (function TK_BOOT_FIX(){
      const TS = Date.now();
      const SS = sessionStorage;

      /* 1) Unblank immediately + keep it unblanked */
      function showCritical(){
        requestAnimationFrame(()=>{
          document.documentElement.classList.remove('tk-prestart');
          if(document.body) document.body.classList.remove('tk-prestart');

          ['tkPortal','categoryPanel','ctaStack'].forEach(id=>{
            const el=document.getElementById(id);
            if(!el) return;
            el.style.display='';
            el.style.opacity='';
            el.style.visibility='';
          });

          document.querySelectorAll('#tkOverlay,.tk-overlay,.overlay,.backdrop,#overlay,#prestart,.prestart,#loading,.loading,#loader,.loader')
            .forEach(n=>{ n.style.display='none'; });
        });
      }

      function keepVisible(el){
        if(!el) return;
        const writeVisible=()=>{
          el.style.display='';
          el.style.opacity='';
          el.style.visibility='';
        };
        new MutationObserver(()=>writeVisible())
          .observe(el,{attributes:true,attributeFilter:['style','class']});
      }

      showCritical();
      document.addEventListener('DOMContentLoaded', showCritical, {once:true});
      window.addEventListener('load', showCritical, {once:true});
      setTimeout(showCritical,0);
      setTimeout(showCritical,250);
      ['tkPortal','categoryPanel','ctaStack']
        .map(id=>document.getElementById(id))
        .forEach(keepVisible);

      /* 2) One-time per tab session: unregister SW + clear Cache Storage */
      (async function nukeSWOnce(){
        if(!('serviceWorker' in navigator)) return;
        const FLAG='tk-sw-nuked';
        if(SS.getItem(FLAG)) return;
        try{
          const regs=await navigator.serviceWorker.getRegistrations();
          await Promise.all(regs.map(r=>r.unregister()));
          if('caches' in window){
            const keys=await caches.keys();
            await Promise.all(keys.map(k=>caches.delete(k)));
          }
        }catch(e){}
        SS.setItem(FLAG,'1');
      })();

      /* 3) Force-fresh critical assets (like DevTools “Disable cache”) */
      (function cacheBust(){
        const bump = String(TS);
        const isCrit = p => /^\/kinksurvey\/(data\/.+\.json|assets\/js\/kinksurvey\/(survey|tk\-enhancer)\.js|css\/kinksurvey_overrides\.css)$/i.test(p);

        // Patch fetch for /kinksurvey/data/*.json
        const ORIG = window.fetch;
        window.fetch = function(input, init){
          try{
            const u=new URL(input, location.origin);
            if(isCrit(u.pathname)){ u.searchParams.set('v', bump); init=Object.assign({cache:'no-store'}, init||{}); return ORIG.call(this, u.toString(), init); }
          }catch(_){ }
          return ORIG.call(this, input, init);
        };

        // Update already-present script/link tags
        const bumpAttr=(el,attr)=>{const href=el.getAttribute(attr);if(!href)return;const u=new URL(href,location.origin);if(isCrit(u.pathname)){u.searchParams.set('v',bump);el.setAttribute(attr, u.pathname+'?'+u.searchParams.toString());}};
        document.querySelectorAll('script[src]').forEach(s=>bumpAttr(s,'src'));
        document.querySelectorAll('link[rel="stylesheet"][href]').forEach(l=>bumpAttr(l,'href'));
      })();

      /* 4) Dead-man switch: if nothing rendered, do one safe cache-busted reload */
      (function deadMan(){
        const FLAG='tk-deadman-reloaded';
        if(SS.getItem(FLAG)) return;             // only once per tab
        const timeout = 1800;                     // ms to wait for first paint
        setTimeout(()=>{
          const portal = document.getElementById('tkPortal');
          const visible = portal && portal.offsetHeight>60 && getComputedStyle(portal).visibility!=='hidden';
          if(!visible){
            SS.setItem(FLAG,'1');
            const u=new URL(location.href);
            u.searchParams.set('nocache', String(TS));
            location.replace(u.toString());
          }
        }, timeout);
      })();

      /* 5) Guard against any script re-hiding the whole body */
      new MutationObserver(()=>{ const s=getComputedStyle(document.body||document.documentElement); if(s.opacity==='0'||s.visibility==='hidden'){ (document.body||document.documentElement).style.opacity='1'; (document.body||document.documentElement).style.visibility='visible'; } })
        .observe(document.documentElement,{attributes:true,subtree:true,attributeFilter:['style','class']});
    })();
    </script>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Talk Kink — Kink Survey</title>

    <!-- =====================  TalkKink • CODEx PASTE BLOCK  =====================
    Goal: Kill the overlay/portal that causes the page to flash, and keep the
    question/rating cards in normal page flow. Paste this ENTIRE block into
    /kinksurvey/ HTML <head>, ABOVE your normal survey script(s).
    ============================================================================= -->

    <!-- 1) Inline runtime: disables & hides any overlay/portal and prevents re-parenting -->
    <script>
    (() => {
      /* Persist flag so your app can skip overlay bootstrap entirely */
      try { localStorage.setItem('__TK_DISABLE_OVERLAY', '1'); } catch {}

      /* CSS: hide any overlay shells, disable animations to prevent flicker */
      const css = document.createElement('style');
      css.id = 'tk-no-overlay-css';
      css.textContent = `
        #tkOverlay, .tkOverlay, .tkDockShell,
        #tkDevOverlay, .tkDevOverlay, [data-tk-overlay], [data-portal] {
          display: none !important; opacity: 0 !important; visibility: hidden !important;
          pointer-events: none !important;
        }
        /* reduce the chance of a visible flash while layout settles */
        * { transition: none !important; animation: none !important; }
      `;
      document.head.appendChild(css);

      /* Remove any overlay nodes already in the DOM */
      const SEL = [
        '#tkPortal', '#tkOverlay', '.tkPortal', '.tkOverlay', '.tkDockShell',
        '#tkDevOverlay', '.tkDevOverlay', '[data-tk-overlay]', '[data-portal]'
      ].join(',');
      const keepPortal = (node) => {
        if (!node || node.id !== 'tkPortal') return false;
        const host = document.getElementById('surveyApp');
        return !!(host && host.contains(node));
      };

      document.querySelectorAll(SEL).forEach(n => {
        try {
          if (!keepPortal(n)) n.remove();
        } catch {}
      });

      /* Ensure the main app stays on top of any leftover artifacts */
      const app = document.querySelector('#surveyApp') || document.querySelector('main');
      if (app) { app.style.position = 'relative'; app.style.zIndex = '2147483640'; }

      /* Soft-block aggressive MutationObservers that try to portal content */
      (function guardMOs(root = window) {
        const MO = root.MutationObserver || root.WebKitMutationObserver;
        if (!MO || !MO.prototype) return;
        const _observe = MO.prototype.observe;
        MO.prototype.observe = function (target, config) {
          try {
            if ((target === document || target === document.body) &&
                config && (config.childList || config.subtree)) {
              return; // refuse whole-document childList observers that often portal
            }
          } catch {}
          return _observe.apply(this, arguments);
        };
      })();

      console.info('[TK] no-overlay inline runtime active (overlay disabled)');
    })();
    </script>

    <!-- 2) OPTIONAL: Let your own survey code read the flag and skip overlay bootstrap.
         Add the following guard at the VERY TOP of your main survey JS (survey.js):

         if (localStorage.getItem('__TK_DISABLE_OVERLAY') === '1') {
           console.info('[TK] Overlay bootstrap skipped');
           // Ensure panel wiring never uses overlay/drawer
           window.TK_PANEL_OPTS = { overlay: false, drawer: false, locked: false };
           // If your file has an explicit overlay init, return early before it runs:
           // return;
         }

         Also force your panel options where you build the UI:
         const PANEL_OPTS = Object.assign({ overlay:false, drawer:false, locked:false }, window.TK_PANEL_OPTS || {});
    -->

    <!-- 3) Load your normal survey script(s) AFTER the block above -->
    <!-- <script src="/assets/survey.js?v=..."></script> -->

    <!-- ====================  End • TalkKink CODEx Paste Block  ==================== -->
    <script>
      // hard reset flags that old code checks
      window.__TK_DISABLE_OVERLAY = true;
      window.__TK_DISABLE_PORTAL = true;
      window.__TK_DISABLE_DRAWER = true;

      // if a legacy boot still runs, neutralize its methods safely
      (function(){
        const noop = ()=>{};
        const g = window;
        const suspects = [
          'tkPanelBoot','tkPortalBoot','tkOverlayBoot',
          'tkDockLayout','tkLockPanel','tkOpenPanel','tkWirePanel'
        ];
        suspects.forEach(k => { if (k in g) g[k] = noop; });
        // remove any pre-existing overlay nodes if injected before this executes
        const keepPortal = (node) => {
          if (!node || node.id !== 'tkPortal') return false;
          const host = document.getElementById('surveyApp');
          return !!(host && host.contains(node));
        };

        const killNodes = () => {
          document.querySelectorAll('#tkPortal,.tk-overlay,.tk-drawer,.tk-panel,.portal-overlay')
            .forEach(n => { if (!keepPortal(n)) n.remove(); });
        };
        document.addEventListener('DOMContentLoaded', killNodes);
        new MutationObserver(killNodes).observe(document.documentElement,{childList:true,subtree:true});
      })();
    </script>

    <link rel="stylesheet" href="/assets/css/kinksurvey/survey.css?v=2025-10-24">
    <script defer src="/assets/js/kinksurvey/survey.js?v=2025-10-24"></script>
    <script defer src="/assets/js/tk-enhancer.js?v=2"></script>

    <style id="tkPrestartStyles">
      /* Categories-only until Start (adapted for docked layout) */
      body.tk-prestart #categoryPanel { display: block !important; }
      body.tk-prestart #tkPortal > :not(.tk-cat-host) { display: none !important; }
      body.tk-prestart .tk-cat-host { display: block !important; }
      body.tk-prestart .tk-cat-host ~ * { display: none !important; }
      body.tk-prestart #tkPortal .tk-left > :not(#categoryPanel) { display: none !important; }
      #surveyApp[hidden], #surveyScoreCard[hidden] { display: none !important; }
    </style>
  </head>
  <body class="tk-prestart">
    <div class="tk-page">
      <header id="tkHeader" class="tk-header">
        <h1 id="pageTitle" class="glow-title">Talk Kink Survey</h1>
      </header>

      <main id="surveyApp" class="survey-root is-prestart" aria-live="polite" data-tk-ready="false">
        <div class="tk-wrap">
          <div id="tkPortal">
            <div class="tk-left tk-cat-host">
              <section id="categoryPanel" class="panel category-panel" aria-label="Categories">
                <div class="panelHeader">
                  <div>
                    <h2 class="tk-side-title">Categories</h2>
                    <div class="tk-cat-count" aria-live="polite"><span id="tkCatSel">0</span> selected</div>
                  </div>
                </div>
                <div class="panelBody">
                  <ul id="categoryChecklist" class="tk-catlist" role="list"></ul>
                </div>
              </section>
            </div>

            <div class="tk-right">
              <div class="tk-meta" aria-label="Theme controls">
                <span class="tk-meta-label">Theme</span>
                <div id="themeControls" class="theme-controls-inline">
                  <button class="theme-btn" data-theme="dark">Dark</button>
                  <button class="theme-btn" data-theme="lipstick">Lipstick</button>
                  <button class="theme-btn" data-theme="forest">Forest</button>
                  <button class="theme-btn" data-theme="azure">Blue Glow</button>
                </div>
              </div>

              <section class="tk-survey-shell">
                <section id="controls" class="tk-controls">
                  <div id="prestartNotice" class="prestart-notice" role="status" aria-live="polite">
                    <h2>Select categories to begin</h2>
                    <p>
                      <span id="prestartCount">0</span>
                      selected so far. Pick at least one category on the left, then press
                      <strong>Start Survey</strong>.
                    </p>
                  </div>
                  <div id="ndProgress" class="tk-progress-shell">
                    <div id="progressBar"><span id="progressPct">0%</span></div>
                    <div id="progressText">Question 0 of 0</div>
                  </div>
                </section>

                <div class="tk-question-layout">
                  <section id="tk-question-host" class="tk-question-host">
                    <div id="tk-progress" class="tk-progress">0%</div>
                    <!-- Ensure these containers exist for JS to target -->
                    <div id="tk-question-card" class="question-card"></div>
                    <aside id="tk-score-rail" class="score-rail"></aside>
                  </section>

                  <aside class="score-sidebar" data-sticky="score">
                    <section class="how-to-score how-to-score--sidebar">
                      <h3>How to score</h3>
                      <ul class="legend">
                        <li><b>0</b> — Brain did a cartwheel (skip for now)</li>
                        <li><b>1</b> — Hard Limit (no-go)</li>
                        <li><b>2</b> — Soft Limit (willing to try…)</li>
                        <li><b>3</b> — Curious / context-dependent</li>
                        <li><b>4</b> — Comfortable / enjoy</li>
                        <li><b>5</b> — Favorite / enthusiastic yes</li>
                      </ul>
                      <div class="rating-box">
                        <div class="label">Rate interest/comfort (0–5)</div>
                        <div class="rating-grid" id="tk-scale-sidebar" data-group="rating-A"></div>
                      </div>
                    </section>
                  </aside>
                </div>

                <script>
                  // ===== TK: hard guarantee that a question renders =====
                  (() => {
                    const q = (sel, root = document) => root.querySelector(sel);

                    document.addEventListener('DOMContentLoaded', () => {
                      tkForceRender();
                      document.addEventListener('change', (event) => {
                        const target = event.target;
                        if (!target) return;
                        if (target.matches('.tk-cat-input, .tk-cat-input *')) tkForceRender();
                      });
                    });

                    async function tkForceRender() {
                      try {
                        const dataURL = new URL('./data/kinks.json', document.baseURI);
                        dataURL.searchParams.set('v', String(Date.now()));
                        const res = await fetch(dataURL.toString());
                        if (!res.ok) return;
                        const raw = await res.json();

                        const catalog = normalizeCatalog(raw);
                        if (!catalog.length) return;

                        const selectedCats = Array.from(document.querySelectorAll('.tk-cat-input:checked'))
                          .map((node) => node.dataset.cat || node.value || '')
                          .filter(Boolean);

                        const selectedName = selectedCats[0] || catalog[0].name;
                        const activeCat = catalog.find((entry) => entry.name === selectedName) || catalog[0];
                        const categoryTitle = activeCat?.name || selectedName || 'Category';
                        const items = Array.isArray(activeCat?.items) ? activeCat.items : [];

                        const first = items[0] ?? 'First item';
                        const label = typeof first === 'string'
                          ? first
                          : first?.label || first?.name || first?.title || first?.prompt || JSON.stringify(first);

                        const host = q('#tk-question-host');
                        if (!host) return;

                        let card = q('#tk-question-card');
                        if (!card) {
                          card = document.createElement('div');
                          card.id = 'tk-question-card';
                          card.className = 'question-card';
                          host.appendChild(card);
                        }
                        card.classList.add('tk-question-card');

                        let rail = q('#tk-score-rail');
                        if (!rail) {
                          rail = document.createElement('aside');
                          rail.id = 'tk-score-rail';
                          rail.className = 'score-rail';
                          host.appendChild(rail);
                        }

                        card.classList.remove('sr-only', 'is-hidden');
                        rail.classList.remove('sr-only', 'is-hidden');

                        const total = items.length || 1;
                        const progress = q('#tk-progress');
                        if (progress) {
                          progress.textContent = '0%';
                          progress.setAttribute('aria-valuenow', '0');
                        }

                        card.innerHTML = `
        <div class="tk-question-title">
          <strong>${categoryTitle}</strong>
          <small>${label}</small>
        </div>
        <div class="tk-scale" id="tk-scale">
          ${[0, 1, 2, 3, 4, 5].map((n) => `<button type="button" data-val="${n}">${n}</button>`).join('')}
        </div>
        <div class="tk-meta">Question 1 of ${total}</div>
      `.trim();

                        const scale = q('#tk-scale');
                        if (scale && !scale.dataset.wired) {
                          scale.dataset.wired = '1';
                          scale.addEventListener('click', (event) => {
                            const button = event.target?.closest('button');
                            if (!button) return;
                            scale.querySelectorAll('button').forEach((el) => {
                              el.classList.toggle('is-active', el === button);
                            });
                          });
                        }
                      } catch (err) {
                        console.error('[TK] force render failed:', err);
                      }
                    }

                    function normalizeCatalog(raw) {
                      const entries = [];

                      if (Array.isArray(raw?.categories)) {
                        raw.categories.forEach((cat) => {
                          const name = tidyName(cat?.name || cat?.title || cat?.category);
                          if (!name) return;
                          entries.push({ name, items: Array.isArray(cat.items) ? cat.items : [] });
                        });
                      } else if (Array.isArray(raw)) {
                        raw.forEach((cat) => {
                          if (typeof cat === 'string') {
                            const name = tidyName(cat);
                            if (!name) return;
                            entries.push({ name, items: [] });
                          } else if (cat && typeof cat === 'object') {
                            const name = tidyName(cat.name || cat.title || cat.category);
                            if (!name) return;
                            entries.push({ name, items: Array.isArray(cat.items) ? cat.items : [] });
                          }
                        });
                      } else if (raw && typeof raw === 'object') {
                        Object.entries(raw).forEach(([key, value]) => {
                          if (key === 'labels') return;
                          if (Array.isArray(value)) {
                            const name = tidyName(key);
                            if (!name) return;
                            entries.push({ name, items: value });
                          }
                        });
                      }

                      return entries;

                      function tidyName(name) {
                        return typeof name === 'string' ? name.trim() : '';
                      }
                    }

                    window.TK_FORCE = tkForceRender;
                  })();
                </script>

                <section id="questionArea" class="tk-question-area">
                  <div id="roleTabs" role="tablist" aria-label="Roles">
                    <button role="tab" data-role="Giving" aria-selected="true">Giving</button>
                    <button role="tab" data-role="Receiving">Receiving</button>
                    <button role="tab" data-role="General">General</button>
                  </div>
                  <section id="question-panel" class="survey-question-panel"></section>

                  <div id="navRow">
                    <button id="prevBtn">Back</button>
                    <button id="skipBtn">Skip</button>
                    <button id="nextBtn">Next</button>
                  </div>
                </section>
              </section>
            </div>
          </div>
        </div>
      </main>

      <script>
        // reveal the chrome once survey.js marks readiness
        const readyTick = setInterval(() => {
          if (window.__TK_SCORE_RAIL_READY__ === true) {
            document.getElementById('surveyApp')?.setAttribute('data-tk-ready', 'true');
            clearInterval(readyTick);
          }
        }, 50);
      </script>
      <section id="exportPayload" hidden aria-hidden="true">
        <table id="compatibilityTable"></table>
      </section>
    </div>

    <!-- CTA stack (safe if it already exists) -->
    <nav id="ctaStack" class="tk-stack" style="display:grid;gap:14px;max-width:560px;">
      <button id="btnStart" class="btn btn-primary" disabled>Start Survey</button>
      <a id="btnKinkAnalysis" class="btn btn-ghost" href="/kinksurvey/analysis/">Individual Kink Analysis</a>
      <a id="btnCompatibility" class="btn btn-ghost" href="/kinksurvey/compat/">Compatibility Page</a>
    </nav>
    <!-- ================== /TK ONE-BOX ================== -->

    <script>
      (function () {
        if (window.__TK_CATEGORY_PRESTART__) return;
        window.__TK_CATEGORY_PRESTART__ = true;

        const log = (...a) => console.info("[TK:cat-bootstrap]", ...a);
        const warn = (...a) => console.warn("[TK:cat-bootstrap]", ...a);

        const ensurePrestart = () => document.body.classList.add("tk-prestart");
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", ensurePrestart, { once: true });
        } else {
          ensurePrestart();
        }

        const $ = (sel, root = document) => root.querySelector(sel);
        const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
        const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

        let catByValue = new Map();

        function cssEscape(value) {
          if (window.CSS && typeof window.CSS.escape === "function") {
            return window.CSS.escape(value);
          }
          return String(value).replace(/["\\]/g, "\\$&");
        }

        function escapeHtml(value) {
          return String(value ?? "").replace(/[&<>"']/g, (ch) => {
            switch (ch) {
              case "&": return "&amp;";
              case "<": return "&lt;";
              case ">": return "&gt;";
              case '"': return "&quot;";
              case "'": return "&#39;";
              default: return ch;
            }
          });
        }

        function slugify(value, fallback = "") {
          const base = value ?? fallback ?? "";
          return String(base)
            .toLowerCase()
            .replace(/&/g, "and")
            .replace(/[^a-z0-9]+/g, "-")
            .replace(/^-+|-+$/g, "");
        }

        function toName(entry, index) {
          if (entry && typeof entry === "object") {
            for (const key of ["name", "title", "label", "category", "cat", "Category"]) {
              if (entry[key]) return String(entry[key]).trim();
            }
          }
          if (typeof entry === "string" || typeof entry === "number") {
            return String(entry).trim();
          }
          if (entry) return String(entry).trim();
          return `Category ${index + 1}`;
        }

        function toValue(entry, fallbackName, index) {
          if (entry && typeof entry === "object") {
            for (const key of ["id", "value", "slug", "key", "code"]) {
              if (entry[key]) return String(entry[key]);
            }
          }
          const fallback = fallbackName || `cat-${index}`;
          const slug = slugify(fallback, `cat-${index}`);
          return slug || `cat-${index}`;
        }

        function captureFromDom(ul) {
          catByValue = new Map();
          const inputs = $$('input[type="checkbox"]', ul);
          inputs.forEach((input) => {
            const id = input.id;
            let labelText = "";
            if (id) {
              const label = ul.querySelector(`label[for="${cssEscape(id)}"]`);
              if (label) labelText = label.textContent.trim();
            }
            if (!labelText) {
              labelText = input.getAttribute("data-label") || input.dataset?.label || input.value;
            }
            catByValue.set(String(input.value), labelText || input.value);
          });
          return inputs.length;
        }

        function render(ul, entries) {
          catByValue = new Map();
          ul.innerHTML = entries.map((entry, idx) => {
            const name = entry.name;
            const rawValue = entry.value ?? name;
            const value = String(rawValue);
            const slug = slugify(value, name) || slugify(name, `cat-${idx}`) || `cat-${idx}`;
            const id = `cat_${slug}`;
            catByValue.set(value, name);
            const safeValue = escapeHtml(value);
            const safeName = escapeHtml(name);
            return `<li data-cat="${safeValue}">
              <input type="checkbox" id="${id}" value="${safeValue}">
              <label for="${id}">${safeName}</label>
            </li>`;
          }).join("");
        }

        function selectedValues(list) {
          return $$('input[type="checkbox"]:checked', list).map((input) => input.value);
        }

        function exitPrestart() {
          if (!document.body.classList.contains("tk-prestart")) return;
          document.body.classList.remove("tk-prestart");
          const app = $("#surveyApp");
          if (app) {
            app.hidden = false;
            app.classList.remove("is-prestart");
          }
          log("exited prestart");
        }

        function getHost() {
          const panel = $("#categoryPanel") || document.body;
          const host = panel.closest(".tk-left") || panel;
          host.classList.add("tk-cat-host");
          if (host !== panel) panel.classList.add("tk-cat-host");
          let tkDiv = $("#tk-cat-list", panel);
          if (!tkDiv) {
            tkDiv = document.createElement("div");
            tkDiv.id = "tk-cat-list";
            panel.appendChild(tkDiv);
          }
          let ul = $("#categoryChecklist", panel);
          if (!ul) {
            ul = document.createElement("ul");
            ul.id = "categoryChecklist";
            ul.className = "category-checklist";
            tkDiv.appendChild(ul);
          }
          return { panel, ul };
        }

        async function tryFetchJSON(urls) {
          for (const url of urls) {
            if (!url) continue;
            try {
              const res = await fetch(url, { credentials: "same-origin" });
              if (!res.ok) {
                log("skip", url, res.status);
                continue;
              }
              const json = await res.json();
              log("loaded", url);
              return json;
            } catch (err) {
              log("fail", url, err.message);
            }
          }
          return null;
        }

        function parseCategoryArray(maybe) {
          if (!maybe) return [];
          if (Array.isArray(maybe)) return maybe;
          if (Array.isArray(maybe.categories)) return maybe.categories;
          if (maybe.data && Array.isArray(maybe.data.categories)) return maybe.data.categories;
          if (Array.isArray(maybe.data)) return maybe.data;
          return [];
        }

        function deriveCategoriesFromKinks(source) {
          if (!source) return [];
          const collected = new Set();
          const push = (value) => {
            if (value != null) {
              const trimmed = String(value).trim();
              if (trimmed) collected.add(trimmed);
            }
          };
          const visit = (arr) => {
            if (!Array.isArray(arr)) return;
            arr.forEach((item) => {
              if (item && typeof item === "object") {
                push(item.category || item.cat || item.Category || item.group);
              } else {
                push(item);
              }
            });
          };
          if (Array.isArray(source)) {
            visit(source);
          } else if (typeof source === "object") {
            visit(source.items);
            visit(source.kinks);
            visit(source.data);
            if (!collected.size) {
              Object.keys(source).forEach((key) => {
                const maybeArr = source[key];
                if (Array.isArray(maybeArr)) {
                  push(key);
                }
              });
            }
          }
          return Array.from(collected).sort();
        }

        function wire(panel) {
          const ul = $("#categoryChecklist", panel);
          if (!ul) return;

          const btn = $("#startSurveyBtn") || $("#btnStart") || $("[data-tk-start]");
          const selEl = $("#categorySelectedCount") || $("#tkCatSel");
          const totEl = $("#categoryTotalCount");
          const prestartCount = $("#prestartCount");

          const total = captureFromDom(ul);
          const totalCount = catByValue.size || total;
          if (totEl && totalCount) totEl.textContent = String(totalCount);

          const update = () => {
            const values = selectedValues(ul);
            const count = values.length;
            if (selEl) selEl.textContent = String(count);
            if (prestartCount) prestartCount.textContent = String(count);
            if (btn) {
              btn.disabled = count === 0;
              if ("classList" in btn) {
                btn.classList.toggle("tk-disabled", count === 0);
              }
              btn.setAttribute("aria-disabled", count === 0 ? "true" : "false");
            }
            panel.dispatchEvent(new CustomEvent("tk:categories:change", {
              bubbles: true,
              detail: {
                selected: values,
                labels: values.map((v) => catByValue.get(v) || v),
                countSelected: count,
                total: totalCount
              }
            }));
          };

          ul.addEventListener("change", (event) => {
            if (event.target?.matches('input[type="checkbox"]')) update();
          });

          if (btn) {
            btn.addEventListener("click", (event) => {
              if (btn.disabled) {
                event.preventDefault();
                return;
              }
              const values = selectedValues(ul);
              const detail = {
                selected: values,
                labels: values.map((v) => catByValue.get(v) || v),
                countSelected: values.length,
                total: totalCount
              };
              exitPrestart();
              panel.dispatchEvent(new CustomEvent("tk:survey:start", {
                bubbles: true,
                detail
              }));
            });
          }

          if (!window.__TK_PRESTART_EXIT_WIRED__) {
            window.__TK_PRESTART_EXIT_WIRED__ = true;
            document.addEventListener("tk:survey:start", exitPrestart);
          }
          panel.addEventListener("tk:survey:start", exitPrestart);

          update();
        }

        async function main() {
          const { panel, ul } = getHost();
          await sleep(200);

          if (ul.children.length > 0) {
            log("Existing bootstrap populated; wiring only.");
            wire(panel);
            return;
          }

          const catsJson = await tryFetchJSON(["/kinksurvey/data/categories.json", "/data/categories.json"]);
          let entries = parseCategoryArray(catsJson);

          if (!entries.length) {
            const kinksJson = await tryFetchJSON(["/kinksurvey/data/kinks.json", "/data/kinks.json"]);
            entries = deriveCategoriesFromKinks(kinksJson);
          }

          if (!entries.length) {
            warn("No categories found (both categories.json & kinks.json empty/unavailable).");
            return;
          }

          const normalized = [];
          const seen = new Set();
          entries.forEach((entry, idx) => {
            const name = toName(entry, idx).trim();
            if (!name) return;
            const key = name.toLowerCase();
            if (seen.has(key)) return;
            seen.add(key);
            const value = toValue(entry, name, normalized.length);
            normalized.push({ name, value });
          });

          normalized.sort((a, b) => a.name.localeCompare(b.name));
          render(ul, normalized);
          wire(panel);
          log(`Rendered ${normalized.length} categories.`);
        }

        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", main, { once: true });
        } else {
          main();
        }
      })();
    </script>

    <script>
      /* ------------------------------------------------------------------
         TK /kinksurvey bootstrap — robust wait + optional enhancer inject
         This runs ONLY on /kinksurvey/ and leaves the landing page alone.
      ------------------------------------------------------------------- */
      (function () {
        if (!location.pathname.startsWith('/kinksurvey/')) return;

        // 1) Version token for cache busting (keep this in sync for /kinksurvey)
        const VER = 'ks-20241020d';

        // 2) Where the enhancer lives (adjust if your path differs)
        const ENHANCER_SRC = '/assets/js/tk-enhancer.js?v=' + encodeURIComponent(VER);

        // 3) Small utilities
        function onReady(fn) {
          document.readyState !== 'loading'
            ? fn()
            : document.addEventListener('DOMContentLoaded', fn);
        }

        function sleep(ms) {
          return new Promise((r) => setTimeout(r, ms));
        }

        function exists(fnName) {
          return typeof window[fnName] === 'function';
        }

        function findEnhancerScript() {
          return Array.from(document.scripts).find((s) => (s.src || '').includes('/assets/js/tk-enhancer.js'));
        }

        async function ensureEnhancerLoaded() {
          // Already present and loaded?
          if (exists('setupDockedSurveyLayout')) return true;

          // If script tag exists but may not have executed yet, wait briefly
          const tag = findEnhancerScript();
          if (tag && !tag.dataset.tkLoadedOnce) {
            for (let i = 0; i < 40; i++) {
              // ~2s max
              if (exists('setupDockedSurveyLayout')) return true;
              await sleep(50);
            }
          }

          // If still not present, inject it now and wait for load
          if (!findEnhancerScript()) {
            await new Promise((resolve, reject) => {
              const s = document.createElement('script');
              s.src = ENHANCER_SRC;
              s.async = true;
              s.onload = () => resolve();
              s.onerror = () => reject(new Error('Failed to load enhancer: ' + ENHANCER_SRC));
              document.head.appendChild(s);
            }).catch((err) => {
              console.warn('[TK] Could not inject enhancer:', err);
            });
          }

          // Final wait loop after injection (or if it existed but was slow)
          for (let i = 0; i < 100; i++) {
            // ~5s max
            if (exists('setupDockedSurveyLayout')) return true;
            await sleep(50);
          }
          return false;
        }

        // 4) Attempt to mount using whatever API is available
        function mountDockNow() {
          // Preferred single entry-point (exported by tk-enhancer.js per prior instructions)
          if (exists('setupDockedSurveyLayout')) {
            try {
              window.setupDockedSurveyLayout();
              return true;
            } catch (e) {
              console.error('[TK] setupDockedSurveyLayout threw:', e);
              return false;
            }
          }

          // Fallback: some builds expose the pieces separately on window or TK
          const NS = window.TK || window;
          const a = NS.ensureDockLayoutNodes;
          const b = NS.mountDockPanel;
          const c = NS.mountDockActions;
          if ([a, b, c].every((fn) => typeof fn === 'function')) {
            try {
              a();
              b();
              c();
              return true;
            } catch (e) {
              console.error('[TK] Dock pieces threw:', e);
              return false;
            }
          }
          return false;
        }

        // 5) Full boot sequence: after DOM, ensure enhancer, then mount
        onReady(async function () {
          // Give survey.js a tiny head-start to build initial DOM
          await sleep(0);

          const ok = await ensureEnhancerLoaded();
          if (!ok) {
            console.warn('[TK] Enhancer not ready – cannot mount docked layout.');
            return;
          }

          // Try mounting immediately
          if (mountDockNow()) return;

          // If mount fails because survey content hasn’t painted yet, retry shortly
          for (let i = 0; i < 40; i++) {
            // ~2s
            await sleep(50);
            if (mountDockNow()) return;
          }

          console.warn('[TK] Dock mount gave up after retries.');
        });
      })();
  </script>



<!-- =======================================================================
TK ONE-BOX PATCH
Goal: (1) Category panel on the LEFT (full-height, page scrolls)
      (2) Three stacked buttons on the RIGHT
      (3) THEME switch directly UNDER the “Talk Kink Survey” title
Paste this block near the BOTTOM of /kinksurvey/index.html, right before </body>.
======================================================================= -->

<style>
  /* --- Layout ------------------------------------------------------- */
  #tkPortal{display:grid;grid-template-columns:380px 1fr;gap:28px;align-items:start}
  @media (max-width:980px){#tkPortal{grid-template-columns:1fr}}

  /* Category panel – left column, no inner scrolling */
  #categoryPanel,.category-panel{grid-column:1!important;position:static!important;max-height:none!important;overflow:visible!important}
  .tk-left{max-height:none!important;overflow:visible!important}

  /* CTA stack – right column */
  #ctaStack{grid-column:2;max-width:560px}
  #ctaStack.tk-stack{display:grid;gap:14px;justify-items:stretch}
  #ctaStack .btn{width:100%;text-align:center;padding:14px 16px;border-radius:12px;font-weight:700}
  #ctaStack .btn-ghost{background:transparent;border:2px solid var(--tk-accent,#39e3ff)}
  #ctaStack .btn[disabled]{opacity:.55;cursor:not-allowed}

  /* THEME row directly under title, spanning both columns */
  .tk-theme-row{grid-column:1/-1;display:flex;flex-wrap:wrap;gap:12px;justify-content:center;align-items:center;margin:-6px 0 18px}
  .tk-theme-row .tk-theme-label{font-weight:700;opacity:.9;margin-right:6px;letter-spacing:.02em}

  /* Category checklist visuals */
  #categoryChecklist{list-style:none;margin:12px 0 16px;padding:0}
  #categoryChecklist li{display:flex;align-items:center;gap:10px;padding:8px 6px;border-radius:8px}
</style>

<!-- If the CTA block is missing, this ensures it exists -->
<nav id="ctaStack" class="tk-stack" style="display:grid;gap:14px;max-width:560px;">
  <button id="btnStart" class="btn btn-primary" disabled>Start Survey</button>
  <a id="btnKinkAnalysis" class="btn btn-ghost" href="/kinksurvey/analysis/">Individual Kink Analysis</a>
  <a id="btnCompatibility" class="btn btn-ghost" href="/kinksurvey/compat/">Compatibility Page</a>
</nav>

<script>
/* =============== 1) Put THEME row directly under the big title =============== */
(function placeThemeUnderTitle(){
  const theme = document.querySelector('#themePicker,#themeSwitch,#themeBar,.theme-picker,.tk-theme,[data-theme-picker]') ||
    Array.from(document.querySelectorAll('nav,.toolbar,.controls,.themes,.btn-row,.button-row'))
      .find(el => /dark|forest|lipstick|blue/i.test(el.textContent||''));
  const title = document.querySelector('#tkTitle,.portal-title h1,.portal-title,header h1,main h1,h1');
  if(!theme || !title || !title.parentElement) return;

  let row = theme.closest('.tk-theme-row');
  if(!row){
    row = document.createElement('div');
    row.className = 'tk-theme-row';
    if(!/theme/i.test(theme.textContent)){ const lbl = document.createElement('span'); lbl.className='tk-theme-label'; lbl.textContent='THEME'; row.appendChild(lbl); }
    theme.parentElement.insertBefore(row, theme); row.appendChild(theme);
  }
  title.parentElement.insertBefore(row, title.nextSibling);
})();

/* =============== 2) Ensure CTAs sit at the right and never get hidden ======= */
(function setCTAs(){
  const portal = document.getElementById('tkPortal');
  const cta = document.getElementById('ctaStack');
  if(!portal || !cta) return;

  if(cta.parentElement !== portal){
    const main = document.getElementById('surveyMain') || document.querySelector('.portal-main');
    if(main && main.parentElement===portal) portal.insertBefore(cta, main);
    else portal.appendChild(cta);
  }
  cta.classList.add('tk-stack'); cta.style.display='';
  new MutationObserver(()=>{ if(getComputedStyle(cta).display==='none') cta.style.display=''; })
    .observe(cta,{attributes:true,attributeFilter:['style','class']});
})();

/* =============== 3) Rebuild/Populate the Categories panel =================== */
(async function buildCategories(){
  const panel = document.getElementById('categoryPanel') || document.querySelector('.category-panel');
  if(!panel) return;

  // make sure the checklist exists
  let list = document.getElementById('categoryChecklist');
  if(!list){ list=document.createElement('ul'); list.id='categoryChecklist'; panel.appendChild(list); }

  const bump = () => String(Date.now());
  async function getFirstJSON(paths){
    for(const p of paths){
      try{
        const u=new URL(p, location.origin); u.searchParams.set('v', bump());
        const r=await fetch(u.toString(), {cache:'no-store'}); if(r.ok) return await r.json();
      }catch(e){}
    }
    return null;
  }
  const normalize = a => [...new Set(a.map(x=>String(x||'').trim()).filter(Boolean))].sort((A,B)=>A.localeCompare(B));

  // 1) Try canonical categories.json
  let categories = null;
  const cats = await getFirstJSON(['/kinksurvey/data/categories.json','./data/categories.json','data/categories.json']);
  if(cats) categories = Array.isArray(cats) ? cats : (cats.categories || null);

  // 2) Fallback: derive from kinks.json
  if(!categories){
    const kinks = await getFirstJSON(['/kinksurvey/data/kinks.json','./data/kinks.json','data/kinks.json']);
    if(kinks){
      const arr = Array.isArray(kinks) ? kinks : (kinks.kinks || []);
      categories = normalize(arr.map(k => k.category || k.Category || ''));
    }
  }

  // 3) Last-resort hardcoded canonical names (ensures panel is never empty)
  if(!categories || !categories.length){
    categories = [
      'Appearance Play','Behavioral Play','Body Fluids and Functions','Body Modification',
      'Body Part / Fetish Play','Body Part Torture','Bondage and Suspension','Breath Play',
      'Breeding','Chastity Devices','Communication','Consensual Non-Consent',
      'Degradation & Humiliation','Domestic Service','Edgeplay','Electrical Play','Food Play',
      'Group Play','Impact Play','Medical Play','Pet Play','Power Exchange','Protocol and Ritual',
      'Psychological Primal / Prey','Psychology Play','Relationship Preferences','Roleplaying',
      'Sensation Play','Service and Restrictive Behaviour','Sexual Activity',
      'Shibari & Rope Bondage','Virtual & Long-Distance Play','Voyeurism/Exhibitionism'
    ];
  }

  // render list
  list.textContent='';
  const frag=document.createDocumentFragment();
  categories.forEach(name=>{
    const id='tk-cat-'+name.toLowerCase().replace(/\s+/g,'-').replace(/[^a-z0-9\-]/g,'');
    const li=document.createElement('li');
    li.innerHTML=`<label style="display:flex;align-items:center;gap:10px;cursor:pointer">
      <input type="checkbox" id="${id}" value="${name}"><span>${name}</span>
    </label>`;
    frag.appendChild(li);
  });
  list.appendChild(frag);

  // enable Start button when at least one category is checked
  const btnStart=document.getElementById('btnStart');
  const selectedCountEl=document.getElementById('categorySelectedCount');
  const totalCountEl=document.getElementById('categoryTotalCount');
  if(totalCountEl) totalCountEl.textContent=String(categories.length);

  const recount=()=>{
    const n=list.querySelectorAll('input[type="checkbox"]:checked').length;
    if(selectedCountEl) selectedCountEl.textContent=String(n);
    if(btnStart) btnStart.disabled=(n===0);
  };
  list.addEventListener('change', e=>{ if(e.target?.matches('input[type="checkbox"]')) recount(); });
  recount();

  if(btnStart){
    btnStart.addEventListener('click', ()=>{
      const selected=[...list.querySelectorAll('input:checked')].map(i=>i.value);
      document.dispatchEvent(new CustomEvent('tk:survey:start',{detail:{categories:selected}}));
      if(window.TKSurvey?.start) window.TKSurvey.start({categories:selected});
    });
  }
})();
</script>

  </body>
</html>
