<!doctype html>
<html lang="en" class="theme-dark">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>TalkKink — Kink Survey</title>

    <script>
      // hard reset flags that old code checks
      window.__TK_DISABLE_OVERLAY = true;
      window.__TK_DISABLE_PORTAL = true;
      window.__TK_DISABLE_DRAWER = true;

      // if a legacy boot still runs, neutralize its methods safely
      (function(){
        const noop = ()=>{};
        const g = window;
        const suspects = [
          'tkPanelBoot','tkPortalBoot','tkOverlayBoot',
          'tkDockLayout','tkLockPanel','tkOpenPanel','tkWirePanel'
        ];
        suspects.forEach(k => { if (k in g) g[k] = noop; });
        // remove any pre-existing overlay nodes if injected before this executes
        const killNodes = () => {
          document.querySelectorAll('#tkPortal,.tk-overlay,.tk-drawer,.tk-panel,.portal-overlay')
            .forEach(n => n.remove());
        };
        document.addEventListener('DOMContentLoaded', killNodes);
        new MutationObserver(killNodes).observe(document.documentElement,{childList:true,subtree:true});
      })();
    </script>

    <link rel="stylesheet" href="/assets/css/kinksurvey/survey.css?v=2025-10-15">
    <script defer src="/assets/js/kinksurvey/survey.js?v=2025-10-15"></script>
    <script defer src="/assets/js/tk-enhancer.js?v=2"></script>
  </head>
  <body>
    <header id="tkHeader" class="header-grid">
      <!-- spacer that matches the fixed left panel width so title never overlaps -->
      <div class="header-spacer" aria-hidden="true"></div>

      <!-- centered title -->
      <h1 id="pageTitle" class="glow-title">TalkKink Survey</h1>

      <!-- theme controls (unchanged buttons) -->
      <div id="themeControls" class="theme-controls">
        <button class="theme-btn" data-theme="dark">Dark</button>
        <button class="theme-btn" data-theme="lipstick">Lipstick</button>
        <button class="theme-btn" data-theme="forest">Forest</button>
        <button class="theme-btn" data-theme="azure">Blue Glow</button>
      </div>
    </header>

    <!-- CTA stack (links to your other pages) -->
    <nav id="ctaStack" class="cta-stack" aria-label="Survey navigation">
      <button id="btnStart" class="cta primary" disabled title="Select at least one category to start">Start Survey</button>
      <a class="cta" href="https://talkkink.org/individualkinkanalysis.html" aria-label="Individual Kink Analysis">Individual Kink Analysis</a>
      <a class="cta" href="https://talkkink.org/compatibility.html" aria-label="Compatibility Page">Compatibility Page</a>
    </nav>

    <main id="surveyApp" class="survey-root is-hidden" aria-live="polite">
      <aside id="categoryPanel" aria-label="Categories">
        <h2 class="tk-side-title">Categories</h2>
        <div class="tk-cat-count" aria-live="polite"><span id="tkCatSel">0</span> selected</div>
        <ul id="categoryChecklist" class="tk-catlist" role="list"></ul>
      </aside>

      <section class="survey-center">
        <section id="controls">
          <div id="ndProgress">
            <div id="progressBar"><span id="progressPct">0%</span></div>
            <div id="progressText">Question 0 of 0</div>
          </div>
        </section>

        <section id="questionArea">
          <div id="roleTabs" role="tablist" aria-label="Roles">
            <button role="tab" data-role="Giving" aria-selected="true">Giving</button>
            <button role="tab" data-role="Receiving">Receiving</button>
            <button role="tab" data-role="General">General</button>
          </div>
          <section id="question-panel" class="survey-question-panel"></section>

          <div id="navRow">
            <button id="prevBtn">Back</button>
            <button id="skipBtn">Skip</button>
            <button id="nextBtn">Next</button>
          </div>
        </section>
      </section>

      <aside class="score-sidebar" data-sticky="score">
        <section class="how-to-score how-to-score--sidebar">
          <h3>How to score</h3>
          <ul class="legend">
            <li><b>0</b> — Brain did a cartwheel (skip for now)</li>
            <li><b>1</b> — Hard Limit (no-go)</li>
            <li><b>2</b> — Soft Limit (willing to try…)</li>
            <li><b>3</b> — Curious / context-dependent</li>
            <li><b>4</b> — Comfortable / enjoy</li>
            <li><b>5</b> — Favorite / enthusiastic yes</li>
          </ul>
          <div class="rating-box">
            <div class="label">Rate interest/comfort (0–5)</div>
            <div class="rating-grid" id="tk-scale-sidebar" data-group="rating-A"></div>
          </div>
        </section>
      </aside>
    </main>
    <section id="exportPayload" hidden aria-hidden="true">
      <table id="compatibilityTable"></table>
    </section>

    <style>
      .survey-root {
        display: grid;
        grid-template-columns: 320px 1fr 340px;
        gap: 16px;
        align-items: start;
      }

      .survey-center {
        display: grid;
        gap: 16px;
      }

      .survey-question-panel .question-card {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 16px;
        padding: 16px;
      }

      .q-head {
        margin-bottom: 8px;
      }

      .q-path {
        opacity: 0.7;
        font-size: 0.9rem;
        margin-bottom: 4px;
      }

      .q-title {
        margin: 0 0 8px;
        font-size: 1.25rem;
      }

      .label {
        font-weight: 600;
        margin-top: 6px;
      }

      #tk-guard {
        margin-top: 6px;
        min-height: 1.2em;
        opacity: 0.8;
      }

      .score-sidebar .how-to-score,
      .how-to-score--sidebar {
        display: block;
      }

      .survey-question-panel .how-to-score,
      #question-panel .how-to-score,
      .how-to-score--inline {
        display: none !important;
      }

      .rating-grid,
      #tk-scale {
        display: grid;
        grid-template-columns: repeat(6, minmax(42px, 1fr));
        gap: 10px;
        margin-top: 10px;
      }

      .rating-grid button,
      #tk-scale button {
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: 12px;
        padding: 10px 0;
        background: transparent;
        color: inherit;
        cursor: pointer;
        font-size: 16px;
      }

      button.option.selected {
        outline: 2px solid currentColor;
        transform: translateY(-1px);
      }

      button.option[aria-pressed="true"] {
        font-weight: 700;
      }

      .score-sidebar .how-to-score {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 16px;
        padding: 14px;
      }

      .how-to-score h3 {
        margin: 0 0 8px;
        font-size: 1.05rem;
      }

      .how-to-score .legend {
        list-style: none;
        padding: 0;
        margin: 0;
        display: grid;
        gap: 8px;
      }

      .how-to-score .legend li {
        background: rgba(255, 255, 255, 0.04);
        border-radius: 12px;
        padding: 10px;
      }

      .score-sidebar .rating-box {
        margin-top: 12px;
        padding-top: 10px;
        border-top: 1px solid rgba(255, 255, 255, 0.08);
      }

      .scoreRow {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 12px;
      }

      .scoreRow button.option {
        min-width: 44px;
        padding: 8px 0;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.04);
      }

      @media (max-width: 980px) {
        .survey-root {
          grid-template-columns: 1fr;
        }

        .score-sidebar {
          order: 3;
          width: 100%;
        }
      }
    </style>

    <script>
      (function () {
        const SCORE_META = Object.freeze({
          0: { label: 'Brain did a cartwheel (skip for now)', tone: 'neutral' },
          1: { label: 'Hard Limit (no-go)', tone: 'hard' },
          2: { label: 'Soft Limit (willing to try…)', tone: 'soft' },
          3: { label: 'Curious / context-dependent', tone: 'curious' },
          4: { label: 'Comfortable / enjoy', tone: 'enjoy' },
          5: { label: 'Favorite / enthusiastic yes', tone: 'favorite' },
        });

        const DEFAULT_GUARD_COPY = 'Select a rating from 0 to 5 to continue.';
        const ratingState = Object.create(null);

        function makeScaleButtons(container, groupKey = 'rating-A') {
          if (!container) return;
          container.dataset.group = groupKey;
          container.dataset.tkScaleReady = '1';
          container.innerHTML = '';
          for (let i = 0; i <= 5; i += 1) {
            const btn = document.createElement('button');
            btn.className = 'option';
            btn.type = 'button';
            btn.dataset.value = String(i);
            btn.dataset.action = 'select';
            btn.textContent = String(i);
            btn.setAttribute('aria-pressed', 'false');
            container.appendChild(btn);
          }
        }

        function renderRatingScales(root) {
          const centerScale = root.querySelector('#tk-scale');
          if (centerScale) makeScaleButtons(centerScale, 'rating-A');
          const sidebarScale = document.getElementById('tk-scale-sidebar');
          if (sidebarScale) makeScaleButtons(sidebarScale, 'rating-A');
        }

        function tagAndHideInlineScoreCards(root) {
          const sidebar = document.querySelector('.score-sidebar');
          const sidebarCard = sidebar?.querySelector('.how-to-score');
          if (sidebarCard) sidebarCard.classList.add('how-to-score--sidebar');

          root
            .querySelectorAll('.survey-question-panel .how-to-score, #question-panel .how-to-score')
            .forEach((el) => el.classList.add('how-to-score--inline'));
        }

        function guardNodes(root) {
          return Array.from(root.querySelectorAll('#tk-guard'));
        }

        function scoreLabel(value) {
          if (value === null || value === undefined || value === '') return '';
          const meta = SCORE_META[value] || SCORE_META[String(value)] || SCORE_META[Number(value)];
          return meta?.label || '';
        }

        function updateGuard(root, value) {
          const nodes = guardNodes(root);
          const hasValue = value !== null && value !== undefined && value !== '';
          nodes.forEach((node) => {
            if (!node) return;
            if (!hasValue) {
              node.textContent = DEFAULT_GUARD_COPY;
              node.dataset.state = 'empty';
              delete node.dataset.tone;
            } else {
              const label = scoreLabel(value);
              node.textContent = label ? `${value} — ${label}` : String(value);
              node.dataset.state = 'value';
              const meta = SCORE_META[value] || SCORE_META[String(value)] || SCORE_META[Number(value)];
              if (meta?.tone) node.dataset.tone = meta.tone;
              else delete node.dataset.tone;
            }
          });
        }

        function syncButtons(root, groupKey, value) {
          const valueStr = value === null || value === undefined || value === '' ? null : String(value);
          root.querySelectorAll(`[data-group="${groupKey}"]`).forEach((container) => {
            if (!container) return;
            if (valueStr === null) {
              container.removeAttribute('data-selected');
              delete container.dataset.selected;
            } else {
              container.setAttribute('data-selected', valueStr);
              container.dataset.selected = valueStr;
            }

            container.querySelectorAll('button.option').forEach((btn) => {
              const btnValue = btn.dataset.value ?? btn.value ?? btn.textContent?.trim();
              const isActive = valueStr !== null && btnValue === valueStr;
              if (!btn.getAttribute('type')) btn.setAttribute('type', 'button');
              btn.classList.toggle('selected', isActive);
              btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            });
          });
        }

        function dispatchChange(root, groupKey, value) {
          const hasValue = value !== null && value !== undefined && value !== '';
          const numeric = hasValue && !Number.isNaN(Number(value)) ? Number(value) : null;
          const detail = {
            group: groupKey,
            value: numeric,
            rawValue: hasValue ? String(value) : null,
            label: hasValue ? scoreLabel(value) : '',
          };
          root.dispatchEvent(new CustomEvent('tk:rating-change', { detail, bubbles: true }));
        }

        function ensureScoreRows(root, groupKey) {
          root.querySelectorAll(`.scoreRow[data-group="${groupKey}"]`).forEach((row) => {
            if (row.dataset.tkScaleReady === '1') return;
            makeScaleButtons(row, groupKey);
          });
        }

        function applySelection(root, groupKey, value, options = {}) {
          ensureScoreRows(root, groupKey);
          const hasValue = value !== null && value !== undefined && value !== '';
          const cleanValue = hasValue ? String(value) : null;
          if (hasValue) ratingState[groupKey] = cleanValue;
          else delete ratingState[groupKey];
          syncButtons(root, groupKey, cleanValue);
          updateGuard(root, cleanValue);
          if (!options.silent) {
            dispatchChange(root, groupKey, cleanValue);
          }
        }

        function collectGroups(root) {
          const groups = new Set();
          root.querySelectorAll('[data-group]').forEach((el) => {
            const key = el.dataset.group || 'default';
            groups.add(key);
          });
          return groups;
        }

        function applyInitialState(root) {
          const groups = collectGroups(root);
          if (!groups.size) {
            updateGuard(root, null);
            return;
          }

          groups.forEach((groupKey) => {
            ensureScoreRows(root, groupKey);
            let initial = null;
            root.querySelectorAll(`[data-group="${groupKey}"]`).forEach((container) => {
              if (initial !== null && initial !== undefined && initial !== '') return;
              const dataSelected = container.getAttribute('data-selected') ?? container.dataset.selected;
              if (dataSelected !== null && dataSelected !== undefined && dataSelected !== '') {
                initial = dataSelected;
                return;
              }
              const pressed = container.querySelector(
                'button.option[aria-pressed="true"], button.option.selected',
              );
              if (pressed) {
                const value = pressed.dataset.value ?? pressed.value ?? pressed.textContent?.trim();
                if (value !== undefined && value !== null && value !== '') {
                  initial = value;
                }
              }
            });
            applySelection(root, groupKey, initial, { silent: true });
          });
        }

        function bindRatingHandler(root) {
          if (!root || root.dataset.tkRatingHandlerBound === '1') return;
          root.dataset.tkRatingHandlerBound = '1';

          root.addEventListener('click', (event) => {
            const btn = event.target?.closest?.('button.option');
            if (!btn || !root.contains(btn)) return;
            const container = btn.closest('[data-group]');
            if (!container) return;
            event.preventDefault();
            const groupKey = container.dataset.group || 'default';
            const value = btn.dataset.value ?? btn.value ?? btn.textContent?.trim() ?? '';
            applySelection(root, groupKey, value);
          });

          root.addEventListener('keydown', (event) => {
            if (!['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(event.key)) return;
            const btn = event.target?.closest?.('button.option');
            if (!btn || !root.contains(btn)) return;
            const container = btn.closest('[data-group]');
            if (!container) return;
            const buttons = Array.from(container.querySelectorAll('button.option'));
            if (!buttons.length) return;
            const currentIndex = buttons.indexOf(btn);
            if (currentIndex === -1) return;
            event.preventDefault();
            const delta = event.key === 'ArrowRight' || event.key === 'ArrowDown' ? 1 : -1;
            let nextIndex = currentIndex + delta;
            if (nextIndex < 0) nextIndex = buttons.length - 1;
            if (nextIndex >= buttons.length) nextIndex = 0;
            buttons[nextIndex].focus();
            buttons[nextIndex].click();
          });
        }

        function initQuestionUIImpl() {
          const root = document.querySelector('.survey-root') || document.body;
          if (!root) return;
          renderRatingScales(root);
          tagAndHideInlineScoreCards(root);
          bindRatingHandler(root);
          applyInitialState(root);
        }

        window.initQuestionUI = function initQuestionUI() {
          initQuestionUIImpl();
        };

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', () => initQuestionUIImpl(), { once: true });
        } else {
          initQuestionUIImpl();
        }
      })();
    </script>

    <!-- TK ONE-CARD SCORE GUIDE PATCH -->
    <style>
      /* Hide the inline duplicate that sits inside the question card */
      .tk-inline-hts {
        display: none !important;
      }

      /* Compact right-rail score card (keep layout intact) */
      .tk-score-aside {
        position: sticky;
        top: 84px;
        /* adjust if your header is taller/shorter */
        align-self: start;
        max-height: calc(100vh - 110px);
        overflow: auto;
        width: 320px;
        /* compact width so it doesn’t force scroll */
        border-radius: 12px;
        padding: 10px 12px;
        background: rgba(8, 12, 16, 0.82);
        box-shadow: 0 0 0 1px rgba(0, 220, 255, 0.18), 0 6px 18px rgba(0, 0, 0, 0.45);
        backdrop-filter: blur(3px);
        font-size: 14px;
        line-height: 1.28;
      }

      .tk-score-aside h1,
      .tk-score-aside h2,
      .tk-score-aside h3,
      .tk-score-aside .title,
      .tk-score-aside .card-title {
        margin: 4px 4px 10px;
        font-weight: 700;
        font-size: 15px;
      }

      /* tighten rows so the card fits */
      .tk-score-aside .row,
      .tk-score-aside li,
      .tk-score-aside .item {
        margin: 6px 0 !important;
        padding: 10px 12px !important;
        border-radius: 10px !important;
      }

      /* On narrow screens, let it flow under the question */
      @media (max-width: 1100px) {
        .tk-score-aside {
          position: static;
          width: auto;
          max-height: none;
          margin-top: 12px;
        }
      }
    </style>

    <script>
      /* --- TK: keep ONE small right-rail score card; hide the inline duplicate --- */
      (() => {
        const FLAG = '__tk_score_fix_v3';
        if (window[FLAG]) return;
        window[FLAG] = true;

        // Only run on /kinksurvey
        if (!/\/kinksurvey\/?$/i.test(location.pathname)) return;

        const q = (sel, root = document) => root.querySelector(sel);
        const qa = (sel, root = document) => Array.from(root.querySelectorAll(sel));

        function findQuestionHost() {
          const root = q('#surveyApp') || q('main') || document.body;
          if (!root) return null;

          // Find a row of 0–5 buttons and climb to a “card-like” ancestor
          const buttons = qa('button,[role="button"]', root).filter((b) =>
            /^\s*[0-5]\s*$/.test(b.textContent || ''),
          );
          if (!buttons.length) return null;

          let node = buttons[0];
          for (let i = 0; i < 6 && node; i += 1) {
            if (node.matches('section,article,.card,.panel,.question,.question-card')) return node;
            node = node.parentElement;
          }
          return null;
        }

        function findScoreCards() {
          // Any block with a title matching "How to score" or legacy "Question Guard"
          const blocks = qa('section,article,aside,div');
          return blocks.filter((el) => {
            const h = q('h1,h2,h3,h4,h5,.title,.card-title', el);
            return h && /(how\s*to\s*score|question\s*guard)/i.test((h.textContent || '').trim());
          });
        }

        function apply() {
          const question = findQuestionHost();
          const cards = findScoreCards();
          if (!question || !cards.length) return;

          // 1) Hide any score card INSIDE the question host (inline duplicate)
          cards.forEach((el) => {
            if (question.contains(el)) el.classList.add('tk-inline-hts');
          });

          // 2) Of the remaining visible cards (outside question), keep exactly one (the right-most)
          const outside = cards.filter((el) => !question.contains(el));
          if (outside.length > 1) {
            outside.sort((a, b) => a.getBoundingClientRect().left - b.getBoundingClientRect().left);
            const keep = outside[outside.length - 1];
            outside.forEach((el) => {
              if (el !== keep) el.remove();
            });
            keep.classList.add('tk-score-aside');
          } else if (outside.length === 1) {
            outside[0].classList.add('tk-score-aside');
          }
        }

        const kick = () => setTimeout(apply, 40);
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', kick, { once: true });
        } else {
          kick();
        }
        new MutationObserver(kick).observe(document.body, { childList: true, subtree: true });

        // optional: quick console check
        window.__TK_SCORE_DEBUG__ = () => ({
          questionFound: !!findQuestionHost(),
          cards: findScoreCards().length,
        });
      })();
    </script>
  </body>
</html>
