<!doctype html>
<html lang="en" class="theme-dark">
  <head>
    <!-- ================== TK “BLACK SCREEN” LAST-RESORT PATCH ==================
    Put this block AT THE VERY TOP of /kinksurvey/index.html (right after <head>).
    It:
      • Forces the page visible immediately (kills prestart/overlay)
      • Nukes old Service Workers + Cache Storage once per tab session
      • Cache-busts all /kinksurvey/ JS/CSS/JSON and patches fetch to no-store
      • Adds a one-time “dead-man switch” reload if nothing renders in time
      • Keeps CTAs/panel from being re-hidden by legacy code
    =========================================================================== -->

    <script id="tk-rescue">
(async () => {
  try {
    // If a stale SW or cached bundle is causing a blank page, clear it and force one clean reload
    const reloadNeeded = !sessionStorage.getItem('tkCacheBusted');

    // Remove ALL service workers for this origin
    if ('serviceWorker' in navigator) {
      const regs = await navigator.serviceWorker.getRegistrations();
      await Promise.all(regs.map(r => r.unregister().catch(() => {})));
    }

    // Purge all Cache Storage buckets
    if ('caches' in window) {
      const keys = await caches.keys();
      await Promise.all(keys.map(k => caches.delete(k).catch(() => {})));
    }

    // Nuke common app caches
    try { localStorage.removeItem('tk-build-hash'); } catch {}
    try { sessionStorage.removeItem('tk-build-hash'); } catch {}

    // One-time cache-busting refresh (prevents infinite loop)
    if (reloadNeeded) {
      sessionStorage.setItem('tkCacheBusted', '1');
      const url = new URL(location.href);
      url.searchParams.set('nuke', Date.now().toString());
      location.replace(url.toString());
      return;
    }
  } catch (e) {
    // Non-fatal: continue to page init
    console.debug('[TK] rescue skipped:', e);
  }

  // Make sure any legacy overlay is suppressed early
  try {
    document.documentElement.classList.add('tk-no-overlay');
    const kill = sel => document.querySelectorAll(sel).forEach(n => n.remove());
    kill('#overlay,#loadingOverlay,.loading-overlay,[data-overlay]');
    const style = document.createElement('style');
    style.textContent = '.tk-no-overlay #overlay,.tk-no-overlay .loading-overlay{display:none!important;visibility:hidden!important;opacity:0!important}';
    document.head.appendChild(style);
  } catch {}
})();
</script>

    <noscript><style>body{background:#0b1418;color:#e7ffff;font:16px system-ui;padding:20px}</style>
    <p>JavaScript is disabled. Please enable it to load the Talk Kink Survey.</p></noscript>

    <style>
      /* Fail-open: never allow hidden page */
      html,body{background:#0b1418;min-height:100%}
      .tk-prestart, body.tk-prestart{opacity:1!important;visibility:visible!important}
      /* If something sets display:none on critical UI, revert it */
      #tkPortal, #categoryPanel, .category-panel, #ctaStack{display:revert!important;opacity:1!important;visibility:visible!important}
    </style>

    <script>
    (function TK_BOOT_FIX(){
      const TS = Date.now();
      const SS = sessionStorage;

      /* 1) Unblank immediately + keep it unblanked */
      function showCritical(){
        requestAnimationFrame(()=>{
          document.documentElement.classList.remove('tk-prestart');
          if(document.body) document.body.classList.remove('tk-prestart');

          ['tkPortal','categoryPanel','ctaStack'].forEach(id=>{
            const el=document.getElementById(id);
            if(!el) return;
            el.style.display='';
            el.style.opacity='';
            el.style.visibility='';
          });

          document.querySelectorAll('#tkOverlay,.tk-overlay,.overlay,.backdrop,#overlay,#prestart,.prestart,#loading,.loading,#loader,.loader')
            .forEach(n=>{ n.style.display='none'; });
        });
      }

      function keepVisible(el){
        if(!el) return;
        const writeVisible=()=>{
          el.style.display='';
          el.style.opacity='';
          el.style.visibility='';
        };
        new MutationObserver(()=>writeVisible())
          .observe(el,{attributes:true,attributeFilter:['style','class']});
      }

      showCritical();
      document.addEventListener('DOMContentLoaded', showCritical, {once:true});
      window.addEventListener('load', showCritical, {once:true});
      setTimeout(showCritical,0);
      setTimeout(showCritical,250);
      ['tkPortal','categoryPanel','ctaStack']
        .map(id=>document.getElementById(id))
        .forEach(keepVisible);

      /* 2) One-time per tab session: unregister SW + clear Cache Storage */
      (async function nukeSWOnce(){
        if(!('serviceWorker' in navigator)) return;
        const FLAG='tk-sw-nuked';
        if(SS.getItem(FLAG)) return;
        try{
          const regs=await navigator.serviceWorker.getRegistrations();
          await Promise.all(regs.map(r=>r.unregister()));
          if('caches' in window){
            const keys=await caches.keys();
            await Promise.all(keys.map(k=>caches.delete(k)));
          }
        }catch(e){}
        SS.setItem(FLAG,'1');
      })();

      /* 3) Force-fresh critical assets (like DevTools “Disable cache”) */
      (function cacheBust(){
        const bump = String(TS);
        const isCrit = p => /^\/kinksurvey\/(data\/.+\.json|assets\/js\/kinksurvey\/(survey|tk\-enhancer)\.js|css\/kinksurvey_overrides\.css)$/i.test(p);

        // Patch fetch for /kinksurvey/data/*.json
        const ORIG = window.fetch;
        window.fetch = function(input, init){
          try{
            const u=new URL(input, location.origin);
            if(isCrit(u.pathname)){ u.searchParams.set('v', bump); init=Object.assign({cache:'no-store'}, init||{}); return ORIG.call(this, u.toString(), init); }
          }catch(_){ }
          return ORIG.call(this, input, init);
        };

        // Update already-present script/link tags
        const bumpAttr=(el,attr)=>{const href=el.getAttribute(attr);if(!href)return;const u=new URL(href,location.origin);if(isCrit(u.pathname)){u.searchParams.set('v',bump);el.setAttribute(attr, u.pathname+'?'+u.searchParams.toString());}};
        document.querySelectorAll('script[src]').forEach(s=>bumpAttr(s,'src'));
        document.querySelectorAll('link[rel="stylesheet"][href]').forEach(l=>bumpAttr(l,'href'));
      })();

      /* 4) Dead-man switch: if nothing rendered, do one safe cache-busted reload */
      (function deadMan(){
        const FLAG='tk-deadman-reloaded';
        if(SS.getItem(FLAG)) return;             // only once per tab
        const timeout = 1800;                     // ms to wait for first paint
        setTimeout(()=>{
          const portal = document.getElementById('tkPortal');
          const visible = portal && portal.offsetHeight>60 && getComputedStyle(portal).visibility!=='hidden';
          if(!visible){
            SS.setItem(FLAG,'1');
            const u=new URL(location.href);
            u.searchParams.set('nocache', String(TS));
            location.replace(u.toString());
          }
        }, timeout);
      })();

      /* 5) Guard against any script re-hiding the whole body */
      new MutationObserver(()=>{ const s=getComputedStyle(document.body||document.documentElement); if(s.opacity==='0'||s.visibility==='hidden'){ (document.body||document.documentElement).style.opacity='1'; (document.body||document.documentElement).style.visibility='visible'; } })
        .observe(document.documentElement,{attributes:true,subtree:true,attributeFilter:['style','class']});
    })();
    </script>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Talk Kink — Kink Survey</title>

    <!-- =====================  TalkKink • CODEx PASTE BLOCK  =====================
    Goal: Kill the overlay/portal that causes the page to flash, and keep the
    question/rating cards in normal page flow. Paste this ENTIRE block into
    /kinksurvey/ HTML <head>, ABOVE your normal survey script(s).
    ============================================================================= -->

    <!-- 1) Inline runtime: disables & hides any overlay/portal and prevents re-parenting -->
    <script>
    (() => {
      /* Persist flag so your app can skip overlay bootstrap entirely */
      try { localStorage.setItem('__TK_DISABLE_OVERLAY', '1'); } catch {}

      /* CSS: hide any overlay shells, disable animations to prevent flicker */
      const css = document.createElement('style');
      css.id = 'tk-no-overlay-css';
      css.textContent = `
        #tkOverlay, .tkOverlay, .tkDockShell,
        #tkDevOverlay, .tkDevOverlay, [data-tk-overlay], [data-portal] {
          display: none !important; opacity: 0 !important; visibility: hidden !important;
          pointer-events: none !important;
        }
        /* reduce the chance of a visible flash while layout settles */
        * { transition: none !important; animation: none !important; }
      `;
      document.head.appendChild(css);

      /* Remove any overlay nodes already in the DOM */
      const SEL = [
        '#tkPortal', '#tkOverlay', '.tkPortal', '.tkOverlay', '.tkDockShell',
        '#tkDevOverlay', '.tkDevOverlay', '[data-tk-overlay]', '[data-portal]'
      ].join(',');
      const keepPortal = (node) => {
        if (!node || node.id !== 'tkPortal') return false;
        const host = document.getElementById('surveyApp');
        return !!(host && host.contains(node));
      };

      document.querySelectorAll(SEL).forEach(n => {
        try {
          if (!keepPortal(n)) n.remove();
        } catch {}
      });

      /* Ensure the main app stays on top of any leftover artifacts */
      const app = document.querySelector('#surveyApp') || document.querySelector('main');
      if (app) { app.style.position = 'relative'; app.style.zIndex = '2147483640'; }

      /* Soft-block aggressive MutationObservers that try to portal content */
      (function guardMOs(root = window) {
        const MO = root.MutationObserver || root.WebKitMutationObserver;
        if (!MO || !MO.prototype) return;
        const _observe = MO.prototype.observe;
        MO.prototype.observe = function (target, config) {
          try {
            if ((target === document || target === document.body) &&
                config && (config.childList || config.subtree)) {
              return; // refuse whole-document childList observers that often portal
            }
          } catch {}
          return _observe.apply(this, arguments);
        };
      })();

      console.info('[TK] no-overlay inline runtime active (overlay disabled)');
    })();
    </script>

    <!-- 2) OPTIONAL: Let your own survey code read the flag and skip overlay bootstrap.
         Add the following guard at the VERY TOP of your main survey JS (survey.js):

         if (localStorage.getItem('__TK_DISABLE_OVERLAY') === '1') {
           console.info('[TK] Overlay bootstrap skipped');
           // Ensure panel wiring never uses overlay/drawer
           window.TK_PANEL_OPTS = { overlay: false, drawer: false, locked: false };
           // If your file has an explicit overlay init, return early before it runs:
           // return;
         }

         Also force your panel options where you build the UI:
         const PANEL_OPTS = Object.assign({ overlay:false, drawer:false, locked:false }, window.TK_PANEL_OPTS || {});
    -->

    <!-- 3) Load your normal survey script(s) AFTER the block above -->
    <!-- <script src="/assets/survey.js?v=..."></script> -->

    <!-- ====================  End • TalkKink CODEx Paste Block  ==================== -->
    <script>
      // hard reset flags that old code checks
      window.__TK_DISABLE_OVERLAY = true;
      window.__TK_DISABLE_PORTAL = true;
      window.__TK_DISABLE_DRAWER = true;

      // if a legacy boot still runs, neutralize its methods safely
      (function(){
        const noop = ()=>{};
        const g = window;
        const suspects = [
          'tkPanelBoot','tkPortalBoot','tkOverlayBoot',
          'tkDockLayout','tkLockPanel','tkOpenPanel','tkWirePanel'
        ];
        suspects.forEach(k => { if (k in g) g[k] = noop; });
        // remove any pre-existing overlay nodes if injected before this executes
        const keepPortal = (node) => {
          if (!node || node.id !== 'tkPortal') return false;
          const host = document.getElementById('surveyApp');
          return !!(host && host.contains(node));
        };

        const killNodes = () => {
          document.querySelectorAll('#tkPortal,.tk-overlay,.tk-drawer,.tk-panel,.portal-overlay')
            .forEach(n => { if (!keepPortal(n)) n.remove(); });
        };
        document.addEventListener('DOMContentLoaded', killNodes);
        new MutationObserver(killNodes).observe(document.documentElement,{childList:true,subtree:true});
      })();
    </script>

    <link rel="stylesheet" href="/assets/css/kinksurvey/survey.css?v=2025-10-24">
    <script defer src="/assets/js/kinksurvey/survey.js?v=2025-10-24"></script>
    <script defer src="/assets/js/tk-enhancer.js?v=2"></script>

    <style id="tkPrestartStyles">
      /* Categories-only until Start (adapted for docked layout) */
      body.tk-prestart #categoryPanel { display: block !important; }
      body.tk-prestart #tkPortal > :not(.tk-cat-host) { display: none !important; }
      body.tk-prestart .tk-cat-host { display: block !important; }
      body.tk-prestart .tk-cat-host ~ * { display: none !important; }
      body.tk-prestart #tkPortal .tk-left > :not(#categoryPanel) { display: none !important; }
      #surveyApp[hidden], #surveyScoreCard[hidden] { display: none !important; }
    </style>

    <style>
      .tk-btn.tk-btn--download {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.6rem;
        padding: 1.1rem 1.4rem;
        border-radius: 18px;
        border: 2px solid rgba(0, 255, 255, 0.35);
        background: radial-gradient(120% 120% at 50% 0%, rgba(0, 255, 255, 0.12), rgba(0, 255, 255, 0.05) 60%, rgba(0, 0, 0, 0.25) 100%);
        box-shadow: 0 0 24px rgba(0, 255, 255, 0.18), inset 0 0 18px rgba(0, 255, 255, 0.12);
        color: #e9fbff;
        font-weight: 800;
        letter-spacing: 0.02em;
        font-size: 1.05rem;
        transition: transform 0.06s ease, box-shadow 0.2s ease, border-color 0.2s ease;
      }

      .tk-btn.tk-btn--download:hover {
        transform: translateY(-1px);
        box-shadow: 0 0 36px rgba(0, 255, 255, 0.28), inset 0 0 22px rgba(0, 255, 255, 0.18);
        border-color: rgba(0, 255, 255, 0.55);
      }

      .tk-btn.tk-btn--download[hidden] {
        display: none !important;
      }
    </style>
  </head>
  <body class="tk-prestart">
    <div class="tk-page">
      <header id="tkHeader" class="tk-header">
        <h1 id="pageTitle" class="glow-title">Talk Kink Survey</h1>
      </header>

      <main id="surveyApp" class="survey-root is-prestart" aria-live="polite" data-tk-ready="false">
        <div class="tk-wrap">
          <div id="tkPortal">
            <div class="tk-left tk-cat-host">
              <section id="categoryPanel" class="panel category-panel" aria-label="Categories">
                <div class="panelHeader">
                  <div>
                    <h2 class="tk-side-title">Categories</h2>
                    <div class="tk-cat-count" aria-live="polite"><span id="tkCatSel">0</span> selected</div>
                  </div>
                </div>
                <div class="panelBody">
                  <ul id="categoryChecklist" class="tk-catlist" role="list"></ul>
                </div>
              </section>
            </div>

            <div class="tk-right">
              <div class="tk-meta" aria-label="Theme controls">
                <span class="tk-meta-label">Theme</span>
                <div id="themeControls" class="theme-controls-inline">
                  <button class="theme-btn" data-theme="dark">Dark</button>
                  <button class="theme-btn" data-theme="lipstick">Lipstick</button>
                  <button class="theme-btn" data-theme="forest">Forest</button>
                  <button class="theme-btn" data-theme="azure">Blue Glow</button>
                </div>
              </div>

              <section class="tk-survey-shell">
                <section id="controls" class="tk-controls">
                  <div id="prestartNotice" class="prestart-notice" role="status" aria-live="polite">
                    <h2>Select categories to begin</h2>
                    <p>
                      <span id="prestartCount">0</span>
                      selected so far. Pick at least one category on the left, then press
                      <strong>Start Survey</strong>.
                    </p>
                  </div>
                  <div id="ndProgress" class="tk-progress-shell">
                    <div id="progressBar"><span id="progressPct">0%</span></div>
                    <div id="progressText">Question 0 of 0</div>
                  </div>
                </section>

                <div class="tk-question-layout">
                  <section id="tk-question-host" class="tk-question-host">
                    <div id="tk-progress" class="tk-progress">0%</div>
                    <!-- Ensure these containers exist for JS to target -->
                    <div id="tk-question-card" class="question-card"></div>
                    <aside id="tk-score-rail" class="score-rail"></aside>
                    <button id="btnDownloadResults" class="tk-btn tk-btn--download" hidden>
                      Download Results
                    </button>
                  </section>

                  <aside class="score-sidebar" data-sticky="score">
                    <section class="how-to-score how-to-score--sidebar">
                      <h3>How to score</h3>
                      <ul class="legend">
                        <li><b>0</b> — Brain did a cartwheel (skip for now)</li>
                        <li><b>1</b> — Hard Limit (no-go)</li>
                        <li><b>2</b> — Soft Limit (willing to try…)</li>
                        <li><b>3</b> — Curious / context-dependent</li>
                        <li><b>4</b> — Comfortable / enjoy</li>
                        <li><b>5</b> — Favorite / enthusiastic yes</li>
                      </ul>
                      <div class="rating-box">
                        <div class="label">Rate interest/comfort (0–5)</div>
                        <div class="rating-grid" id="tk-scale-sidebar" data-group="rating-A"></div>
                      </div>
                    </section>
                  </aside>
                </div>

                <script>
                  // ===== TK: hard guarantee that a question renders =====
                  (() => {
                    const q = (sel, root = document) => root.querySelector(sel);

                    document.addEventListener('DOMContentLoaded', () => {
                      tkForceRender();
                      document.addEventListener('change', (event) => {
                        const target = event.target;
                        if (!target) return;
                        if (target.matches('.tk-cat-input, .tk-cat-input *')) tkForceRender();
                      });
                    });

                    async function tkForceRender() {
                      try {
                        const dataURL = new URL('./data/kinks.json', document.baseURI);
                        dataURL.searchParams.set('v', String(Date.now()));
                        const res = await fetch(dataURL.toString());
                        if (!res.ok) return;
                        const raw = await res.json();

                        const catalog = normalizeCatalog(raw);
                        if (!catalog.length) return;

                        const selectedCats = Array.from(document.querySelectorAll('.tk-cat-input:checked'))
                          .map((node) => node.dataset.cat || node.value || '')
                          .filter(Boolean);

                        const selectedName = selectedCats[0] || catalog[0].name;
                        const activeCat = catalog.find((entry) => entry.name === selectedName) || catalog[0];
                        const categoryTitle = activeCat?.name || selectedName || 'Category';
                        const items = Array.isArray(activeCat?.items) ? activeCat.items : [];

                        const first = items[0] ?? 'First item';
                        const label = typeof first === 'string'
                          ? first
                          : first?.label || first?.name || first?.title || first?.prompt || JSON.stringify(first);

                        const host = q('#tk-question-host');
                        if (!host) return;

                        let card = q('#tk-question-card');
                        if (!card) {
                          card = document.createElement('div');
                          card.id = 'tk-question-card';
                          card.className = 'question-card';
                          host.appendChild(card);
                        }
                        card.classList.add('tk-question-card');

                        let rail = q('#tk-score-rail');
                        if (!rail) {
                          rail = document.createElement('aside');
                          rail.id = 'tk-score-rail';
                          rail.className = 'score-rail';
                          host.appendChild(rail);
                        }

                        card.classList.remove('sr-only', 'is-hidden');
                        rail.classList.remove('sr-only', 'is-hidden');

                        const total = items.length || 1;
                        const progress = q('#tk-progress');
                        if (progress) {
                          progress.textContent = '0%';
                          progress.setAttribute('aria-valuenow', '0');
                        }

                        card.innerHTML = `
        <div class="tk-question-title">
          <strong>${categoryTitle}</strong>
          <small>${label}</small>
        </div>
        <div class="tk-scale" id="tk-scale">
          ${[0, 1, 2, 3, 4, 5].map((n) => `<button type="button" data-val="${n}">${n}</button>`).join('')}
        </div>
        <div class="tk-meta">Question 1 of ${total}</div>
      `.trim();

                        const scale = q('#tk-scale');
                        if (scale && !scale.dataset.wired) {
                          scale.dataset.wired = '1';
                          scale.addEventListener('click', (event) => {
                            const button = event.target?.closest('button');
                            if (!button) return;
                            scale.querySelectorAll('button').forEach((el) => {
                              el.classList.toggle('is-active', el === button);
                            });
                          });
                        }
                      } catch (err) {
                        console.error('[TK] force render failed:', err);
                      }
                    }

                    function normalizeCatalog(raw) {
                      const entries = [];

                      if (Array.isArray(raw?.categories)) {
                        raw.categories.forEach((cat) => {
                          const name = tidyName(cat?.name || cat?.title || cat?.category);
                          if (!name) return;
                          entries.push({ name, items: Array.isArray(cat.items) ? cat.items : [] });
                        });
                      } else if (Array.isArray(raw)) {
                        raw.forEach((cat) => {
                          if (typeof cat === 'string') {
                            const name = tidyName(cat);
                            if (!name) return;
                            entries.push({ name, items: [] });
                          } else if (cat && typeof cat === 'object') {
                            const name = tidyName(cat.name || cat.title || cat.category);
                            if (!name) return;
                            entries.push({ name, items: Array.isArray(cat.items) ? cat.items : [] });
                          }
                        });
                      } else if (raw && typeof raw === 'object') {
                        Object.entries(raw).forEach(([key, value]) => {
                          if (key === 'labels') return;
                          if (Array.isArray(value)) {
                            const name = tidyName(key);
                            if (!name) return;
                            entries.push({ name, items: value });
                          }
                        });
                      }

                      return entries;

                      function tidyName(name) {
                        return typeof name === 'string' ? name.trim() : '';
                      }
                    }

                    window.TK_FORCE = tkForceRender;
                  })();
                </script>

                <section id="questionArea" class="tk-question-area">
                  <div id="roleTabs" role="tablist" aria-label="Roles">
                    <button role="tab" data-role="Giving" aria-selected="true">Giving</button>
                    <button role="tab" data-role="Receiving">Receiving</button>
                    <button role="tab" data-role="General">General</button>
                  </div>
                  <section id="question-panel" class="survey-question-panel"></section>

                  <div id="navRow">
                    <button id="prevBtn">Back</button>
                    <button id="skipBtn">Skip</button>
                    <button id="nextBtn">Next</button>
                  </div>
                </section>
              </section>
            </div>
          </div>
        </div>
      </main>

      <script>
        // reveal the chrome once survey.js marks readiness
        const readyTick = setInterval(() => {
          if (window.__TK_SCORE_RAIL_READY__ === true) {
            document.getElementById('surveyApp')?.setAttribute('data-tk-ready', 'true');
            clearInterval(readyTick);
          }
        }, 50);
      </script>
      <section id="exportPayload" hidden aria-hidden="true">
        <table id="compatibilityTable"></table>
      </section>
    </div>

<!-- ================== /TK ONE-BOX ================== -->

    <script>
      (function () {
        if (window.__TK_CATEGORY_PRESTART__) return;
        window.__TK_CATEGORY_PRESTART__ = true;

        const log = (...a) => console.info("[TK:cat-bootstrap]", ...a);
        const warn = (...a) => console.warn("[TK:cat-bootstrap]", ...a);

        const ensurePrestart = () => document.body.classList.add("tk-prestart");
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", ensurePrestart, { once: true });
        } else {
          ensurePrestart();
        }

        const $ = (sel, root = document) => root.querySelector(sel);
        const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
        const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

        let catByValue = new Map();

        function cssEscape(value) {
          if (window.CSS && typeof window.CSS.escape === "function") {
            return window.CSS.escape(value);
          }
          return String(value).replace(/["\\]/g, "\\$&");
        }

        function escapeHtml(value) {
          return String(value ?? "").replace(/[&<>"']/g, (ch) => {
            switch (ch) {
              case "&": return "&amp;";
              case "<": return "&lt;";
              case ">": return "&gt;";
              case '"': return "&quot;";
              case "'": return "&#39;";
              default: return ch;
            }
          });
        }

        function slugify(value, fallback = "") {
          const base = value ?? fallback ?? "";
          return String(base)
            .toLowerCase()
            .replace(/&/g, "and")
            .replace(/[^a-z0-9]+/g, "-")
            .replace(/^-+|-+$/g, "");
        }

        function toName(entry, index) {
          if (entry && typeof entry === "object") {
            for (const key of ["name", "title", "label", "category", "cat", "Category"]) {
              if (entry[key]) return String(entry[key]).trim();
            }
          }
          if (typeof entry === "string" || typeof entry === "number") {
            return String(entry).trim();
          }
          if (entry) return String(entry).trim();
          return `Category ${index + 1}`;
        }

        function toValue(entry, fallbackName, index) {
          if (entry && typeof entry === "object") {
            for (const key of ["id", "value", "slug", "key", "code"]) {
              if (entry[key]) return String(entry[key]);
            }
          }
          const fallback = fallbackName || `cat-${index}`;
          const slug = slugify(fallback, `cat-${index}`);
          return slug || `cat-${index}`;
        }

        function captureFromDom(ul) {
          catByValue = new Map();
          const inputs = $$('input[type="checkbox"]', ul);
          inputs.forEach((input) => {
            const id = input.id;
            let labelText = "";
            if (id) {
              const label = ul.querySelector(`label[for="${cssEscape(id)}"]`);
              if (label) labelText = label.textContent.trim();
            }
            if (!labelText) {
              labelText = input.getAttribute("data-label") || input.dataset?.label || input.value;
            }
            catByValue.set(String(input.value), labelText || input.value);
          });
          return inputs.length;
        }

        function render(ul, entries) {
          catByValue = new Map();
          ul.innerHTML = entries.map((entry, idx) => {
            const name = entry.name;
            const rawValue = entry.value ?? name;
            const value = String(rawValue);
            const slug = slugify(value, name) || slugify(name, `cat-${idx}`) || `cat-${idx}`;
            const id = `cat_${slug}`;
            catByValue.set(value, name);
            const safeValue = escapeHtml(value);
            const safeName = escapeHtml(name);
            return `<li data-cat="${safeValue}">
              <input type="checkbox" id="${id}" value="${safeValue}">
              <label for="${id}">${safeName}</label>
            </li>`;
          }).join("");
        }

        function selectedValues(list) {
          return $$('input[type="checkbox"]:checked', list).map((input) => input.value);
        }

        function exitPrestart() {
          if (!document.body.classList.contains("tk-prestart")) return;
          document.body.classList.remove("tk-prestart");
          const app = $("#surveyApp");
          if (app) {
            app.hidden = false;
            app.classList.remove("is-prestart");
          }
          log("exited prestart");
        }

        function getHost() {
          const panel = $("#categoryPanel") || document.body;
          const host = panel.closest(".tk-left") || panel;
          host.classList.add("tk-cat-host");
          if (host !== panel) panel.classList.add("tk-cat-host");
          let tkDiv = $("#tk-cat-list", panel);
          if (!tkDiv) {
            tkDiv = document.createElement("div");
            tkDiv.id = "tk-cat-list";
            panel.appendChild(tkDiv);
          }
          let ul = $("#categoryChecklist", panel);
          if (!ul) {
            ul = document.createElement("ul");
            ul.id = "categoryChecklist";
            ul.className = "category-checklist";
            tkDiv.appendChild(ul);
          }
          return { panel, ul };
        }

        async function tryFetchJSON(urls) {
          for (const url of urls) {
            if (!url) continue;
            try {
              const res = await fetch(url, { credentials: "same-origin" });
              if (!res.ok) {
                log("skip", url, res.status);
                continue;
              }
              const json = await res.json();
              log("loaded", url);
              return json;
            } catch (err) {
              log("fail", url, err.message);
            }
          }
          return null;
        }

        function parseCategoryArray(maybe) {
          if (!maybe) return [];
          if (Array.isArray(maybe)) return maybe;
          if (Array.isArray(maybe.categories)) return maybe.categories;
          if (maybe.data && Array.isArray(maybe.data.categories)) return maybe.data.categories;
          if (Array.isArray(maybe.data)) return maybe.data;
          return [];
        }

        function deriveCategoriesFromKinks(source) {
          if (!source) return [];
          const collected = new Set();
          const push = (value) => {
            if (value != null) {
              const trimmed = String(value).trim();
              if (trimmed) collected.add(trimmed);
            }
          };
          const visit = (arr) => {
            if (!Array.isArray(arr)) return;
            arr.forEach((item) => {
              if (item && typeof item === "object") {
                push(item.category || item.cat || item.Category || item.group);
              } else {
                push(item);
              }
            });
          };
          if (Array.isArray(source)) {
            visit(source);
          } else if (typeof source === "object") {
            visit(source.items);
            visit(source.kinks);
            visit(source.data);
            if (!collected.size) {
              Object.keys(source).forEach((key) => {
                const maybeArr = source[key];
                if (Array.isArray(maybeArr)) {
                  push(key);
                }
              });
            }
          }
          return Array.from(collected).sort();
        }

        function wire(panel) {
          const ul = $("#categoryChecklist", panel);
          if (!ul) return;

          const btn = $("#startSurveyBtn") || $("#btnStart") || $("[data-tk-start]");
          const selEl = $("#categorySelectedCount") || $("#tkCatSel");
          const totEl = $("#categoryTotalCount");
          const prestartCount = $("#prestartCount");

          const total = captureFromDom(ul);
          const totalCount = catByValue.size || total;
          if (totEl && totalCount) totEl.textContent = String(totalCount);

          const update = () => {
            const values = selectedValues(ul);
            const count = values.length;
            if (selEl) selEl.textContent = String(count);
            if (prestartCount) prestartCount.textContent = String(count);
            if (btn) {
              btn.disabled = count === 0;
              if ("classList" in btn) {
                btn.classList.toggle("tk-disabled", count === 0);
              }
              btn.setAttribute("aria-disabled", count === 0 ? "true" : "false");
            }
            panel.dispatchEvent(new CustomEvent("tk:categories:change", {
              bubbles: true,
              detail: {
                selected: values,
                labels: values.map((v) => catByValue.get(v) || v),
                countSelected: count,
                total: totalCount
              }
            }));
          };

          ul.addEventListener("change", (event) => {
            if (event.target?.matches('input[type="checkbox"]')) update();
          });

          if (btn) {
            btn.addEventListener("click", (event) => {
              if (btn.disabled) {
                event.preventDefault();
                return;
              }
              const values = selectedValues(ul);
              const detail = {
                selected: values,
                labels: values.map((v) => catByValue.get(v) || v),
                countSelected: values.length,
                total: totalCount
              };
              exitPrestart();
              panel.dispatchEvent(new CustomEvent("tk:survey:start", {
                bubbles: true,
                detail
              }));
            });
          }

          if (!window.__TK_PRESTART_EXIT_WIRED__) {
            window.__TK_PRESTART_EXIT_WIRED__ = true;
            document.addEventListener("tk:survey:start", exitPrestart);
          }
          panel.addEventListener("tk:survey:start", exitPrestart);

          update();
        }

        async function main() {
          const { panel, ul } = getHost();
          await sleep(200);

          if (ul.children.length > 0) {
            log("Existing bootstrap populated; wiring only.");
            wire(panel);
            return;
          }

          const catsJson = await tryFetchJSON(["/kinksurvey/data/categories.json", "/data/categories.json"]);
          let entries = parseCategoryArray(catsJson);

          if (!entries.length) {
            const kinksJson = await tryFetchJSON(["/kinksurvey/data/kinks.json", "/data/kinks.json"]);
            entries = deriveCategoriesFromKinks(kinksJson);
          }

          if (!entries.length) {
            warn("No categories found (both categories.json & kinks.json empty/unavailable).");
            return;
          }

          const normalized = [];
          const seen = new Set();
          entries.forEach((entry, idx) => {
            const name = toName(entry, idx).trim();
            if (!name) return;
            const key = name.toLowerCase();
            if (seen.has(key)) return;
            seen.add(key);
            const value = toValue(entry, name, normalized.length);
            normalized.push({ name, value });
          });

          normalized.sort((a, b) => a.name.localeCompare(b.name));
          render(ul, normalized);
          wire(panel);
          log(`Rendered ${normalized.length} categories.`);
        }

        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", main, { once: true });
        } else {
          main();
        }
      })();
    </script>

    <script>
      /* ------------------------------------------------------------------
         TK /kinksurvey bootstrap — robust wait + optional enhancer inject
         This runs ONLY on /kinksurvey/ and leaves the landing page alone.
      ------------------------------------------------------------------- */
      (function () {
        if (!location.pathname.startsWith('/kinksurvey/')) return;

        // 1) Version token for cache busting (keep this in sync for /kinksurvey)
        const VER = 'ks-20241020d';

        // 2) Where the enhancer lives (adjust if your path differs)
        const ENHANCER_SRC = '/assets/js/tk-enhancer.js?v=' + encodeURIComponent(VER);

        // 3) Small utilities
        function onReady(fn) {
          document.readyState !== 'loading'
            ? fn()
            : document.addEventListener('DOMContentLoaded', fn);
        }

        function sleep(ms) {
          return new Promise((r) => setTimeout(r, ms));
        }

        function exists(fnName) {
          return typeof window[fnName] === 'function';
        }

        function findEnhancerScript() {
          return Array.from(document.scripts).find((s) => (s.src || '').includes('/assets/js/tk-enhancer.js'));
        }

        async function ensureEnhancerLoaded() {
          // Already present and loaded?
          if (exists('setupDockedSurveyLayout')) return true;

          // If script tag exists but may not have executed yet, wait briefly
          const tag = findEnhancerScript();
          if (tag && !tag.dataset.tkLoadedOnce) {
            for (let i = 0; i < 40; i++) {
              // ~2s max
              if (exists('setupDockedSurveyLayout')) return true;
              await sleep(50);
            }
          }

          // If still not present, inject it now and wait for load
          if (!findEnhancerScript()) {
            await new Promise((resolve, reject) => {
              const s = document.createElement('script');
              s.src = ENHANCER_SRC;
              s.async = true;
              s.onload = () => resolve();
              s.onerror = () => reject(new Error('Failed to load enhancer: ' + ENHANCER_SRC));
              document.head.appendChild(s);
            }).catch((err) => {
              console.warn('[TK] Could not inject enhancer:', err);
            });
          }

          // Final wait loop after injection (or if it existed but was slow)
          for (let i = 0; i < 100; i++) {
            // ~5s max
            if (exists('setupDockedSurveyLayout')) return true;
            await sleep(50);
          }
          return false;
        }

        // 4) Attempt to mount using whatever API is available
        function mountDockNow() {
          // Preferred single entry-point (exported by tk-enhancer.js per prior instructions)
          if (exists('setupDockedSurveyLayout')) {
            try {
              window.setupDockedSurveyLayout();
              return true;
            } catch (e) {
              console.error('[TK] setupDockedSurveyLayout threw:', e);
              return false;
            }
          }

          // Fallback: some builds expose the pieces separately on window or TK
          const NS = window.TK || window;
          const a = NS.ensureDockLayoutNodes;
          const b = NS.mountDockPanel;
          const c = NS.mountDockActions;
          if ([a, b, c].every((fn) => typeof fn === 'function')) {
            try {
              a();
              b();
              c();
              return true;
            } catch (e) {
              console.error('[TK] Dock pieces threw:', e);
              return false;
            }
          }
          return false;
        }

        // 5) Full boot sequence: after DOM, ensure enhancer, then mount
        onReady(async function () {
          // Give survey.js a tiny head-start to build initial DOM
          await sleep(0);

          const ok = await ensureEnhancerLoaded();
          if (!ok) {
            console.warn('[TK] Enhancer not ready – cannot mount docked layout.');
            return;
          }

          // Try mounting immediately
          if (mountDockNow()) return;

          // If mount fails because survey content hasn’t painted yet, retry shortly
          for (let i = 0; i < 40; i++) {
            // ~2s
            await sleep(50);
            if (mountDockNow()) return;
          }

          console.warn('[TK] Dock mount gave up after retries.');
        });
      })();
  </script>




<!-- =====================  DROP-IN FIX FOR /kinksurvey/  =====================
Restores layout & clears caches so the page boots without DevTools.
=========================================================================== -->

<style>
  :root{
    --tk-gap: 28px;
    --tk-left: 360px;     /* left column width  */
    --tk-right: 420px;    /* right column width */
    --tk-top: 96px;       /* clearance under the big title */
  }

  /* 3-col portal */
  #tkPortal{
    display:grid;
    grid-template-columns: var(--tk-left) 1fr var(--tk-right);
    gap: var(--tk-gap);
    align-items:start;
  }

  /* LEFT: categories – tall and sticky */
  #categoryPanel, .category-panel, #tk-cat-list{
    grid-column:1 !important;
    position:sticky; top:var(--tk-top);
    max-height:calc(100vh - var(--tk-top));
    overflow:auto;
    display:block !important;
    visibility:visible !important;
  }

  /* CENTER: survey/questions */
  #tkCenter{
    grid-column:2 !important;
    min-width:0;
  }

  /* RIGHT: guard panel */
  #tkRight{
    grid-column:3;
    position:sticky; top:var(--tk-top);
    max-height:calc(100vh - var(--tk-top));
    overflow:auto;
    display:flex; flex-direction:column; gap:16px;
  }

  /* Stacked CTAs sit at top of center column */
  #ctaStack{ grid-column:2; display:grid; gap:14px; max-width:640px; }

  /* Prevent any “overlay” code from hiding our columns */
  .tk-force-show{ display:block !important; visibility:visible !important; opacity:1 !important; }

  /* Theme row still spans full width */
  .tk-theme-row{
    grid-column:1 / -1;
    display:flex; flex-wrap:wrap; gap:12px;
    justify-content:center; align-items:center;
    margin:-6px 0 18px;
  }
  .tk-theme-row .tk-theme-label{ font-weight:700; opacity:.9; margin-right:6px; letter-spacing:.02em }

  /* (Light checklist cosmetics if your CSS doesn’t already style it) */
  #categoryChecklist{ list-style:none; margin:12px 0 16px; padding:0 }
  #categoryChecklist li{ display:flex; align-items:center; gap:10px; padding:8px 6px; border-radius:8px }
</style>

<!-- Optional: add CTAs if your page doesn’t already have them -->
<nav id="ctaStack" class="tk-stack" style="display:grid;gap:14px;max-width:560px;">
  <button id="btnStart" class="btn btn-primary" disabled>Start Survey</button>
  <a id="btnKinkAnalysis" class="btn btn-ghost" href="/kinksurvey/analysis/">Individual Kink Analysis</a>
  <a id="btnCompatibility" class="btn btn-ghost" href="/kinksurvey/compat/">Compatibility Page</a>
</nav>

<script id="tk-layout">
(() => {
  const $  = (sel, root = document) => root.querySelector(sel);
  const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));

  const portal = $('#tkPortal') || document.body;
  if (portal && !portal.id) portal.id = 'tkPortal';

  const catPanel = $('#categoryPanel') || $('.category-panel') || $('#tk-cat-list');
  const main     = $('#surveyMain') || $('#tkSurveyMain') || $('.portal-main, .survey-main, main .content');
  const ctas     = $('#ctaStack');

  let center = $('#tkCenter');
  if (!center) {
    center = document.createElement('div');
    center.id = 'tkCenter';
    center.classList.add('tk-force-show');
  }

  let right = $('#tkRight');
  if (!right) {
    right = document.createElement('div');
    right.id = 'tkRight';
    right.classList.add('tk-force-show');
  }

  if (portal && !portal.contains(center)) portal.appendChild(center);
  if (portal && !portal.contains(right)) portal.appendChild(right);

  if (catPanel) {
    if (catPanel.parentElement !== portal) portal.prepend(catPanel);
    catPanel.classList.add('tk-force-show');
    catPanel.style.display = '';
  }

  if (ctas) {
    ctas.classList.add('tk-force-show', 'tk-stack');
    if (ctas.parentElement !== portal) {
      portal.insertBefore(ctas, center);
    }
    ctas.style.display = 'grid';
    ctas.removeAttribute('hidden');
  }

  if (main) {
    if (main.classList && typeof main.classList.add === 'function') {
      main.classList.add('tk-force-show');
    }
    main.style.display = '';
    if (!center.contains(main)) {
      center.appendChild(main);
    }
  }

  function pickGuardRoot(){
    const byHeading = $$('aside,section,div').find(el => {
      const h = el.querySelector('h2,h3,h4');
      return h && /how to score|question guard/i.test((h.textContent || '').trim());
    });
    if (byHeading) return byHeading;

    const ruleChips = $$('.badge, .chip, .pill, .score, .tk-score, .howto .row');
    if (ruleChips.length >= 4) {
      return ruleChips[0].closest('aside,section,.card,.panel') || ruleChips[0].parentElement;
    }
    return null;
  }

  let guard = pickGuardRoot();

  function mountGuard(panel){
    if (!panel) return;
    panel.classList.add('tk-force-show');
    panel.removeAttribute('hidden');
    if (panel.parentElement !== right) {
      right.appendChild(panel);
    }
  }

  function ensureGuard(){
    if (guard && !guard.isConnected) {
      guard = null;
    }
    if (!guard) {
      guard = pickGuardRoot();
      if (guard) mountGuard(guard);
    }
    if (right) {
      if (guard && right.contains(guard)) {
        right.style.display = '';
      } else if (!right.children.length) {
        right.style.display = 'none';
      }
    }
  }

  ensureGuard();

  center.removeAttribute('hidden');
  right.removeAttribute('hidden');

  /* THEME under title */
  (function placeTheme(){
    const title = $('#tkTitle') || $('.portal-title h1') || $('.portal-title') || $('header h1') || $('main h1') || $('h1');
    const theme = $('#themePicker,#themeSwitch,#themeBar,.theme-picker,.tk-theme,[data-theme-picker]') ||
                  Array.from(document.querySelectorAll('nav,.toolbar,.controls,.themes,.btn-row,.button-row'))
                       .find(el => /dark|forest|lipstick|blue/i.test((el.textContent||'').toLowerCase()));
    if (!title || !theme) return;
    let row = theme.closest('.tk-theme-row');
    if (!row) {
      row = document.createElement('div'); row.className = 'tk-theme-row';
      if (!/theme/i.test(theme.textContent)) {
        const lbl = document.createElement('span'); lbl.className = 'tk-theme-label'; lbl.textContent = 'THEME';
        row.appendChild(lbl);
      }
      theme.parentElement.insertBefore(row, theme); row.appendChild(theme);
    }
    title.parentElement.insertBefore(row, title.nextSibling);
  })();

  /* Keep critical columns visible if legacy code hides them */
  const mo = new MutationObserver(() => {
    ensureGuard();
    if (ctas && getComputedStyle(ctas).display === 'none') ctas.style.display = 'grid';
    if (catPanel && getComputedStyle(catPanel).display === 'none') catPanel.style.display = 'block';
    if (center && getComputedStyle(center).display === 'none') center.style.display = 'block';
    if (right && getComputedStyle(right).display === 'none' && right.children.length) right.style.display = 'flex';
    if (guard && getComputedStyle(guard).display === 'none') guard.style.display = '';
  });
  mo.observe(document.documentElement, {subtree:true, childList:true, attributes:true, attributeFilter:['style','class']});

  /* Enable Start when a category is checked and show counts */
  (function bindStart(){
    const list = $('#categoryChecklist');
    const btn  = $('#btnStart');
    const selCount = $('#categorySelectedCount');
    const totalCount= $('#categoryTotalCount');

    function recount(){
      if(!list || !btn) return;
      const n = list.querySelectorAll('input[type="checkbox"]:checked').length;
      btn.disabled = (n===0);
      if(selCount) selCount.textContent = String(n);
      if(totalCount && !totalCount.textContent) {
        totalCount.textContent = String(list.querySelectorAll('input[type="checkbox"]').length || '');
      }
    }
    if(list){
      list.addEventListener('change', e => { if(e.target?.matches('input[type="checkbox"]')) recount(); });
      recount();
    }
    if (btn) btn.addEventListener('click', () => { if (ctas) ctas.style.display='grid'; });
  })();

  /* Populate categories if the UL is empty */
  (async function ensureCategories(){
    const ul = $('#categoryChecklist') || (catPanel && catPanel.querySelector('ul'));
    if (!ul || ul.children.length) return;

    async function getJSON(url){
      const r = await fetch(url, {cache:'no-store'}); if(!r.ok) throw new Error(url); return r.json();
    }
    let cats = [];
    try { cats = await getJSON('/kinksurvey/data/categories.json'); }
    catch {
      try {
        const kinks = await getJSON('/kinksurvey/data/kinks.json');
        const set = new Set(); (kinks||[]).forEach(k => k?.category && set.add(k.category));
        cats = Array.from(set).sort();
      } catch {}
    }
    if (Array.isArray(cats) && cats.length) {
      ul.innerHTML = cats.map(name => `
        <li>
          <label style="display:flex;align-items:center;gap:10px;cursor:pointer;">
            <input type="checkbox" data-category="${name}">
            <span>${name}</span>
          </label>
        </li>`).join('');
      ul.dispatchEvent(new Event('change'));
    }
  })();
})();
</script>

    <script>
      (function () {
        const SELECTORS = Object.freeze({
          questionCard: '#questionCard, #tk-question-card, .tk-question-card, [data-role="question-card"]',
          progressBar: '#progressBar, .tk-progress-bar, [data-role="progress"]'
        });

        const btn = document.getElementById('btnDownloadResults');
        if (!btn) return;

        function uniqueInputs() {
          const seen = new WeakSet();
          const nodes = [];
          document
            .querySelectorAll(
              '#categoryChecklist input[type="checkbox"], .tk-cat-input, .tk-category-list input[type="checkbox"], .category-list input[type="checkbox"]'
            )
            .forEach((input) => {
              if (!(input instanceof HTMLInputElement) || input.type !== 'checkbox') return;
              if (seen.has(input)) return;
              seen.add(input);
              nodes.push(input);
            });
          return nodes;
        }

        function getSelectedCategories() {
          const chosen = [];
          uniqueInputs().forEach((cb) => {
            if (!cb.checked) return;
            const fromDataset = cb.dataset?.cat || cb.dataset?.category;
            if (fromDataset) {
              chosen.push(fromDataset.trim());
              return;
            }
            const label = cb.closest('label');
            const text = label?.querySelector('.tk-catname')?.textContent || label?.textContent || '';
            const cleaned = text.replace(/\s+/g, ' ').trim();
            if (cleaned) chosen.push(cleaned);
          });
          return chosen;
        }

        function getCurrentQuestion() {
          const card = document.querySelector(SELECTORS.questionCard);
          if (!card) return { title: '', path: '' };
          const title = card.querySelector('.q-title, .tk-question-title strong, .tk-question-title, h2, h3, [data-role="question-title"]');
          const path = card.querySelector('#questionPath, .q-path, .tk-question-title small');
          return {
            title: (title?.textContent || '').trim(),
            path: (path?.textContent || '').trim()
          };
        }

        function getCurrentScore() {
          const active = document.querySelector(
            '.tk-rating__choices .tk-scale-btn.is-active, .tk-rating__choices button[aria-pressed="true"], .tk-scale button.is-active, .tk-scale button[aria-pressed="true"]'
          );
          if (!active) return '';
          const value = active.getAttribute('data-value') || active.dataset?.value || active.textContent;
          return (value || '').trim();
        }

        function buildResultsHTML() {
          const categories = getSelectedCategories();
          const now = new Date();
          const stamp = now.toLocaleString();
          const question = getCurrentQuestion();
          const currentScore = getCurrentScore();
          const questionLine = [question.path, question.title].filter(Boolean).join(' — ');

          const categoryList = categories.length
            ? categories.map((c) => `<li>${escapeHTML(c)}</li>`).join('')
            : '<li><em>No categories selected.</em></li>';

          return `<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Talk Kink — Survey Summary</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  :root{ --fg:#EAEFF2; --sub:#9FB7C1; --glow:rgba(0,255,255,.35); }
  html,body{height:100%}
  body{ margin:0; background:#000; color:var(--fg); font:16px/1.6 ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial; }
  .wrap{ max-width:980px; margin:56px auto; padding:0 20px; }
  h1{ font-size:clamp(28px,4.5vw,56px); margin:0 0 8px; letter-spacing:.02em }
  .sub{ color:var(--sub); margin:0 0 28px }
  section{ border:1px solid #0b2c2c; border-radius:16px; padding:22px 20px; margin:16px 0;
           background:linear-gradient(180deg,rgba(0,255,255,.05),rgba(0,255,255,.02)); box-shadow:0 0 28px rgba(0,255,255,.08) inset; }
  h2{ font-size:20px; margin:0 0 12px; letter-spacing:.015em }
  ul{ margin:10px 0 0 20px }
  .badge{ display:inline-block; min-width:1.8rem; text-align:center; border:1px solid var(--glow); border-radius:999px; padding:.15rem .55rem; margin-left:.45rem; }
  .muted{ color:var(--sub); }
  .footer{ margin-top:32px; color:#89a3ab; font-size:13px }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Talk Kink Survey</h1>
    <p class="sub">Export generated ${escapeHTML(stamp)}</p>

    <section>
      <h2>Selected Categories</h2>
      <ul>${categoryList}</ul>
    </section>

    <section>
      <h2>Last Question Answered</h2>
      <p><strong>${escapeHTML(questionLine || '—')}</strong>
         ${currentScore !== '' ? `<span class="badge">Score: ${escapeHTML(currentScore)}</span>` : ''}
      </p>
      <p class="muted">This export shows your chosen categories and the final question context. Your full answers are saved in your browser’s storage for privacy.</p>
    </section>

    <p class="footer">© Talk Kink — local export for your records</p>
  </div>
</body>
</html>`;
        }

        function escapeHTML(value) {
          return String(value ?? '').replace(/[&<>"']/g, (ch) => ({
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
          })[ch]);
        }

        function downloadResults() {
          const html = buildResultsHTML();
          const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `talkkink-survey-summary-${new Date().toISOString().replace(/[:.]/g, '-')}.html`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(() => URL.revokeObjectURL(url), 1500);
        }

        function getProgressPercent() {
          const pctNode = document.getElementById('progressPct');
          if (pctNode) {
            const match = pctNode.textContent?.match(/(\d+(?:\.\d+)?)/);
            if (match) return Number(match[1]);
          }
          const bar = document.querySelector(SELECTORS.progressBar);
          if (!bar) return 0;
          const aria = bar.getAttribute('aria-valuenow');
          if (aria && !Number.isNaN(Number(aria))) return Number(aria);
          const datasetValue = bar.dataset?.value || bar.dataset?.progress || bar.dataset?.percent;
          if (datasetValue && !Number.isNaN(Number(datasetValue))) return Number(datasetValue);
          const width = bar.style?.getPropertyValue('--w');
          if (width) {
            const match = width.match(/(\d+(?:\.\d+)?)%/);
            if (match) return Number(match[1]);
          }
          const textMatch = bar.textContent?.match(/(\d+(?:\.\d+)?)\s*%/);
          if (textMatch) return Number(textMatch[1]);
          return 0;
        }

        function atCompletion() {
          return getProgressPercent() >= 100;
        }

        function findQuestionCard() {
          const cards = Array.from(document.querySelectorAll(SELECTORS.questionCard));
          if (!cards.length) return null;
          return (
            cards.find((el) => el.querySelector('.tk-rating__choices, .tk-scale, [data-group="rating-A"]')) ||
            cards[0]
          );
        }

        function placeButton() {
          const card = findQuestionCard();
          if (!card || !card.parentElement) return;
          if (btn.parentElement === card.parentElement && btn.previousElementSibling === card) return;
          card.insertAdjacentElement('afterend', btn);
        }

        function updateButtonVisibility() {
          placeButton();
          btn.hidden = !atCompletion();
        }

        btn.addEventListener('click', downloadResults);

        const host = document.getElementById('tk-question-host');
        if (host) {
          const mo = new MutationObserver(() => {
            placeButton();
            updateButtonVisibility();
          });
          mo.observe(host, { childList: true, subtree: true });
        }

        const progressEl = document.querySelector(SELECTORS.progressBar);
        if (progressEl) {
          const mo = new MutationObserver(updateButtonVisibility);
          mo.observe(progressEl, { attributes: true, childList: true, subtree: true, characterData: true });
        }

        document.addEventListener('tk:categories:changed', updateButtonVisibility);
        document.addEventListener('tk:progress:changed', updateButtonVisibility);

        updateButtonVisibility();
      })();
    </script>


  </body>
</html>
