<!-- ======================= CODEX DROP-IN: Partner Upload Consent + Clean PDF ======================= -->
<!-- Place this near the end of your page (before </body>). It adds:
     1) A consent modal that appears when a Partner Survey JSON is selected.
     2) Client-side generation of a clean PDF with partner categories/items/scores.
     3) A lightweight banner confirming consent after upload.
-->

<!-- (A) Partner file input (use your own markup if you already have one; keep data-partner-upload) -->
<input id="partnerFile" type="file" accept="application/json" data-partner-upload style="display:none" />
<!-- Example trigger button; wire to your existing UI if you prefer -->
<button id="partnerUploadBtn" type="button">Upload Partner Survey (JSON)</button>

<!-- (B) Consent modal -->
<style>
  .tk-consent-backdrop{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);z-index:9999}
  .tk-consent-modal{width:min(560px,92vw);background:#0b0b0c;color:#e9e9ef;border:1px solid #2a2a35;border-radius:16px;padding:18px 18px 14px;box-shadow:0 12px 40px rgba(0,0,0,.6);font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial}
  .tk-consent-modal h3{margin:0 0 6px 0;font-size:18px}
  .tk-consent-modal p{margin:6px 0 10px}
  .tk-consent-row{display:flex;gap:10px;align-items:flex-start;margin:10px 0 16px}
  .tk-consent-row input[type="checkbox"]{margin-top:2px;transform:scale(1.05)}
  .tk-consent-actions{display:flex;gap:10px;justify-content:flex-end}
  .tk-btn{padding:10px 14px;border-radius:12px;border:1px solid #3b3b49;background:#18181c;color:#fafafc;cursor:pointer}
  .tk-btn.primary{background:#2b64ff;border-color:#2b64ff}
  .tk-btn:disabled{opacity:.6;cursor:not-allowed}
  .tk-consent-small{opacity:.8}
  /* tiny consent banner after success */
  .tk-consent-banner{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:#0e2810;color:#d7f8dd;border:1px solid #2e6b33;border-radius:10px;padding:8px 12px;display:none;z-index:10000}
</style>

<div id="tk-consent" class="tk-consent-backdrop" aria-hidden="true">
  <div role="dialog" aria-modal="true" aria-labelledby="tk-consent-title" class="tk-consent-modal">
    <h3 id="tk-consent-title">Confirm Partner Consent</h3>
    <p>Before importing a partner’s survey, confirm you have their explicit consent to upload and compare their responses here.</p>
    <div class="tk-consent-row">
      <input id="tk-consent-checkbox" type="checkbox" />
      <label for="tk-consent-checkbox">
        I have my partner’s explicit permission to upload and process their survey responses on this site.
      </label>
    </div>
    <p class="tk-consent-small">If you do not have consent, click <b>Cancel</b>. You can delete uploaded data at any time.</p>
    <div class="tk-consent-actions">
      <button class="tk-btn" data-action="cancel">Cancel</button>
      <button class="tk-btn primary" data-action="continue" disabled>Continue</button>
    </div>
  </div>
</div>

<div id="tk-consent-banner" class="tk-consent-banner">✔ Partner consent confirmed. Processing file…</div>

<!-- (C) jsPDF + autoTable for clean PDF generation -->
<script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js" crossorigin="anonymous"></script>
<script src="https://unpkg.com/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js" crossorigin="anonymous"></script>

<script>
/* =============================== Partner Consent Gate =============================== */
(function () {
  const $ = (s, r=document) => r.querySelector(s);

  // Public API: await window.tkConfirmPartnerConsent()
  async function tkConfirmPartnerConsent() {
    const root = $("#tk-consent");
    if (!root) return true; // fail-open if modal missing

    const checkbox = $("#tk-consent-checkbox", root);
    const btnContinue = root.querySelector('[data-action="continue"]');
    const btnCancel   = root.querySelector('[data-action="cancel"]');

    // reset state
    checkbox.checked = false; btnContinue.disabled = true;

    const done = (()=>{ let resolve; const p=new Promise(r=>resolve=r); return {promise:p, resolve}; })();
    const onCheck = () => { btnContinue.disabled = !checkbox.checked; };
    const onCancel = () => cleanup(false);
    const onContinue = () => cleanup(true);

    checkbox.addEventListener('change', onCheck);
    btnCancel.addEventListener('click', onCancel);
    btnContinue.addEventListener('click', onContinue);

    show(root);

    function cleanup(val){
      hide(root);
      checkbox.removeEventListener('change', onCheck);
      btnCancel.removeEventListener('click', onCancel);
      btnContinue.removeEventListener('click', onContinue);
      done.resolve(val);
    }
    return done.promise;
  }
  window.tkConfirmPartnerConsent = tkConfirmPartnerConsent;

  // Wire input + button
  const input = document.querySelector('input[data-partner-upload]') || document.querySelector('#partnerFile');
  const button = document.querySelector('#partnerUploadBtn');
  if (button && input) button.addEventListener('click', ()=> input.click());

  if (input) {
    input.addEventListener('change', async (ev) => {
      const file = ev.target?.files?.[0];
      if (!file) return;

      const ok = await tkConfirmPartnerConsent();
      if (!ok) { ev.target.value = ''; return; }

      flashConsentBanner();

      // Read JSON then generate PDF
      try {
        const text = await file.text();
        const data = JSON.parse(text);
        const rows = extractRowsFromTalkKinkJSON(data); // {Category, Item, Role, Score}
        await generateCleanPartnerPDF(rows, data?.meta);
      } catch (err) {
        console.error('[talkkink] partner file processing error:', err);
        alert('Sorry—could not read that file. Is it a valid TalkKink survey JSON?');
      } finally {
        ev.target.value = '';
      }
    });
  }

  function show(el){ el.style.display='flex'; el.setAttribute('aria-hidden','false'); }
  function hide(el){ el.style.display='none'; el.setAttribute('aria-hidden','true'); }
  function flashConsentBanner() {
    const b = document.getElementById('tk-consent-banner'); if (!b) return;
    b.style.display='block'; setTimeout(()=>{ b.style.display='none'; }, 2500);
  }

  /* ======================== Parser: TalkKink JSON -> rows ======================== */
  function extractRowsFromTalkKinkJSON(data){
    // Expected keys: answersById (id => score), meta.categories
    // ID format like: 'behavioral-play-assigning-corner-time-or-time-outs-giving'
    const map = data?.answersById || {};
    const rows = [];
    for (const [id, score] of Object.entries(map)) {
      const parts = id.split('-');
      const role  = parts[parts.length - 1];                     // giving | receiving | general
      const category = (parts[0] + ' ' + parts[1]).replace(/\b\w/g, m=>m.toUpperCase());
      const item = parts.slice(2, -1).join(' ')
        .replace(/\bTv\b/gi, 'TV')
        .replace(/\s+/g,' ')
        .trim();
      rows.push({ Category: category, Item: capFirst(item), Role: capFirst(role), Score: Number(score) });
    }
    // Sort: Category -> Role -> Item
    rows.sort((a,b)=> a.Category.localeCompare(b.Category) || a.Role.localeCompare(b.Role) || a.Item.localeCompare(b.Item));
    return rows;
  }
  function capFirst(s){ return s ? s.charAt(0).toUpperCase() + s.slice(1) : s; }

  /* =========================== PDF: Clean Partner Tables =========================== */
  async function generateCleanPartnerPDF(rows, meta){
    const { jsPDF } = window.jspdf || {};
    if (!jsPDF || !docAutoTableAvailable()) {
      alert('Sorry—PDF engine not available.');
      return;
    }

    const doc = new jsPDF({ unit:'pt', format:'letter' });
    const timestamp = new Date().toLocaleString();
    const layout = createHeaderLayout(doc, { meta, timestamp });
    const grouped = buildGroupedRows(rows);

    const headerRenderer = () => drawHeaderCenteredToPage(doc, layout);

    if (!grouped.body.length) {
      headerRenderer();
      doc.setFont('helvetica', 'italic');
      doc.setFontSize(12);
      doc.setTextColor(220, 220, 230);
      doc.text('No survey responses found in this file.', doc.internal.pageSize.getWidth() / 2, layout.startY + 28, { align: 'center' });
      doc.save('partner-survey-clean.pdf');
      return;
    }

    doc.autoTable({
      columns: grouped.columns,
      body: grouped.body,
      margin: { left: layout.marginX, right: layout.marginX },
      startY: layout.startY,
      tableWidth: 'auto',
      styles: {
        font: 'helvetica',
        fontSize: 10,
        textColor: [255, 255, 255],
        fillColor: [8, 8, 10],
        lineColor: [32, 32, 40],
        lineWidth: 0.25,
        cellPadding: { top: 6, right: 6, bottom: 6, left: 6 },
        valign: 'middle',
        overflow: 'linebreak'
      },
      headStyles: {
        fontStyle: 'bold',
        fontSize: 11,
        fillColor: [0, 0, 0],
        textColor: [0, 255, 255],
        lineColor: [32, 32, 40],
        lineWidth: 0.4,
        halign: 'left'
      },
      alternateRowStyles: { fillColor: [14, 14, 20] },
      columnStyles: {
        Role: { cellWidth: 96 },
        Item: { cellWidth: 'wrap' },
        Score: { cellWidth: 60, halign: 'center' }
      },
      didDrawPage: headerRenderer,
      didParseCell(data) {
        if (data.section !== 'body') return;
        const raw = data.row.raw;
        if (raw && raw.__type === 'category') {
          if (data.column.index === 0) {
            data.cell.colSpan = grouped.columns.length;
            data.cell.text = [raw.label];
            data.cell.styles.fontStyle = 'bold';
            data.cell.styles.fillColor = [20, 20, 28];
            data.cell.styles.textColor = [0, 255, 255];
            data.cell.styles.halign = 'center';
            data.cell.styles.cellPadding = { top: 8, right: 6, bottom: 8, left: 6 };
          } else {
            data.cell.text = [];
          }
        }
      }
    });

    doc.save('partner-survey-clean.pdf');
  }

  function docAutoTableAvailable() {
    return !!(
      (window.jspdf && window.jspdf.jsPDF && window.jspdf.jsPDF.API && typeof window.jspdf.jsPDF.API.autoTable === 'function') ||
      (window.jsPDF && window.jsPDF.API && typeof window.jsPDF.API.autoTable === 'function')
    );
  }

  function createHeaderLayout(doc, { meta, timestamp }) {
    const pageWidth = doc.internal.pageSize.getWidth();
    const centerX = pageWidth / 2;
    const marginX = 72;
    const detailText = Array.isArray(meta?.categories) && meta.categories.length
      ? `Categories in file: ${meta.categories.join(', ')}`
      : '';
    const detailLines = detailText ? doc.splitTextToSize(detailText, pageWidth - marginX * 2) : [];
    const detailStartY = 134;
    const startY = detailLines.length ? detailStartY + detailLines.length * 12 + 18 : 136;

    return {
      centerX,
      marginX,
      timestamp,
      detailLines,
      startY,
      draw(docInstance) {
        const doc = docInstance;
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(26);
        doc.setTextColor(255, 255, 255);
        doc.text('TalkKink — Partner Survey (Clean Report)', centerX, 64, { align: 'center' });

        doc.setFont('helvetica', 'normal');
        doc.setFontSize(9);
        doc.setTextColor(170, 210, 255);
        doc.text(`Generated: ${timestamp}`, centerX, 82, { align: 'center' });

        doc.setDrawColor(0, 255, 255);
        if (doc.setLineWidth) doc.setLineWidth(1);
        doc.line(marginX, 92, pageWidth - marginX, 92);

        doc.setFont('helvetica', 'bold');
        doc.setFontSize(18);
        doc.setTextColor(255, 255, 255);
        doc.text('Partner Upload Snapshot', centerX, 118, { align: 'center' });

        if (detailLines.length) {
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(10);
          doc.setTextColor(210, 230, 255);
          detailLines.forEach((line, idx) => {
            doc.text(line, centerX, detailStartY + idx * 12, { align: 'center' });
          });
        }
      }
    };
  }

  function drawHeaderCenteredToPage(doc, layout) {
    layout.draw(doc);
  }

  function buildGroupedRows(rows = []) {
    const body = [];
    const columns = [
      { header: 'Role', dataKey: 'Role' },
      { header: 'Item', dataKey: 'Item' },
      { header: 'Score', dataKey: 'Score' }
    ];

    const map = new Map();
    (Array.isArray(rows) ? rows : []).forEach(row => {
      const key = row?.Category || 'Other';
      if (!map.has(key)) map.set(key, []);
      map.get(key).push(row);
    });

    for (const [category, list] of map.entries()) {
      body.push({ __type: 'category', label: category, Role: category, Item: '', Score: '' });
      list.forEach(item => {
        body.push({
          __type: 'entry',
          Role: item?.Role ?? '',
          Item: item?.Item ?? '',
          Score: item?.Score != null ? String(item.Score) : ''
        });
      });
    }

    return { columns, body };
  }
})();
</script>
