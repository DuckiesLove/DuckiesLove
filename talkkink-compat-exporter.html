<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>TalkKink Compatibility Exporter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
  :root{
    --tk-bg: #0b0b0c;
    --tk-cyan: #14e3e9;
    --tk-cyan-rgb: 20,227,233;
    --tk-ink: #f7f7f7;
    --page-pad: 16px;
    --maxw: 1200px;
  }
  html,body{height:100%;background:var(--tk-bg);margin:0}
  body{display:flex;justify-content:center}
  .page{
    width:100%;
    max-width:var(--maxw);
    padding: clamp(12px,2vw,24px);
    box-sizing:border-box;
  }

  /* Headline & subtitle centered, with outlined/glow text */
  .hx{
    margin:0;
    text-align:center;
    color: var(--tk-cyan);
    letter-spacing:.5px;
    /* multi-direction glow outline (safe in PDF html2canvas too) */
    text-shadow:
      0 0 2px rgba(var(--tk-cyan-rgb),.9),
      0 0 6px rgba(var(--tk-cyan-rgb),.6),
      -1px 0 0 rgba(0,0,0,.9), 1px 0 0 rgba(0,0,0,.9),
      0 -1px 0 rgba(0,0,0,.9), 0 1px 0 rgba(0,0,0,.9),
      -1px -1px 0 rgba(0,0,0,.9), 1px 1px 0 rgba(0,0,0,.9);
  }
  .h1{font: 800 clamp(28px, 5vw, 56px) system-ui}
  .h2{font: 800 clamp(22px, 4.2vw, 40px) system-ui; margin-top:.35em}
  .sub{
    text-align:center; color:#b7ffff; opacity:.85;
    margin:.25rem 0 .75rem 0; font: 500 clamp(12px,1.6vw,16px) system-ui
  }
  .rule{height:3px;background:var(--tk-cyan);opacity:.75;margin:.35rem auto 1rem auto;width:100%}

  /* Table: centered, fills width, no extra white bands */
  table.compat{
    width:100%; border-collapse:separate; border-spacing:0;
    background:rgba(0,0,0,.35); color:var(--tk-ink);
    box-shadow: 0 0 0 1px rgba(255,255,255,.04) inset;
  }
  table.compat caption{display:none}
  table.compat thead th{
    position:sticky; top:0; z-index:2;
    background:#0f1214; color: var(--tk-cyan);
    font: 700 clamp(12px,1.7vw,18px) system-ui;
    padding: .7rem .7rem; border-bottom:1px solid rgba(255,255,255,.08);
    text-shadow:
      0 0 2px rgba(var(--tk-cyan-rgb),.7),
      0 0 6px rgba(var(--tk-cyan-rgb),.4);
  }
  table.compat td{
    font: 500 clamp(12px,1.5vw,18px) system-ui;
    padding:.75rem .7rem; border-bottom:1px solid rgba(255,255,255,.06);
    background: rgba(255,255,255,.02);
  }
  table.compat tr:nth-child(odd) td{background: rgba(255,255,255,.035)}
  table.compat .num{ text-align:center; font-variant-numeric: tabular-nums }
  table.compat .label{ word-break: break-word }

  table.compat colgroup col.label{ width: 64% }
  table.compat colgroup col.pa{ width: 12% }
  table.compat colgroup col.match{ width: 12% }
  table.compat colgroup col.pb{ width: 12% }

  /* Remove accidental duplicate header row if an upstream script injects again */
  table.compat thead tr + tr{ display:none !important }

  /* Download button (optional) */
  .bar{display:flex;justify-content:center;margin:1rem 0}
  .btn{
    background:linear-gradient(0deg, rgba(var(--tk-cyan-rgb),.18), rgba(var(--tk-cyan-rgb),.28));
    color:#001a1c; font: 700 15px system-ui; border:1px solid rgba(var(--tk-cyan-rgb),.55);
    border-radius: 12px; padding:.6rem 1rem; cursor:pointer
  }
  .btn:active{ transform: translateY(1px) }
  </style>
</head>
<body>
<div class="page" id="tk-root">
  <h1 class="hx h1">TalkKink Compatibility</h1>
  <div class="sub" id="tk-ts">Generated: —</div>
  <div class="rule"></div>
  <h2 class="hx h2">Behavioral Play</h2>

  <!-- Your compatibility table; the colgroup keeps widths in sync with PDF -->
  <table class="compat" id="compatTable">
    <colgroup>
      <col class="label"><col class="pa"><col class="match"><col class="pb">
    </colgroup>
    <thead>
      <tr>
        <th>Item</th><th>Partner A</th><th>Match</th><th>Partner B</th>
      </tr>
    </thead>
    <tbody id="compatBody"><!-- rows injected by your app; leave empty in template --></tbody>
  </table>

  <div class="bar">
    <button class="btn" id="downloadPdfBtn">Download PDF</button>
  </div>
</div>

<script>
(() => {
  const tsEl = document.getElementById('tk-ts');
  if (tsEl) tsEl.textContent = `Generated: ${new Date().toLocaleString()}`;
})();
</script>
<script>
(() => {
  const CFG = {
    pdfKillSwitch: false,
    selectors: { downloadBtn: '#downloadPdfBtn' },
    columns: [
      { key: 'item',  header: 'Item',      w: 320 },
      { key: 'a',     header: 'Partner A', w: 80  },
      { key: 'match', header: 'Match',     w: 80  },
      { key: 'b',     header: 'Partner B', w: 80  },
    ],
    cdn: {
      jspdf: [
        'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js',
        'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js',
      ],
      autotable: [
        'https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js',
        'https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js',
      ],
    },
  };

  let libsReady = false;
  let rowsReady = false;
  let cachedRows = [];
  let libsPromise = null;

  /* ---------------------- Loader Helpers ---------------------- */

  function loadScript(src, key) {
    return new Promise((resolve, reject) => {
      const existing = document.querySelector(`script[data-lib="${key}"]`);
      if (existing?.dataset.loaded === '1') return resolve();
      if (existing) {
        existing.addEventListener('load', resolve, { once: true });
        existing.addEventListener('error', reject, { once: true });
        return;
      }
      const s = document.createElement('script');
      s.src = src;
      s.defer = true;
      s.crossOrigin = 'anonymous';
      if (key) s.dataset.lib = key;
      s.onload = () => { if (key) s.dataset.loaded = '1'; resolve(); };
      s.onerror = reject;
      document.head.appendChild(s);
    });
  }

  const hasJsPDF = () => !!window.jspdf?.jsPDF || !!window.jsPDF;

  const hasAutoTable = () => {
    const api = window.jspdf?.jsPDF?.API || window.jsPDF?.API;
    return !!(api?.autoTable || api?.__autoTable__);
  };

  async function loadPDFLibs() {
    if (libsPromise) return libsPromise;
    libsPromise = (async () => {
      if (!hasJsPDF()) {
        for (const src of CFG.cdn.jspdf) {
          try { await loadScript(src, 'jspdf'); break; } catch {}
        }
      }
      if (!window.jsPDF && window.jspdf?.jsPDF) window.jsPDF = window.jspdf.jsPDF;

      if (!hasAutoTable()) {
        for (const src of CFG.cdn.autotable) {
          try { await loadScript(src, 'autotable'); break; } catch {}
        }
      }
      if (!hasJsPDF()) throw new Error('jsPDF not available');
      if (!hasAutoTable()) throw new Error('autoTable not available');

      libsReady = true;
      setButtonState();
      return window.jsPDF;
    })();
    return libsPromise;
  }

  /* ---------------------- Helpers ---------------------- */

  const TK_ACCENT = [0, 214, 199];

  const safe = v =>
    v == null || v === 'null' || v === 'undefined' ? '' : String(v);

  const coerceNum = v => {
    if (v == null || v === '') return null;
    const n = Number(String(v).replace(/[^\d.-]/g, ''));
    return Number.isFinite(n) ? n : null;
  };

  function computeMatch(a, b, raw) {
    const direct = coerceNum(raw);
    if (direct != null) return Math.min(Math.max(direct, 0), 100);
    if (a != null && b != null) {
      const diff = Math.abs(a - b);
      return Math.round(100 - (diff / 5) * 100);
    }
    return null;
  }

  function normalizeRow(r) {
    let item, aRaw, bRaw, matchRaw;

    if (Array.isArray(r)) {
      if (r.length >= 5) {
        [item, aRaw, matchRaw, , bRaw] = r;
      } else {
        [item, aRaw, matchRaw, bRaw] = r;
      }
    } else {
      item = r.item ?? r.label ?? '';
      aRaw = r.a ?? r.partnerA ?? null;
      bRaw = r.b ?? r.partnerB ?? null;
      matchRaw = r.matchPercent ?? r.match ?? null;
    }

    const a = coerceNum(aRaw);
    const b = coerceNum(bRaw);
    const pct = computeMatch(a, b, matchRaw);

    return {
      item: safe(item),
      a: a != null ? String(a) : safe(aRaw),
      b: b != null ? String(b) : safe(bRaw),
      match: pct != null ? pct + '%' : safe(matchRaw),
      aNum: a,
      bNum: b,
      pct,
    };
  }

  function header(doc, title, y) {
    const pageW = doc.internal.pageSize.getWidth();
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(36);
    doc.setTextColor(255, 255, 255);

    const w = doc.getTextWidth(title);
    doc.text(title, (pageW - w) / 2, y);

    doc.setFontSize(12);
    const sub = 'Generated: ' + new Date().toLocaleString();
    const w2 = doc.getTextWidth(sub);
    doc.text(sub, (pageW - w2) / 2, y + 20);

    doc.setDrawColor(...TK_ACCENT);
    doc.setLineWidth(2.5);
    doc.line(80, y + 34, pageW - 80, y + 34);

    return y + 60;
  }

  function renderSection(doc, title, rows, startY) {
    const pageW = doc.internal.pageSize.getWidth();
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(24);
    doc.setTextColor(255, 255, 255);

    const tw = doc.getTextWidth(title);
    doc.text(title, (pageW - tw) / 2, startY);

    const tableRows = rows.map(r => ({
      item: r.item,
      a: r.a,
      match: r.match,
      b: r.b,
    }));

    const columnStyles = Object.fromEntries(
      CFG.columns.map((col, idx) => [idx, {
        cellWidth: col.w,
        halign: idx === 0 ? 'left' : 'center',
      }])
    );

    doc.autoTable({
      startY: startY + 26,
      margin: { left: 70, right: 70 },
      head: [CFG.columns.map(c => c.header)],
      body: tableRows.map(r => [r.item, r.a, r.match, r.b]),
      theme: 'grid',
      styles: {
        font: 'helvetica',
        fontSize: 12,
        textColor: [230, 230, 230],
        fillColor: [25, 25, 28],
        lineColor: [40, 40, 45],
        lineWidth: 1.2,
        halign: 'left',
      },
      headStyles: {
        fontStyle: 'bold',
        textColor: [0, 255, 245],
        fillColor: [28, 28, 32],
        halign: 'center',
      },
      columnStyles,
    });
  }

  /* ---------------------- PDF Generator ---------------------- */

  async function generatePDF(rows) {
    if (!rows?.length) throw new Error('No rows to export');

    await loadPDFLibs();
    const jsPDF = window.jsPDF;

    const doc = new jsPDF({
      orientation: 'landscape',
      unit: 'pt',
      format: 'letter',
    });

    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();

    doc.setFillColor(18, 19, 20);
    doc.rect(0, 0, pageW, pageH, 'F');

    const normalized = rows.map(normalizeRow);

    const y = header(doc, 'Talk Kink Compatibility Survey', 70);
    renderSection(doc, 'Behavioral Play', normalized, y);

    doc.save('TalkKink-compatibility.pdf');
  }

  /* ---------------------- State & Button ---------------------- */

  function getBtn() { return document.querySelector(CFG.selectors.downloadBtn); }

  function extractRowsFromTable() {
    const body = document.querySelector('#compatBody');
    if (!body) return [];
    const rows = [];
    body.querySelectorAll('tr').forEach(tr => {
      const cells = Array.from(tr.children, td => safe(td?.textContent).trim());
      if (cells.length >= 4) {
        rows.push(cells.slice(0, 4));
      }
    });
    return rows;
  }

  function computeRows() {
    if (cachedRows?.length) return cachedRows;
    if (Array.isArray(window.talkkinkCompatRows) && window.talkkinkCompatRows.length) {
      cachedRows = window.talkkinkCompatRows.slice();
    } else {
      cachedRows = extractRowsFromTable();
    }
    return cachedRows;
  }

  function setButtonState() {
    const btn = getBtn();
    if (!btn) return;
    rowsReady = computeRows().length > 0;
    const enabled = libsReady && rowsReady && !CFG.pdfKillSwitch;
    btn.disabled = !enabled;
  }

  window.TKCompatPDF = {
    notifyRowsUpdated(rows) {
      if (Array.isArray(rows)) {
        cachedRows = rows.slice();
        window.talkkinkCompatRows = rows.slice();
      } else {
        cachedRows = [];
        window.talkkinkCompatRows = undefined;
      }
      setButtonState();
    },
    setKillSwitch(disabled) {
      CFG.pdfKillSwitch = !!disabled;
      setButtonState();
    },
  };

  function init() {
    const btn = getBtn();
    if (btn) btn.disabled = true;

    if (Array.isArray(window.talkkinkCompatRows))
      cachedRows = window.talkkinkCompatRows.slice();
    else
      cachedRows = extractRowsFromTable();

    setButtonState();

    btn?.addEventListener('click', async e => {
      e.preventDefault();
      try {
        const rows = computeRows();
        if (!rows.length) return alert('Upload both surveys first.');
        await generatePDF(rows);
      } catch (err) {
        console.error(err);
        alert('PDF error — see console');
      }
    });

    loadPDFLibs().catch(err => console.error(err));
  }

  document.readyState === 'loading'
    ? document.addEventListener('DOMContentLoaded', init, { once: true })
    : init();

})();
</script>
</body>
</html>
