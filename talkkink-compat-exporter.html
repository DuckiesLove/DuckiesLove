<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>TalkKink Compatibility Exporter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
  :root{
    --tk-bg: #0b0b0c;
    --tk-cyan: #14e3e9;
    --tk-cyan-rgb: 20,227,233;
    --tk-ink: #f7f7f7;
    --page-pad: 16px;
    --maxw: 1200px;
  }
  html,body{height:100%;background:var(--tk-bg);margin:0}
  body{display:flex;justify-content:center}
  .page{
    width:100%;
    max-width:var(--maxw);
    padding: clamp(12px,2vw,24px);
    box-sizing:border-box;
  }

  /* Headline & subtitle centered, with outlined/glow text */
  .hx{
    margin:0;
    text-align:center;
    color: var(--tk-cyan);
    letter-spacing:.5px;
    /* multi-direction glow outline (safe in PDF html2canvas too) */
    text-shadow:
      0 0 2px rgba(var(--tk-cyan-rgb),.9),
      0 0 6px rgba(var(--tk-cyan-rgb),.6),
      -1px 0 0 rgba(0,0,0,.9), 1px 0 0 rgba(0,0,0,.9),
      0 -1px 0 rgba(0,0,0,.9), 0 1px 0 rgba(0,0,0,.9),
      -1px -1px 0 rgba(0,0,0,.9), 1px 1px 0 rgba(0,0,0,.9);
  }
  .h1{font: 800 clamp(28px, 5vw, 56px) system-ui}
  .h2{font: 800 clamp(22px, 4.2vw, 40px) system-ui; margin-top:.35em}
  .sub{
    text-align:center; color:#b7ffff; opacity:.85;
    margin:.25rem 0 .75rem 0; font: 500 clamp(12px,1.6vw,16px) system-ui
  }
  .rule{height:3px;background:var(--tk-cyan);opacity:.75;margin:.35rem auto 1rem auto;width:100%}

  /* Table: centered, fills width, no extra white bands */
  table.compat{
    width:100%; border-collapse:separate; border-spacing:0;
    background:rgba(0,0,0,.35); color:var(--tk-ink);
    box-shadow: 0 0 0 1px rgba(255,255,255,.04) inset;
  }
  table.compat caption{display:none}
  table.compat thead th{
    position:sticky; top:0; z-index:2;
    background:#0f1214; color: var(--tk-cyan);
    font: 700 clamp(12px,1.7vw,18px) system-ui;
    padding: .7rem .7rem; border-bottom:1px solid rgba(255,255,255,.08);
    text-shadow:
      0 0 2px rgba(var(--tk-cyan-rgb),.7),
      0 0 6px rgba(var(--tk-cyan-rgb),.4);
  }
  table.compat td{
    font: 500 clamp(12px,1.5vw,18px) system-ui;
    padding:.75rem .7rem; border-bottom:1px solid rgba(255,255,255,.06);
    background: rgba(255,255,255,.02);
  }
  table.compat tr:nth-child(odd) td{background: rgba(255,255,255,.035)}
  table.compat .num,
  table.compat .flag{ text-align:center; font-variant-numeric: tabular-nums }
  table.compat .label{ word-break: break-word }

  table.compat colgroup col.label{ width: 56% }
  table.compat colgroup col.pa{ width: 11% }
  table.compat colgroup col.match{ width: 11% }
  table.compat colgroup col.flag{ width: 11% }
  table.compat colgroup col.pb{ width: 11% }

  /* Remove accidental duplicate header row if an upstream script injects again */
  table.compat thead tr + tr{ display:none !important }

  /* Download button (optional) */
  .bar{display:flex;justify-content:center;margin:1rem 0}
  .btn{
    background:linear-gradient(0deg, rgba(var(--tk-cyan-rgb),.18), rgba(var(--tk-cyan-rgb),.28));
    color:#001a1c; font: 700 15px system-ui; border:1px solid rgba(var(--tk-cyan-rgb),.55);
    border-radius: 12px; padding:.6rem 1rem; cursor:pointer
  }
  .btn:active{ transform: translateY(1px) }
  </style>
</head>
<body>
<div class="page" id="tk-root">
  <h1 class="hx h1">TalkKink Compatibility</h1>
  <div class="sub" id="tk-ts">Generated: â€”</div>
  <div class="rule"></div>
  <h2 class="hx h2">Behavioral Play</h2>

  <!-- Your compatibility table; the colgroup keeps widths in sync with PDF -->
  <table class="compat" id="compatTable">
    <colgroup>
      <col class="label"><col class="pa"><col class="match"><col class="flag"><col class="pb">
    </colgroup>
    <thead>
      <tr>
        <th>Item</th><th>Partner A</th><th>Match</th><th>Flag</th><th>Partner B</th>
      </tr>
    </thead>
    <tbody id="compatBody"><!-- rows injected by your app; leave empty in template --></tbody>
  </table>

  <div class="bar">
    <button class="btn" id="downloadPdfBtn">Download PDF</button>
  </div>
</div>

<script>
(() => {
  const tsEl = document.getElementById('tk-ts');
  if (tsEl) tsEl.textContent = `Generated: ${new Date().toLocaleString()}`;
})();
</script>
<script>
(() => {
  const CFG = {
    pdfKillSwitch: false,
    selectors: { downloadBtn: '#downloadPdfBtn' },
    columns: [
      { key: 'item',  header: 'Item',      w: 320 },
      { key: 'a',     header: 'Partner A', w: 70  },
      { key: 'match', header: 'Match',     w: 80  },
      { key: 'flag',  header: 'Flag',      w: 60  },
      { key: 'b',     header: 'Partner B', w: 70  },
    ],
    cdn: {
      jspdf: [
        'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js',
        'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js',
      ],
      autotable: [
        'https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js',
        'https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js',
      ],
    },
  };

  let libsReady = false;
  let rowsReady = false;
  let cachedRows = [];
  let libsPromise = null;

  /* ---------------------- Loader Helpers ---------------------- */

  function loadScript(src, key) {
    return new Promise((resolve, reject) => {
      const existing = document.querySelector(`script[data-lib="${key}"]`);
      if (existing?.dataset.loaded === '1') return resolve();
      if (existing) {
        existing.addEventListener('load', resolve, { once: true });
        existing.addEventListener('error', reject, { once: true });
        return;
      }
      const s = document.createElement('script');
      s.src = src;
      s.defer = true;
      s.crossOrigin = 'anonymous';
      if (key) s.dataset.lib = key;
      s.onload = () => { if (key) s.dataset.loaded = '1'; resolve(); };
      s.onerror = reject;
      document.head.appendChild(s);
    });
  }

  const hasJsPDF = () => !!window.jspdf?.jsPDF || !!window.jsPDF;

  const hasAutoTable = () => {
    const api = window.jspdf?.jsPDF?.API || window.jsPDF?.API;
    return !!(api?.autoTable || api?.__autoTable__);
  };

  async function loadPDFLibs() {
    if (libsPromise) return libsPromise;
    libsPromise = (async () => {
      if (!hasJsPDF()) {
        for (const src of CFG.cdn.jspdf) {
          try { await loadScript(src, 'jspdf'); break; } catch {}
        }
      }
      if (!window.jsPDF && window.jspdf?.jsPDF) window.jsPDF = window.jspdf.jsPDF;

      if (!hasAutoTable()) {
        for (const src of CFG.cdn.autotable) {
          try { await loadScript(src, 'autotable'); break; } catch {}
        }
      }
      if (!hasJsPDF()) throw new Error('jsPDF not available');
      if (!hasAutoTable()) throw new Error('autoTable not available');

      libsReady = true;
      setButtonState();
      return window.jsPDF;
    })();
    return libsPromise;
  }

  /* ---------------------- Helpers ---------------------- */

  const TK_ACCENT = [0, 214, 199];
  const TK_FLAG_EMOJI = { green: 'ðŸŸ©', yellow: 'ðŸŸ¨', red: 'ðŸŸ¥' };
  const TK_FLAG_RGB = {
    green: [24, 214, 154],
    yellow: [255, 204, 0],
    red: [255, 66, 66],
  };

  const safe = (v) =>
    v == null || v === 'null' || v === 'undefined' ? '' : String(v);

  const clampPercent = (value) => Math.max(0, Math.min(100, value));

  const coerceNum = (v) => {
    if (v == null || v === '') return null;
    const cleaned = String(v).replace(/[^\d.-]/g, '');
    if (!cleaned) return null;
    const n = Number(cleaned);
    return Number.isFinite(n) ? n : null;
  };

  function tk_matchPercent(a, b) {
    if (typeof a !== 'number' || typeof b !== 'number') return null;
    if (!Number.isFinite(a) || !Number.isFinite(b)) return null;
    const diff = Math.min(5, Math.abs(a - b));
    return Math.round(((5 - diff) / 5) * 100);
  }

  function tk_normalizeFlag(value) {
    if (value == null) return '';
    const str = String(value).trim();
    if (!str) return '';
    const lower = str.toLowerCase();
    if (['green', 'yellow', 'red'].includes(lower)) return lower;
    if (str === 'ðŸŸ©' || str === 'ðŸŸ¢') return 'green';
    if (str === 'ðŸŸ¨' || str === 'ðŸŸ¡' || str === 'ðŸŸ ') return 'yellow';
    if (str === 'ðŸŸ¥' || str === 'ðŸ”´') return 'red';
    return '';
  }

  function tk_flagStatus(a, b, matchPercent) {
    if (Number.isFinite(matchPercent)) {
      if (matchPercent >= 90) return 'green';
      if (matchPercent <= 30) return 'red';
    }
    if (!Number.isFinite(a) || !Number.isFinite(b)) return '';
    const oneIsFive = a === 5 || b === 5;
    if (oneIsFive && Math.abs(a - b) >= 1) return 'yellow';
    return '';
  }

  function tk_drawFlagSquare(doc, cell, colorName) {
    const rgb = TK_FLAG_RGB[colorName];
    if (!rgb || !cell) return;
    const size = Math.min(cell.width, cell.height) * 0.45;
    const sx = cell.x + (cell.width - size) / 2;
    const sy = cell.y + (cell.height - size) / 2;
    doc.setFillColor(rgb[0], rgb[1], rgb[2]);
    doc.rect(sx, sy, size, size, 'F');
  }

  function tk_renderMatchColumn(a, b, matchPercent, matchRaw) {
    if (Number.isFinite(matchPercent)) return `${matchPercent}%`;
    const computed = tk_matchPercent(a, b);
    if (computed !== null) return `${computed}%`;
    const str = safe(matchRaw).trim();
    return str || 'N/A';
  }

  function normalizeRow(r) {
    let item;
    let aRaw;
    let bRaw;
    let matchRaw;
    let flagRaw;

    if (Array.isArray(r)) {
      [item, aRaw, matchRaw, flagRaw, bRaw] = r;
      if (r.length === 4) {
        [item, aRaw, matchRaw, bRaw] = r;
        flagRaw = null;
      }
    } else if (r && typeof r === 'object') {
      item = r.item ?? r.label ?? '';
      aRaw = r.a ?? r.partnerA ?? r.aScore ?? null;
      bRaw = r.b ?? r.partnerB ?? r.bScore ?? null;
      matchRaw =
        r.matchPercent ??
        r.match ??
        r.matchPct ??
        r.matchValue ??
        null;
      flagRaw = r.flag ?? r.flagEmoji ?? r.flagStatus ?? r.flagLabel ?? null;
    }

    const a = coerceNum(aRaw);
    const b = coerceNum(bRaw);
    const directMatch = coerceNum(matchRaw);
    const matchPct =
      directMatch != null ? clampPercent(Math.round(directMatch)) : tk_matchPercent(a, b);
    const matchDisplay = tk_renderMatchColumn(a, b, matchPct, matchRaw);
    const explicitFlag = tk_normalizeFlag(flagRaw);
    const computedFlag = tk_flagStatus(a, b, matchPct);
    const flagStatus = explicitFlag || computedFlag || '';
    const flagEmoji = flagStatus ? TK_FLAG_EMOJI[flagStatus] || '' : '';

    return {
      item: safe(item),
      a: a != null ? String(a) : safe(aRaw),
      match: matchDisplay,
      flag: flagEmoji,
      b: b != null ? String(b) : safe(bRaw),
      aNum: a,
      bNum: b,
      pct: matchPct,
      flagStatus,
    };
  }

  function header(doc, title, y) {
    const pageW = doc.internal.pageSize.getWidth();
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(36);
    doc.setTextColor(255, 255, 255);

    const w = doc.getTextWidth(title);
    doc.text(title, (pageW - w) / 2, y);

    doc.setFontSize(12);
    const sub = 'Generated: ' + new Date().toLocaleString();
    const w2 = doc.getTextWidth(sub);
    doc.text(sub, (pageW - w2) / 2, y + 20);

    doc.setDrawColor(...TK_ACCENT);
    doc.setLineWidth(2.5);
    doc.line(80, y + 34, pageW - 80, y + 34);

    return y + 60;
  }

  function renderSection(doc, title, rows, startY) {
    const pageW = doc.internal.pageSize.getWidth();
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(24);
    doc.setTextColor(255, 255, 255);

    const tw = doc.getTextWidth(title);
    doc.text(title, (pageW - tw) / 2, startY);

    const tableRows = rows.map((r) => ({
      item: safe(r.item),
      a: safe(r.a),
      match: safe(r.match),
      flag: r.flag || '',
      b: safe(r.b),
      __flagStatus: r.flagStatus || '',
    }));

    const itemColumn = CFG.columns.find((col) => col.key === 'item');
    const wrapWidth = Math.max(40, (itemColumn?.w || 320) - 12);

    const bodyRows = tableRows.map((row) => ({
      ...row,
      item:
        row.item && typeof doc.splitTextToSize === 'function'
          ? doc.splitTextToSize(row.item, wrapWidth)
          : row.item,
    }));

    const columnStyles = Object.fromEntries(
      CFG.columns.map((col) => [col.key, {
        cellWidth: col.w,
        halign: col.key === 'item' ? 'left' : 'center',
      }])
    );

    const columns = CFG.columns.map((col) => ({ header: col.header, dataKey: col.key }));

    doc.autoTable({
      startY: startY + 26,
      margin: { left: 70, right: 70 },
      columns,
      body: bodyRows,
      theme: 'grid',
      styles: {
        font: 'helvetica',
        fontSize: 12,
        textColor: [230, 230, 230],
        fillColor: [25, 25, 28],
        lineColor: [40, 40, 45],
        lineWidth: 1.2,
        halign: 'left',
        overflow: 'linebreak',
      },
      headStyles: {
        fontStyle: 'bold',
        textColor: [0, 255, 245],
        fillColor: [28, 28, 32],
        halign: 'center',
      },
      columnStyles,
      didDrawCell(data) {
        if (data.section !== 'body') return;
        if (data.column.dataKey === 'flag') {
          const status = data.row.raw?.__flagStatus;
          if (status) {
            tk_drawFlagSquare(doc, data.cell, status);
            data.cell.text = [];
          }
        }
      },
    });
  }

  /* ---------------------- PDF Generator ---------------------- */

  async function generatePDF(rows) {
    if (!rows?.length) throw new Error('No rows to export');

    await loadPDFLibs();
    const jsPDF = window.jsPDF;

    const doc = new jsPDF({
      orientation: 'landscape',
      unit: 'pt',
      format: 'letter',
    });

    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();

    doc.setFillColor(18, 19, 20);
    doc.rect(0, 0, pageW, pageH, 'F');

    const normalized = rows.map(normalizeRow);

    const y = header(doc, 'Talk Kink Compatibility Survey', 70);
    renderSection(doc, 'Behavioral Play', normalized, y);

    doc.save('TalkKink-compatibility.pdf');
  }

  /* ---------------------- State & Button ---------------------- */

  function getBtn() { return document.querySelector(CFG.selectors.downloadBtn); }

  function extractRowsFromTable() {
    const body = document.querySelector('#compatBody');
    if (!body) return [];
    const rows = [];
    body.querySelectorAll('tr').forEach(tr => {
      const cells = Array.from(tr.children, td => safe(td?.textContent).trim());
      if (cells.length >= 4) {
        const normalized = cells.slice(0, 5);
        if (normalized.length === 4) normalized.splice(3, 0, '');
        rows.push(normalized);
      }
    });
    return rows;
  }

  function computeRows() {
    if (cachedRows?.length) return cachedRows;
    if (Array.isArray(window.talkkinkCompatRows) && window.talkkinkCompatRows.length) {
      cachedRows = window.talkkinkCompatRows.slice();
    } else {
      cachedRows = extractRowsFromTable();
    }
    return cachedRows;
  }

  function setButtonState() {
    const btn = getBtn();
    if (!btn) return;
    rowsReady = computeRows().length > 0;
    const enabled = libsReady && rowsReady && !CFG.pdfKillSwitch;
    btn.disabled = !enabled;
  }

  window.TKCompatPDF = {
    notifyRowsUpdated(rows) {
      if (Array.isArray(rows)) {
        cachedRows = rows.slice();
        window.talkkinkCompatRows = rows.slice();
      } else {
        cachedRows = [];
        window.talkkinkCompatRows = undefined;
      }
      setButtonState();
    },
    setKillSwitch(disabled) {
      CFG.pdfKillSwitch = !!disabled;
      setButtonState();
    },
  };

  function init() {
    const btn = getBtn();
    if (btn) btn.disabled = true;

    if (Array.isArray(window.talkkinkCompatRows))
      cachedRows = window.talkkinkCompatRows.slice();
    else
      cachedRows = extractRowsFromTable();

    setButtonState();

    btn?.addEventListener('click', async e => {
      e.preventDefault();
      try {
        const rows = computeRows();
        if (!rows.length) return alert('Upload both surveys first.');
        await generatePDF(rows);
      } catch (err) {
        console.error(err);
        alert('PDF error â€” see console');
      }
    });

    loadPDFLibs().catch(err => console.error(err));
  }

  document.readyState === 'loading'
    ? document.addEventListener('DOMContentLoaded', init, { once: true })
    : init();

})();
</script>
</body>
</html>
