<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>TalkKink Compatibility Exporter</title>
  <link rel="icon" href="data:," />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
  :root{
    --tk-bg: #05131a;
    --tk-panel: #0a1d26;
    --tk-cyan: #10e2f0;
    --tk-cyan-rgb: 16,226,240;
    --tk-ink: #e8f7fb;
    --page-pad: 16px;
    --maxw: 1200px;
  }
  html,body{height:100%;background:var(--tk-bg);margin:0}
  body{display:flex;justify-content:center}
  .page{
    width:100%;
    max-width:var(--maxw);
    padding: clamp(12px,2vw,24px);
    box-sizing:border-box;
    background: linear-gradient(135deg, rgba(0,229,255,.12), rgba(0,229,255,.02));
    border-radius: 18px;
    box-shadow: 0 0 0 1px rgba(255,255,255,.04) inset;
  }

  /* Headline & subtitle centered, with outlined/glow text */
  .hx{
    margin:0;
    text-align:center;
    color: var(--tk-cyan);
    letter-spacing:.5px;
    /* multi-direction glow outline (safe in PDF html2canvas too) */
    text-shadow:
      0 0 2px rgba(var(--tk-cyan-rgb),.9),
      0 0 6px rgba(var(--tk-cyan-rgb),.6),
      -1px 0 0 rgba(0,0,0,.9), 1px 0 0 rgba(0,0,0,.9),
      0 -1px 0 rgba(0,0,0,.9), 0 1px 0 rgba(0,0,0,.9),
      -1px -1px 0 rgba(0,0,0,.9), 1px 1px 0 rgba(0,0,0,.9);
  }
  .h1{font: 800 clamp(28px, 5vw, 56px) system-ui}
  .h2{
    font: 800 clamp(22px, 4.2vw, 40px) system-ui;
    margin-top:.35em;
    display:inline-block;
    padding: .45em .9em;
    background: var(--tk-panel);
    border-radius: 14px;
    box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset, 0 10px 24px rgba(0,0,0,.2);
  }
  .sub{
    text-align:center; color:#b7ffff; opacity:.85;
    margin:.25rem 0 .75rem 0; font: 500 clamp(12px,1.6vw,16px) system-ui
  }
  .rule{height:3px;background:var(--tk-cyan);opacity:.75;margin:.35rem auto 1rem auto;width:100%}

  /* Table: centered, fills width, no extra white bands */
  table.compat{
    width:100%; border-collapse:separate; border-spacing:0;
    background:rgba(0,0,0,.35); color:var(--tk-ink);
    box-shadow: 0 0 0 1px rgba(255,255,255,.04) inset;
    border-radius: 14px; overflow:hidden;
  }
  table.compat caption{display:none}
  table.compat thead th{
    position:sticky; top:0; z-index:2;
    background:#0b171f; color: var(--tk-cyan);
    font: 700 clamp(12px,1.7vw,18px) system-ui;
    padding: .7rem .7rem; border-bottom:1px solid rgba(255,255,255,.08);
    text-shadow:
      0 0 2px rgba(var(--tk-cyan-rgb),.7),
      0 0 6px rgba(var(--tk-cyan-rgb),.4);
  }
  table.compat td{
    font: 500 clamp(12px,1.5vw,18px) system-ui;
    padding:.75rem .7rem; border-bottom:1px solid rgba(255,255,255,.06);
    background: rgba(255,255,255,.02);
  }
  table.compat tr:nth-child(odd) td{background: rgba(255,255,255,.035)}
  table.compat td:nth-child(2),
  table.compat td:nth-child(4){ background: rgba(var(--tk-cyan-rgb),.06); color: #c6f7ff }
  table.compat td:nth-child(3){ background: rgba(255,255,255,.02); color:#e7fbff }
  table.compat .num{ text-align:center; font-variant-numeric: tabular-nums }
  table.compat .label{ word-break: break-word }

  table.compat colgroup col.label{ width: 60% }
  table.compat colgroup col.pa{ width: 12% }
  table.compat colgroup col.match{ width: 16% }
  table.compat colgroup col.pb{ width: 12% }

  /* Remove accidental duplicate header row if an upstream script injects again */
  table.compat thead tr + tr{ display:none !important }

  /* Download button (optional) */
  .bar{display:flex;justify-content:center;margin:1rem 0}
  .btn{
    background:linear-gradient(0deg, rgba(var(--tk-cyan-rgb),.18), rgba(var(--tk-cyan-rgb),.28));
    color:#001a1c; font: 700 15px system-ui; border:1px solid rgba(var(--tk-cyan-rgb),.55);
    border-radius: 12px; padding:.6rem 1rem; cursor:pointer
  }
  .btn:active{ transform: translateY(1px) }
  </style>
</head>
<body>
<div class="page" id="tk-root">
  <h1 class="hx h1">TalkKink Compatibility Survey</h1>
  <div class="sub" id="tk-ts">Generated: â€”</div>
  <div class="rule"></div>
  <h2 class="hx h2">Behavioral Play</h2>

  <!-- Your compatibility table; the colgroup keeps widths in sync with PDF -->
  <table class="compat" id="compatTable">
    <colgroup>
      <col class="label"><col class="pa"><col class="match"><col class="pb">
    </colgroup>
    <thead>
      <tr>
        <th>Kinks</th><th>Giving Partner A</th><th>Match %</th><th>Giving Partner B</th>
      </tr>
    </thead>
    <tbody id="compatBody"><!-- rows injected by your app; leave empty in template --></tbody>
  </table>

  <div class="bar">
    <button class="btn" id="downloadPdfBtn">Download PDF</button>
  </div>
</div>

<script>
(() => {
  const tsEl = document.getElementById('tk-ts');
  if (tsEl) tsEl.textContent = `Generated: ${new Date().toLocaleString()}`;
})();
</script>
<script>
(() => {
  const CFG = {
    pdfKillSwitch: false,
    selectors: { downloadBtn: '#downloadPdfBtn' },
    cdn: {
      jspdf: [
        'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js',
        'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js',
      ],
      autotable: [
        'https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js',
        'https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js',
      ],
    },
  };

  let libsReady = false;
  let rowsReady = false;
  let cachedRows = [];
  let libsPromise = null;

  /* ---------------------- Loader Helpers ---------------------- */

  function loadScript(src, key) {
    return new Promise((resolve, reject) => {
      const existing = document.querySelector(`script[data-lib="${key}"]`);
      if (existing?.dataset.loaded === '1') return resolve();
      if (existing) {
        existing.addEventListener('load', resolve, { once: true });
        existing.addEventListener('error', reject, { once: true });
        return;
      }
      const s = document.createElement('script');
      s.src = src;
      s.defer = true;
      s.crossOrigin = 'anonymous';
      if (key) s.dataset.lib = key;
      s.onload = () => { if (key) s.dataset.loaded = '1'; resolve(); };
      s.onerror = reject;
      document.head.appendChild(s);
    });
  }

  const hasJsPDF = () => !!window.jspdf?.jsPDF || !!window.jsPDF;

  const hasAutoTable = () => {
    const api = window.jspdf?.jsPDF?.API || window.jsPDF?.API;
    return !!(api?.autoTable || api?.__autoTable__);
  };

  async function loadPDFLibs() {
    if (libsPromise) return libsPromise;
    libsPromise = (async () => {
      if (!hasJsPDF()) {
        for (const src of CFG.cdn.jspdf) {
          try { await loadScript(src, 'jspdf'); break; } catch {}
        }
      }
      if (!window.jsPDF && window.jspdf?.jsPDF) window.jsPDF = window.jspdf.jsPDF;

      if (!hasAutoTable()) {
        for (const src of CFG.cdn.autotable) {
          try { await loadScript(src, 'autotable'); break; } catch {}
        }
      }
      if (!hasJsPDF()) throw new Error('jsPDF not available');
      if (!hasAutoTable()) throw new Error('autoTable not available');

      libsReady = true;
      setButtonState();
      return window.jsPDF;
    })();
    return libsPromise;
  }

  /* ---------------------- Helpers ---------------------- */

  const safe = (v) =>
    v == null || v === 'null' || v === 'undefined' ? '' : String(v);

  function safeValue(val, fallback = '') {
    if (val === null || val === undefined || Number.isNaN(val)) return fallback;
    const text = cleanText(val);
    if (!text) return fallback;
    return text;
  }

  const cleanText = (value) => safe(value).replace(/\s+/g, ' ').trim();

  const displayValue = (value, fallback = '') => {
    if (value === undefined || value === null) return fallback;
    const text = cleanText(value);
    if (!text || text === '&&&') return fallback;
    return text;
  };

  const clampPercent = (value) => Math.max(0, Math.min(100, value));

  const coerceNum = (v) => {
    if (v == null || v === '') return null;
    const cleaned = String(v).replace(/[^\d.-]/g, '');
    if (!cleaned) return null;
    const n = Number(cleaned);
    return Number.isFinite(n) ? n : null;
  };

  function tk_matchPercent(a, b) {
    const aScore = Number.isFinite(a) ? a : coerceNum(a);
    const bScore = Number.isFinite(b) ? b : coerceNum(b);
    if (!Number.isFinite(aScore) || !Number.isFinite(bScore)) return null;
    const diff = Math.min(5, Math.abs(aScore - bScore));
    return Math.round(((5 - diff) / 5) * 100);
  }

  function tk_normalizeFlag(value) {
    if (value == null) return '';
    const str = String(value).trim();
    if (!str) return '';
    const lower = str.toLowerCase();
    if (['â­', 'â­ï¸', 'star', 'stars', 'green', 'ðŸŸ©', 'ðŸŸ¢'].includes(lower)) return 'green';
    if (['ðŸš©', 'red-flag', 'red flag', 'red', 'ðŸŸ¥', 'ðŸ”´'].includes(lower)) return 'red';
    if (['ðŸŸ¨', 'ðŸŸ¡', 'yellow', 'caution', 'warn', 'warning', 'âš ï¸'].includes(lower)) return 'yellow';
    return '';
  }

  /* Flag logic (Green, Yellow, Red) */
  function tk_flagStatus(a, b, matchPercent) {
    if (a == null || b == null || isNaN(matchPercent)) return '';
    if (matchPercent >= 90) return 'green';
    if (matchPercent <= 30) return 'red';
    const oneIsFive = a === 5 || b === 5;
    if (oneIsFive && Math.abs(a - b) >= 1) return 'yellow';
    return '';
  }

  function tk_drawFlagSquare(doc, cell, color) {
    const colors = {
      green: [42, 204, 126],
      yellow: [247, 221, 85],
      red: [236, 84, 84],
    };
    const fill = colors[color];
    if (!fill) return;
    const { x, y, height, width } = cell;
    const size = Math.min(width, height) * 0.45;
    const sx = x + (width - size) / 2;
    const sy = y + (height - size) / 2;
    doc.setFillColor(...fill);
    doc.rect(sx, sy, size, size, 'F');
  }

  /* Shorten label utility */
  function tk_shortenLabel(label) {
    return (label || '')
      .replace(/^Giving: /, '')
      .replace(/^Receiving: /, '')
      .replace(/\s*\(.*?\)/g, '')
      .replace(/Body Part Torture/g, 'BPT')
      .replace(/Cock, Ball Torture \(CBT\)/g, 'CBT')
      .replace(/Clit clips\/weights\/suction/g, 'Clit tools')
      .trim();
  }

  function tk_cleanMatchDisplay(text) {
    const normalized = safe(text).replace(/\s+/g, ' ').trim();
    if (!normalized) return '';
    const collapsed = normalized
      .replace(/&{2,}/g, '&')
      .replace(/%{2,}/g, '%')
      .replace(/&+$/g, '')
      .trim();
    return collapsed;
  }

  function tk_renderMatchText(a, b, matchPercent, matchRaw) {
    if (Number.isFinite(matchPercent)) return `${clampPercent(matchPercent)}%`;
    const computed = tk_matchPercent(a, b);
    if (Number.isFinite(computed)) return `${computed}%`;
    const cleaned = tk_cleanMatchDisplay(matchRaw);
    return cleaned || '';
  }

  function buildRow(item) {
    if (!item || typeof item !== 'object' || Array.isArray(item)) return item;
    const labelShort = tk_shortenLabel(item.labelShort ?? item.label ?? item.item ?? '');
    const aScore = Number.isFinite(item.scoreA)
      ? item.scoreA
      : Number.isFinite(item.aScore)
      ? item.aScore
      : null;
    const bScore = Number.isFinite(item.scoreB)
      ? item.scoreB
      : Number.isFinite(item.bScore)
      ? item.bScore
      : null;
    const aDisplay = safe(item.a ?? item.partnerA ?? (aScore != null ? String(aScore) : ''));
    const bDisplay = safe(item.b ?? item.partnerB ?? (bScore != null ? String(bScore) : ''));
    const directMatch = coerceNum(
      item.matchPercent ?? item.matchPct ?? item.match ?? item.matchValue ?? null
    );
    const derivedMatch =
      directMatch != null
        ? clampPercent(Math.round(directMatch))
        : Number.isFinite(aScore) && Number.isFinite(bScore)
        ? clampPercent(100 - Math.abs(aScore - bScore) * 20)
        : null;
    const flagColor =
      tk_normalizeFlag(
        item.flagEmoji ?? item.flag ?? item.flagLabel ?? item.flagStatus ?? item.flagName ?? null
      ) || (derivedMatch != null ? tk_normalizeFlag(tk_flagStatus(aScore, bScore, derivedMatch)) : '');

    return {
      ...item,
      labelShort,
      a: aDisplay,
      b: bDisplay,
      matchPercent: derivedMatch,
      flagColor,
      scoreA: aScore ?? item.scoreA ?? item.aScore ?? null,
      scoreB: bScore ?? item.scoreB ?? item.bScore ?? null,
    };
  }

  function sanitizeCompatRows(rows) {
    if (!Array.isArray(rows)) return [];
    return rows
      .map((row) => (row && typeof row === 'object' && !Array.isArray(row) ? buildRow(row) : row))
      .map(normalizeRow)
      .filter(Boolean);
  }

  function normalizeRow(r) {
    let item;
    let aRaw;
    let bRaw;
    let matchRaw;
    let flagRaw;

    if (Array.isArray(r)) {
      if (r.length >= 5) {
        [item, aRaw, matchRaw, flagRaw, bRaw] = r;
      } else {
        [item, aRaw, matchRaw, bRaw] = r;
        flagRaw = null;
      }
    } else if (r && typeof r === 'object') {
      item = tk_shortenLabel(r.labelShort ?? r.item ?? r.label ?? '');
      aRaw = r.a ?? r.partnerA ?? r.aScore ?? r.scoreA ?? null;
      bRaw = r.b ?? r.partnerB ?? r.bScore ?? r.scoreB ?? null;
      matchRaw =
        r.matchPercent ??
        r.match ??
        r.matchPct ??
        r.matchValue ??
        null;
      flagRaw = r.flagEmoji ?? r.flag ?? r.flagStatus ?? r.flagLabel ?? null;
    }

    if (aRaw == null && bRaw == null && !item) return null;

    const a = coerceNum(aRaw);
    const b = coerceNum(bRaw);
    const directMatch = coerceNum(matchRaw);
    let matchPct = null;
    if (directMatch != null) {
      const normalized = directMatch >= 0 && directMatch <= 1 ? directMatch * 100 : directMatch;
      matchPct = clampPercent(Math.round(normalized));
    } else {
      matchPct = tk_matchPercent(a, b);
    }
    const matchDisplay = tk_renderMatchText(a, b, matchPct, matchRaw);
    const explicitFlag = tk_normalizeFlag(flagRaw);
    const computedFlag = tk_normalizeFlag(tk_flagStatus(a, b, matchPct));
    const flagColor = explicitFlag || computedFlag;

    return {
      item: cleanText(item),
      a: a != null ? String(a) : cleanText(aRaw),
      match: matchDisplay,
      b: b != null ? String(b) : cleanText(bRaw),
      aNum: a,
      bNum: b,
      pct: matchPct,
      flagColor,
    };
  }

  function getText(selector, fallback) {
    const el = document.querySelector(selector);
    const text = cleanText(el?.textContent);
    return text || fallback;
  }

  const tableStyle = {
    theme: 'grid',
    styles: {
      fontSize: 10,
      font: 'helvetica',
      textColor: '#FFFFFF',
      halign: 'left',
      valign: 'middle',
      cellPadding: { top: 2, bottom: 2, left: 2, right: 2 },
      lineColor: '#222',
      lineWidth: 0.3,
      fontStyle: 'normal',
      overflow: 'linebreak',
    },
    headStyles: {
      fillColor: '#00FFFF',
      textColor: '#000000',
      fontSize: 10,
      halign: 'left',
      fontStyle: 'bold',
    },
    columnStyles: {
      0: { cellWidth: 130 },
      1: { cellWidth: 20, halign: 'center' },
      2: { cellWidth: 20, halign: 'center' },
      3: { cellWidth: 20, halign: 'center' },
    },
  };

  function emojiForMatch(scoreA, scoreB) {
    const diff = Math.abs(scoreA - scoreB);
    if (scoreA === scoreB && scoreA > 0) return 'â­';
    if (diff >= 3) return 'ðŸš©';
    if ((scoreA === 5 || scoreB === 5) && diff >= 1) return 'ðŸŸ¨';
    return '';
  }

  function renderSection(doc, rows, { title, subtitle, sectionTitle }) {
    const pageWidth = doc.internal.pageSize.getWidth();

    const kinkRows = rows.map((r) => {
      const aScore = Number.isFinite(r.aNum) ? r.aNum : coerceNum(r.a);
      const bScore = Number.isFinite(r.bNum) ? r.bNum : coerceNum(r.b);
      const matchPercent = Number.isFinite(r.pct) ? r.pct : tk_matchPercent(aScore, bScore);
      const matchText = tk_renderMatchText(aScore, bScore, matchPercent, r.match);
      return [
        safeValue(displayValue(r.item)),
        safeValue(displayValue(r.a)),
        matchText || '',
        safeValue(displayValue(r.b)),
      ];
    });

    doc.setFontSize(18);
    doc.setTextColor('#00FFFF');
    doc.text(title, pageWidth / 2, 20, { align: 'center' });

    doc.setFontSize(10);
    doc.setTextColor('#FFFFFF');
    doc.text(subtitle, pageWidth / 2, 26, { align: 'center' });

    doc.setFontSize(14);
    doc.setTextColor('#00FFFF');
    doc.text(sectionTitle, pageWidth / 2, 35, { align: 'center' });

    doc.autoTable({
      startY: 40,
      head: [['Kinks', 'Partner A', 'Match', 'Partner B']],
      body: kinkRows,
      ...tableStyle,
    });
  }

  /* ---------------------- PDF Generator ---------------------- */

  async function generatePDF(rows) {
    if (!rows?.length) throw new Error('No rows to export');

    await loadPDFLibs();
    const jsPDF = window.jsPDF;

    const doc = new jsPDF({
      orientation: 'landscape',
      unit: 'mm',
      format: 'letter',
    });

    doc.setFontSize(10);

    const normalized = sanitizeCompatRows(rows);
    const title = getText('.hx.h1', 'TalkKink Compatibility Survey');
    const subtitle = getText('#tk-ts', `Generated: ${new Date().toLocaleString()}`);
    const sectionTitle = getText('.hx.h2', 'Behavioral Play');

    renderSection(doc, normalized, { title, subtitle, sectionTitle });

    doc.save('TalkKink-compatibility.pdf');
  }

  /* ---------------------- State & Button ---------------------- */

  function getBtn() { return document.querySelector(CFG.selectors.downloadBtn); }

  function extractRowsFromTable() {
    const body = document.querySelector('#compatBody');
    if (!body) return [];
    const rows = [];
    body.querySelectorAll('tr').forEach(tr => {
      const cells = Array.from(tr.children, td => safe(td?.textContent).trim());
      if (cells.length >= 4) {
        rows.push(cells.slice(0, Math.min(5, cells.length)));
      }
    });
    return rows;
  }

  function computeRows() {
    if (cachedRows?.length) return cachedRows;
    if (Array.isArray(window.talkkinkCompatRows) && window.talkkinkCompatRows.length) {
      const prepared = sanitizeCompatRows(window.talkkinkCompatRows);
      cachedRows = prepared.slice();
      window.talkkinkCompatRows = prepared.slice();
    } else {
      cachedRows = sanitizeCompatRows(extractRowsFromTable());
    }
    return cachedRows;
  }

  function setButtonState() {
    const btn = getBtn();
    if (!btn) return;
    rowsReady = computeRows().length > 0;
    const enabled = libsReady && rowsReady && !CFG.pdfKillSwitch;
    btn.disabled = !enabled;
  }

  window.TKCompatPDF = {
    notifyRowsUpdated(rows) {
      if (Array.isArray(rows)) {
        const prepared = sanitizeCompatRows(rows);
        cachedRows = prepared.slice();
        window.talkkinkCompatRows = prepared.slice();
      } else {
        cachedRows = [];
        window.talkkinkCompatRows = undefined;
      }
      setButtonState();
    },
    setKillSwitch(disabled) {
      CFG.pdfKillSwitch = !!disabled;
      setButtonState();
    },
  };

  function init() {
    const btn = getBtn();
    if (btn) btn.disabled = true;

    if (Array.isArray(window.talkkinkCompatRows))
      cachedRows = sanitizeCompatRows(window.talkkinkCompatRows);
    else
      cachedRows = sanitizeCompatRows(extractRowsFromTable());

    setButtonState();

    btn?.addEventListener('click', async e => {
      e.preventDefault();
      try {
        const rows = computeRows();
        if (!rows.length) return alert('Upload both surveys first.');
        await generatePDF(rows);
      } catch (err) {
        console.error(err);
        alert('PDF error â€” see console');
      }
    });

    loadPDFLibs().catch(err => console.error(err));
  }

  document.readyState === 'loading'
    ? document.addEventListener('DOMContentLoaded', init, { once: true })
    : init();

})();
</script>
</body>
</html>
