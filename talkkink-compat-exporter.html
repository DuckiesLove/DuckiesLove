<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>TalkKink Compatibility Exporter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
  :root{
    --tk-bg: #0b0b0c;
    --tk-cyan: #14e3e9;
    --tk-cyan-rgb: 20,227,233;
    --tk-ink: #f7f7f7;
    --page-pad: 16px;
    --maxw: 1200px;
  }
  html,body{height:100%;background:var(--tk-bg);margin:0}
  body{display:flex;justify-content:center}
  .page{
    width:100%;
    max-width:var(--maxw);
    padding: clamp(12px,2vw,24px);
    box-sizing:border-box;
  }

  /* Headline & subtitle centered, with outlined/glow text */
  .hx{
    margin:0;
    text-align:center;
    color: var(--tk-cyan);
    letter-spacing:.5px;
    /* multi-direction glow outline (safe in PDF html2canvas too) */
    text-shadow:
      0 0 2px rgba(var(--tk-cyan-rgb),.9),
      0 0 6px rgba(var(--tk-cyan-rgb),.6),
      -1px 0 0 rgba(0,0,0,.9), 1px 0 0 rgba(0,0,0,.9),
      0 -1px 0 rgba(0,0,0,.9), 0 1px 0 rgba(0,0,0,.9),
      -1px -1px 0 rgba(0,0,0,.9), 1px 1px 0 rgba(0,0,0,.9);
  }
  .h1{font: 800 clamp(28px, 5vw, 56px) system-ui}
  .h2{font: 800 clamp(22px, 4.2vw, 40px) system-ui; margin-top:.35em}
  .sub{
    text-align:center; color:#b7ffff; opacity:.85;
    margin:.25rem 0 .75rem 0; font: 500 clamp(12px,1.6vw,16px) system-ui
  }
  .rule{height:3px;background:var(--tk-cyan);opacity:.75;margin:.35rem auto 1rem auto;width:100%}

  /* Table: centered, fills width, no extra white bands */
  table.compat{
    width:100%; border-collapse:separate; border-spacing:0;
    background:rgba(0,0,0,.35); color:var(--tk-ink);
    box-shadow: 0 0 0 1px rgba(255,255,255,.04) inset;
  }
  table.compat caption{display:none}
  table.compat thead th{
    position:sticky; top:0; z-index:2;
    background:#0f1214; color: var(--tk-cyan);
    font: 700 clamp(12px,1.7vw,18px) system-ui;
    padding: .7rem .7rem; border-bottom:1px solid rgba(255,255,255,.08);
    text-shadow:
      0 0 2px rgba(var(--tk-cyan-rgb),.7),
      0 0 6px rgba(var(--tk-cyan-rgb),.4);
  }
  table.compat td{
    font: 500 clamp(12px,1.5vw,18px) system-ui;
    padding:.75rem .7rem; border-bottom:1px solid rgba(255,255,255,.06);
    background: rgba(255,255,255,.02);
  }
  table.compat tr:nth-child(odd) td{background: rgba(255,255,255,.035)}
  table.compat .num{ text-align:center; font-variant-numeric: tabular-nums }
  table.compat .label{ word-break: break-word }

  table.compat colgroup col.label{ width: 60% }
  table.compat colgroup col.pa{ width: 12% }
  table.compat colgroup col.match{ width: 16% }
  table.compat colgroup col.pb{ width: 12% }

  /* Remove accidental duplicate header row if an upstream script injects again */
  table.compat thead tr + tr{ display:none !important }

  /* Download button (optional) */
  .bar{display:flex;justify-content:center;margin:1rem 0}
  .btn{
    background:linear-gradient(0deg, rgba(var(--tk-cyan-rgb),.18), rgba(var(--tk-cyan-rgb),.28));
    color:#001a1c; font: 700 15px system-ui; border:1px solid rgba(var(--tk-cyan-rgb),.55);
    border-radius: 12px; padding:.6rem 1rem; cursor:pointer
  }
  .btn:active{ transform: translateY(1px) }
  </style>
</head>
<body>
<div class="page" id="tk-root">
  <h1 class="hx h1">TalkKink Compatibility</h1>
  <div class="sub" id="tk-ts">Generated: ‚Äî</div>
  <div class="rule"></div>
  <h2 class="hx h2">Behavioral Play</h2>

  <!-- Your compatibility table; the colgroup keeps widths in sync with PDF -->
  <table class="compat" id="compatTable">
    <colgroup>
      <col class="label"><col class="pa"><col class="match"><col class="pb">
    </colgroup>
    <thead>
      <tr>
        <th>Kinks</th><th>Partner A</th><th>Match %</th><th>Partner B</th>
      </tr>
    </thead>
    <tbody id="compatBody"><!-- rows injected by your app; leave empty in template --></tbody>
  </table>

  <div class="bar">
    <button class="btn" id="downloadPdfBtn">Download PDF</button>
  </div>
</div>

<script>
(() => {
  const tsEl = document.getElementById('tk-ts');
  if (tsEl) tsEl.textContent = `Generated: ${new Date().toLocaleString()}`;
})();
</script>
<script>
(() => {
  const CFG = {
    pdfKillSwitch: false,
    selectors: { downloadBtn: '#downloadPdfBtn' },
    columns: [
      { key: 'item',  header: 'Kinks',     w: 330 },
      { key: 'a',     header: 'Partner A', w: 80  },
      { key: 'match', header: 'Match %',   w: 140 },
      { key: 'b',     header: 'Partner B', w: 80  },
    ],
    cdn: {
      jspdf: [
        'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js',
        'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js',
      ],
      autotable: [
        'https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js',
        'https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js',
      ],
    },
  };

  let libsReady = false;
  let rowsReady = false;
  let cachedRows = [];
  let libsPromise = null;

  /* ---------------------- Loader Helpers ---------------------- */

  function loadScript(src, key) {
    return new Promise((resolve, reject) => {
      const existing = document.querySelector(`script[data-lib="${key}"]`);
      if (existing?.dataset.loaded === '1') return resolve();
      if (existing) {
        existing.addEventListener('load', resolve, { once: true });
        existing.addEventListener('error', reject, { once: true });
        return;
      }
      const s = document.createElement('script');
      s.src = src;
      s.defer = true;
      s.crossOrigin = 'anonymous';
      if (key) s.dataset.lib = key;
      s.onload = () => { if (key) s.dataset.loaded = '1'; resolve(); };
      s.onerror = reject;
      document.head.appendChild(s);
    });
  }

  const hasJsPDF = () => !!window.jspdf?.jsPDF || !!window.jsPDF;

  const hasAutoTable = () => {
    const api = window.jspdf?.jsPDF?.API || window.jsPDF?.API;
    return !!(api?.autoTable || api?.__autoTable__);
  };

  async function loadPDFLibs() {
    if (libsPromise) return libsPromise;
    libsPromise = (async () => {
      if (!hasJsPDF()) {
        for (const src of CFG.cdn.jspdf) {
          try { await loadScript(src, 'jspdf'); break; } catch {}
        }
      }
      if (!window.jsPDF && window.jspdf?.jsPDF) window.jsPDF = window.jspdf.jsPDF;

      if (!hasAutoTable()) {
        for (const src of CFG.cdn.autotable) {
          try { await loadScript(src, 'autotable'); break; } catch {}
        }
      }
      if (!hasJsPDF()) throw new Error('jsPDF not available');
      if (!hasAutoTable()) throw new Error('autoTable not available');

      libsReady = true;
      setButtonState();
      return window.jsPDF;
    })();
    return libsPromise;
  }

  /* ---------------------- Helpers ---------------------- */

  const TK_ACCENT = [0, 214, 199];

  const safe = (v) =>
    v == null || v === 'null' || v === 'undefined' ? '' : String(v);

  const cleanText = (value) => safe(value).replace(/\s+/g, ' ').trim();

  const clampPercent = (value) => Math.max(0, Math.min(100, value));

  const coerceNum = (v) => {
    if (v == null || v === '') return null;
    const cleaned = String(v).replace(/[^\d.-]/g, '');
    if (!cleaned) return null;
    const n = Number(cleaned);
    return Number.isFinite(n) ? n : null;
  };

  function tk_matchPercent(a, b) {
    if (typeof a !== 'number' || typeof b !== 'number') return null;
    if (!Number.isFinite(a) || !Number.isFinite(b)) return null;
    const diff = Math.min(5, Math.abs(a - b));
    return Math.round(((5 - diff) / 5) * 100);
  }

  function tk_normalizeFlag(value) {
    if (value == null) return '';
    const str = String(value).trim();
    if (!str) return '';
    const lower = str.toLowerCase();
    if (['‚≠ê', '‚≠êÔ∏è', 'star', 'stars', 'green', 'üü©', 'üü¢'].includes(lower)) return '‚≠ê';
    if (['üö©', 'red-flag', 'red flag', 'red', 'üü•', 'üî¥'].includes(lower)) return 'üö©';
    if (['üü®', 'üü°', 'yellow', 'caution', 'warn', 'warning', '‚ö†Ô∏è'].includes(lower)) return 'üü®';
    return '';
  }

  function tk_flagStatus(partnerAScore, partnerBScore, matchPercent) {
    const aScore = Number.isFinite(partnerAScore) ? partnerAScore : coerceNum(partnerAScore);
    const bScore = Number.isFinite(partnerBScore) ? partnerBScore : coerceNum(partnerBScore);
    let pct = Number.isFinite(matchPercent) ? matchPercent : null;
    if (!Number.isFinite(pct)) pct = tk_matchPercent(aScore, bScore);
    if (!Number.isFinite(pct)) return '';
    if (pct >= 90) return '‚≠ê';
    if (pct <= 30) return 'üö©';
    if (
      Number.isFinite(aScore) &&
      Number.isFinite(bScore) &&
      (aScore === 5 || bScore === 5) &&
      Math.abs(aScore - bScore) >= 1
    ) {
      return 'üü®';
    }
    return '';
  }

  function tk_drawMatchCell(doc, cell, matchPercent, flagEmoji, fallbackText) {
    if (!doc || !cell) return;
    const { x, y, width, height } = cell;
    const cleanFallback = cleanText(fallbackText) || 'N/A';
    const pctText = Number.isFinite(matchPercent) ? `${matchPercent}%` : cleanFallback;
    const display = flagEmoji ? `${pctText} ${flagEmoji}` : pctText;
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(12);
    doc.text(display.trim(), x + width / 2, y + height / 2, {
      align: 'center',
      baseline: 'middle',
    });
  }

  function buildRow(item) {
    if (!item || typeof item !== 'object' || Array.isArray(item)) return item;
    const labelShort = cleanText(item.labelShort ?? item.label ?? item.item ?? '');
    const aScore = Number.isFinite(item.scoreA)
      ? item.scoreA
      : Number.isFinite(item.aScore)
      ? item.aScore
      : null;
    const bScore = Number.isFinite(item.scoreB)
      ? item.scoreB
      : Number.isFinite(item.bScore)
      ? item.bScore
      : null;
    const aDisplay = safe(item.a ?? item.partnerA ?? (aScore != null ? String(aScore) : ''));
    const bDisplay = safe(item.b ?? item.partnerB ?? (bScore != null ? String(bScore) : ''));
    const directMatch = coerceNum(
      item.matchPercent ?? item.matchPct ?? item.match ?? item.matchValue ?? null
    );
    const derivedMatch =
      directMatch != null
        ? clampPercent(Math.round(directMatch))
        : Number.isFinite(aScore) && Number.isFinite(bScore)
        ? clampPercent(100 - Math.abs(aScore - bScore) * 20)
        : null;
    const flagEmoji =
      tk_normalizeFlag(
        item.flagEmoji ?? item.flag ?? item.flagLabel ?? item.flagStatus ?? item.flagName ?? null
      ) || (derivedMatch != null ? tk_flagStatus(aScore, bScore, derivedMatch) : '');

    return {
      ...item,
      labelShort,
      a: aDisplay,
      b: bDisplay,
      matchPercent: derivedMatch,
      flagEmoji,
      scoreA: aScore ?? item.scoreA ?? item.aScore ?? null,
      scoreB: bScore ?? item.scoreB ?? item.bScore ?? null,
    };
  }

  function tk_renderMatchColumn(a, b, matchPercent, matchRaw) {
    if (Number.isFinite(matchPercent)) return `${matchPercent}%`;
    const computed = tk_matchPercent(a, b);
    if (computed !== null) return `${computed}%`;
    const str = safe(matchRaw).replace(/\s+/g, ' ').trim();
    return str || 'N/A';
  }

  function sanitizeCompatRows(rows) {
    if (!Array.isArray(rows)) return [];
    return rows.map((row) => (row && typeof row === 'object' && !Array.isArray(row) ? buildRow(row) : row));
  }

  function normalizeRow(r) {
    let item;
    let aRaw;
    let bRaw;
    let matchRaw;
    let flagRaw;

    if (Array.isArray(r)) {
      if (r.length >= 5) {
        [item, aRaw, matchRaw, flagRaw, bRaw] = r;
      } else {
        [item, aRaw, matchRaw, bRaw] = r;
        flagRaw = null;
      }
    } else if (r && typeof r === 'object') {
      item = r.labelShort ?? r.item ?? r.label ?? '';
      aRaw = r.a ?? r.partnerA ?? r.aScore ?? r.scoreA ?? null;
      bRaw = r.b ?? r.partnerB ?? r.bScore ?? r.scoreB ?? null;
      matchRaw =
        r.matchPercent ??
        r.match ??
        r.matchPct ??
        r.matchValue ??
        null;
      flagRaw = r.flagEmoji ?? r.flag ?? r.flagStatus ?? r.flagLabel ?? null;
    }

    const a = coerceNum(aRaw);
    const b = coerceNum(bRaw);
    const directMatch = coerceNum(matchRaw);
    let matchPct = null;
    if (directMatch != null) {
      const normalized = directMatch >= 0 && directMatch <= 1 ? directMatch * 100 : directMatch;
      matchPct = clampPercent(Math.round(normalized));
    } else {
      matchPct = tk_matchPercent(a, b);
    }
    const matchDisplay = tk_renderMatchColumn(a, b, matchPct, matchRaw);
    const explicitFlag = tk_normalizeFlag(flagRaw);
    const computedFlag = tk_flagStatus(a, b, matchPct);
    const flagEmoji = explicitFlag || computedFlag;

    return {
      item: cleanText(item),
      a: a != null ? String(a) : cleanText(aRaw),
      match: matchDisplay,
      b: b != null ? String(b) : cleanText(bRaw),
      aNum: a,
      bNum: b,
      pct: matchPct,
      flagEmoji,
    };
  }

  function getText(selector, fallback) {
    const el = document.querySelector(selector);
    const text = cleanText(el?.textContent);
    return text || fallback;
  }

  function buildHeaderMeta(doc, { title, subtitle, sectionTitle }) {
    const pageW = doc.internal.pageSize.getWidth();
    const titleY = 70;
    const subtitleY = titleY + 28;
    const ruleY = subtitleY + 14;
    const sectionY = ruleY + 34;
    const tableStartY = sectionY + 30;
    return { pageW, titleY, subtitleY, ruleY, sectionY, tableStartY, title, subtitle, sectionTitle };
  }

  function paintPageBackground(doc) {
    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();
    doc.setFillColor(5, 6, 8);
    doc.rect(0, 0, pageW, pageH, 'F');
  }

  function drawHeader(doc, meta) {
    const opts = { align: 'center', baseline: 'alphabetic' };
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(44);
    doc.setTextColor(...TK_ACCENT);
    doc.text(meta.title, meta.pageW / 2, meta.titleY, opts);

    doc.setFont('helvetica', 'normal');
    doc.setFontSize(14);
    doc.setTextColor(183, 255, 255);
    doc.text(meta.subtitle, meta.pageW / 2, meta.subtitleY, opts);

    doc.setDrawColor(...TK_ACCENT);
    doc.setLineWidth(2.4);
    doc.line(80, meta.ruleY, meta.pageW - 80, meta.ruleY);

    doc.setFont('helvetica', 'bold');
    doc.setFontSize(30);
    doc.text(meta.sectionTitle, meta.pageW / 2, meta.sectionY, opts);
  }

  function renderSection(doc, rows, headerMeta) {
    const pdfColumns = CFG.columns;
    const tableRows = rows.map((r) => ({
      item: cleanText(r.item),
      a: cleanText(r.a),
      match: cleanText(r.match),
      b: cleanText(r.b),
      flagEmoji: r.flagEmoji,
      matchPercent: r.pct,
      partnerA: r.aNum,
      partnerB: r.bNum,
    }));

    const itemColumn = pdfColumns.find((col) => col.key === 'item');
    const wrapWidth = Math.max(40, (itemColumn?.w || 330) - 16);

    const bodyRows = tableRows.map((row) => ({
      ...row,
      item:
        row.item && typeof doc.splitTextToSize === 'function'
          ? doc.splitTextToSize(row.item, wrapWidth)
          : row.item,
    }));

    const columnStyles = Object.fromEntries(
      pdfColumns.map((col) => [col.key, {
        cellWidth: col.w,
        halign: col.key === 'item' ? 'left' : 'center',
      }])
    );

    const columns = pdfColumns.map((col) => ({ header: col.header, dataKey: col.key }));

    doc.autoTable({
      startY: headerMeta.tableStartY,
      margin: { left: 70, right: 70, top: headerMeta.tableStartY },
      columns,
      body: bodyRows,
      theme: 'grid',
      styles: {
        font: 'helvetica',
        fontSize: 12,
        textColor: [228, 238, 240],
        fillColor: [18, 21, 27],
        cellPadding: { top: 8, bottom: 8, left: 10, right: 10 },
        lineColor: [35, 42, 48],
        lineWidth: 0.9,
        halign: 'left',
        overflow: 'linebreak',
      },
      headStyles: {
        fontStyle: 'bold',
        fontSize: 13,
        textColor: TK_ACCENT,
        fillColor: [11, 16, 20],
        halign: 'center',
        lineWidth: 1.1,
        lineColor: [35, 42, 48],
      },
      alternateRowStyles: {
        fillColor: [12, 14, 18],
      },
      columnStyles,
      didParseCell: (data) => {
        if (data.column.dataKey !== 'match') return;
        const row = data.row?.raw || {};
        const fallbackText =
          cleanText(row.match) || cleanText(data.cell.raw ?? data.cell.text?.[0] ?? '');
        const matchPercent =
          Number.isFinite(row.matchPercent)
            ? row.matchPercent
            : Number.isFinite(row.pct)
            ? row.pct
            : coerceNum(fallbackText);
        const aScore = Number.isFinite(row.partnerA)
          ? row.partnerA
          : Number.isFinite(row.aNum)
          ? row.aNum
          : coerceNum(row.a);
        const bScore = Number.isFinite(row.partnerB)
          ? row.partnerB
          : Number.isFinite(row.bNum)
          ? row.bNum
          : coerceNum(row.b);
        const flagEmoji = row.flagEmoji || tk_flagStatus(aScore, bScore, matchPercent);
        data.cell.text = [''];
        data.cell._tkMatchCell = { matchPercent, flagEmoji, fallbackText };
      },
      didDrawCell: (data) => {
        if (data.column.dataKey !== 'match') return;
        const payload = data.cell?._tkMatchCell;
        if (!payload) return;
        tk_drawMatchCell(doc, data.cell, payload.matchPercent, payload.flagEmoji, payload.fallbackText);
      },
      didDrawPage: () => {
        drawHeader(doc, headerMeta);
      },
    });
  }

  /* ---------------------- PDF Generator ---------------------- */

  async function generatePDF(rows) {
    if (!rows?.length) throw new Error('No rows to export');

    await loadPDFLibs();
    const jsPDF = window.jsPDF;

    const doc = new jsPDF({
      orientation: 'landscape',
      unit: 'pt',
      format: 'letter',
    });

    const normalized = rows.map(normalizeRow);
    const title = getText('.hx.h1', 'TalkKink Compatibility');
    const subtitle = getText('#tk-ts', `Generated: ${new Date().toLocaleString()}`);
    const sectionTitle = getText('.hx.h2', 'Behavioral Play');
    const headerMeta = buildHeaderMeta(doc, { title, subtitle, sectionTitle });

    paintPageBackground(doc);
    const originalAddPage = doc.addPage.bind(doc);
    doc.addPage = (...args) => {
      const result = originalAddPage(...args);
      paintPageBackground(doc);
      return result;
    };

    renderSection(doc, normalized, headerMeta);

    doc.addPage = originalAddPage;

    doc.save('TalkKink-compatibility.pdf');
  }

  /* ---------------------- State & Button ---------------------- */

  function getBtn() { return document.querySelector(CFG.selectors.downloadBtn); }

  function extractRowsFromTable() {
    const body = document.querySelector('#compatBody');
    if (!body) return [];
    const rows = [];
    body.querySelectorAll('tr').forEach(tr => {
      const cells = Array.from(tr.children, td => safe(td?.textContent).trim());
      if (cells.length >= 4) {
        rows.push(cells.slice(0, 4));
      }
    });
    return rows;
  }

  function computeRows() {
    if (cachedRows?.length) return cachedRows;
    if (Array.isArray(window.talkkinkCompatRows) && window.talkkinkCompatRows.length) {
      const prepared = sanitizeCompatRows(window.talkkinkCompatRows);
      cachedRows = prepared.slice();
      window.talkkinkCompatRows = prepared.slice();
    } else {
      cachedRows = extractRowsFromTable();
    }
    return cachedRows;
  }

  function setButtonState() {
    const btn = getBtn();
    if (!btn) return;
    rowsReady = computeRows().length > 0;
    const enabled = libsReady && rowsReady && !CFG.pdfKillSwitch;
    btn.disabled = !enabled;
  }

  window.TKCompatPDF = {
    notifyRowsUpdated(rows) {
      if (Array.isArray(rows)) {
        const prepared = sanitizeCompatRows(rows);
        cachedRows = prepared.slice();
        window.talkkinkCompatRows = prepared.slice();
      } else {
        cachedRows = [];
        window.talkkinkCompatRows = undefined;
      }
      setButtonState();
    },
    setKillSwitch(disabled) {
      CFG.pdfKillSwitch = !!disabled;
      setButtonState();
    },
  };

  function init() {
    const btn = getBtn();
    if (btn) btn.disabled = true;

    if (Array.isArray(window.talkkinkCompatRows))
      cachedRows = sanitizeCompatRows(window.talkkinkCompatRows);
    else
      cachedRows = extractRowsFromTable();

    setButtonState();

    btn?.addEventListener('click', async e => {
      e.preventDefault();
      try {
        const rows = computeRows();
        if (!rows.length) return alert('Upload both surveys first.');
        await generatePDF(rows);
      } catch (err) {
        console.error(err);
        alert('PDF error ‚Äî see console');
      }
    });

    loadPDFLibs().catch(err => console.error(err));
  }

  document.readyState === 'loading'
    ? document.addEventListener('DOMContentLoaded', init, { once: true })
    : init();

})();
</script>
</body>
</html>
