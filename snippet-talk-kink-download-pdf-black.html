<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>TalkKink — Download PDF (Black Theme)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <script>
  ;(() => {
    /***** 1) OPTIONAL: kill demo fallback entirely (keeps buttons from exporting stale PDFs) *****/
    // If the snippet checks a flag before using its hard-coded demo, set it here:
    window.TK_DISABLE_PDF_DEMO = true; // the snippet should prefer real data when present anyway

    /***** 2) Helper: publish the globals the snippet needs *****/
    function publishToExporter(questions, answersMap) {
      if (!Array.isArray(questions) || !(answersMap instanceof Map)) {
        console.error('[pdf-bridge] Invalid data. Need questions:Array and answers:Map');
        return;
      }
      window.QUESTIONS = questions;
      window.answers   = answersMap;

      // Let late listeners (including the snippet) know data is ready/updated
      try {
        window.dispatchEvent(new CustomEvent('tk-export-data-ready', {
          detail: { count: questions.length, answered: answersMap.size }
        }));
      } catch {}
      console.info('[pdf-bridge] Export data published:', { q: questions.length, a: answersMap.size });
    }

    /***** 3) Adapters — convert your existing sources to {QUESTIONS, answers Map} *****/

    // 3a) From live FORM state (edit this to your form’s structures)
    function collectFromForm() {
      // EXAMPLE shape — replace with your real form model if you use one
      // Return { questions: [{id,label}], answers: Map }
      const q = [];                   // e.g., gather from DOM or app state
      const a = new Map();            // e.g., new Map([['q1', 4], ['q2', 1], ...])
      // TODO: fill q/a based on your app’s live data
      return (q.length && a.size) ? { questions: q, answers: a } : null;
    }

    // 3b) From uploaded JSON (yourJSON / partnerJSON).
    // Supports a couple of common shapes; tweak if your schema differs.
    function collectFromUploadedJSON() {
      const sources = [window.yourJSON, window.partnerJSON].filter(Boolean);
      if (!sources.length) return null;

      // Build a unique list of questions (order preserved by first appearance)
      const qMap = new Map(); // id -> {id,label,...}
      const answers = new Map();

      for (const src of sources) {
        // Accept shapes like:
        //   src.questions = [{id, label, ...}]
        //   src.items     = [{id, label, ...}]
        //   src.answers   = { id: score, ... } OR [{id, score}] OR Map
        const items = Array.isArray(src.questions) ? src.questions
                    : Array.isArray(src.items)     ? src.items
                    : [];

        for (const it of items) {
          if (!it || !it.id) continue;
          if (!qMap.has(it.id)) qMap.set(it.id, { id: it.id, label: it.label || it.text || String(it.id) });
        }

        const rawAns = src.answers ?? src.response ?? src.scores;
        if (rawAns instanceof Map) {
          for (const [id, val] of rawAns) if (id) answers.set(String(id), Number(val));
        } else if (Array.isArray(rawAns)) {
          for (const row of rawAns) if (row && row.id != null) answers.set(String(row.id), Number(row.score ?? row.value ?? row.answer));
        } else if (rawAns && typeof rawAns === 'object') {
          for (const id of Object.keys(rawAns)) answers.set(String(id), Number(rawAns[id]));
        }
      }

      if (!qMap.size || !answers.size) return null;
      return { questions: Array.from(qMap.values()), answers };
    }

    /***** 4) Selection logic — prefer live form, then uploaded JSON *****/
    function resolveData() {
      return (
        collectFromForm() ||
        collectFromUploadedJSON()
      );
    }

    /***** 5) Initial publish (runs before the snippet if you include this ABOVE it) *****/
    const found = resolveData();
    if (found) publishToExporter(found.questions, found.answers);

    /***** 6) Keep it fresh — whenever your app state changes, republish *****/
    // If you have your own events, hook them here and call publishToExporter(...)
    // Example: after uploads finish
    window.addEventListener('tk-uploads-changed', () => {
      const latest = resolveData();
      if (latest) publishToExporter(latest.questions, latest.answers);
    });

    // Example: after form save
    window.addEventListener('tk-form-saved', () => {
      const latest = collectFromForm();
      if (latest) publishToExporter(latest.questions, latest.answers);
    });

    /***** 7) Safety: expose a manual way to push data from anywhere in your app *****/
    window.tkPushPdfData = (questions, answersLike) => {
      const map = answersLike instanceof Map
        ? answersLike
        : new Map(
            Array.isArray(answersLike)
              ? answersLike.map(([id,val]) => [String(id), Number(val)])
              : Object.entries(answersLike || {}).map(([id,val]) => [String(id), Number(val)])
          );
      publishToExporter(questions, map);
    };
  })();
  </script>

  <!-- jsPDF (UMD) -->
  <script src="/assets/js/vendor/jspdf.umd.min.js?v=2025-11-08"></script>
  <!-- make global jsPDF available -->
  <script>window.jsPDF = (window.jspdf && window.jspdf.jsPDF) || window.jsPDF;</script>

  <!-- jsPDF AutoTable plugin -->
  <script src="/assets/js/vendor/jspdf.plugin.autotable.min.js?v=2025-11-08"></script>

  <!-- TalkKink PDF generator -->
  <script defer src="/assets/js/tk-compat-download-pdf-black.js?v=2025-11-08"></script>

  <style>
    :root {
      --bg: #06131a;
      --teal: #00e5ff;
      --muted: #9bd3e0;
      --card: #0c1c24;
      --text: #dff7ff;
    }
    body {
      margin: 0; padding: 32px;
      background: var(--bg);
      color: var(--text);
      font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }
    h1 {
      margin: 0 0 10px; font-size: 40px; letter-spacing: .5px;
      text-shadow: 0 0 18px rgba(0,229,255,.35);
    }
    .hint { color: var(--muted); margin-bottom: 16px }
    .row { display: flex; gap: 16px; align-items: center; flex-wrap: wrap }
    button {
      all: unset; cursor: pointer;
      background: linear-gradient(180deg, #112834, #0e222c);
      border: 2px solid rgba(0,229,255,.6);
      box-shadow: 0 0 22px rgba(0,229,255,.12) inset, 0 0 22px rgba(0,229,255,.08);
      color: #eaffff;
      padding: 14px 22px; border-radius: 16px; font-weight: 700;
      transition: transform .05s ease, box-shadow .15s ease, border-color .15s ease;
    }
    button:hover { transform: translateY(-1px); box-shadow: 0 0 26px rgba(0,229,255,.2) inset, 0 0 26px rgba(0,229,255,.14) }
    .card {
      margin-top: 20px; padding: 16px 20px; border-radius: 18px;
      background: var(--card); border: 1px solid rgba(0,229,255,.25);
    }
    code { background:#07202a; color:#b9f4ff; padding:2px 6px; border-radius:8px }
  </style>
</head>
<body>
  <h1>Talk Kink — PDF Export (Black)</h1>
  <div class="hint">
    Click <strong>Download PDF</strong> to open a black PDF with category sections and your scores (0–5).<br />
    This file is generated entirely in your browser.
  </div>

  <div class="row">
    <button id="btnDownloadPDF">Download PDF</button>
  </div>

  <div class="card">
    <strong>How this integrates with your page</strong>
    <div class="hint">
      This snippet looks for your existing globals: <code>QUESTIONS</code> (array of { id, text, cat }) and <code>answers</code> (Map&lt;id, score&gt;).<br />
      If they exist, it uses them. If not, it will use a tiny demo dataset so you can test the PDF right away.
    </div>
  </div>

  <!-- PDF generator logic now lives in /assets/js/tk-compat-download-pdf-black.js -->
</body>
</html>
