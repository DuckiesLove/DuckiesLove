<!-- === One-Box: Fix loadLabels + Force Full-Bleed Black PDF === -->
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.2/dist/jspdf.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.3/dist/jspdf.plugin.autotable.min.js"></script>
<script>
/* 0) Pre-patch: intercept future assignment to window.loadLabels and wrap it so it returns an iterable */
(function interceptLoadLabels(){
  function updateLabelBox(mapLike){
    if (!mapLike || typeof mapLike !== 'object') return;
    let map = mapLike;
    if (Array.isArray(mapLike)) {
      const entries = [];
      for (const item of mapLike) {
        if (!item) continue;
        if (Array.isArray(item)) {
          const [k, v] = item;
          if (k != null) entries.push([String(k), String(v ?? k)]);
          continue;
        }
        if (typeof item === 'object') {
          const key = item.id || item.key || item.code || item[0];
          const label = item.label || item.name || item.text || item.value || item[1];
          if (key != null) entries.push([String(key), String(label ?? key)]);
        }
      }
      if (!entries.length) return;
      map = Object.fromEntries(entries);
    }

    const apply = () => {
      window.__tkLabelsById = Object.assign({}, window.__tkLabelsById || {}, map);
      let host = document.getElementById('tk-label-map-box');
      if (!host) {
        host = document.createElement('details');
        host.id = 'tk-label-map-box';
        host.open = false;
        host.style.position = 'fixed';
        host.style.bottom = '16px';
        host.style.right = '16px';
        host.style.maxWidth = 'min(480px, 90vw)';
        host.style.maxHeight = '60vh';
        host.style.padding = '12px';
        host.style.border = '1px solid rgba(255,255,255,0.4)';
        host.style.background = 'rgba(0,0,0,0.85)';
        host.style.color = '#fff';
        host.style.font = '13px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        host.style.zIndex = '9999';
        host.style.borderRadius = '8px';
        host.style.boxShadow = '0 8px 24px rgba(0,0,0,0.35)';

        const summary = document.createElement('summary');
        summary.textContent = 'Label map';
        summary.style.cursor = 'pointer';
        summary.style.fontWeight = '600';
        summary.style.marginBottom = '8px';
        host.appendChild(summary);

        const pre = document.createElement('pre');
        pre.style.margin = '0';
        pre.style.padding = '0';
        pre.style.whiteSpace = 'pre-wrap';
        pre.style.wordBreak = 'break-word';
        pre.style.overflow = 'auto';
        host.appendChild(pre);

        document.body.appendChild(host);
      }

      const pre = host.querySelector('pre');
      if (pre) {
        pre.textContent = JSON.stringify(map, null, 2);
      }
    };

    if (document.body) apply();
    else document.addEventListener('DOMContentLoaded', apply, { once: true });
  }

  if (!('loadLabels' in window)) {
    Object.defineProperty(window, 'loadLabels', {
      configurable: true,
      set(fn){
        // wrap the real function
        const wrapped = async function(...args){
          const out = await fn(...args);
          // If it's a plain object, return entries so for..of works
          if (out && typeof out === 'object' && !Array.isArray(out)) {
            const byId = {};
            for (const [k,v] of Object.entries(out)) byId[String(k)] = String(v ?? k);
            window.__tkLabelsById = byId;                 // optional map for other code
            updateLabelBox(byId);
            return Object.entries(byId);                  // <-- iterable
          }
          updateLabelBox(out);
          return out ?? [];                               // still iterable for for..of
        };
        Object.defineProperty(window, 'loadLabels', { value: wrapped, writable: true, configurable: true });
      }
    });
  } else {
    // If already defined, wrap it immediately
    const orig = window.loadLabels;
    window.loadLabels = async function(...args){
      const out = await orig(...args);
      if (out && typeof out === 'object' && !Array.isArray(out)) {
        const byId = {};
        for (const [k,v] of Object.entries(out)) byId[String(k)] = String(v ?? k);
        window.__tkLabelsById = byId;
        updateLabelBox(byId);
        return Object.entries(byId);
      }
      updateLabelBox(out);
      return out ?? [];
    };
  }
})();

/* 1) Kill legacy print/export paths that reintroduce margins/timestamps */
try { window.print = () => console.warn('[tk] window.print() disabled'); } catch(e){}
['downloadCompatibilityPDF','exportCompatibilityPDF','makePDF','createPDF','saveReportPDF','compatPDF','exportPDF','downloadPDF']
  .forEach(n => { try { delete window[n]; } catch(_){} });

/* 2) Consent (always ask) */
async function tkConsent(){ return confirm("Consent check:\nDo you have your partner’s consent to export/share this PDF?"); }

/* 3) Ultra full-bleed black exporter (no title/timestamp/footer/margins/borders/padding) */
async function tkExportPDF_BlackEdge({
  filename='compatibility.pdf',
  columns=[
    { header:'Category', dataKey:'category' },
    { header:'Partner A', dataKey:'a' },
    { header:'Match %',  dataKey:'m' },
    { header:'Partner B',dataKey:'b' },
  ],
  rows=[]
} = {}) {
  if(!(await tkConsent())) return;
  console.log('[tk] USING BlackEdge');

  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({ unit:'pt', format:'letter', compress:true, putOnlyUsedFonts:true });

  const W = doc.internal.pageSize.getWidth();
  const H = doc.internal.pageSize.getHeight();
  const BLEED = 10; // overpaint beyond page to defeat anti-alias halos

  const paint = () => { doc.setFillColor(0,0,0); doc.rect(-BLEED,-BLEED,W+BLEED*2,H+BLEED*2,'F'); };
  paint();
  doc.setTextColor(255,255,255);
  doc.setDrawColor(0,0,0);
  doc.setLineWidth(0);

  // If not provided, scrape the on-page table
  if (!rows.length) {
    const table = document.querySelector('table');
    if (table) {
      const ths = [...table.querySelectorAll('thead th')].map(th => th.textContent.trim());
      const trs = [...table.querySelectorAll('tbody tr')];
      const guessCols = ths.length ? ths : ['Category','Partner A','Match %','Partner B'];
      columns = guessCols.map((h,i)=>({header:h,dataKey:String(i)}));
      rows = trs.map(tr => {
        const cells = [...tr.children].map(td => td.textContent.trim());
        const obj = {};
        cells.forEach((v,i)=> obj[String(i)] = v || '—');
        return obj;
      });
    }
  }

  const head = [columns.map(c => c.header ?? c.title ?? c)];
  const body = rows.map(r => columns.map(c => {
    const k = c.dataKey ?? c.key ?? c;
    const v = r[k];
    return (v===undefined || v===null || v==='') ? '—' : String(v);
  }));

  doc.autoTable({
    head, body,
    startY: -BLEED,
    startX: -BLEED,
    tableWidth: W + BLEED*2,
    margin: { top:0, right:0, bottom:0, left:0 },
    theme: 'plain',
    horizontalPageBreak: true,

    styles: { font:'helvetica', fontSize:10, textColor:[255,255,255], cellPadding:0, lineWidth:0, fillColor:null, overflow:'linebreak', minCellHeight:14 },
    headStyles:{ fontStyle:'bold', textColor:[255,255,255], fillColor:null, cellPadding:0, lineWidth:0, minCellHeight:16 },
    tableLineWidth: 0, tableLineColor: [0,0,0],
    columnStyles:{ 0:{halign:'left'}, 1:{halign:'center'}, 2:{halign:'center'}, 3:{halign:'center'} },

    didParseCell(d){ d.cell.styles.fillColor=null; d.cell.styles.lineWidth=0; d.cell.styles.lineColor=[0,0,0]; },
    didAddPage(){ paint(); doc.setTextColor(255,255,255); doc.setDrawColor(0,0,0); doc.setLineWidth(0); }
  });

  doc.save(filename);
}

/* 4) Rewire the existing “Download PDF” button to this exporter */
(function wireDownloadBtn(){
  const btn = [...document.querySelectorAll('a,button,input[type="button"],input[type="submit"]')]
    .find(el => /download pdf/i.test((el.textContent||el.value||'').trim()));
  if (!btn) { console.warn('[tk] Download PDF button not found'); return; }
  btn.onclick = null;
  btn.removeAttribute('href');
  btn.addEventListener('click', function(e){
    e.preventDefault();
    e.stopImmediatePropagation();
    tkExportPDF_BlackEdge({});
  }, { capture:true });

  // Also alias common globals in case other code calls them
  ['downloadCompatibilityPDF','exportCompatibilityPDF','makePDF','createPDF','saveReportPDF','compatPDF','exportPDF','downloadPDF']
    .forEach(n => { window[n] = tkExportPDF_BlackEdge; });

  console.log('[tk] Button rewired + exporters patched');
})();

/* 5) Optional: solid-black proof. From console, run: tkSolidBlackTest() */
window.tkSolidBlackTest = function(){
  const { jsPDF } = window.jspdf;
  const d = new jsPDF({ unit:'pt', format:'letter' });
  const w = d.internal.pageSize.getWidth(), h = d.internal.pageSize.getHeight();
  d.setFillColor(0,0,0); d.rect(-14,-14,w+28,h+28,'F'); d.save('solid-black.pdf');
  console.log('[tk] solid-black.pdf exported');
};
</script>
