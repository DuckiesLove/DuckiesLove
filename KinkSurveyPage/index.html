<!doctype html>
<html lang="en">
<head>
  <!-- TK rescue: clear stale caches and overlays before we load styles/scripts -->
  <script>
  (async () => {
    try {
      if ('serviceWorker' in navigator) {
        const regs = await navigator.serviceWorker.getRegistrations();
        for (const r of regs) {
          try {
            await r.unregister();
          } catch {}
        }
      }
      if (window.caches) {
        const keys = await caches.keys();
        await Promise.all(keys.map(k => caches.delete(k)));
      }
    } catch {}
    try {
      const style = document.createElement('style');
      style.textContent = `#overlay, .overlay, [data-overlay], .tk-overlay { display:none !important; }
         body { opacity:1 !important; }`;
      document.head.appendChild(style);
    } catch {}
    try {
      const u = new URL(location.href);
      if (!u.searchParams.has('nuke')) {
        u.searchParams.set('nuke', Date.now());
        location.replace(u);
      }
    } catch {}
  })();
  </script>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Talk Kink Survey â€” Prototype</title>
<style>
  /* --- global box model so borders/padding don't cause overflow --- */
  *,*::before,*::after{ box-sizing:border-box }

  :root{
    --bg: #000000;
    --panel: #040608;
    --ink: #e8fbff;
    --ink-dim: #96d6e8;
    --edge: rgba(0,204,255,.35);
    --edge-soft: rgba(0,204,255,.18);
    --edge-strong: rgba(0,204,255,.6);
    --glow: 0 0 1.1rem rgba(0,204,255,.32);
    --accent: #00ccff;
    --accent-soft: rgba(0,204,255,.08);

    --left: 360px;    /* left column */
    --right: 420px;   /* right column */
    --gap: 24px;      /* column gap */
    --radius: 16px;
  }

  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font:16px/1.4 system-ui, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  }

  .container{max-width:1300px; margin:0 auto; padding:24px 18px 64px}

  h1#title{
    margin: 0 0 12px;                 /* tighter so the right panel appears above the fold */
    text-align:center;
    font-size: clamp(28px, 6vw, 64px);
    font-weight: 800;
    letter-spacing:.5px;
    text-shadow: 0 0 18px rgba(0,204,255,.38);
  }

  .theme-row{
    display:flex; flex-wrap:wrap; gap:10px; justify-content:center; margin: 0 0 10px;
  }
  .chip{ 
    background:rgba(255,255,255,.03); border:1px solid var(--edge);
    padding:7px 12px; border-radius:999px; color:var(--ink); cursor:pointer;
    transition:transform .12s ease, background .12s ease, border-color .12s ease;
  }
  .chip:hover{ transform:translateY(-1px); background:rgba(255,255,255,.05); border-color:var(--edge-strong) }
  .chip.active{ box-shadow: var(--glow); background:var(--accent-soft, rgba(0,204,255,.12)); border-color:var(--edge) }

  /* CTAs */
  .cta-stack{
    display:grid;
    gap:10px;
    margin:18px auto 0;
    justify-items: stretch;
    width:min(420px, 100%);
  }
  .btn{
    border:1px solid var(--edge); background:rgba(255,255,255,.03); color:var(--ink);
    padding:14px 18px; border-radius:999px; text-align:center; font-weight:700;
    box-shadow: var(--glow); cursor:pointer; transition:transform .12s ease, background .12s ease, border-color .12s ease;
  }
  .btn:hover{ transform: translateY(-1px); background: rgba(255,255,255,.06); border-color: var(--edge-strong); }
  .btn.ready{
    background: rgba(0,204,255,.14);
    border-color: var(--edge-strong);
    box-shadow: 0 0 1rem rgba(0,204,255,.45);
    animation: tkPulse 1.8s ease-in-out infinite;
  }
  .btn.ready:hover{ transform: translateY(-2px); }

  @keyframes tkPulse{
    0%, 100%{ box-shadow: 0 0 0.75rem rgba(0,204,255,.35); }
    50%{ box-shadow: 0 0 1.35rem rgba(0,204,255,.6); }
  }

  /* 3 columns */
  .tk-columns{
    display:grid;
    grid-template-columns: var(--left) 1fr var(--right);
    gap: var(--gap);
    align-items:start;
  }

  .card{
    background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.03));
    background-color: var(--panel);
    border:1px solid var(--edge); border-radius:var(--radius); box-shadow: var(--glow);
  }
  .card > .card-hd{
    padding:14px 16px; border-bottom:1px solid var(--edge-soft); color:var(--ink);
    font-size: clamp(18px, 2.6vw, 24px); font-weight:800; letter-spacing:.3px;
  }
  .card > .card-bd{ padding:14px 16px 16px }

  .progress-wrap{
    display:flex; flex-direction:column; gap:6px; margin-bottom:12px;
  }
  .progress-label{
    font-weight:700; color:var(--ink-dim);
    font-size: clamp(13px, 1.8vw, 15px);
  }
  .progress-track{
    position:relative; height:10px; border-radius:999px;
    background:rgba(255,255,255,.06); overflow:hidden;
    border:1px solid var(--edge-soft);
  }
  .progress-fill{
    position:absolute; inset:0; width:0%; border-radius:999px;
    background: var(--accent); box-shadow:0 0 0.5rem rgba(0,204,255,.6);
    transition: width .25s ease;
  }

  /* left categories */
  .tk-left{ max-height: calc(100vh - 170px); overflow:auto }  /* a bit taller, still fits viewport */
  .cat-list{ list-style:none; margin:0; padding:0 }
  .cat-item{
    display:flex; align-items:center; gap:12px; padding:12px 14px; margin:8px 12px;
    border-radius:12px; background:rgba(255,255,255,.02); border:1px solid var(--edge-soft); color:var(--ink);
  }
  .cat-item input{ accent-color: var(--accent) }

  /* middle card */
  #surveyMain.card{ width:100%; max-width:none; margin-inline:0; font-size:0.95rem }
  #surveyMain .lead{ color: var(--ink-dim); font-size: clamp(15px, 2vw, 18px) }
  #surveyMain .scale-heading{
    margin-top:6px;
    font-size: clamp(15px, 2vw, 20px);
    font-weight:800;
  }

  /* --- FIT-BETTER rating box --- */
  .rating-wrap{
    background: var(--accent-soft, rgba(255,255,255,.03));
    border: 1px solid var(--edge);
    border-radius: 14px;
    padding:12px;
    margin-top: 8px;
  }
  .scale-title{ font-weight:700; color:var(--ink-dim); margin-bottom:8px }

  /* Key change: flex + equal-width pills that shrink as needed. No overflow. */
  .scale-row{
    display:flex; gap:8px; align-items:stretch; width:100%;
    min-width: 0;            /* allow shrink inside grid cell */
  }
  .pill{
    flex: 1 1 0;             /* equal columns; can shrink */
    min-width: 0;            /* let text/radio wrap within */
    display:flex; align-items:center; justify-content:center; gap:6px;
    padding:10px 4px; border-radius:12px;
    border:1px solid var(--edge); background:rgba(255,255,255,.03);
    cursor:pointer; user-select:none;
    transition: background .15s ease, transform .15s ease, border-color .15s ease;
  }
  .pill:hover{ background: rgba(255,255,255,.06); border-color: var(--edge-strong); transform: translateY(-1px);}
  .pill input{ width:14px; height:14px; margin:0; accent-color: var(--accent); }
  .pill.active{ background: rgba(0,204,255,.18); border-color: rgba(0,204,255,.6); box-shadow: 0 0 0.45rem rgba(0,204,255,.45); }

  /* right guard: raise header so first guard card is visible without scrolling on laptops */
  .tk-right{ max-height: calc(100vh - 170px); overflow:auto } /* internal scroll only when needed */
  .tk-right .card-hd{ position:sticky; top:0; background:linear-gradient(180deg, rgba(0,0,0,.9), rgba(0,0,0,.72)); backdrop-filter: blur(2px); z-index:2 }

  .guard-list{ display:flex; flex-direction:column; gap:6px; padding:8px }
  .guard-item{
    display:flex; gap:8px; align-items:flex-start;
    padding:8px 10px; border-radius:12px; background:rgba(255,255,255,.03); border:1px solid var(--edge);
    font-size:clamp(12.5px,1.5vw,13.5px); line-height:1.35;
  }
  .guard-item strong{ display:block; margin-bottom:2px; font-size:1em; }
  .badge{
    width:26px; height:26px; min-width:26px; display:grid; place-items:center;
    border-radius:999px; font-weight:800; color:#04141b; background:#58f1ff;
    font-size:13px;
  }
  .badge.bad-1{ background:#ff6b6b}
  .badge.bad-2{ background:#ffd166}
  .badge.bad-3{ background:#6fd3ff}
  .badge.bad-4{ background:#72ffb3}

  @media (max-width: 1160px){ :root{ --right: 360px; --left: 320px } }
  @media (max-width: 980px){
    .tk-columns{
      grid-template-columns: 1fr;
    }
    .tk-left,.tk-right{ max-height:none; overflow:visible }
  }

  .hidden{ display:none !important }

  .start-wrap{ margin: 16px auto 28px; display:flex; justify-content:center; }
  .start-wrap .btn{ width:min(320px,100%); }

  .download-wrap{
    margin: 0;
    padding: 18px 16px 20px;
    border-top: 1px solid var(--edge-soft);
    display:flex;
    flex-direction:column;
    gap:12px;
    align-items:center;
    justify-content:center;
  }
  .download-wrap .btn{ width:min(320px,100%); }
</style>
</head>
<body>
  <div class="container">
    <h1 id="title">Talk Kink Survey</h1>

    <div class="theme-row" id="themeRow">
      <button class="chip active" data-theme="dark">Dark</button>
      <button class="chip" data-theme="lipstick">Lipstick</button>
      <button class="chip" data-theme="forest">Forest</button>
      <button class="chip" data-theme="glow">Blue Glow</button>
    </div>

    <div class="start-wrap">
      <button type="button" class="btn" id="startSurveyBtn" disabled aria-disabled="true">Start Survey</button>
    </div>

    <section class="tk-columns">
      <!-- LEFT -->
      <aside class="card tk-left" id="catCard">
        <div class="card-hd">Categories</div>
        <div class="card-bd">
          <ul id="catList" class="cat-list" aria-label="Kink categories"></ul>
        </div>
      </aside>

      <!-- MIDDLE -->
      <main class="card" id="surveyMain" aria-live="polite">
        <div class="card-hd">
          <div class="progress-wrap hidden" id="progressWrap" aria-live="polite">
            <div class="progress-label" id="progressLabel">Loading progressâ€¦</div>
            <div class="progress-track" id="progressTrack" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" aria-valuetext="0 of 0 answered">
              <div class="progress-fill" id="progressFill"></div>
            </div>
          </div>
          <div class="lead" id="questionCategory">Loading categoryâ€¦</div>
          <div class="scale-heading" id="questionPrompt">Loading questionâ€¦</div>
        </div>
        <div class="card-bd">
          <div class="rating-wrap" role="group" aria-labelledby="scaleTitle">
            <div id="scaleTitle" class="scale-title">Rate interest/comfort (0â€“5)</div>
            <div class="scale-row" id="scaleRow"></div>
          </div>
          <nav class="cta-stack" aria-label="Additional survey tools">
            <a class="btn" href="https://talkkink.org/KinkSurveyPage/index.html#analysis">Individual Kink Analysis</a>
            <a class="btn" href="https://talkkink.org/KinkSurveyPage/index.html#compatibility">Compatibility Page</a>
          </nav>
        </div>

        <div id="downloadWrap" class="download-wrap hidden">
          <button type="button" class="btn" id="downloadBtn">Download Survey</button>
          <button type="button" class="btn" id="compatExportBtn">Download Compatibility Export</button>
        </div>
      </main>

      <!-- RIGHT -->
      <aside class="card tk-right">
        <div class="card-hd">Rate interest/comfort (0â€“5)</div>
        <div class="guard-list card-bd">
          <div class="guard-item">
            <div class="badge">0</div>
            <div><strong>Brain did a cartwheel</strong> â€” skipped for now ðŸ¥²</div>
          </div>
          <div class="guard-item">
            <div class="badge bad-1">1</div>
            <div><strong>Hard Limit</strong> â€” full stop / non-negotiable</div>
          </div>
          <div class="guard-item">
            <div class="badge bad-2">2</div>
            <div><strong>Soft Limit</strong> â€” willing to try; strong boundaries &amp; safety checks</div>
          </div>
          <div class="guard-item">
            <div class="badge bad-3">3</div>
            <div><strong>Curious / context-dependent</strong> â€” okay with discussion; needs clear negotiation</div>
          </div>
          <div class="guard-item">
            <div class="badge bad-4">4</div>
            <div><strong>Comfortable / enjoy</strong> â€” generally a yes; normal precautions &amp; check-ins</div>
          </div>
          <div class="guard-item">
            <div class="badge">5</div>
            <div><strong>Favorite / enthusiastic yes</strong> â€” happily into it; green-light</div>
          </div>
        </div>
      </aside>
    </section>

  </div>

<script>
/* themes (cosmetic) */
const themeChips = Array.from(document.querySelectorAll('.chip'));
const rootStyle = document.documentElement?.style;
const THEME_KEY = 'tkSurveyTheme';
const THEMES = {
  dark: {
    bg: '#000000',
    panel: '#040608',
    ink: '#e8fbff',
    inkDim: '#96d6e8',
    edge: 'rgba(0,204,255,.35)',
    edgeSoft: 'rgba(0,204,255,.18)',
    edgeStrong: 'rgba(0,204,255,.6)',
    accent: '#00ccff',
    glow: '0 0 1.1rem rgba(0,204,255,.32)',
    accentSoft: 'rgba(0,204,255,.1)'
  },
  lipstick: {
    bg: '#000000',
    panel: '#12050b',
    ink: '#ffe8f2',
    inkDim: '#f7aacd',
    edge: 'rgba(255,77,166,.42)',
    edgeSoft: 'rgba(255,77,166,.22)',
    edgeStrong: 'rgba(255,77,166,.64)',
    accent: '#ff4da6',
    glow: '0 0 0.75rem rgba(255,77,166,.32)',
    accentSoft: 'rgba(255,77,166,.14)'
  },
  forest: {
    bg: '#000000',
    panel: '#04140b',
    ink: '#e7fff0',
    inkDim: '#a7d8b6',
    edge: 'rgba(56,245,155,.32)',
    edgeSoft: 'rgba(56,245,155,.18)',
    edgeStrong: 'rgba(56,245,155,.55)',
    accent: '#38f59b',
    glow: '0 0 0.75rem rgba(56,245,155,.26)',
    accentSoft: 'rgba(56,245,155,.15)'
  },
  glow: {
    bg: '#040c12',
    panel: '#0b1e2b',
    ink: '#e5f6ff',
    inkDim: '#9ecbe1',
    edge: 'rgba(0,234,255,.36)',
    edgeSoft: 'rgba(0,234,255,.2)',
    edgeStrong: 'rgba(0,234,255,.6)',
    accent: '#00eaff',
    glow: '0 0 0.75rem rgba(0,234,255,.28)',
    accentSoft: 'rgba(0,234,255,.14)'
  }
};

function applyTheme(name, { persist = true } = {}) {
  const themeName = THEMES[name] ? name : 'dark';
  const theme = THEMES[themeName];
  if (rootStyle) {
    rootStyle.setProperty('--bg', theme.bg);
    rootStyle.setProperty('--panel', theme.panel);
    rootStyle.setProperty('--ink', theme.ink);
    rootStyle.setProperty('--ink-dim', theme.inkDim);
    rootStyle.setProperty('--edge', theme.edge);
    rootStyle.setProperty('--edge-soft', theme.edgeSoft || theme.edge);
    rootStyle.setProperty('--edge-strong', theme.edgeStrong || theme.edge);
    rootStyle.setProperty('--accent', theme.accent);
    rootStyle.setProperty('--glow', theme.glow);
    rootStyle.setProperty('--accent-soft', theme.accentSoft || 'rgba(255,255,255,.03)');
  }
  if (document.body) {
    document.body.classList.remove('theme-dark', 'theme-lipstick', 'theme-forest', 'theme-glow');
    document.body.classList.add(`theme-${themeName}`);
  }
  themeChips.forEach(chip => {
    chip.classList.toggle('active', chip.dataset.theme === themeName);
  });
  if (persist) {
    try {
      localStorage.setItem(THEME_KEY, themeName);
    } catch (_) {}
  }
}

themeChips.forEach(chip => {
  chip.addEventListener('click', () => {
    const themeName = chip.dataset.theme;
    applyTheme(themeName);
  });
});

let initialTheme = 'dark';
try {
  const stored = localStorage.getItem(THEME_KEY);
  if (stored && THEMES[stored]) {
    initialTheme = stored;
  }
} catch (_) {}
applyTheme(initialTheme, { persist: false });

/* categories */
const catTargets = [
  '/data/categories.json',
  '/kinksurvey/data/categories.json',
  '/KinkSurveyPage/data/categories.json'
];
const startSurveyBtn = document.getElementById('startSurveyBtn');
const selectedCategories = new Set();
const DEFAULT_PRE_SURVEY_MESSAGE = 'Select one or more categories on the left, then press Start Survey to begin.';
const READY_PRE_SURVEY_MESSAGE = 'Categories selected â€” press Start Survey to begin!';
let preSurveyMessage = DEFAULT_PRE_SURVEY_MESSAGE;
let surveyStarted = false;

function normalizeCategoryName(value){
  return String(value ?? '').trim().toLowerCase();
}

function refreshPreSurveyMessage(){
  if(surveyStarted) return;
  preSurveyMessage = selectedCategories.size ? READY_PRE_SURVEY_MESSAGE : DEFAULT_PRE_SURVEY_MESSAGE;
  renderQuestion();
}

function updateStartSurveyState(){
  if(!startSurveyBtn) return;
  const hasSelection = selectedCategories.size > 0;
  startSurveyBtn.disabled = !hasSelection;
  startSurveyBtn.setAttribute('aria-disabled', hasSelection ? 'false' : 'true');
  startSurveyBtn.classList.toggle('ready', hasSelection && !surveyStarted);
  refreshPreSurveyMessage();
}

function handleCategoryChange(event){
  const name = event.target.dataset.name ?? '';
  if(event.target.checked){
    selectedCategories.add(name);
  }else{
    selectedCategories.delete(name);
  }
  updateStartSurveyState();
}

async function loadCategories(){
  let data = null;
  for(const path of catTargets){
    try{ const r = await fetch(path,{cache:'no-store'}); if(r.ok){ data = await r.json(); break; } }catch(e){}
  }
  if(!data){
    data = ["Appearance Play","Behavioral Play","Body Fluids and Functions","Body Modification",
            "Body Part / Fetish Play","Body Part Torture","Bondage and Suspension","Breath Play",
            "Breeding","Chastity Devices","Communication","Consent & Safewords"];
  }
  const normalize = v => typeof v === 'string' ? v : (v?.name ?? String(v));
  const ul = document.getElementById('catList');
  ul.innerHTML = '';
  selectedCategories.clear();
  (Array.isArray(data)?data.map(normalize):[]).forEach(name=>{
    const li = document.createElement('li');
    li.className = 'cat-item';
    li.innerHTML = `<input type="checkbox" aria-label="${name}"><span>${name}</span>`;
    const input = li.querySelector('input');
    input.dataset.name = name;
    input.addEventListener('change', handleCategoryChange);
    ul.appendChild(li);
  });
  updateStartSurveyState();
}
loadCategories();

/* 0â€“5 pills: equal width, never overflow */
const scaleRow = document.getElementById('scaleRow');
const questionCategoryEl = document.getElementById('questionCategory');
const questionPromptEl = document.getElementById('questionPrompt');
const progressWrap = document.getElementById('progressWrap');
const progressLabel = document.getElementById('progressLabel');
const progressTrack = document.getElementById('progressTrack');
const progressFill = document.getElementById('progressFill');
const downloadWrap = document.getElementById('downloadWrap');
const downloadBtn = document.getElementById('downloadBtn');

const scaleInputs = [];
const scaleLabels = [];
for(let v=0; v<=5; v++){
  const lab = document.createElement('label');
  lab.className = 'pill';
  lab.innerHTML = `<input type="radio" name="score" value="${v}" aria-label="Score ${v}"><span>${v}</span>`;
  const input = lab.querySelector('input');
  input.addEventListener('change', ()=>handleScore(Number(input.value)));
  scaleLabels.push(lab);
  scaleInputs.push(input);
  scaleRow.appendChild(lab);
}

const questionTargets = [
  '/KinkSurveyPage/data/kinks.json',
  '/kinksurvey/data/kinks.json',
  '/data/kinks.json'
];

let allQuestions = [];
let questionList = [];
let currentQuestionIndex = 0;
const answers = new Map();

function normalizeQuestions(data){
  const categories = Array.isArray(data?.categories) ? data.categories : [];
  const result = [];
  categories.forEach((cat, catIndex)=>{
    const catName = String(cat?.category ?? cat?.name ?? cat?.title ?? `Category ${catIndex+1}`);
    const items = Array.isArray(cat?.items) ? cat.items : [];
    items.forEach((item, itemIndex)=>{
      if(item?.type && item.type !== 'scale') return;
      const baseId = String(item?.id ?? `${catIndex}-${itemIndex}`);
      const label = String(item?.label ?? item?.text ?? item?.title ?? 'Survey question');
      const roles = Array.isArray(item?.roles) && item.roles.length ? [item.roles[0]] : [null];
      roles.forEach((role, roleIndex)=>{
        const roleSlug = role ? role.toLowerCase().replace(/[^a-z0-9]+/g,'-') : `role${roleIndex}`;
        result.push({
          id: `${baseId}-${roleSlug}`,
          category: catName,
          prompt: role ? `${role}: ${label}` : label
        });
      });
    });
  });
  return result;
}

function fallbackQuestions(){
  return [
    { id:'fallback-appearance-giving', category:'Appearance Play', prompt:'Giving: Choosing my partnerâ€™s outfit for the day or a scene' },
    { id:'fallback-appearance-receiving', category:'Appearance Play', prompt:'Receiving: Selecting their underwear, lingerie, or base layers' },
    { id:'fallback-protocol', category:'Protocol and Ritual', prompt:'Giving: Offering makeup, polish, or accessories as part of ritual or play' },
    { id:'fallback-impact', category:'Impact Play', prompt:'Giving: Hair pulling intensity preferences' },
    { id:'fallback-voyeurism', category:'Voyeurism/Exhibitionism', prompt:'Receiving: Exhibition scenes with a small audience' }
  ];
}

async function loadQuestions(){
  for(const path of questionTargets){
    try{
      const res = await fetch(path,{cache:'no-store'});
      if(res.ok){
        const json = await res.json();
        const normalized = normalizeQuestions(json);
        if(normalized.length){
          return normalized;
        }
      }
    }catch(e){}
  }
  return fallbackQuestions();
}

function startSurvey(){
  if(selectedCategories.size === 0){
    preSurveyMessage = 'Select at least one category to start the survey.';
    surveyStarted = false;
    renderQuestion();
    return;
  }

  if(!allQuestions.length){
    preSurveyMessage = 'Survey questions are still loading. Please try again in a moment.';
    surveyStarted = false;
    renderQuestion();
    return;
  }

  const normalizedSelected = new Set([...selectedCategories].map(normalizeCategoryName));
  const filtered = allQuestions.filter(q=>normalizedSelected.has(normalizeCategoryName(q.category)));

  if(!filtered.length){
    preSurveyMessage = 'No survey questions are available for the selected categories. Try a different selection.';
    surveyStarted = false;
    renderQuestion();
    return;
  }

  surveyStarted = true;
  questionList = filtered;
  currentQuestionIndex = 0;
  answers.clear();
  preSurveyMessage = DEFAULT_PRE_SURVEY_MESSAGE;
  if(startSurveyBtn){
    startSurveyBtn.classList.remove('ready');
  }
  renderQuestion();
  const surveyMain = document.getElementById('surveyMain');
  if(surveyMain){
    surveyMain.scrollIntoView({behavior:'smooth', block:'start'});
  }
}

if(startSurveyBtn){
  startSurveyBtn.addEventListener('click', startSurvey);
}

function updateProgress(total, completed){
  const percent = total ? Math.min(100, (completed / total) * 100) : 0;
  progressFill.style.width = `${percent}%`;
  progressTrack.setAttribute('aria-valuenow', percent.toFixed(1));
  progressTrack.setAttribute('aria-valuetext', `${completed} of ${total} answered`);
}

function resetScaleState(disabled){
  scaleInputs.forEach((input, idx)=>{
    input.checked = false;
    input.disabled = !!disabled;
    scaleLabels[idx].classList.remove('active');
  });
}

function renderQuestion(){
  if(!surveyStarted){
    progressWrap.classList.add('hidden');
    questionCategoryEl.textContent = 'Survey not started';
    questionPromptEl.textContent = preSurveyMessage;
    progressLabel.textContent = 'Waiting to start';
    resetScaleState(true);
    downloadWrap.classList.add('hidden');
    updateProgress(0,0);
    return;
  }

  const total = questionList.length;
  const completed = answers.size;

  if(!total){
    progressWrap.classList.add('hidden');
    questionCategoryEl.textContent = 'No survey questions available.';
    questionPromptEl.textContent = 'Please adjust your category selection or try again later.';
    resetScaleState(true);
    downloadWrap.classList.add('hidden');
    updateProgress(0,0);
    return;
  }

  progressWrap.classList.remove('hidden');
  updateProgress(total, completed);

  if(currentQuestionIndex >= total){
    questionCategoryEl.textContent = 'Survey complete';
    questionPromptEl.textContent = 'You have answered all available questions.';
    resetScaleState(true);
    progressLabel.textContent = `Survey complete â€¢ ${total} questions`;
    updateProgress(total, total);
    downloadWrap.classList.remove('hidden');
    return;
  }

  downloadWrap.classList.add('hidden');
  resetScaleState(false);

  const current = questionList[currentQuestionIndex];
  questionCategoryEl.textContent = current.category;
  questionPromptEl.textContent = current.prompt;
  progressLabel.textContent = `Question ${currentQuestionIndex + 1} of ${total}`;

  const existingScore = answers.get(current.id);
  if(existingScore != null){
    scaleInputs.forEach((input, idx)=>{
      if(Number(input.value) === existingScore){
        input.checked = true;
        scaleLabels[idx].classList.add('active');
      }
    });
  }
}

function handleScore(value){
  if(!surveyStarted || !questionList.length || currentQuestionIndex >= questionList.length) return;
  const current = questionList[currentQuestionIndex];
  answers.set(current.id, value);
  if(currentQuestionIndex < questionList.length - 1){
    currentQuestionIndex++;
  }else{
    currentQuestionIndex = questionList.length;
  }
  renderQuestion();
}

downloadBtn.addEventListener('click', ()=>{
  if(!surveyStarted || !questionList.length || answers.size < questionList.length) return;

  const originalText = downloadBtn.textContent;
  downloadBtn.textContent = 'Preparing downloadâ€¦';
  downloadBtn.setAttribute('aria-busy', 'true');
  downloadBtn.disabled = true;

  try{
    const responses = questionList.map((q, idx)=>{
      const rating = answers.has(q.id) ? answers.get(q.id) : null;
      return {
        index: idx + 1,
        id: q.id,
        category: q.category,
        prompt: q.prompt,
        rating: typeof rating === 'number' ? rating : null
      };
    });

    const answersByKey = {};
    const answersById = {};
    const cells = [];
    responses.forEach(entry=>{
      const rating = typeof entry.rating === 'number' ? entry.rating : 0;
      answersByKey[String(entry.index)] = rating;
      answersById[entry.id] = rating;
      cells.push(rating);
    });

    const payload = {
      version: 1,
      generatedAt: new Date().toISOString(),
      meta: {
        categories: Array.from(new Set(responses.map(r=>r.category))),
        selectedCategories: Array.from(selectedCategories),
        totals: {
          questions: questionList.length,
          answered: responses.filter(r=>typeof r.rating === 'number').length
        }
      },
      responses,
      answers: { ...answersByKey },
      answersByKey,
      answersById,
      cells
    };

    const json = JSON.stringify(payload, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const anchor = document.createElement('a');
    anchor.href = url;
    anchor.download = `talkkink-survey-${Date.now()}.json`;
    document.body.appendChild(anchor);
    anchor.click();
    setTimeout(()=>{
      URL.revokeObjectURL(url);
      anchor.remove();
    },0);
  }catch(err){
    console.error('Failed to prepare survey export', err);
    alert('Could not prepare the survey export. Please try again.');
  }finally{
    downloadBtn.disabled = false;
    downloadBtn.textContent = originalText;
    downloadBtn.removeAttribute('aria-busy');
  }
});

(async ()=>{
  allQuestions = await loadQuestions();
  questionList = [];
  currentQuestionIndex = 0;
  answers.clear();
  surveyStarted = false;
  preSurveyMessage = DEFAULT_PRE_SURVEY_MESSAGE;
  renderQuestion();
})();
</script>

<script>
(() => {
  /***********************
   * TalkKink â€“ Export v2 *
   ***********************/
  const EXPORT_FORMAT = 'talkkink.v2';
  const LS_KEYS = ['tk_answers_v2', 'tk_answers', 'survey_answers', 'talkkink.answers'];
  const CATEGORIES_SRC = window.TK_CATEGORIES || window.categories || null;
  const KINKS_SRC = window.TK_KINKS || window.kinks || null;

  /** Utilities **/
  const qs = (sel, el = document) => el.querySelector(sel);
  const qsa = (sel, el = document) => Array.from(el.querySelectorAll(sel));
  const nowISO = () => new Date().toISOString();
  const pad = (n) => String(n).padStart(2, '0');
  const stamp = (d) => `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}`;

  function download(filename, text, type = 'application/json') {
    const blob = new Blob([text], { type });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.append(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function deepClone(o) {
    try {
      return JSON.parse(JSON.stringify(o));
    } catch (err) {
      return null;
    }
  }

  const slugify = (value) =>
    String(value || '')
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-');

  const capitalize = (value) => {
    if (!value) return '';
    const str = String(value);
    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
  };

  const clampScore = (value) => {
    const num = Number(value);
    if (!Number.isFinite(num)) return null;
    if (num <= 0) return 0;
    if (num >= 5) return 5;
    return Math.round(num);
  };

  function questionCatalog() {
    const catalog = new Map();
    const push = (question, index) => {
      if (!question || !question.id) return;
      const id = String(question.id);
      if (!catalog.has(id)) {
        catalog.set(id, {
          id,
          prompt: question.prompt || question.label || question.text || '',
          label: question.label || question.prompt || question.text || '',
          category: question.category || question.categoryName || '',
          categoryId: question.categoryId || question.sectionId || '',
          role: question.role || '',
          index
        });
      }
    };

    if (Array.isArray(window.questionList)) {
      window.questionList.forEach((q, idx) => push(q, idx));
    }
    if (Array.isArray(window.allQuestions)) {
      window.allQuestions.forEach((q, idx) => push(q, idx));
    }
    return catalog;
  }

  function ingestCategories(catById) {
    const apply = (entry) => {
      if (!entry) return;
      if (typeof entry === 'string') {
        const id = slugify(entry) || entry;
        if (!catById.has(id)) catById.set(id, { id, name: entry });
        return;
      }
      const id = String(entry.id || entry.slug || entry.handle || entry.category || entry.name || '');
      const name = String(entry.name || entry.title || entry.category || id || 'Uncategorized');
      if (!id && !name) return;
      const finalId = id || slugify(name) || 'category';
      if (!catById.has(finalId)) {
        catById.set(finalId, { id: finalId, name });
      }
    };

    const absorb = (source) => {
      if (!source) return;
      if (Array.isArray(source)) {
        source.forEach((item) => absorb(item));
        return;
      }
      if (typeof source !== 'object') return;
      if (Array.isArray(source.categories)) {
        source.categories.forEach((cat) => absorb(cat));
      }
      if (Array.isArray(source.sections)) {
        source.sections.forEach((cat) => absorb(cat));
      }
      if (Array.isArray(source.groups)) {
        source.groups.forEach((cat) => absorb(cat));
      }
      if (source.category || source.name) {
        apply(source);
      }
    };

    absorb(CATEGORIES_SRC);
    absorb(KINKS_SRC);
  }

  function ingestKinks(catById) {
    const kinkById = new Map();

    const applyLabelMap = (labels) => {
      if (!labels || typeof labels !== 'object') return;
      Object.entries(labels).forEach(([id, label]) => {
        const key = String(id);
        if (!kinkById.has(key)) kinkById.set(key, { id: key });
        kinkById.get(key).label = String(label);
      });
    };

    const absorbItems = (items, cat) => {
      if (!Array.isArray(items)) return;
      items.forEach((item) => {
        if (!item) return;
        const id = String(item.id || item.slug || item.code || item.key || item.qid || item.questionId || '');
        if (!id) return;
        if (!kinkById.has(id)) kinkById.set(id, { id });
        const entry = kinkById.get(id);
        if (!entry.label && (item.label || item.text || item.title)) {
          entry.label = String(item.label || item.text || item.title);
        }
        if (Array.isArray(item.roles) && item.roles.length) {
          entry.roles = Array.from(new Set([...(entry.roles || []), ...item.roles.map(String)]));
        }
        if (cat) {
          const catId = String(cat.id || cat.slug || cat.handle || cat.category || cat.name || '');
          const catName = String(cat.name || cat.title || cat.category || catId || 'Uncategorized');
          entry.categoryId = entry.categoryId || catId || slugify(catName);
          entry.category = entry.category || catName;
          if (entry.categoryId && !catById.has(entry.categoryId)) {
            catById.set(entry.categoryId, { id: entry.categoryId, name: entry.category || catName });
          }
        }
      });
    };

    const absorb = (source) => {
      if (!source) return;
      if (Array.isArray(source)) {
        source.forEach((item) => absorb(item));
        return kinkById;
      }
      if (typeof source !== 'object') return kinkById;
      if (source.labels) applyLabelMap(source.labels);
      if (Array.isArray(source.categories)) {
        source.categories.forEach((cat) => {
          absorbItems(cat?.items || cat?.kinks, cat);
        });
      }
      if (Array.isArray(source.sections)) {
        source.sections.forEach((cat) => {
          absorbItems(cat?.items || cat?.kinks, cat);
        });
      }
      if (Array.isArray(source.groups)) {
        source.groups.forEach((cat) => {
          absorbItems(cat?.items || cat?.kinks, cat);
        });
      }
      if (Array.isArray(source.items)) {
        absorbItems(source.items, null);
      }
      return kinkById;
    };

    absorb(KINKS_SRC);
    return kinkById;
  }

  function guessRoleFromPrompt(prompt) {
    if (!prompt || typeof prompt !== 'string') return '';
    const parts = prompt.split(':');
    if (parts.length < 2) return '';
    const candidate = parts[0].trim();
    if (/^(giving|receiving|general|watching|sharing|leading|following|switching)$/i.test(candidate)) {
      return capitalize(candidate);
    }
    return '';
  }

  function stripRoleFromPrompt(prompt) {
    if (!prompt || typeof prompt !== 'string') return prompt;
    const idx = prompt.indexOf(':');
    if (idx === -1) return prompt;
    return prompt.slice(idx + 1).trim();
  }

  /** Try to collect answers from common places without breaking your page */
  function readAnswersFromKnownPlaces() {
    const catalog = questionCatalog();

    if (typeof answers !== 'undefined' && answers && typeof answers.forEach === 'function' && answers.size) {
      const items = [];
      let order = 0;
      answers.forEach((score, id) => {
        const meta = catalog.get(String(id)) || {};
        items.push({
          id: String(id),
          score,
          prompt: meta.prompt,
          label: meta.label,
          category: meta.category,
          categoryId: meta.categoryId,
          role: meta.role,
          order: meta.index ?? order
        });
        order += 1;
      });
      items.sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
      return { flat: true, items };
    }

    if (window.TK_SURVEY?.answers) return deepClone(window.TK_SURVEY.answers);
    if (window.SURVEY?.answers) return deepClone(window.SURVEY.answers);
    if (window.appState?.answers) return deepClone(window.appState.answers);

    for (const key of LS_KEYS) {
      try {
        const raw = localStorage.getItem(key);
        if (raw) {
          const parsed = JSON.parse(raw);
          if (parsed && typeof parsed === 'object') return parsed;
        }
      } catch (e) {}
    }

    const rows = qsa('[data-qid]');
    if (rows.length) {
      const scraped = [];
      rows.forEach((row, idx) => {
        const qid = row.getAttribute('data-qid');
        const label = row.getAttribute('data-label') || '';
        const role = row.getAttribute('data-role') || '';
        const selected =
          qs('input[type="radio"][name][value]:checked', row) || qs('[role="radio"][aria-checked="true"]', row);
        if (!selected) return;
        const v = selected.value ?? selected.getAttribute('data-value') ?? selected.textContent?.trim();
        const score = Number(v);
        if (!Number.isNaN(score)) scraped.push({ id: qid, label, role, score, order: idx });
      });
      return scraped.length ? { flat: true, items: scraped } : null;
    }

    return null;
  }

  function finalizeRecord(entry, index, kinkById, catById) {
    if (entry == null) return null;

    let base = entry;
    if (Array.isArray(entry)) {
      if (entry.length < 2) return null;
      base = { id: entry[0], score: entry[1], label: entry[2], category: entry[3] };
    } else if (typeof entry === 'number') {
      const lookup =
        (Array.isArray(window.questionList) && window.questionList[index]) ||
        (Array.isArray(window.allQuestions) && window.allQuestions[index]);
      if (!lookup || !lookup.id) return null;
      base = {
        id: lookup.id,
        score: entry,
        label: lookup.prompt || lookup.label,
        prompt: lookup.prompt || lookup.label,
        category: lookup.category,
        role: lookup.role,
        order: index
      };
    }

    const idRaw = base.id ?? base.qid ?? base.key ?? base.code ?? base.questionId ?? base.slug;
    if (!idRaw) return null;
    const id = String(idRaw).trim();
    if (!id) return null;

    const score = clampScore(base.score ?? base.value ?? base.rating ?? base.answer ?? base.selected ?? base.val ?? base.s);
    if (score == null) return null;

    let prompt = base.prompt || base.label || base.text || base.name || '';
    let label = base.label || base.text || base.name || '';
    let role = base.role || base.mode || base.position || '';
    let categoryName = base.category || base.categoryName || base.section || base.group || base.bucket || '';
    let categoryId = base.categoryId || base.sectionId || base.groupId || '';

    const meta = kinkById.get(id) || {};
    if (!label && meta.label) label = meta.label;
    if (!prompt && meta.label) prompt = meta.label;
    if (!categoryName && meta.category) categoryName = meta.category;
    if (!categoryId && meta.categoryId) categoryId = meta.categoryId;
    if (!role && Array.isArray(meta.roles) && meta.roles.length === 1) role = meta.roles[0];

    if (!categoryId && categoryName) {
      categoryId = slugify(categoryName);
    }
    if (!categoryName && categoryId && catById.has(categoryId)) {
      categoryName = catById.get(categoryId).name || categoryId;
    }

    if (!categoryId) categoryId = 'uncategorized';
    if (!categoryName) categoryName = 'Uncategorized';

    if (!role) {
      const guessed = guessRoleFromPrompt(prompt);
      if (guessed) {
        role = guessed;
        prompt = stripRoleFromPrompt(prompt);
      }
    }

    const cleanLabel = label ? String(label).trim() : '';
    const cleanPrompt = prompt ? String(prompt).trim() : cleanLabel;
    const final = { id, score };
    if (cleanLabel) final.label = cleanLabel;
    if (cleanPrompt && cleanPrompt !== cleanLabel) final.prompt = cleanPrompt;
    if (role) final.role = role;

    return {
      answer: final,
      categoryId,
      categoryName,
      order: Number.isFinite(base.order) ? base.order : index
    };
  }

  /** Normalize whatever we found into the compatibility JSON your /compatibility.html expects. */
  function buildExportObject() {
    const raw = readAnswersFromKnownPlaces();
    if (!raw) return null;

    const catById = new Map();
    ingestCategories(catById);
    const kinkById = ingestKinks(catById);

    const ensureCategory = (list, categoryId, categoryName) => {
      const id = categoryId || slugify(categoryName) || 'uncategorized';
      const name = categoryName || (catById.get(id)?.name ?? 'Uncategorized');
      let cat = list.find((entry) => entry.id === id);
      if (!cat) {
        cat = { id, name, answers: [], order: list.length };
        list.push(cat);
      }
      return cat;
    };

    const categorized = [];
    const flatRecords = [];

    const collectFlat = (items) => {
      if (!Array.isArray(items)) return;
      items.forEach((item, idx) => {
        const normalized = finalizeRecord(item, idx, kinkById, catById);
        if (normalized) {
          flatRecords.push(normalized);
        }
      });
    };

    const groups = raw?.categories || raw?.sections || raw?.groups;
    if (Array.isArray(groups)) {
      groups.forEach((group, gIdx) => {
        const catId = String(group?.id || group?.slug || group?.category || group?.name || `category-${gIdx}`);
        const catName = String(group?.name || group?.title || group?.category || catId || 'Uncategorized');
        const category = ensureCategory(categorized, catId, catName);
        const items = group?.items || group?.questions || group?.kinks || [];
        items.forEach((item, idx) => {
          const normalized = finalizeRecord(item, idx, kinkById, catById);
          if (normalized) {
            category.answers.push(normalized.answer);
            flatRecords.push({ ...normalized, categoryId: category.id, categoryName: category.name });
          }
        });
      });
    }

    if (!flatRecords.length) {
      if (raw?.flat === true && Array.isArray(raw?.items)) collectFlat(raw.items);
      collectFlat(raw?.items);
      collectFlat(raw?.answers);
      collectFlat(raw?.responses);
      collectFlat(raw?.rows);
      collectFlat(raw?.data?.answers);
      if (Array.isArray(raw)) collectFlat(raw);

      const mapCandidates = [raw?.answersById, raw?.answersByKey, raw?.map, raw?.scores, raw?.ratings];
      mapCandidates.forEach((candidate) => {
        if (!candidate || typeof candidate !== 'object') return;
        Object.entries(candidate).forEach(([id, score]) => {
          const normalized = finalizeRecord({ id, score }, flatRecords.length, kinkById, catById);
          if (normalized) flatRecords.push(normalized);
        });
      });
    }

    const filteredFlat = flatRecords.filter((entry) => entry && entry.answer);
    filteredFlat.sort((a, b) => (a.order ?? 0) - (b.order ?? 0));

    filteredFlat.forEach((entry) => {
      const category = ensureCategory(categorized, entry.categoryId, entry.categoryName);
      category.answers.push(entry.answer);
    });

    const finalCategories = categorized
      .filter((cat) => Array.isArray(cat.answers) && cat.answers.length)
      .map((cat) => ({ id: cat.id, name: cat.name, answers: cat.answers }));

    const items = [];
    const answersById = {};
    finalCategories.forEach((cat) => {
      cat.answers.forEach((ans) => {
        items.push({ ...ans, categoryId: cat.id, category: cat.name });
        answersById[ans.id] = ans.score;
      });
    });

    if (!items.length) return null;

    const now = new Date();
    const theme =
      document.documentElement.getAttribute('data-theme') ||
      qs('[data-theme-active]')?.getAttribute('data-theme-active') ||
      'dark';

    const exportObject = {
      format: EXPORT_FORMAT,
      version: 1,
      generatedAt: nowISO(),
      stamp: stamp(now),
      theme,
      source: {
        url: window.location?.href || '',
        title: document.title || '',
        theme,
        generatedAt: raw?.generatedAt || raw?.timestamp || null
      },
      counts: {
        categories: finalCategories.length,
        answers: items.length
      },
      categories: finalCategories,
      items,
      answers: answersById
    };

    if (!exportObject.source.generatedAt) delete exportObject.source.generatedAt;

    const context = {};
    ['meta', 'profile', 'partner', 'partnerName', 'partners', 'info', 'notes'].forEach((key) => {
      if (raw && raw[key] != null && typeof raw[key] !== 'function') {
        context[key] = raw[key];
      }
    });
    if (raw?.summary) context.summary = raw.summary;
    if (Object.keys(context).length) {
      exportObject.context = context;
    }

    window.TK_LAST_EXPORT = exportObject;
    return exportObject;
  }

  function handleExportClick() {
    const btn = document.getElementById('compatExportBtn');
    if (!btn) return;
    const original = btn.textContent;
    btn.disabled = true;
    btn.textContent = 'Preparing exportâ€¦';
    btn.setAttribute('aria-busy', 'true');
    try {
      const payload = buildExportObject();
      if (!payload) {
        alert('Could not find completed survey answers to export.');
        return;
      }
      const file = `talkkink-compat-${stamp(new Date())}.json`;
      const text = JSON.stringify(payload, null, 2);
      download(file, text);
    } catch (err) {
      console.error('[TalkKink] compatibility export failed', err);
      alert('Could not prepare the compatibility export. Please try again.');
    } finally {
      btn.disabled = false;
      btn.textContent = original;
      btn.removeAttribute('aria-busy');
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    const btn = document.getElementById('compatExportBtn');
    if (!btn) return;
    btn.addEventListener('click', handleExportClick);
  });

  window.TK_EXPORT = {
    build: buildExportObject,
    trigger: handleExportClick
  };
})();
</script>
</body>
</html>
