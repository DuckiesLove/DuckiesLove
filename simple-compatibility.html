<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Compatibility Module</title>
</head>
<body>
<!-- ========== Partner A + Partner B (robust load + auto row IDs) ========== -->
<div id="compat-ui" style="margin:.75rem 0 1rem">
  <div id="globalError" style="display:none;color:#ff6b6b;margin:.5rem 0;"></div>

  <div style="display:flex;gap:1rem;flex-wrap:wrap;align-items:center">
    <label><strong>Survey A (Partner A):</strong>
      <input id="uploadA" type="file" accept=".json,application/json" />
    </label>
    <span id="statusA" style="font-size:.9rem;color:#8aa">No file</span>
  </div>

  <div style="display:flex;gap:1rem;flex-wrap:wrap;align-items:center;margin-top:.5rem">
    <button id="loadPartnerBtn" type="button">Load Partner Survey</button>
    <input id="uploadB" type="file" accept=".json,application/json" hidden />
    <span id="statusB" style="font-size:.9rem;color:#8aa">No file</span>
  </div>

  <button id="downloadBtn" disabled style="margin-top:.75rem">Download Compatibility Report</button>
</div>

<table border="1" style="margin-top:1em; border-collapse:collapse; min-width:360px;">
  <thead>
    <tr>
      <th>Category</th>
      <th>Partner A</th>
      <th>Match</th>
      <th>Partner B</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>

<script>
/* ---------- tiny UI helpers ---------- */
function tkSetStatus(which, msg, ok=true){
  const el = document.getElementById(which==="A" ? "statusA" : "statusB");
  if (el){ el.textContent = msg; el.style.color = ok ? "#59ff9b" : "#ff6b6b"; }
}
function tkSetError(msg){
  const el = document.getElementById("globalError");
  if (!el) return;
  if (!msg){ el.style.display="none"; el.textContent=""; return; }
  el.style.display="block"; el.textContent = msg;
}
function tkEnableDownload(){
  const btn = document.getElementById("downloadBtn");
  if (!btn) return;
  btn.disabled = !(window.tkA?.length > 0 && window.tkB?.length > 0);
}

/* ---------- make every row addressable: add data-kink-id = slug(first-cell) ---------- */
function tkSlug(s){
  return String(s||"")
    .toLowerCase()
    .normalize("NFKD").replace(/[\u0300-\u036f]/g,"")  // strip accents
    .replace(/['â€™]/g,"")                                // drop apostrophes
    .replace(/[^a-z0-9]+/g,"_")                         // non-alnum -> underscore
    .replace(/^_+|_+$/g,"");                            // trim underscores
}
function tkEnsureRowIds(){
  const rows = document.querySelectorAll("table tbody tr");
  rows.forEach(tr=>{
    if (tr.hasAttribute("data-kink-id")) return;
    const td = tr.querySelector("td");
    if (!td) return;
    const id = tkSlug(td.textContent.trim());
    if (id) tr.setAttribute("data-kink-id", id);
  });
}

/* ---------- JSON parsing + normalization ---------- */
function tkSafeParse(text){
  try{
    if (text && text.charCodeAt(0)===0xFEFF) text = text.slice(1);  // strip BOM
    text = text.replace(/[\u201C\u201D]/g,'"').replace(/[\u2018\u2019]/g,"'"); // smart quotes
    text = text.replace(/,\s*([\]}])/g,"$1"); // trailing commas
    return JSON.parse(text);
  }catch(e){ return null; }
}
function tkCoerceScore(v){
  if (typeof v === "number" && Number.isFinite(v)) return v;
  if (typeof v === "string"){
    const t = v.trim();
    if (/^\d+%$/.test(t)) return Number(t.slice(0,-1))/20;     // 80% -> 4.0
    if (/^\d+\s*\/\s*\d+$/.test(t)) return Number(t.split("/")[0]); // "4/5" -> 4
    const n = Number(t); if (!Number.isNaN(n)) return n;
  }
  if (v && typeof v === "object"){
    const s = v.rating ?? v.score ?? v.value ?? v.val ?? v.points ?? v.level;
    return tkCoerceScore(s);
  }
  return null;
}
/* Return array of {id,label,score} where id = slug(label) */
function tkNormalize(json){
  // object map: {"Label": 5, ...}
  if (json && typeof json === "object" && !Array.isArray(json)){
    const out = [];
    for (const [label,val] of Object.entries(json)){
      const score = tkCoerceScore(val);
      if (typeof score === "number"){
        out.push({ id: tkSlug(label), label, score });
      }
    }
    return out;
  }
  // array-ish
  let rows = [];
  if (Array.isArray(json)) rows = json;
  else if (Array.isArray(json?.items)) rows=json.items;
  else if (Array.isArray(json?.answers)) rows=json.answers;
  else if (Array.isArray(json?.data)) rows=json.data;
  else if (json && typeof json === "object"){
    const firstArr = Object.values(json).find(v=>Array.isArray(v));
    if (Array.isArray(firstArr)) rows = firstArr;
  }
  const NAME = ["label","name","title","id","key","slug"];
  const SCORE = ["rating","score","value","val","points","level"];
  const out=[];
  for (const row of rows||[]){
    if (!row || typeof row !== "object") continue;
    const cand = ["","item","question","meta","data"].map(p=>p?row[p]:row).find(v=>v && typeof v==="object") || row;
    let label = null; for (const k of NAME) if (k in cand){ label = cand[k]; break; }
    label = (typeof label==="string" ? label : String(label??"")).trim();
    if (!label) continue;
    let s = null; for (const k of SCORE) if (k in cand){ s = cand[k]; break; }
    const score = tkCoerceScore(s);
    if (typeof score === "number") out.push({ id: tkSlug(label), label, score });
  }
  return out;
}

/* ---------- scale + match + table injection ---------- */
function tkDetectScale(items){
  const vals = items.map(i=>i.score).filter(n=>typeof n==="number");
  if (!vals.length) return 1;
  const max = Math.max(...vals), min = Math.min(...vals);
  if (max<=5 && min>=0) return 1;
  if (max<=1 && min>=0) return 5;
  if (max<=7)  return 5/7;
  if (max<=10) return 5/10;
  if (max<=100) return 5/100;
  return 5/Math.max(5,max);
}
function tkMatch(a5,b5){ const d=Math.abs(a5-b5); return Math.max(0, 100 - (d/5)*100); }

function tkEnsureCells(tr){
  if (!tr.querySelector('[data-cell="A"]'))  tr.insertCell(1).setAttribute("data-cell","A");
  if (!tr.querySelector('[data-cell="Match"]')) tr.insertCell(2).setAttribute("data-cell","Match");
  if (!tr.querySelector('[data-cell="B"]'))  tr.insertCell(3).setAttribute("data-cell","B");
}
function tkRebuildTableFromUnion(){
  const tbody = document.querySelector("table tbody");
  if (!tbody) return;
  const union = new Map(); // id -> label
  (window.tkA||[]).forEach(i=>union.set(i.id,i.label));
  (window.tkB||[]).forEach(i=>union.set(i.id,i.label));
  const sorted = [...union.entries()].sort((a,b)=> a[1].localeCompare(b[1]));
  tbody.innerHTML="";
  for (const [id,label] of sorted){
    const tr = document.createElement("tr");
    tr.setAttribute("data-kink-id", id);
    const td = document.createElement("td"); td.textContent = label;
    tr.appendChild(td);
    const tdA=document.createElement("td"); tdA.setAttribute("data-cell","A"); tdA.textContent="-";
    const tdM=document.createElement("td"); tdM.setAttribute("data-cell","Match"); tdM.textContent="-";
    const tdB=document.createElement("td"); tdB.setAttribute("data-cell","B"); tdB.textContent="-";
    tr.append(tdA,tdM,tdB);
    tbody.appendChild(tr);
  }
}

function tkUpdate(){
  tkEnsureRowIds();

  // If table has no identifiable rows yet but we have data, build from data
  if (!document.querySelector('tbody tr[data-kink-id]') && ((window.tkA&&tkA.length) || (window.tkB&&tkB.length))){
    tkRebuildTableFromUnion();
  }

  const aMap = new Map((window.tkA||[]).map(i=>[i.id,i]));
  const bMap = new Map((window.tkB||[]).map(i=>[i.id,i]));
  const sA = tkDetectScale(window.tkA||[]);
  const sB = tkDetectScale(window.tkB||[]);

  // show what couldn't be matched
  const tbody = document.querySelector("table tbody");
  const haveIds = new Set(Array.from(tbody.querySelectorAll('tr[data-kink-id]')).map(tr=>tr.getAttribute('data-kink-id')));
  const aUnmatched = (window.tkA||[]).filter(i=>!haveIds.has(i.id)).slice(0,5);
  const bUnmatched = (window.tkB||[]).filter(i=>!haveIds.has(i.id)).slice(0,5);
  if (aUnmatched.length || bUnmatched.length){
    console.warn("Unmatched A:", aUnmatched);
    console.warn("Unmatched B:", bUnmatched);
  }

  document.querySelectorAll('tbody tr[data-kink-id]').forEach(tr=>{
    const id = tr.getAttribute('data-kink-id');
    tkEnsureCells(tr);

    const A = aMap.get(id), B = bMap.get(id);
    const aCell = tr.querySelector('[data-cell="A"]');
    const bCell = tr.querySelector('[data-cell="B"]');
    const mCell = tr.querySelector('[data-cell="Match"]');

    const aRaw = (typeof A?.score==="number") ? A.score : null;
    const bRaw = (typeof B?.score==="number") ? B.score : null;

    aCell.textContent = aRaw ?? "-";
    bCell.textContent = bRaw ?? "-";

    if (aRaw!=null && bRaw!=null){
      const pct = Math.round(tkMatch(aRaw*sA, bRaw*sB));
      mCell.textContent = `${pct}%`;
    } else {
      mCell.textContent = "-";
    }
  });

  tkEnableDownload();
}

/* ---------- unified upload path (A and B both use this) ---------- */
async function tkHandleUpload(file, which){
  if (!file){ tkSetStatus(which,"No file selected",false); tkEnableDownload(); return; }
  try{
    const text = await file.text();
    const json = tkSafeParse(text);
    if (!json){ tkSetStatus(which,"Invalid JSON",false); tkEnableDownload(); return; }

    const items = tkNormalize(json);
    if (!items.length){ tkSetStatus(which,"No recognizable items",false); tkEnableDownload(); return; }

    if (which==="A") window.tkA = items; else window.tkB = items;
    tkSetStatus(which, `Loaded ${items.length} items`);
    tkUpdate();
    tkSetError(null);
  }catch(err){
    tkSetStatus(which, `Read failed: ${err.message}`, false);
  }finally{
    tkEnableDownload();
  }
}

/* ---------- wire up: A = input; B = button opens hidden input ---------- */
(function tkWire(){
  // ensure table rows have ids now
  tkEnsureRowIds();

  const inA = document.getElementById("uploadA");
  const inB = document.getElementById("uploadB");
  const btnB = document.getElementById("loadPartnerBtn"); // your visible button

  if (inA) inA.addEventListener("change", e=>{
    if (e.target.files?.[0]) tkHandleUpload(e.target.files[0], "A");
  });

  if (btnB && inB){
    btnB.addEventListener("click", ()=>{
      inB.value = "";            // important: allows selecting the same file again
      inB.click();
    });
    inB.addEventListener("change", e=>{
      if (e.target.files?.[0]) tkHandleUpload(e.target.files[0], "B");
    });
    // in case you programmatically set files
    inB.addEventListener("input", e=>{
      if (e.target.files?.[0]) tkHandleUpload(e.target.files[0], "B");
    });
  }
})();
</script>

</body>
</html>

