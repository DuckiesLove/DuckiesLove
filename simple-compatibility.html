<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Compatibility Module</title>
</head>
<body>
<!-- ========== Partner A + Partner B (robust load + auto row IDs) ========== -->
<div id="compat-ui" style="margin:.75rem 0 1rem">
  <div id="globalError" style="display:none;color:#ff6b6b;margin:.5rem 0;"></div>

  <div style="display:flex;gap:1rem;flex-wrap:wrap;align-items:center">
    <label><strong>Survey A (Partner A):</strong>
      <input id="uploadA" type="file" accept=".json,application/json" />
    </label>
    <span id="statusA" style="font-size:.9rem;color:#8aa">No file</span>
  </div>

  <div style="display:flex;gap:1rem;flex-wrap:wrap;align-items:center;margin-top:.5rem">
    <button id="loadPartnerBtn" type="button">Load Partner Survey</button>
    <input id="uploadB" type="file" accept=".json,application/json" hidden />
    <span id="statusB" style="font-size:.9rem;color:#8aa">No file</span>
  </div>

  <button id="downloadPdfBtn" disabled style="margin-top:.75rem">Download Compatibility Report</button>
</div>

<table id="compatibilityTable" border="1" style="margin-top:1em; border-collapse:collapse; min-width:360px;">
  <thead>
    <tr>
      <th>Category</th>
      <th>Partner A</th>
      <th>Match</th>
      <th>Flag</th>
      <th>Partner B</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>
<script>
/* ---------- tiny UI helpers ---------- */
function tkSetStatus(which, msg, ok=true){
  const el = document.getElementById(which==="A" ? "statusA" : "statusB");
  if (el){ el.textContent = msg; el.style.color = ok ? "#59ff9b" : "#ff6b6b"; }
}
function tkSetError(msg){
  const el = document.getElementById("globalError");
  if (!el) return;
  if (!msg){ el.style.display="none"; el.textContent=""; return; }
  el.style.display="block"; el.textContent = msg;
}
function tkEnableDownload(){
  const btn = document.getElementById("downloadPdfBtn");
  if (!btn) return;
  btn.disabled = !(window.tkA?.length > 0 && window.tkB?.length > 0);
}

/* ---------- make every row addressable: add data-kink-id = slug(first-cell) ---------- */
function tkSlug(s){
  return String(s||"")
    .toLowerCase()
    .normalize("NFKD").replace(/[\u0300-\u036f]/g,"")  // strip accents
    .replace(/['’]/g,"")                                // drop apostrophes
    .replace(/[^a-z0-9]+/g,"_")                         // non-alnum -> underscore
    .replace(/^_+|_+$/g,"");                            // trim underscores
}

/* ---------- Fetch shared kink labels (for nicer Category text) ---------- */
const TK_UNION_PATHS = [
  '/data/kinks.json',
  '/kinksurvey/data/kinks.json',
  '/kinksurvey/kinks.json',
  '/kinks.json',
  '/assets/kinks.json'
];
let tkLabelPromise = null;
let tkKeyLabelMap = null;

function tkSniffExistingUnion(){
  if (typeof window !== 'object') return null;
  const candidates = ['KINKS_UNION','union','rows','kinks'];
  for (const name of candidates){
    const v = window[name];
    if (Array.isArray(v) && v.length && typeof v[0] === 'object' && 'key' in v[0]) return v;
  }
  try {
    for (const v of Object.values(window)){
      if (Array.isArray(v) && v.length && typeof v[0] === 'object' && 'key' in v[0]) return v;
    }
  } catch(_){}
  return null;
}

async function tkFetchUnion(){
  const existing = tkSniffExistingUnion();
  if (existing) return existing;
  for (const url of TK_UNION_PATHS){
    try{
      const res = await fetch(url, { cache: 'no-store' });
      if (!res?.ok) continue;
      const json = await res.json();
      if (Array.isArray(json)) return json;
      if (Array.isArray(json?.union)) return json.union;
      if (Array.isArray(json?.rows))  return json.rows;
      if (Array.isArray(json?.kinks)) return json.kinks;
    }catch(_){/* ignore individual failures */}
  }
  return [];
}

function tkBuildLabelMap(union){
  const map = new Map();
  const store = (key, label)=>{
    if (!key) return;
    const cleanKey = String(key).trim();
    if (!cleanKey) return;
    const finalLabel = label || cleanKey;
    map.set(cleanKey, finalLabel);
    map.set(tkSlug(cleanKey), finalLabel);
  };
  union.forEach(row=>{
    if (!row || typeof row !== 'object') return;
    const label = String(row.label ?? row.name ?? row.text ?? '').trim();
    const key = String(row.key ?? row.id ?? row.slug ?? '').trim();
    if (key) store(key, label || key);
    if (label) store(label, label);
    if (Array.isArray(row.aliases)) row.aliases.forEach(alias=>store(alias, label || key));
  });
  return map;
}

async function tkEnsureLabelMap(){
  if (tkLabelPromise) return tkLabelPromise;
  tkLabelPromise = (async()=>{
    try{
      const union = await tkFetchUnion();
      tkKeyLabelMap = tkBuildLabelMap(union);
      if (typeof window === 'object') window.tkKeyLabelMap = tkKeyLabelMap;
      tkRefreshVisibleLabels();
    }catch(err){
      console.warn('[TK] Failed to fetch union labels:', err);
      tkKeyLabelMap = new Map();
    }
    return tkKeyLabelMap;
  })();
  return tkLabelPromise;
}

function tkLabelFor(id, fallback){
  const txt = String(id ?? '').trim();
  if (!txt) return fallback;
  const map = tkKeyLabelMap;
  if (!map) return fallback;
  const fb = String(fallback ?? '').trim();
  return map.get(txt) || map.get(tkSlug(txt)) || map.get(fb) || map.get(tkSlug(fb)) || fallback;
}

function tkApplyLabels(items){
  if (!Array.isArray(items) || !tkKeyLabelMap) return;
  items.forEach(item=>{
    if (!item || !item.id) return;
    const nice = tkLabelFor(item.id, item.label);
    if (nice) item.label = nice;
  });
}

function tkRefreshVisibleLabels(){
  if (!tkKeyLabelMap) return;
  document.querySelectorAll('tbody tr[data-kink-id]').forEach(tr=>{
    const td = tr.querySelector('td');
    if (!td) return;
    const id = tr.getAttribute('data-kink-id');
    const current = td.textContent.trim();
    const nice = tkLabelFor(id, current);
    if (nice && nice !== current) td.textContent = nice;
  });
}

function tkEnsureRowIds(){
  const rows = document.querySelectorAll("table tbody tr");
  rows.forEach(tr=>{
    if (tr.hasAttribute("data-kink-id")) return;
    const td = tr.querySelector("td");
    if (!td) return;
    const id = tkSlug(td.textContent.trim());
    if (id) tr.setAttribute("data-kink-id", id);
  });
}

/* ---------- JSON parsing + normalization ---------- */
function tkSafeParse(text){
  try{
    if (text && text.charCodeAt(0)===0xFEFF) text = text.slice(1);  // strip BOM
    text = text.replace(/[\u201C\u201D]/g,'"').replace(/[\u2018\u2019]/g,"'"); // smart quotes
    text = text.replace(/,\s*([\]}])/g,"$1"); // trailing commas
    return JSON.parse(text);
  }catch(e){ return null; }
}
function tkCoerceScore(v){
  if (typeof v === "number" && Number.isFinite(v)) return v;
  if (typeof v === "string"){
    const t = v.trim();
    if (/^\d+%$/.test(t)) return Number(t.slice(0,-1))/20;     // 80% -> 4.0
    if (/^\d+\s*\/\s*\d+$/.test(t)) return Number(t.split("/")[0]); // "4/5" -> 4
    const n = Number(t); if (!Number.isNaN(n)) return n;
  }
  if (v && typeof v === "object"){
    const s = v.rating ?? v.score ?? v.value ?? v.val ?? v.points ?? v.level;
    return tkCoerceScore(s);
  }
  return null;
}
/* Return array of {id,label,score} where id = slug(label) */
function tkNormalize(json){
  // object map: {"Label": 5, ...}
  if (json && typeof json === "object" && !Array.isArray(json)){
    const out = [];
    for (const [label,val] of Object.entries(json)){
      const score = tkCoerceScore(val);
      if (typeof score === "number"){
        out.push({ id: tkSlug(label), label, score });
      }
    }
    return out;
  }
  // array-ish
  let rows = [];
  if (Array.isArray(json)) rows = json;
  else if (Array.isArray(json?.items)) rows=json.items;
  else if (Array.isArray(json?.answers)) rows=json.answers;
  else if (Array.isArray(json?.data)) rows=json.data;
  else if (json && typeof json === "object"){
    const firstArr = Object.values(json).find(v=>Array.isArray(v));
    if (Array.isArray(firstArr)) rows = firstArr;
  }
  const NAME = ["label","name","title","id","key","slug"];
  const SCORE = ["rating","score","value","val","points","level"];
  const out=[];
  for (const row of rows||[]){
    if (!row || typeof row !== "object") continue;
    const cand = ["","item","question","meta","data"].map(p=>p?row[p]:row).find(v=>v && typeof v==="object") || row;
    let label = null; for (const k of NAME) if (k in cand){ label = cand[k]; break; }
    label = (typeof label==="string" ? label : String(label??"")).trim();
    if (!label) continue;
    let s = null; for (const k of SCORE) if (k in cand){ s = cand[k]; break; }
    const score = tkCoerceScore(s);
    if (typeof score === "number") out.push({ id: tkSlug(label), label, score });
  }
  return out;
}

/* ---------- scale + match + table injection ---------- */
function tkDetectScale(items){
  const vals = items.map(i=>i.score).filter(n=>typeof n==="number");
  if (!vals.length) return 1;
  const max = Math.max(...vals), min = Math.min(...vals);
  if (max<=5 && min>=0) return 1;
  if (max<=1 && min>=0) return 5;
  if (max<=7)  return 5/7;
  if (max<=10) return 5/10;
  if (max<=100) return 5/100;
  return 5/Math.max(5,max);
}
function tkMatch(a5,b5){ const d=Math.abs(a5-b5); return Math.max(0, 100 - (d/5)*100); }

function tkFlag(match, a, b){
  if (match >= 90) return '⭐';
  const high = v => typeof v === 'number' && v >= 4;
  const missing = v => v === null || v === undefined || v === 0;
  if (match <= 50 || ((high(a) || high(b)) && (missing(a) || missing(b)))) return '🚩';
  return '';
}

function tkEnsureCells(tr){
  if (!tr.querySelector('[data-cell="A"]'))    tr.insertCell(1).setAttribute("data-cell","A");
  if (!tr.querySelector('[data-cell="Match"]')) tr.insertCell(2).setAttribute("data-cell","Match");
  if (!tr.querySelector('[data-cell="Flag"]'))  tr.insertCell(3).setAttribute("data-cell","Flag");
  if (!tr.querySelector('[data-cell="B"]'))     tr.insertCell(4).setAttribute("data-cell","B");
}
function tkRebuildTableFromUnion(){
  const tbody = document.querySelector("table tbody");
  if (!tbody) return;
  const union = new Map(); // id -> label
  (window.tkA||[]).forEach(i=>union.set(i.id, tkLabelFor(i.id, i.label)));
  (window.tkB||[]).forEach(i=>union.set(i.id, tkLabelFor(i.id, i.label)));
  const sorted = [...union.entries()].sort((a,b)=> a[1].localeCompare(b[1]));
  tbody.innerHTML="";
  for (const [id,label] of sorted){
    const tr = document.createElement("tr");
    tr.setAttribute("data-kink-id", id);
    const td = document.createElement("td"); td.textContent = tkLabelFor(id, label);
    tr.appendChild(td);
    const tdA=document.createElement("td"); tdA.setAttribute("data-cell","A"); tdA.textContent="-";
    const tdM=document.createElement("td"); tdM.setAttribute("data-cell","Match"); tdM.textContent="-";
    const tdF=document.createElement("td"); tdF.setAttribute("data-cell","Flag"); tdF.textContent="";
    const tdB=document.createElement("td"); tdB.setAttribute("data-cell","B"); tdB.textContent="-";
    tr.append(tdA,tdM,tdF,tdB);
    tbody.appendChild(tr);
  }
  tkRefreshVisibleLabels();
}

function tkUpdate(){
  tkEnsureRowIds();
  tkRefreshVisibleLabels();

  // If table has no identifiable rows yet but we have data, build from data
  if (!document.querySelector('tbody tr[data-kink-id]') && ((window.tkA&&tkA.length) || (window.tkB&&tkB.length))){
    tkRebuildTableFromUnion();
  }

  const aMap = new Map((window.tkA||[]).map(i=>[i.id,i]));
  const bMap = new Map((window.tkB||[]).map(i=>[i.id,i]));
  const sA = tkDetectScale(window.tkA||[]);
  const sB = tkDetectScale(window.tkB||[]);

  // show what couldn't be matched
  const tbody = document.querySelector("table tbody");
  const haveIds = new Set(Array.from(tbody.querySelectorAll('tr[data-kink-id]')).map(tr=>tr.getAttribute('data-kink-id')));
  const aUnmatched = (window.tkA||[]).filter(i=>!haveIds.has(i.id)).slice(0,5);
  const bUnmatched = (window.tkB||[]).filter(i=>!haveIds.has(i.id)).slice(0,5);
  if (aUnmatched.length || bUnmatched.length){
    console.warn("Unmatched A:", aUnmatched);
    console.warn("Unmatched B:", bUnmatched);
  }

  document.querySelectorAll('tbody tr[data-kink-id]').forEach(tr=>{
    const id = tr.getAttribute('data-kink-id');
    tkEnsureCells(tr);
    const labelCell = tr.querySelector('td');
    if (labelCell){
      const current = labelCell.textContent.trim();
      const nice = tkLabelFor(id, current);
      if (nice && nice !== current) labelCell.textContent = nice;
    }

    const A = aMap.get(id), B = bMap.get(id);
    const aCell = tr.querySelector('[data-cell="A"]');
    const bCell = tr.querySelector('[data-cell="B"]');
    const mCell = tr.querySelector('[data-cell="Match"]');
    const fCell = tr.querySelector('[data-cell="Flag"]');

    const aRaw = (typeof A?.score==="number") ? A.score : null;
    const bRaw = (typeof B?.score==="number") ? B.score : null;

    aCell.textContent = aRaw ?? "-";
    bCell.textContent = bRaw ?? "-";

    if (aRaw!=null && bRaw!=null){
      const a5 = aRaw*sA;
      const b5 = bRaw*sB;
      const pct = Math.round(tkMatch(a5, b5));
      mCell.textContent = `${pct}%`;
      fCell.textContent = tkFlag(pct, a5, b5);
    } else {
      mCell.textContent = "-";
      fCell.textContent = '';
    }
  });

  tkEnableDownload();
}

/* ---------- unified upload path (A and B both use this) ---------- */
async function tkHandleUpload(file, which){
  if (!file){ tkSetStatus(which,"No file selected",false); tkEnableDownload(); return; }
  try{
    const text = await file.text();
    const json = tkSafeParse(text);
    if (!json){ tkSetStatus(which,"Invalid JSON",false); tkEnableDownload(); return; }

    await tkEnsureLabelMap().catch(()=>null);
    const items = tkNormalize(json);
    if (!items.length){ tkSetStatus(which,"No recognizable items",false); tkEnableDownload(); return; }
    tkApplyLabels(items);

    if (which==="A") window.tkA = items; else window.tkB = items;
    tkSetStatus(which, `Loaded ${items.length} items`);
    tkUpdate();
    tkSetError(null);
  }catch(err){
    tkSetStatus(which, `Read failed: ${err.message}`, false);
  }finally{
    tkEnableDownload();
  }
}

// kick off label fetch in the background
tkEnsureLabelMap().catch(()=>null);

/* ---------- wire up: A = input; B = button opens hidden input ---------- */
(function tkWire(){
  // ensure table rows have ids now
  tkEnsureRowIds();

  const inA = document.getElementById("uploadA");
  const inB = document.getElementById("uploadB");
  const btnB = document.getElementById("loadPartnerBtn"); // your visible button

  if (inA) inA.addEventListener("change", e=>{
    if (e.target.files?.[0]) tkHandleUpload(e.target.files[0], "A");
  });

  if (btnB && inB){
    btnB.addEventListener("click", ()=>{
      inB.value = "";            // important: allows selecting the same file again
      inB.click();
    });
    inB.addEventListener("change", e=>{
      if (e.target.files?.[0]) tkHandleUpload(e.target.files[0], "B");
    });
    // in case you programmatically set files
    inB.addEventListener("input", e=>{
      if (e.target.files?.[0]) tkHandleUpload(e.target.files[0], "B");
    });
  }
})();
</script>

<!--
TALK KINK • FINAL ONE-BOX EXPORTER
Fixes shown issue (“&” in Flag column and duplicated Category text in PDF).
- Uses your EXISTING download button: #downloadBtn or #downloadPdfBtn or [data-download-pdf]
- Reads the visible table, but IGNORES the table’s Match/Flag cells and RECOMPUTES them:
    Match = % similarity from Partner A vs Partner B (0–5 scale)
    Flag  = ★ (>=90%), ⚑ (>=60%), 🚩 (<=30%), otherwise blank
- Dedupes repeated category text like “...scene ...scene”
- Falls back to window.partnerAData / window.partnerBData if table rows aren’t present
- Loads jsPDF + AutoTable if missing

Paste this WHOLE block at the very end of the page (after your table renders).
-->
<script>
(function () {
  /* ===== libs ===== */
  function loadScript(src){return new Promise((res,rej)=>{const s=document.createElement('script');s.src=src;s.onload=res;s.onerror=()=>rej(new Error('Failed to load '+src));document.head.appendChild(s);});}
  async function ensureLibs(){
    if(!(window.jspdf && window.jspdf.jsPDF)){
      await loadScript("https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js");
    }
    const hasAuto=(window.jspdf&&window.jspdf.autoTable)||(window.jsPDF&&window.jsPDF.API&&window.jsPDF.API.autoTable);
    if(!hasAuto){
      await loadScript("https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.3/jspdf.plugin.autotable.min.js");
    }
  }
  function runAutoTable(doc, opts){
    if(typeof doc.autoTable==="function") return doc.autoTable(opts);
    if(window.jspdf && typeof window.jspdf.autoTable==="function") return window.jspdf.autoTable(doc, opts);
    throw new Error("jsPDF-AutoTable not available");
  }

  /* ===== helpers ===== */
  const THRESH={star:90, flag:60, low:30};
  const ICON={star:"★", flag:"⚑", low:"🚩", blank:""};
  const toNum=v=>{const n=Number(String(v??"").trim());return Number.isFinite(n)?n:null;};
  const pct=(a,b)=>{const A=toNum(a),B=toNum(b); if(A==null||B==null) return null; return Math.round(100-(Math.abs(A-B)/5)*100);};
  const flagFor=p=>p==null?ICON.blank:(p>=THRESH.star?ICON.star:(p>=THRESH.flag?ICON.flag:(p<=THRESH.low?ICON.low:ICON.blank)));
  const tidy=s=>(s||"").replace(/\s+/g," ").trim();
  // if a cell accidentally contains the same text twice concatenated (“foofoo”), cut it in half:
  const dedupeDupedText=s=>{const t=tidy(s); const L=t.length; if(L&&L%2===0){const h=L/2; if(t.slice(0,h)===t.slice(h)) return t.slice(0,h);} return t;};

  /* ===== table discovery & row extraction ===== */
  function getTable(){
    return document.getElementById("compatibilityTable")
        || document.querySelector('table[aria-label*="compatibility" i]')
        || document.querySelector("table");
  }
  function headerIndex(table){
    let ths=[...table.querySelectorAll("thead th")];
    if(!ths.length) ths=[...table.querySelectorAll("tr th")];
    const labs=ths.map(th=>tidy(th.textContent).toLowerCase());
    // defaults if not found
    const idx={cat:0, A:1, B:4};
    const f=(k)=>labs.findIndex(t=>t.includes(k));
    const c=f("category"); if(c>-1) idx.cat=c;
    const a=f("partner a"); if(a>-1) idx.A=a;
    const b=f("partner b"); if(b>-1) idx.B=b;
    return idx;
  }
  function rowsFromTable(){
    const table=getTable(); if(!table) return [];
    const idx=headerIndex(table);
    let trs=[...table.querySelectorAll("tbody tr")];
    if(!trs.length) trs=[...table.querySelectorAll("tr")].filter(tr=>tr.closest("table")===table && tr.querySelectorAll("td").length);
    const out=[];
    for(const tr of trs){
      const tds=[...tr.querySelectorAll("td")]; if(!tds.length) continue;
      const catCell = tds[idx.cat] || tds[0];
      const aCell   = tr.querySelector('td[data-cell="A"]') || tds[idx.A] || tds[1];
      const bCell   = tr.querySelector('td[data-cell="B"]') || tds[idx.B] || tds[tds.length-1];

      const cat = dedupeDupedText(catCell?.textContent || tr.getAttribute("data-kink-id") || "");
      const A   = toNum(aCell?.textContent);
      const B   = toNum(bCell?.textContent);
      const P   = pct(A,B);

      out.push([ cat || "—", (A==null?"—":A), (P==null?"—":`${P}%`), flagFor(P), (B==null?"—":B) ]);
    }
    return out;
  }

  /* ===== memory fallback ===== */
  function rowsFromMemory(){
    const A=(window.partnerAData?.items)||(Array.isArray(window.partnerAData)?window.partnerAData:null);
    const B=(window.partnerBData?.items)||(Array.isArray(window.partnerBData)?window.partnerBData:null);
    if(!A && !B) return [];
    const mA=new Map((A||[]).map(i=>[(i.id||i.label),i]));
    const mB=new Map((B||[]).map(i=>[(i.id||i.label),i]));
    const keys=new Map(); (A||[]).forEach(i=>keys.set(i.id||i.label,i.label||i.id)); (B||[]).forEach(i=>keys.set(i.id||i.label,i.label||i.id));
    const out=[];
    for(const [id,label] of keys){
      const a=mA.get(id), b=mB.get(id);
      const Ar=toNum(a?.score), Br=toNum(b?.score);
      const P=pct(Ar,Br);
      out.push([label||id||"—",(Ar??"—"),(P==null?"—":`${P}%`),flagFor(P),(Br??"—")]);
    }
    return out;
  }

  /* ===== export ===== */
  async function exportPDF(ev){
    ev?.preventDefault?.();
    try{
      await ensureLibs();
      const { jsPDF }=window.jspdf;

      let rows=rowsFromTable();
      if(!rows.length) rows=rowsFromMemory();

      if(!rows.length){ alert("No data rows found to export. Load a survey or ensure the table is visible."); return; }

      const doc=new jsPDF({orientation:"landscape", unit:"pt", format:"a4"});
      doc.setFontSize(20);
      doc.text("Talk Kink • Compatibility Report", doc.internal.pageSize.width/2, 48, {align:"center"});

      runAutoTable(doc, {
        head: [["Category","Partner A","Match","Flag","Partner B"]],
        body: rows,
        startY: 70,
        styles:{ fontSize: 11, cellPadding: 6, overflow:"linebreak" },
        headStyles:{ fillColor:[0,0,0], textColor:[255,255,255], fontStyle:"bold" },
        columnStyles:{
          0:{ halign:"left",   cellWidth: 560 },
          1:{ halign:"center", cellWidth: 80  },
          2:{ halign:"center", cellWidth: 90  },
          3:{ halign:"center", cellWidth: 60  },
          4:{ halign:"center", cellWidth: 80  }
        }
      });

      doc.save("compatibility-report.pdf");
    }catch(err){
      console.error("[PDF] Export failed:", err);
      alert("PDF export failed: " + err.message);
    }
  }

  /* ===== bind to your existing button ===== */
  function bind(){
    const btn=document.querySelector("#downloadBtn")||document.querySelector("#downloadPdfBtn")||document.querySelector("[data-download-pdf]");
    if(!btn){ console.warn("[PDF] Download button not found (#downloadBtn, #downloadPdfBtn, or [data-download-pdf])."); return; }
    btn.removeEventListener("click", exportPDF);
    btn.addEventListener("click", exportPDF);
    console.log("[PDF] Exporter bound:", btn);
  }
  if(document.readyState==="loading") document.addEventListener("DOMContentLoaded", bind); else bind();
  new MutationObserver(bind).observe(document.documentElement,{childList:true,subtree:true});
})();
</script>

<!-- ✅ 1) Add this *once* near the end of every page that was freezing (before </body>) -->
<script>
/* ---------- TalkKink Safe Bootstrap (drop-in) ---------- */
(function () {
  const LOG = (...a) => console.log("[TK-SAFE]", ...a);

  /* A. QUICK SANITY CHECKS — find & warn about merge markers (these often lock pages) */
  try {
    const html = document.documentElement.innerHTML;
    const HEAD = '<'.repeat(7);
    const SEP = '='.repeat(7);
    const TAIL = '>'.repeat(7);
    if (html.includes(HEAD) && html.includes(SEP) && html.includes(TAIL)) {
      const conflictPattern = new RegExp(`${HEAD}[\s\S]*?${SEP}[\s\S]*?${TAIL}`);
      if (conflictPattern.test(html)) {
        console.warn("[TK-SAFE] Merge conflict markers detected in DOM. Remove them to avoid broken JS/CSS.");
      }
    }
  } catch (_) {}

  /* B. ONE-TIME INIT GUARD (prevents duplicate event bind/render loops) */
  if (window.__TK_INITED__) {
    LOG("Init skipped: already initialized.");
    return;
  }
  window.__TK_INITED__ = true;

  /* C. SAFE-MODE FLAGS (use ?safe=1 or ?nopdf=1 or ?noscore=1 to bypass heavy work) */
  const params = new URLSearchParams(location.search);
  const SAFE_MODE  = params.has("safe");
  const NO_PDF     = SAFE_MODE || params.has("nopdf");
  const NO_SCORE   = SAFE_MODE || params.has("noscore");

  if (SAFE_MODE) LOG("SAFE MODE ON: skipping scoring/render and lazy-loading libraries.");

  /* D. SMALL UTILITIES */
  const byId = (id) => document.getElementById(id);
  function once(el, type, handler, opts) {
    // prevent stacked duplicate listeners after HMR/partials
    el && el.addEventListener(type, function f(e) {
      el.removeEventListener(type, f, opts);
      handler(e);
    }, opts);
  }
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      if (document.querySelector(`script[src="${src}"]`)) return resolve();
      const s = document.createElement("script");
      s.src = src; s.async = true; s.defer = true;
      s.onload = resolve;
      s.onerror = () => reject(new Error("Failed to load " + src));
      document.head.appendChild(s);
    });
  }
  function idle(fn) {
    // yield back to the browser to keep UI responsive
    return (window.requestIdleCallback || ((cb)=>setTimeout(cb,0)))(fn);
  }

  /* E. LAZY LOADERS FOR HEAVY LIBS (loaded only on click) */
  async function ensureJsPDF() {
    if (!(window.jspdf && window.jspdf.jsPDF)) {
      await loadScript("https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js");
    }
  }
  async function ensureAutoTable() {
    // Only after jsPDF UMD maps window.jspdf.jsPDF
    await ensureJsPDF();
    const hasAT = (window.jspdf && window.jspdf.jsPDF && window.jspdf.jsPDF.API && window.jspdf.jsPDF.API.autoTable)
               || (window.jspdf && window.jspdf.autoTable);
    if (!hasAT) {
      await loadScript("https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.3/jspdf.plugin.autotable.min.js");
    }
  }

  /* F. DEFENSIVE BINDINGS (buttons used across pages) */
  idle(() => {
    // PDF buttons (compatibility, IKA, etc.)
    const dl1 = byId("downloadBtn");
    const dl2 = byId("downloadPdfBtn");
    const anyDownload = dl1 || dl2;

    if (anyDownload) {
      const handler = async (e) => {
        e.preventDefault();
        if (NO_PDF) { alert("PDF disabled (safe mode). Add ?safe=0 or remove ?nopdf."); return; }
        try {
          // Lazy load heavy libs only now
          await ensureAutoTable();
          // Yield once more before heavy export:
          await new Promise(r => setTimeout(r, 0));
          // Call your existing exporter (must be defined elsewhere)
          if (typeof window.TKPDF_export === "function") {
            await window.TKPDF_export();
          } else if (typeof window.TKPDF_forceDark === "function") {
            await window.TKPDF_forceDark();
          } else if (typeof window.exportIKAPdf === "function") {
            await window.exportIKAPdf();
          } else {
            alert("Export function not found. Expected TKPDF_export/TKPDF_forceDark/exportIKAPdf.");
          }
        } catch (err) {
          console.error("[TK-SAFE] PDF export failed:", err);
          alert("PDF export failed: " + (err?.message || err));
        }
      };

      // Bind once to whichever exists
      if (dl1) once(dl1, "click", handler);
      if (dl2) once(dl2, "click", handler);
      LOG("Bound PDF button(s).");
    }

    // File upload styled label (IKA)
    const fileInput = byId("ikaFile");
    const fileLabel = document.querySelector('label[for="ikaFile"]');
    if (fileInput && fileLabel) {
      once(fileLabel, "click", () => fileInput.click());
      LOG("Bound Upload Survey label→input.");
    }
  });

  /* G. STOP RUNNING EXPENSIVE WORK ON LOAD (scoring/rendering) */
  // Wrap your page’s auto-render or scoring in this gate:
  window.TK_canRunHeavy = function () {
    if (SAFE_MODE) return false;
    // Avoid running more than once
    if (window.__TK_HEAVY_RAN__) return false;
    window.__TK_HEAVY_RAN__ = true;
    return true;
  };

  // Example usage for your pages (leave here; your code can call it):
  // if (window.TK_canRunHeavy()) {
  //   // run scoring/render here or schedule with idle(...)
  //   idle(() => window.renderResults && window.renderResults());
  // }

  /* H. GLOBAL CATCH FOR ACCIDENTAL LONG TASKS */
  // If something still locks the UI, advise safe mode.
  window.addEventListener("error", (e) => {
    console.warn("[TK-SAFE] Window error:", e.message);
  });
})();
</script>
<!-- ---------- End Safe Bootstrap ---------- -->
</body>
</html>

