<!-- TalkKink â€“ Question Glow + Guard + 0â€“5 Scale (wide layout) -->
<script>
/* ===========================================================
   TalkKink â€“ Question Glow + Guard + 0â€“5 Scale (wide layout)
   Paste into Codex once. Works across themes, cards, Next/Back.
   Hotkey: Alt+G to re-run.
   =========================================================== */
(function () {
  if (window.__tkQuestionGuardWide) return;
  window.__tkQuestionGuardWide = true;

  const SURVEY_UI = window.SURVEY_UI ?? (window.SURVEY_UI = {});
  const SHOW_INLINE_SCORE_CARD = SURVEY_UI.showInlineScoreCard ?? true;

  // --- CSS (once) ---
  if (!document.getElementById('tkQGuardCSSv3')) {
    const style = document.createElement('style');
    style.id = 'tkQGuardCSSv3';
    style.textContent = `
      .tk-question-card {
        position: relative;
        border-radius: 16px;
        background: rgba(10,12,16,.88);
        border: 1px solid rgba(120,200,255,.22);
        box-shadow:
          0 0 0 1px rgba(120,200,255,.18) inset,
          0 12px 30px rgba(0,0,0,.45),
          0 0 20px rgba(60,170,255,.28);
        padding: clamp(18px, 2.6vw, 28px);
        color: #e9f4ff;
      }
      .tk-question-layout,
      .tk-question-card > .tk-question-header {
        display: flex;
        flex-direction: column;
        gap: clamp(14px, 2vw, 22px);
      }
      .tk-question-header {
        gap: 6px;
      }
      .tk-question-meta {
        text-transform: uppercase;
        letter-spacing: .18em;
        font-size: .75rem;
        color: rgba(180,220,255,.72);
      }
      .tk-question-title {
        margin: 0;
        font-size: clamp(1.2rem, 2.6vw, 1.7rem);
        font-weight: 700;
        letter-spacing: .02em;
        color: #f0f8ff;
        text-shadow: 0 0 12px rgba(90,190,255,.25);
      }
      .tk-question-prompt {
        margin: 0;
        color: rgba(215,232,255,.86);
        font-size: clamp(.98rem, 2vw, 1.05rem);
        line-height: 1.45;
      }
      .tk-rating-row {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }
      .tk-rating-wrap {
        display: grid;
        gap: clamp(14px, 2vw, 22px);
        margin-top: 6px;
      }
      .tk-rating-wrap > * {
        min-width: 0;
      }
      .tk-rating-title {
        font-size: .82rem;
        letter-spacing: .22em;
        text-transform: uppercase;
        color: rgba(160,220,255,.82);
        font-weight: 700;
        text-shadow: 0 0 12px rgba(90,190,255,.3);
      }
      .tk-rating-row button {
        border: 1px solid rgba(120,200,255,.28);
        background: rgba(12,18,26,.78);
        color: #e3f3ff;
        font-weight: 700;
        min-width: 48px;
        padding: .55rem .85rem;
        border-radius: 12px;
        cursor: pointer;
        user-select: none;
        transition: transform .1s ease, box-shadow .15s ease, border-color .15s ease, background .15s ease;
      }
      .tk-rating-row button:hover {
        transform: translateY(-1px);
      }
      .tk-rating-row button:focus-visible {
        outline: 2px solid rgba(100,200,255,.85);
        outline-offset: 2px;
      }
      .tk-rating-row button.is-active {
        background: rgba(16,24,36,.95);
        border-color: rgba(120,220,255,.55);
        box-shadow:
          0 0 0 1px rgba(120,220,255,.35) inset,
          0 0 20px rgba(70,180,255,.35);
      }
      #tk-score-card,
      .tk-score-card {
        border-radius: 14px;
        background: rgba(12,16,22,.92);
        border: 1px solid rgba(120,200,255,.22);
        box-shadow:
          0 0 0 1px rgba(120,200,255,.15) inset,
          0 0 18px rgba(60,170,255,.22);
        padding: clamp(16px, 2.2vw, 22px);
        display: grid;
        gap: 14px;
        color: #d9eaff;
      }
      .tk-score-card--inline {
        margin-top: 16px;
        border-radius: 12px;
        box-shadow:
          0 0 0 1px rgba(0, 200, 255, 0.25),
          0 10px 24px rgba(0, 0, 0, 0.35);
        background: rgba(8, 12, 16, 0.75);
        backdrop-filter: blur(6px);
      }
      .tk-score-title {
        text-transform: uppercase;
        font-size: .85rem;
        letter-spacing: .22em;
        color: rgba(140,220,255,.85);
        font-weight: 700;
      }
      .tk-score-card--inline .tk-score-title,
      .tk-score-title {
        margin: 0 0 8px 0 !important;
        font-weight: 700;
        letter-spacing: 0.25px;
        color: var(--accent, #bfefff);
        text-shadow: 0 0 18px rgba(0, 230, 255, 0.35);
      }
      .tk-score-card .tk-row {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 12px;
        align-items: flex-start;
      }
      .tk-score-card .dot {
        display: grid;
        place-items: center;
        font-weight: 800;
        width: 32px;
        height: 32px;
        border-radius: 999px;
        color: #00121a;
        text-shadow: 0 1px 2px rgba(0,0,0,.35);
        box-shadow: 0 0 12px currentColor;
      }
      .tk-score-card .dot.blue { background: #53c0ff; }
      .tk-score-card .dot.red { background: #ff6b81; }
      .tk-score-card .dot.yellow {
        background: #ffd65a;
        color: #3f2c00;
      }
      .tk-score-card .dot.green {
        background: #58e0a6;
        color: #003926;
      }
      .tk-score-card strong { display: block; margin-bottom: 2px; }
      @media (min-width: 768px) {
        .tk-rating-wrap {
          grid-template-columns: minmax(0, 1.15fr) minmax(0, .95fr);
          grid-template-areas:
            "title score"
            "row score";
          align-items: start;
        }
        .tk-rating-title { grid-area: title; }
        #tk-rating-row { grid-area: row; }
        #tk-score-card { grid-area: score; }
      }
      .tk-hidden { display: none !important; }
      #scoreGuideAside,
      .score-aside,
      aside[aria-label*="Question Guard"],
      aside:has(h2:matches-css(text, "Question Guard")) {
        display: none !important;
      }
    `;
    document.head.appendChild(style);
  }

  // --- helpers you may already have ---
  function tkRenderScale(root, onPick) {
    if (!root) return;
    const frag = document.createDocumentFragment();
    [0, 1, 2, 3, 4, 5].forEach((n) => {
      const b = document.createElement('button');
      b.type = 'button';
      b.textContent = String(n);
      if (typeof onPick === 'function') {
        b.onclick = () => onPick(n);
      }
      frag.appendChild(b);
    });
    root.innerHTML = '';
    root.appendChild(frag);
  }

  const TK_GUARD_WIDE = [
    { dot: 'blue',   label: '0 â€” Brain did a cartwheel',          desc: 'skipped for now ðŸ˜…' },
    { dot: 'red',    label: '1 â€” Hard Limit',                      desc: 'full stop / non-negotiable' },
    { dot: 'yellow', label: '2 â€” Soft Limit â€” willing to try',     desc: 'with strong boundaries, safety checks, and aftercare planned' },
    { dot: 'green',  label: '3 â€” Curious / context-dependent',     desc: 'okay with discussion, mood, and trust; needs clear negotiation' },
    { dot: 'green',  label: '4 â€” Comfortable / enjoy',             desc: 'generally a yes; normal precautions and check-ins' },
    { dot: 'green',  label: '5 â€” Favorite / enthusiastic yes',     desc: 'happily into it; green light' }
  ];

  function tkRenderScoreCard(root) {
    if (!root) return;
    root.classList.add('tk-score-card', 'tk-score-card--inline');
    root.innerHTML = `
      <div class="tk-score-title">How to score</div>
      ${TK_GUARD_WIDE.map((r) => `
        <div class="tk-row">
          <span class="dot ${r.dot}">${r.label.split('â€”')[0].trim()}</span>
          <div>
            <strong>${r.label}</strong>
            <div style="opacity:.88">${r.desc}</div>
          </div>
        </div>
      `).join('')}
    `;
  }

  // --- utilities ---
  const log = (...a) => console.log('%c[TK]', 'color:#76d1ff', ...a);
  const rateRegex = /rate\s*interest\s*\/\s*comfort\s*\(\s*0\s*[â€“-]?\s*5\s*\)/i;

  const cleanText = (value) => {
    if (value == null) return '';
    return String(value).replace(/\s+/g, ' ').trim();
  };
  const textFrom = (node) => cleanText(node?.textContent);

  function findByText(re) {
    const all = document.querySelectorAll('*');
    for (let i = 0; i < all.length; i++) {
      const n = all[i];
      if (re.test(n.textContent || '')) return n;
    }
    return null;
  }

  function findNumberButtons(context) {
    const container = context || document;
    const selectors = ['button', '.btn', '[role="button"]', 'input[type="button"]', 'input[type="submit"]'];
    const nodes = Array.from(container.querySelectorAll(selectors.join(',')));
    return nodes.filter((el) => {
      if (!el) return false;
      if (el.closest('#tk-rating-row')) return false;
      const txt = cleanText(el.textContent || el.value || '');
      return /^[0-5]$/.test(txt);
    });
  }

  function nearestQuestionCard(fromEl) {
    if (!fromEl) return null;
    let el = fromEl;
    for (let i = 0; i < 8 && el; i++) {
      const hasControls = el.querySelector && (
        el.querySelector('button') ||
        el.querySelector('[role="button"]') ||
        el.querySelector('input')
      );
      const hasHeading = el.querySelector && el.querySelector('h1,h2,h3,h4,h5');
      if (hasControls && hasHeading) return el;
      el = el.parentElement;
    }
    return fromEl.parentElement || fromEl;
  }

  function removeVerticalGuard() {
    const rail = document.querySelector('#tk-guard-rail, .tk-guard-rail, .side-guard');
    if (rail && typeof rail.remove === 'function') rail.remove();
  }

  function ensureLayout(card, rateLabel, options = {}) {
    if (!card) return {};
    const { includeScoreCard = true } = options;

    let header = card.querySelector('.tk-question-header');
    if (!header) {
      header = document.createElement('header');
      header.className = 'tk-question-header';
      header.innerHTML = `
        <div id="tk-question-meta" class="tk-question-meta"></div>
        <h2 id="tk-question-title" class="tk-question-title"></h2>
        <p id="tk-question-prompt" class="tk-question-prompt tk-hidden"></p>
      `;
      if (rateLabel && rateLabel.parentNode) {
        rateLabel.insertAdjacentElement('beforebegin', header);
      } else {
        card.prepend(header);
      }
    }

    const meta = header.querySelector('#tk-question-meta');
    const title = header.querySelector('#tk-question-title');
    const prompt = header.querySelector('#tk-question-prompt');

    const container = header.parentNode || card;

    let ratingWrap = card.querySelector('.tk-rating-wrap');
    if (!ratingWrap) {
      ratingWrap = document.createElement('div');
      ratingWrap.className = 'tk-rating-wrap';
      if (header.nextSibling) {
        container.insertBefore(ratingWrap, header.nextSibling);
      } else {
        container.appendChild(ratingWrap);
      }
    }

    let ratingTitle = ratingWrap.querySelector('.tk-rating-title');
    if (!ratingTitle) {
      ratingTitle = document.createElement('div');
      ratingTitle.className = 'tk-rating-title';
      ratingWrap.prepend(ratingTitle);
    }
    const labelText = cleanText(rateLabel?.textContent) || 'Rate interest/comfort (0â€“5)';
    ratingTitle.textContent = labelText;

    let ratingRow = ratingWrap.querySelector('#tk-rating-row') || card.querySelector('#tk-rating-row');
    if (!ratingRow) {
      ratingRow = document.createElement('div');
      ratingRow.id = 'tk-rating-row';
      ratingRow.className = 'tk-rating-row';
    }
    if (ratingRow.parentNode !== ratingWrap) {
      ratingWrap.appendChild(ratingRow);
    }

    let scoreCard = null;
    if (includeScoreCard) {
      scoreCard = card.querySelector('#tk-score-card');
      if (!scoreCard) {
        scoreCard = document.createElement('div');
        scoreCard.id = 'tk-score-card';
        scoreCard.className = 'tk-score-card tk-score-card--inline';
      }
      if (scoreCard.parentNode !== ratingWrap) {
        ratingWrap.appendChild(scoreCard);
      }
    } else {
      const existing = card.querySelector('#tk-score-card');
      if (existing && typeof existing.remove === 'function') existing.remove();
    }

    return { header, meta, title, prompt, ratingWrap, ratingTitle, ratingRow, scoreCard };
  }

  function gatherMeta(card, rateLabel) {
    const crumbCandidates = [
      card.querySelector('[data-role="question-path"]'),
      card.querySelector('.question-path'),
      card.querySelector('.question-crumbs'),
      card.querySelector('.breadcrumbs'),
      card.querySelector('.tk-crumbs'),
      card.querySelector('nav[aria-label*="crumb"]'),
      rateLabel?.closest('.question')?.querySelector('.question-path')
    ].filter(Boolean);
    const crumbNode = crumbCandidates.find((node) => textFrom(node));
    const crumbText = cleanText(window.TK_CURRENT_CRUMBS) || textFrom(crumbNode);

    const heading = card.querySelector('h1,h2,h3,h4,h5');
    const headingText = textFrom(heading);
    let titleText = cleanText(window.TK_CURRENT_TITLE) || headingText || textFrom(rateLabel);
    if (!titleText) titleText = 'Giving: Rate interest/comfort (0â€“5)';

    const promptCandidates = [
      card.querySelector('.question-prompt'),
      card.querySelector('.prompt'),
      heading?.nextElementSibling,
      rateLabel?.closest('.question')?.querySelector('p'),
      rateLabel?.parentElement?.querySelector('p')
    ].filter(Boolean);
    const promptNode = promptCandidates.find((node) => {
      const txt = textFrom(node);
      return txt && txt !== headingText;
    });
    let promptText = cleanText(window.TK_CURRENT_PROMPT) || textFrom(promptNode);
    if (promptText === titleText) promptText = '';
    if (promptText === crumbText) promptText = '';

    return { crumbText, titleText, promptText, heading, crumbNode, promptNode };
  }

  function applyMeta(layout, info) {
    if (!layout) return;
    const { meta, title, prompt } = layout;
    if (meta) {
      meta.textContent = info.crumbText || '';
      meta.classList.toggle('tk-hidden', !info.crumbText);
    }
    if (title) {
      title.textContent = info.titleText || '';
    }
    if (prompt) {
      if (info.promptText) {
        prompt.textContent = info.promptText;
        prompt.classList.remove('tk-hidden');
      } else {
        prompt.textContent = '';
        prompt.classList.add('tk-hidden');
      }
    }
  }

  function hideIfMatch(node, expected) {
    if (!node || !expected) return;
    if (textFrom(node) === expected) {
      node.classList.add('tk-hidden');
    }
  }

  function hideLegacy(nativeButtons, rateLabel) {
    if (rateLabel) rateLabel.classList.add('tk-hidden');
    const wrappers = new Set();
    nativeButtons.forEach((btn) => {
      const wrap = btn.closest('.question-row, .rating-row, .rate-row, .tk-rate-row, .row, .button-row, .tk-legacy-row');
      if (wrap) wrappers.add(wrap);
    });
    wrappers.forEach((node) => node.classList.add('tk-hidden'));
  }

  function setupScale(row, nativeButtons) {
    if (!row) return;
    row.setAttribute('role', 'group');
    row.setAttribute('aria-label', 'Interest rating (0 to 5)');

    const filteredNative = (nativeButtons || []).filter(Boolean);

    if (row.dataset.tkScaleBound === '1') {
      if (typeof row.__tkSync === 'function') row.__tkSync();
      return;
    }

    let handlePick = () => {};
    tkRenderScale(row, (val) => handlePick(String(val)));

    const buttons = Array.from(row.querySelectorAll('button'));
    if (!buttons.length) return;

    const highlight = (val) => {
      buttons.forEach((btn) => {
        const text = cleanText(btn.textContent);
        const active = val != null && text === String(val);
        btn.classList.toggle('is-active', active);
        btn.setAttribute('aria-pressed', String(active));
      });
    };

    if (!filteredNative.length) {
      handlePick = (val) => {
        row.dataset.tkSelected = val;
        highlight(val);
      };
      row.__tkSync = () => highlight(row.dataset.tkSelected || null);
      buttons.forEach((btn) => {
        const val = cleanText(btn.textContent);
        btn.addEventListener('click', () => {
          row.dataset.tkSelected = val;
          highlight(val);
        });
      });
      row.dataset.tkScaleBound = '1';
      row.__tkSync();
      return;
    }

    const map = new Map();
    filteredNative.forEach((btn) => {
      const text = cleanText(btn.textContent || btn.value || '');
      if (/^[0-5]$/.test(text) && !map.has(text)) {
        map.set(text, btn);
      }
    });

    const detectNative = () => {
      for (const [text, btn] of map.entries()) {
        if (btn.matches('[aria-pressed="true"], [aria-selected="true"], [aria-checked="true"], .selected, .is-active, .active, .btn-primary, .btn-success')) {
          return text;
        }
        if (btn.dataset) {
          if (btn.dataset.selected === 'true' || btn.dataset.state === 'selected' || btn.dataset.tkSelected === 'true') {
            return text;
          }
        }
      }
      return null;
    };

    handlePick = (val) => {
      const target = map.get(val);
      if (target && typeof target.click === 'function') {
        target.click();
      }
      row.dataset.tkSelected = val;
      highlight(val);
    };

    buttons.forEach((btn) => {
      const val = cleanText(btn.textContent);
      btn.addEventListener('click', () => handlePick(val));
    });

    filteredNative.forEach((btn) => {
      if (btn.dataset.tkMirrorBound === '1') return;
      btn.addEventListener('click', () => {
        const val = cleanText(btn.textContent || btn.value || '');
        if (val) {
          row.dataset.tkSelected = val;
          highlight(val);
        }
      }, { capture: true });
      btn.dataset.tkMirrorBound = '1';
    });

    row.__tkSync = () => {
      const nativeVal = detectNative();
      const stored = row.dataset.tkSelected || null;
      highlight(nativeVal || stored);
    };

    row.dataset.tkScaleBound = '1';
    row.__tkSync();
  }

  function enhance() {
    const rateLabel = findByText(rateRegex);
    if (!rateLabel) {
      log('Enhancer: no label found yet.');
      return;
    }

    const card = nearestQuestionCard(rateLabel);
    if (!card) {
      log('Enhancer: question card not detected.');
      return;
    }

    card.classList.add('tk-question-card');
    removeVerticalGuard();

    const layout = ensureLayout(card, rateLabel, { includeScoreCard: SHOW_INLINE_SCORE_CARD });
    const info = gatherMeta(card, rateLabel);
    applyMeta(layout, info);
    hideIfMatch(info.heading, info.titleText);
    hideIfMatch(info.crumbNode, info.crumbText);
    hideIfMatch(info.promptNode, info.promptText);

    const nativeButtons = findNumberButtons(card);
    hideLegacy(nativeButtons, rateLabel);

    setupScale(layout.ratingRow, nativeButtons);
    if (SHOW_INLINE_SCORE_CARD) {
      tkRenderScoreCard(layout.scoreCard);
    }

    log('Question guard layout applied.');
  }

  let rerunTimer;
  const mo = new MutationObserver(() => {
    clearTimeout(rerunTimer);
    rerunTimer = setTimeout(enhance, 60);
  });
  mo.observe(document.body, { childList: true, subtree: true });

  window.addEventListener('keydown', (e) => {
    if (e.altKey && e.key.toLowerCase() === 'g') {
      log('Alt+G: manual re-scan');
      enhance();
    }
  });

  enhance();
})();
</script>
