<!-- Keep these just above the final script; update paths if needed -->
<script src="/assets/js/vendor/jspdf.umd.min.js?v=3"></script>
<script src="/assets/js/vendor/jspdf.plugin.autotable.min.js?v=3"></script>

<script>
/* ========== TalkKink PDF: centered header + centered table ========== */
(function attachTKPdf() {
  // --- Diagnostics helper
  const log = (...a)=>console.log('[compat][pdf]', ...a);
  const err = (...a)=>console.error('[compat][pdf]', ...a);

  // --- Verify libs
  const jsPDF = (window.jspdf && window.jspdf.jsPDF) || window.jsPDF;
  if (!jsPDF) { err('jsPDF missing'); return; }
  if (typeof (jsPDF.prototype || {}).autoTable !== 'function') {
    err('autoTable plugin missing'); return;
  }
  log('libs ok');

  // --- Find the Download button robustly
  function findDownloadButton(){
    const guesses = ['#downloadPdfBtn', '#downloadPDF', '#tkDownloadPdf', 'button[data-action="download-pdf"]'];
    for (const sel of guesses){
      const el = document.querySelector(sel);
      if (el) return {el, via: sel};
    }
    // Fallback: search by visible text
    const cands = Array.from(document.querySelectorAll('button, a[role="button"], .btn'));
    const hit = cands.find(b => /download\s*pdf/i.test(b.textContent || ''));
    if (hit) return {el: hit, via: 'text:Download PDF'};
    return {el:null, via:'none'};
  }
  let {el:btn, via} = findDownloadButton();
  if (!btn) { err('Download button not found'); return; }
  log('button located via', via);

  // --- Remove any previous listeners by cloning the node
  const clone = btn.cloneNode(true);
  btn.parentNode.replaceChild(clone, btn);
  btn = clone;

  // --- Public rebinder for you (run in console if needed)
  window.forcePdfBind = () => { attachTKPdf(); log('re-bound via window.forcePdfBind()'); };

  // --- Theme tokens
  const TOK = {
    cyan: [0,255,255],
    bodyFill: [10,10,12],
    grid: [34,34,42],
    margins: { top: 56, right: 56, bottom: 60, left: 56 },
    title: 'TalkKink Compatibility',
    section: 'Behavioral Play'
  };

  const pageUnit = 'pt', pageFormat = 'letter';

  function cx(doc){ return doc.internal.pageSize.getWidth() / 2; }

  function drawHeader(doc){
    const w = doc.internal.pageSize.getWidth();
    // Title
    doc.setFont('helvetica','bold'); doc.setTextColor(255,255,255); doc.setFontSize(28);
    doc.text(TOK.title, cx(doc), 70, {align:'center'});
    // Timestamp
    doc.setFont('helvetica','normal'); doc.setTextColor(175,210,255); doc.setFontSize(10);
    doc.text('Generated: ' + new Date().toLocaleString(), cx(doc), 88, {align:'center'});
    // Rule
    if (doc.setLineWidth) doc.setLineWidth(1);
    doc.setDrawColor(...TOK.cyan);
    doc.line(TOK.margins.left, 100, w - TOK.margins.right, 100);
    // Section
    doc.setFont('helvetica','bold'); doc.setTextColor(255,255,255); doc.setFontSize(22);
    doc.text(TOK.section, cx(doc), 124, {align:'center'});
    return 140;
  }

  // Build rows from live data if available; otherwise small fallback
  async function buildRows(){
    if (typeof window.buildCompatibilityRows === 'function') {
      try { const r = await window.buildCompatibilityRows(); if (Array.isArray(r) && r.length) { log('rows from buildCompatibilityRows()', r.length); return r; } } catch(e){ err('buildCompatibilityRows error', e); }
    }
    const Q = Array.isArray(window.QUESTIONS) ? window.QUESTIONS : [];
    const A = window.answers instanceof Map ? window.answers : null;
    if (Q.length && A){
      const rows = Q.map(q => {
        const a = A.get(q.id) || {};
        return [
          q.text || q.label || '',
          String(a.a ?? ''),
          (a.match != null ? a.match : 0) + '%',
          '▶',
          String(a.b ?? '')
        ];
      });
      log('rows from QUESTIONS/answers', rows.length);
      return rows;
    }
    log('using minimal fallback rows');
    return [['Sample item', '3', '100%', '▶', '3']];
  }

  // Fixed column widths => exact table width => true centering
  const COLW = {0: 360, 1: 70, 2: 70, 3: 50, 4: 70}; // total = 620 pt
  function centeredMargin(doc){
    const total = Object.values(COLW).reduce((a,b)=>a+b,0);
    const pageW = doc.internal.pageSize.getWidth();
    const left = Math.max(TOK.margins.left, (pageW - total)/2);
    return { top: TOK.margins.top, right: TOK.margins.right, bottom: TOK.margins.bottom, left };
  }

  async function onDownloadClick(ev){
    ev.preventDefault();
    const doc = new jsPDF({unit: pageUnit, format: pageFormat});
    const startY = drawHeader(doc);
    const body = await buildRows();

    doc.autoTable({
      head: [['Item', 'Partner A', 'Match', 'Flag', 'Partner B']],
      body,
      startY,
      margin: centeredMargin(doc),
      styles:     { fillColor: TOK.bodyFill, textColor:[255,255,255], lineColor: TOK.grid, lineWidth: 0.25, valign:'middle' },
      headStyles: { fillColor:[0,0,0],        textColor: TOK.cyan,     lineColor: TOK.grid, fontStyle:'bold' },
      columnStyles: {
        0: { cellWidth: COLW[0], halign:'left'  },
        1: { cellWidth: COLW[1], halign:'center'},
        2: { cellWidth: COLW[2], halign:'center'},
        3: { cellWidth: COLW[3], halign:'center'},
        4: { cellWidth: COLW[4], halign:'center'}
      },
      didDrawPage(data){ if (data.pageNumber > 1) drawHeader(doc); }
    });

    doc.save('compatibility-pretty-dark.pdf');
    log('PDF saved');
  }

  btn.addEventListener('click', onDownloadClick);
  log('Bound new PDF generator →', btn);
})();
</script>
