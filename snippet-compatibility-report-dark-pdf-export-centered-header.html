<!-- Keep these just above the final script; update paths if needed -->
<script src="/assets/js/vendor/jspdf.umd.min.js?v=3"></script>
<script src="/assets/js/vendor/jspdf.plugin.autotable.min.js?v=3"></script>

<script>
/* ========== TalkKink PDF: centered header + centered table ========== */
(function attachTKPdf() {
  // --- Diagnostics helper
  const log = (...a)=>console.log('[compat][pdf]', ...a);
  const err = (...a)=>console.error('[compat][pdf]', ...a);

  // --- Verify libs
  const jsPDF = (window.jspdf && window.jspdf.jsPDF) || window.jsPDF;
  if (!jsPDF) { err('jsPDF missing'); return; }
  if (typeof (jsPDF.prototype || {}).autoTable !== 'function') {
    err('autoTable plugin missing'); return;
  }
  log('libs ok');

  // --- Find the Download button robustly
  function findDownloadButton(){
    const guesses = ['#downloadPdfBtn', '#downloadPDF', '#tkDownloadPdf', 'button[data-action="download-pdf"]'];
    for (const sel of guesses){
      const el = document.querySelector(sel);
      if (el) return {el, via: sel};
    }
    // Fallback: search by visible text
    const cands = Array.from(document.querySelectorAll('button, a[role="button"], .btn'));
    const hit = cands.find(b => /download\s*pdf/i.test(b.textContent || ''));
    if (hit) return {el: hit, via: 'text:Download PDF'};
    return {el:null, via:'none'};
  }
  let {el:btn, via} = findDownloadButton();
  if (!btn) { err('Download button not found'); return; }
  log('button located via', via);

  // --- Remove any previous listeners by cloning the node
  const clone = btn.cloneNode(true);
  btn.parentNode.replaceChild(clone, btn);
  btn = clone;

  // --- Public rebinder for you (run in console if needed)
  window.forcePdfBind = () => { attachTKPdf(); log('re-bound via window.forcePdfBind()'); };

  // --- Theme tokens
  const TOK = {
    cyan: [0,255,255],
    bodyFill: [10,10,12],
    grid: [34,34,42],
    margins: { top: 56, right: 56, bottom: 60, left: 56 },
    title: 'TalkKink Compatibility',
    section: 'Behavioral Play',
    timestamp: [160,220,220]
  };

  const DEFAULT_COLW = [360, 70, 70, 50, 70];
  const pageUnit = 'pt', pageFormat = 'letter';

  function computeTableMargin(doc, baseMargin = TOK.margins, colw = DEFAULT_COLW){
    const total = colw.reduce((a,b)=>a+b,0);
    const pageW = doc.internal.pageSize.getWidth();
    const left = Math.max(baseMargin.left, (pageW - total) / 2);
    return { ...baseMargin, left };
  }

  function drawCenteredHeaderToTable(doc, opts = {}){
    const margin = opts.margin || TOK.margins;
    const colw = opts.COLW || DEFAULT_COLW;
    const tableLeft = margin.left;
    const tableWidth = colw.reduce((a,b)=>a+b,0);
    const pageWidth = opts.pageWidth || doc.internal.pageSize.getWidth();
    const centerX = pageWidth / 2;

    const titleY = opts.titleY ?? 84;
    const timeY  = opts.timeY  ?? 100;
    const catY   = opts.catY   ?? 126;
    const timeStamp = opts.timestamp || new Date().toLocaleString();

    doc.setFont('helvetica','bold');
    doc.setFontSize(28);
    doc.setTextColor(255,255,255);
    doc.text(TOK.title, centerX, titleY, { align: 'center' });

    doc.setFont('helvetica','normal');
    doc.setFontSize(11);
    doc.setTextColor(...TOK.timestamp);
    doc.text(`Generated: ${timeStamp}`, centerX, timeY, { align: 'center' });

    doc.setFont('helvetica','bold');
    doc.setFontSize(22);
    doc.setTextColor(255,255,255);
    doc.text(TOK.section, centerX, catY, { align: 'center' });

    const gap = opts.afterCategoryGap ?? 14;
    return { startY: opts.startY ?? (catY + gap) };
  }

  // Build rows from live data if available; otherwise small fallback
  async function buildRows(){
    if (typeof window.buildCompatibilityRows === 'function') {
      try { const r = await window.buildCompatibilityRows(); if (Array.isArray(r) && r.length) { log('rows from buildCompatibilityRows()', r.length); return r; } } catch(e){ err('buildCompatibilityRows error', e); }
    }
    const Q = Array.isArray(window.QUESTIONS) ? window.QUESTIONS : [];
    const A = window.answers instanceof Map ? window.answers : null;
    if (Q.length && A){
      const rows = Q.map(q => {
        const a = A.get(q.id) || {};
        return [
          q.text || q.label || '',
          String(a.a ?? ''),
          (a.match != null ? a.match : 0) + '%',
          '▶',
          String(a.b ?? '')
        ];
      });
      log('rows from QUESTIONS/answers', rows.length);
      return rows;
    }
    log('using minimal fallback rows');
    return [['Sample item', '3', '100%', '▶', '3']];
  }

  // Fixed column widths => exact table width => true centering
  const COLW = DEFAULT_COLW;

  function paintPage(doc){
    const page = doc.internal.pageSize;
    const width = page.getWidth();
    const height = page.getHeight();
    doc.setFillColor(...TOK.bodyFill);
    doc.rect(0, 0, width, height, 'F');
    doc.setTextColor(255,255,255);
  }

  async function onDownloadClick(ev){
    ev.preventDefault();
    const doc = new jsPDF({unit: pageUnit, format: pageFormat});
    const originalAddPage = doc.addPage.bind(doc);
    doc.addPage = function patchedAddPage(...args){
      const result = originalAddPage(...args);
      paintPage(this);
      return result;
    };
    paintPage(doc);
    const margin = computeTableMargin(doc, TOK.margins, COLW);
    const generatedStamp = new Date().toLocaleString();
    const headerConfig = {
      margin,
      COLW,
      titleY: 84,
      timeY: 100,
      catY: 126,
      timestamp: generatedStamp,
      pageWidth: doc.internal.pageSize.getWidth(),
    };
    const { startY } = drawCenteredHeaderToTable(doc, headerConfig);
    const body = await buildRows();

    doc.autoTable({
      head: [['Item', 'Partner A', 'Match', 'Flag', 'Partner B']],
      body,
      startY,
      margin,
      styles:     { fillColor: TOK.bodyFill, textColor:[255,255,255], lineColor: TOK.grid, lineWidth: 0.25, valign:'middle' },
      headStyles: { fillColor:[0,0,0],        textColor: TOK.cyan,     lineColor: TOK.grid, fontStyle:'bold' },
      columnStyles: {
        0: { cellWidth: COLW[0], halign:'left'  },
        1: { cellWidth: COLW[1], halign:'center'},
        2: { cellWidth: COLW[2], halign:'center'},
        3: { cellWidth: COLW[3], halign:'center'},
        4: { cellWidth: COLW[4], halign:'center'}
      },
      didDrawPage(data){ if (data.pageNumber > 1) drawCenteredHeaderToTable(doc, headerConfig); }
    });

    doc.save('compatibility-pretty-dark.pdf');
    log('PDF saved');
  }

  btn.addEventListener('click', onDownloadClick);
  log('Bound new PDF generator →', btn);
})();
</script>
