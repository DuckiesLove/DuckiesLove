<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Compatibility Upload Test</title>
</head>
<body>
<!-- ======= UI: error surfaces, status, file inputs, and download button ======= -->
<div id="compat-upload">
  <div id="globalError" style="display:none;color:#b00020;margin:.5rem 0;"></div>

  <div style="display:flex;gap:1rem;align-items:center;flex-wrap:wrap">
    <label>
      <strong>Survey A (Partner A):</strong>
      <input id="uploadA" type="file" accept="application/json,.json" />
    </label>
    <span id="statusA" style="font-size:.9rem;color:#666">No file</span>
  </div>

  <div style="display:flex;gap:1rem;align-items:center;flex-wrap:wrap;margin-top:.5rem">
    <label>
      <strong>Survey B (Partner B):</strong>
      <input id="uploadB" type="file" accept="application/json,.json" />
    </label>
    <span id="statusB" style="font-size:.9rem;color:#666">No file</span>
  </div>

  <button id="downloadBtn" disabled style="margin-top:.75rem">Download Compatibility PDF</button>
</div>

<script>
(function(){
/* =====================================================================
   Robust, symmetric upload pipeline for Survey A & B
   - Parses a wide range of JSON shapes
   - Validates & shows per-survey status
   - Enables "Download" only when BOTH surveys have numeric items
   - No alerts; messages shown inline
   ===================================================================== */

let partnerAData = null;
let partnerBData = null;

const NAME_KEYS  = ["id","key","name","label","title","slug"];
const SCORE_KEYS = ["rating","score","value","val","points","level"];

/* If your <tr> ids differ from the JSON keys, map them here */
const ID_ALIAS = new Map([
  // ["JSON key", "your data-kink-id value"],
]);

/* ---------- helpers ---------- */
function escapeHtml(s){return String(s).replace(/[&<>"']/g,m=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[m]))}
function pick(obj, keys) { for (const k of keys) if (obj && Object.prototype.hasOwnProperty.call(obj, k)) return obj[k]; }
function toNumberish(v) {
  if (typeof v === "number" && !Number.isNaN(v)) return v > 5 && v <= 10 ? v / 2 : v;
  if (typeof v === "string") {
    const t = v.trim();
    if (/^\d+%$/.test(t)) return Number(t.slice(0, -1)) / 20;      // e.g. "80%" -> 4.0 on 0–5
    if (/^\d+\s*\/\s*\d+$/.test(t)) return Number(t.split("/")[0]); // e.g. "4/5" -> 4
    const n = Number(t);
    if (!Number.isNaN(n)) return n > 5 && n <= 10 ? n / 2 : n;      // handle 1–10 scales
  }
  return null;
}

/* Accepts varied row shapes and returns {id,label,score} or null */
function mapRow(row) {
  if (!row || typeof row !== "object") return null;
  const candidate = ["", "item", "question", "meta", "data"]
    .map(prefix => prefix ? row[prefix] : row)
    .find(v => v && typeof v === "object") || row;

  const nameLike  = pick(candidate, NAME_KEYS);
  const scoreLike = pick(candidate, SCORE_KEYS);

  const idRaw = (typeof nameLike === "string" ? nameLike : String(nameLike ?? "")).trim();
  if (!idRaw) return null;

  const score = toNumberish(scoreLike);
  const id = ID_ALIAS.get(idRaw) || idRaw;
  return { id, label: idRaw, score };
}

/* Accept {items:[...]}, {answers:[...]}, {data:[...]}, bare array, first array found, or plain object map */
function normalizeSurvey(json) {
  let rows = [];
  let usingObjectMap = false;
  if (Array.isArray(json)) rows = json;
  else if (Array.isArray(json?.items)) rows = json.items;
  else if (Array.isArray(json?.answers)) rows = json.answers;
  else if (Array.isArray(json?.data)) rows = json.data;
  else if (json && typeof json === "object") {
    const firstArray = Object.values(json).find(v => Array.isArray(v));
    if (Array.isArray(firstArray)) rows = firstArray;
    else {
      usingObjectMap = true;
      rows = Object.entries(json);
    }
  }
  if (!rows) rows = [];

  const items = [];
  let missingScores = 0;

  if (usingObjectMap) {
    for (const [k, v] of rows) {
      const score = toNumberish(v);
      if (typeof score !== "number") missingScores++;
      const id = ID_ALIAS.get(k) || k;
      items.push({ id, label: k, score });
    }
  } else {
    for (const r of rows) {
      const m = mapRow(r);
      if (!m) continue;
      if (typeof m.score !== "number") missingScores++;
      items.push({ id: m.id, label: m.label, score: m.score });
    }
  }
  return { items, missingScores };
}

function validateNormalized(n) {
  const errors = [];
  if (!n.items.length) errors.push("No recognizable items with names/ids were found.");
  const scored = n.items.filter(i => typeof i.score === "number");
  if (n.items.length && !scored.length) errors.push("Items found, but none contained numeric scores.");
  return { errors, scoredCount: scored.length, total: n.items.length, missing: n.missingScores };
}

/* ---------- UI feedback ---------- */
function setGlobalError(msgs) {
  const box = document.getElementById("globalError");
  if (!box) return;
  if (!msgs || msgs.length === 0) { box.style.display = "none"; box.innerHTML = ""; return; }
  box.style.display = "block";
  box.innerHTML = msgs.map(m => `<div>• ${escapeHtml(m)}</div>`).join("");
}

function setStatus(which, text, state) {
  const el = document.getElementById(which === "A" ? "statusA" : "statusB");
  if (!el) return;
  el.textContent = text;
  if (state === true) el.style.color = "#1b5e20";
  else if (state === false) el.style.color = "#b00020";
  else el.style.color = "#666";
}

/* Enable download only when BOTH A and B have at least one numeric score */
function updateUIStates() {
  const btn = document.getElementById("downloadBtn");
  const aOk = !!(partnerAData?.items?.some(i => typeof i.score === "number"));
  const bOk = !!(partnerBData?.items?.some(i => typeof i.score === "number"));
  btn.disabled = !(aOk && bOk);
  if (!aOk || !bOk) {
    setGlobalError([]);
  }
}

// Escape an arbitrary id for use in querySelector
function cssEscape(str){
  return String(str).replace(/["\\#.:><~+^$[\]|(){}=]/g, "\\$&");
}

// Ensure a table row exists for a given id; creates one if missing
function ensureRowExists(id, label){
  let tbody = document.querySelector('tbody');
  if (!tbody){
    const anyRow = document.querySelector('[data-kink-id]');
    if (anyRow) tbody = anyRow.parentElement;
    else return null;
  }
  let row = document.querySelector(`[data-kink-id="${cssEscape(id)}"]`);
  if (row) return row;

  row = document.createElement('tr');
  row.setAttribute('data-kink-id', id);

  const tdLabel = document.createElement('td');
  tdLabel.textContent = label || id;

  const tdA = document.createElement('td');
  tdA.setAttribute('data-cell','A');
  tdA.textContent = 'N/A';

  const tdMatch = document.createElement('td');
  tdMatch.setAttribute('data-cell','Match');
  tdMatch.textContent = 'N/A';

  const tdB = document.createElement('td');
  tdB.setAttribute('data-cell','B');
  tdB.textContent = 'N/A';

  row.append(tdLabel, tdA, tdMatch, tdB);
  tbody.appendChild(row);
  return row;
}

/* ---------- Public upload handlers: wired to both inputs ---------- */
async function handleUpload(file, which) {
  if (!file) return;

  setStatus(which, "Loading...", null);
  await new Promise(r => setTimeout(r));

  try {
    const text = await file.text();
    await new Promise(r => setTimeout(r));
    const json = JSON.parse(text);
    await new Promise(r => setTimeout(r));

    const normalized = normalizeSurvey(json);
    const { errors, scoredCount, total, missing } = validateNormalized(normalized);

    // Store by partner
    if (which === "A") partnerAData = normalized;
    else partnerBData = normalized;

    // Update comparison table right away (no-op if you haven’t built it)
    updateComparison();

    if (errors.length) {
      setStatus(which, `Loaded ${total} items (${scoredCount} scored). Issues: ${errors.join(" ")}`, false);
    } else {
      const warn = missing ? ` • ${missing} item(s) missing scores → shown as N/A` : "";
      setStatus(which, `✅ Loaded ${total} items, ${scoredCount} scored${warn}`, true);
    }

    updateUIStates();
    console.info(`[Upload ${which}]`, { total, scoredCount, missing, errors });

  } catch (e) {
    setStatus(which, `Invalid JSON for Survey ${which}. ${e.message}`, false);
    updateUIStates();
  }
}

/* ---------- Table injection (creates missing rows when needed) ---------- */
function updateComparison() {
  const aItems = partnerAData?.items || [];
  const bItems = partnerBData?.items || [];
  const aMap = new Map(aItems.map(i => [i.id, i]));
  const bMap = new Map(bItems.map(i => [i.id, i]));

  const ids = new Set([...aMap.keys(), ...bMap.keys()]);
  let updated = 0;

  ids.forEach(id => {
    const a = aMap.get(id);
    const b = bMap.get(id);
    const label = a?.label || b?.label || id;

    let tr = document.querySelector(`[data-kink-id="${cssEscape(id)}"]`);
    if (!tr) tr = ensureRowExists(id, label);
    if (!tr) return; // still nothing to attach to

    const aCell = tr.querySelector('[data-cell="A"]');
    if (aCell) aCell.textContent = typeof a?.score === 'number' ? String(a.score) : 'N/A';

    const bCell = tr.querySelector('[data-cell="B"]');
    if (bCell) bCell.textContent = typeof b?.score === 'number' ? String(b.score) : 'N/A';

    const matchCell = tr.querySelector('[data-cell="Match"]');
    if (matchCell) {
      if (typeof a?.score === 'number' && typeof b?.score === 'number') {
        const diff = Math.abs(a.score - b.score);
        const pct = Math.max(0, 100 - (diff / 5) * 100);
        matchCell.textContent = `${Math.round(pct)}%`;
      } else {
        matchCell.textContent = 'N/A';
      }
    }

    const flagCell = tr.querySelector('[data-cell="Flag"]');
    if (flagCell) {
      if (typeof a?.score === 'number' && typeof b?.score === 'number') {
        flagCell.textContent = Math.abs(a.score - b.score) >= 3 ? '🚩' : '';
      } else {
        flagCell.textContent = '';
      }
    }
    updated++;
  });

  if (!updated) {
    setGlobalError(['No matching rows were found or created. Check your ID_ALIAS mappings or table structure.']);
  } else {
    setGlobalError([]);
  }
}

/* ---------- PDF guard (plug in your jsPDF code where indicated) ---------- */
async function downloadCompatibilityPDF() {
  const aOk = partnerAData?.items?.some(i => typeof i.score === "number");
  const bOk = partnerBData?.items?.some(i => typeof i.score === "number");
  if (!aOk || !bOk) {
    setGlobalError(["You need valid scores for both Survey A and Survey B before generating the PDF."]);
    return;
  }

  // --- Your jsPDF export goes here ---
  // const { jsPDF } = window.jspdf;
  // const doc = new jsPDF({ orientation: "landscape", unit: "pt", format: "a4" });
  // doc.text("Talk Kink Compatibility Report", 40, 40);
  // ... build from DOM or partnerAData/partnerBData ...
  // doc.save("compatibility.pdf");
}

/* ---------- Wire up inputs & button ---------- */
document.getElementById("uploadA")?.addEventListener("change", e => handleUpload(e.target.files?.[0], "A"));
document.getElementById("uploadB")?.addEventListener("change", e => handleUpload(e.target.files?.[0], "B"));
document.getElementById("downloadBtn")?.addEventListener("click", downloadCompatibilityPDF);

})();
</script>

<!-- ===== TalkKink Compatibility – Test Harness =====
Place this AFTER your existing compatibility script (so it can call handleUpload). -->

<style>
  .tk-testbar { display:flex; flex-wrap:wrap; gap:.5rem; margin:1rem 0; }
  .tk-note { font-size:.9rem; opacity:.8; }
</style>

<div class="tk-testbar" id="tk-tests">
  <button type="button" onclick="TK_loadSample('A','objectMap05')">Load Sample A (Object map 0–5)</button>
  <button type="button" onclick="TK_loadSample('B','array10')">Load Sample B (Array 1–10 → scaled)</button>
  <button type="button" onclick="TK_loadSample('B','percent')">Load Sample B (Percent strings)</button>
  <button type="button" onclick="TK_loadSample('B','mismatch')">Load Sample B (Fuzzy label mismatch)</button>
  <button type="button" onclick="TK_loadSample('A','malformed')">Load Malformed JSON → error</button>
  <div class="tk-note">Use these to verify parsing, fuzzy mapping, scaling, and PDF gating.</div>
</div>

<script>
/* ------- Test Fixtures ------- */
const TK_FIXTURES = {
  /* A: object map like your export (0–5 scale) */
  objectMap05: {
    "Choosing my partner’s outfit for the day or a scene": 5,
    "Selecting their underwear, lingerie, or base layers": 5,
    "Styling their hair (braiding, brushing, tying, etc.)": 1,
    "Picking head coverings (bonnets, veils, hoods, hats) for mood or protocol": 1,
    "Offering makeup, polish, or accessories as part of ritual or play": 5
  },

  /* B: array of rows on a 1–10 scale → should normalize to 0–5 */
  array10: [
    { label: "Choosing my partner’s outfit for the day or a scene", rating: 8 },
    { label: "Selecting their underwear, lingerie, or base layers", rating: 7 },
    { label: "Styling their hair (braiding, brushing, tying, etc.)", rating: 2 },
    { label: "Picking head coverings (bonnets, veils, hoods, hats) for mood or protocol", rating: 3 },
    { label: "Offering makeup, polish, or accessories as part of ritual or play", rating: 9 }
  ],

  /* B: percent strings → should coerce to 0–5 (80% → 4.0) */
  percent: {
    "Choosing my partner’s outfit for the day or a scene": "80%",
    "Selecting their underwear, lingerie, or base layers": "60%",
    "Styling their hair (braiding, brushing, tying, etc.)": "20%",
    "Picking head coverings (bonnets, veils, hoods, hats) for mood or protocol": "40%",
    "Offering makeup, polish, or accessories as part of ritual or play": "100%"
  },

  /* B: labels with punctuation/spacing differences → tests fuzzy match */
  mismatch: {
    "Choosing my partners outfit for the day (or scene)": 4,
    "Selecting underwear / lingerie / base layers": 3,
    "Styling their hair - braiding, brushing, tying etc": 2,
    "Picking head coverings (hoods, hats, veils)": 2,
    "Makeup / polish / accessories as ritual or play": 5
  },

  /* Malformed JSON (string, not parseable on purpose) */
  malformed: "{ this is not valid JSON }"
};

/* ------- Loader: calls your existing handleUpload(file, 'A'|'B') ------- */
async function TK_loadSample(which, key){
  const data = TK_FIXTURES[key];
  let file;

  if (key === "malformed") {
    file = new File([TK_FIXTURES.malformed], `malformed-${which}.json`, { type: "application/json" });
  } else {
    const text = JSON.stringify(data, null, 2);
    file = new File([text], `sample-${key}-${which}.json`, { type: "application/json" });
  }

  // Prefer the real UI pathway if your script uses input change listeners
  const input = document.getElementById(which === 'A' ? 'uploadA' : 'uploadB');
  if (input) {
    // Trigger your existing handler path by dispatching a synthetic change
    const dt = new DataTransfer();
    dt.items.add(file);
    input.files = dt.files;
    input.dispatchEvent(new Event('change', { bubbles: true }));
    return;
  }

  // Fallback: call global handleUpload directly if exposed
  if (typeof handleUpload === "function") {
    await handleUpload(file, which);
  } else {
    console.warn("handleUpload is not in global scope; ensure the main module script is loaded first.");
  }
}

/* ------- Quick “Test Plan” you can follow step-by-step (visible in console) ------- */
console.log(`TalkKink Test Plan:
1) Click "Load Sample A (Object map 0–5)" → Partner A column should fill with 5,5,1,1,5.
2) Click "Load Partner Survey" (if present) or one of the B buttons:
   a) "Array 1–10" → values normalize; Match% computed.
   b) "Percent strings" → 80% becomes 4.0, etc.
   c) "Fuzzy mismatch" → labels with different punctuation still map to rows.
3) Try "Malformed JSON" → status should turn red with an error message; Download remains disabled.
4) After both A and B are valid, Download button enables. If jsPDF + AutoTable are on the page, a PDF is generated.
`);
</script>
</body>
</html>
