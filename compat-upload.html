<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Compatibility Upload Test</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.3/jspdf.plugin.autotable.min.js"></script>
</head>
<body>
<!-- ======= UI: error surfaces, status, file inputs, and download button ======= -->
<div id="compat-upload">
  <div id="globalError" style="display:none;color:#b00020;margin:.5rem 0;"></div>

  <div style="display:flex;gap:1rem;align-items:center;flex-wrap:wrap">
    <label>
      <strong>Survey A (Partner A):</strong>
      <input id="uploadA" type="file" accept="application/json,.json" />
    </label>
    <span id="statusA" style="font-size:.9rem;color:#666">No file</span>
  </div>

  <div style="display:flex;gap:1rem;align-items:center;flex-wrap:wrap;margin-top:.5rem">
    <label>
      <strong>Survey B (Partner B):</strong>
      <input id="uploadB" type="file" accept="application/json,.json" />
    </label>
    <span id="statusB" style="font-size:.9rem;color:#666">No file</span>
  </div>

  <button id="downloadBtn" disabled style="margin-top:.75rem">Download Compatibility PDF</button>
</div>

<script>
(function(){
/* =====================================================================
   Robust, symmetric upload pipeline for Survey A & B
   - Parses a wide range of JSON shapes
   - Validates & shows per-survey status
   - Enables "Download" only when BOTH surveys have numeric items
   - No alerts; messages shown inline
   ===================================================================== */

let partnerAData = null;
let partnerBData = null;

const NAME_KEYS  = ["id","key","name","label","title","slug"];
const SCORE_KEYS = ["rating","score","value","val","points","level"];

/* If your <tr> ids differ from the JSON keys, map them here */
const ID_ALIAS = new Map([
  // ["JSON key", "your data-kink-id value"],
]);

/* ---------- helpers ---------- */
function escapeHtml(s){return String(s).replace(/[&<>"']/g,m=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[m]))}
function pick(obj, keys) { for (const k of keys) if (obj && Object.prototype.hasOwnProperty.call(obj, k)) return obj[k]; }
function toNumberish(v) {
  if (typeof v === "number" && !Number.isNaN(v)) return v > 5 && v <= 10 ? v / 2 : v;
  if (typeof v === "string") {
    const t = v.trim();
    if (/^\d+%$/.test(t)) return Number(t.slice(0, -1)) / 20;      // e.g. "80%" -> 4.0 on 0‚Äì5
    if (/^\d+\s*\/\s*\d+$/.test(t)) return Number(t.split("/")[0]); // e.g. "4/5" -> 4
    const n = Number(t);
    if (!Number.isNaN(n)) return n > 5 && n <= 10 ? n / 2 : n;      // handle 1‚Äì10 scales
  }
  return null;
}

/* Accepts varied row shapes and returns {id,label,score} or null */
function mapRow(row) {
  if (!row || typeof row !== "object") return null;
  const candidate = ["", "item", "question", "meta", "data"]
    .map(prefix => prefix ? row[prefix] : row)
    .find(v => v && typeof v === "object") || row;

  const nameLike  = pick(candidate, NAME_KEYS);
  const scoreLike = pick(candidate, SCORE_KEYS);

  const idRaw = (typeof nameLike === "string" ? nameLike : String(nameLike ?? "")).trim();
  if (!idRaw) return null;

  const score = toNumberish(scoreLike);
  const id = ID_ALIAS.get(idRaw) || idRaw;
  return { id, label: idRaw, score };
}

/* Accept {items:[...]}, {answers:[...]}, {data:[...]}, bare array, first array found, or plain object map */
function normalizeSurvey(json) {
  let rows = [];
  let usingObjectMap = false;
  if (Array.isArray(json)) rows = json;
  else if (Array.isArray(json?.items)) rows = json.items;
  else if (Array.isArray(json?.answers)) rows = json.answers;
  else if (Array.isArray(json?.data)) rows = json.data;
  else if (json && typeof json === "object") {
    const firstArray = Object.values(json).find(v => Array.isArray(v));
    if (Array.isArray(firstArray)) rows = firstArray;
    else {
      usingObjectMap = true;
      rows = Object.entries(json);
    }
  }
  if (!rows) rows = [];

  const items = [];
  let missingScores = 0;

  if (usingObjectMap) {
    for (const [k, v] of rows) {
      const score = toNumberish(v);
      if (typeof score !== "number") missingScores++;
      const id = ID_ALIAS.get(k) || k;
      items.push({ id, label: k, score });
    }
  } else {
    for (const r of rows) {
      const m = mapRow(r);
      if (!m) continue;
      if (typeof m.score !== "number") missingScores++;
      items.push({ id: m.id, label: m.label, score: m.score });
    }
  }
  return { items, missingScores };
}

function validateNormalized(n) {
  const errors = [];
  if (!n.items.length) errors.push("No recognizable items with names/ids were found.");
  const scored = n.items.filter(i => typeof i.score === "number");
  if (n.items.length && !scored.length) errors.push("Items found, but none contained numeric scores.");
  return { errors, scoredCount: scored.length, total: n.items.length, missing: n.missingScores };
}

/* ---------- UI feedback ---------- */
function setGlobalError(msgs) {
  const box = document.getElementById("globalError");
  if (!box) return;
  if (!msgs || msgs.length === 0) { box.style.display = "none"; box.innerHTML = ""; return; }
  box.style.display = "block";
  box.innerHTML = msgs.map(m => `<div>‚Ä¢ ${escapeHtml(m)}</div>`).join("");
}

function setStatus(which, text, state) {
  const el = document.getElementById(which === "A" ? "statusA" : "statusB");
  if (!el) return;
  el.textContent = text;
  if (state === true) el.style.color = "#1b5e20";
  else if (state === false) el.style.color = "#b00020";
  else el.style.color = "#666";
}

/* Enable download only when BOTH A and B have at least one numeric score */
function updateUIStates() {
  const btn = document.getElementById("downloadBtn");
  const aOk = !!(partnerAData?.items?.some(i => typeof i.score === "number"));
  const bOk = !!(partnerBData?.items?.some(i => typeof i.score === "number"));
  btn.disabled = !(aOk && bOk);
  if (!aOk || !bOk) {
    setGlobalError([]);
  }
}

// Escape an arbitrary id for use in querySelector
function cssEscape(str){
  return String(str).replace(/["\\#.:><~+^$[\]|(){}=]/g, "\\$&");
}

// Ensure a table row exists for a given id; creates one if missing
function ensureRowExists(id, label){
  let tbody = document.querySelector('tbody');
  if (!tbody){
    const anyRow = document.querySelector('[data-kink-id]');
    if (anyRow) tbody = anyRow.parentElement;
    else return null;
  }
  let row = document.querySelector(`[data-kink-id="${cssEscape(id)}"]`);
  if (row) return row;

  row = document.createElement('tr');
  row.setAttribute('data-kink-id', id);

  const tdLabel = document.createElement('td');
  tdLabel.textContent = label || id;

  const tdA = document.createElement('td');
  tdA.setAttribute('data-cell','A');
  tdA.textContent = 'N/A';

  const tdMatch = document.createElement('td');
  tdMatch.setAttribute('data-cell','Match');
  tdMatch.textContent = 'N/A';

  const tdB = document.createElement('td');
  tdB.setAttribute('data-cell','B');
  tdB.textContent = 'N/A';

  row.append(tdLabel, tdA, tdMatch, tdB);
  tbody.appendChild(row);
  return row;
}

/* ---------- Public upload handlers: wired to both inputs ---------- */
async function handleUpload(file, which) {
  if (!file) return;

  setStatus(which, "Loading...", null);
  await new Promise(r => setTimeout(r));

  try {
    const text = await file.text();
    await new Promise(r => setTimeout(r));
    const json = JSON.parse(text);
    await new Promise(r => setTimeout(r));

    const normalized = normalizeSurvey(json);
    const { errors, scoredCount, total, missing } = validateNormalized(normalized);

    // Store by partner
    if (which === "A") partnerAData = normalized;
    else partnerBData = normalized;

    // Update comparison table right away (no-op if you haven‚Äôt built it)
    updateComparison();

    if (errors.length) {
      setStatus(which, `Loaded ${total} items (${scoredCount} scored). Issues: ${errors.join(" ")}`, false);
    } else {
      const warn = missing ? ` ‚Ä¢ ${missing} item(s) missing scores ‚Üí shown as N/A` : "";
      setStatus(which, `‚úÖ Loaded ${total} items, ${scoredCount} scored${warn}`, true);
    }

    updateUIStates();
    console.info(`[Upload ${which}]`, { total, scoredCount, missing, errors });

  } catch (e) {
    setStatus(which, `Invalid JSON for Survey ${which}. ${e.message}`, false);
    updateUIStates();
  }
}

/* ---------- Table injection (creates missing rows when needed) ---------- */
function updateComparison() {
  const aItems = partnerAData?.items || [];
  const bItems = partnerBData?.items || [];
  const aMap = new Map(aItems.map(i => [i.id, i]));
  const bMap = new Map(bItems.map(i => [i.id, i]));

  const ids = new Set([...aMap.keys(), ...bMap.keys()]);
  let updated = 0;

  ids.forEach(id => {
    const a = aMap.get(id);
    const b = bMap.get(id);
    const label = a?.label || b?.label || id;

    let tr = document.querySelector(`[data-kink-id="${cssEscape(id)}"]`);
    if (!tr) tr = ensureRowExists(id, label);
    if (!tr) return; // still nothing to attach to

    const aCell = tr.querySelector('[data-cell="A"]');
    if (aCell) aCell.textContent = typeof a?.score === 'number' ? String(a.score) : 'N/A';

    const bCell = tr.querySelector('[data-cell="B"]');
    if (bCell) bCell.textContent = typeof b?.score === 'number' ? String(b.score) : 'N/A';

    const matchCell = tr.querySelector('[data-cell="Match"]');
    if (matchCell) {
      if (typeof a?.score === 'number' && typeof b?.score === 'number') {
        const diff = Math.abs(a.score - b.score);
        const pct = Math.max(0, 100 - (diff / 5) * 100);
        matchCell.textContent = `${Math.round(pct)}%`;
      } else {
        matchCell.textContent = 'N/A';
      }
    }

    const flagCell = tr.querySelector('[data-cell="Flag"]');
    if (flagCell) {
      if (typeof a?.score === 'number' && typeof b?.score === 'number') {
        flagCell.textContent = Math.abs(a.score - b.score) >= 3 ? 'üö©' : '';
      } else {
        flagCell.textContent = '';
      }
    }
    updated++;
  });

  if (!updated) {
    setGlobalError(['No matching rows were found or created. Check your ID_ALIAS mappings or table structure.']);
  } else {
    setGlobalError([]);
  }
}

  /* ---------- Wire up inputs & button ---------- */
  document.getElementById("uploadA")?.addEventListener("change", e => handleUpload(e.target.files?.[0], "A"));
  document.getElementById("uploadB")?.addEventListener("change", e => handleUpload(e.target.files?.[0], "B"));

  })();
</script>

<script>
(function installSolidPdfExport(){
  // ---- thresholds/icons
  const TK_THRESH = { star: 90, flag: 60, low: 30 };
  const ICONS = { star: "‚òÖ", flag: "‚öë", low: "üö©", blank: "" };

  // ---- utils
  const num = v => {
    const n = Number(String(v ?? "").trim());
    return Number.isFinite(n) ? n : null;
  };
  const matchPct = (a, b) => {
    const A = num(a), B = num(b);
    if (A == null || B == null) return null;
    return Math.round(100 - (Math.abs(A - B) / 5) * 100);
  };
  const flagFor = pct => {
    if (pct == null) return ICONS.blank;
    if (pct >= TK_THRESH.star) return ICONS.star;
    if (pct >= TK_THRESH.flag) return ICONS.flag;
    if (pct <= TK_THRESH.low)  return ICONS.low;
    return ICONS.blank;
  };

  // ---- collect rows from DOM
  function collectRows() {
    let trs = Array.from(document.querySelectorAll('tbody tr[data-kink-id]'));
    if (trs.length === 0) {
      trs = Array.from(document.querySelectorAll('tbody tr'))
        .filter(tr => tr.querySelector('td'));
    }
    const rows = [];
    for (const tr of trs) {
      const cat = tr.cells?.[0]?.textContent?.trim() || tr.getAttribute('data-kink-id') || "";
      const aTxt = tr.querySelector('td[data-cell="A"]')?.textContent
                ?? tr.cells?.[1]?.textContent ?? "";
      const bTxt = tr.querySelector('td[data-cell="B"]')?.textContent
                ?? tr.cells?.[tr.cells.length - 1]?.textContent ?? "";

      const A = num(aTxt), B = num(bTxt);
      const pct = matchPct(A, B);

      rows.push([
        cat || "‚Äî",
        (A ?? "‚Äî"),
        (pct == null ? "‚Äî" : `${pct}%`),
        flagFor(pct),
        (B ?? "‚Äî")
      ]);
    }
    return rows;
  }

  // ---- call AutoTable for any UMD/attach style
  function runAutoTable(doc, opts) {
    if (typeof doc.autoTable === "function") {
      doc.autoTable(opts);
    } else if (window.jspdf && typeof window.jspdf.autoTable === "function") {
      window.jspdf.autoTable(doc, opts);
    } else {
      throw new Error("jsPDF-AutoTable not found. Include the plugin before this script.");
    }
  }

  // ---- main export function
  async function exportCompatibilityPDF() {
    try {
      if (!(window.jspdf && window.jspdf.jsPDF)) {
        alert("Missing jsPDF. Add the CDN script before this exporter.");
        return;
      }

      const rows = collectRows();
      if (!rows.length) {
        console.warn("[PDF] No data rows found.");
        alert("No data rows found to export. Make sure the table has rows before exporting.");
        return;
      }

      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({ orientation: "landscape", unit: "pt", format: "a4" });

      doc.setFontSize(18);
      doc.text("Talk Kink ‚Ä¢ Compatibility Report", 40, 48);

      runAutoTable(doc, {
        head: [["Category", "Partner A", "Match", "Flag", "Partner B"]],
        body: rows,
        startY: 70,
        styles: { fontSize: 10, cellPadding: 6, overflow: "linebreak" },
        headStyles: { fillColor: [0, 0, 0], textColor: [255, 255, 255], fontStyle: "bold" },
        columnStyles: {
          0: { halign: "left"  },
          1: { halign: "center" },
          2: { halign: "center" },
          3: { halign: "center" },
          4: { halign: "center" }
        }
      });

      doc.save("compatibility-report.pdf");
    } catch (err) {
      console.error("[PDF] Export failed:", err);
      alert("PDF export failed: " + err.message);
    }
  }

  // ---- bind button
  const btn = document.getElementById("downloadBtn") || document.querySelector("[data-download-pdf]");
  if (btn) btn.onclick = exportCompatibilityPDF;
  window.downloadCompatibilityPDF = exportCompatibilityPDF;

  // Debug info
  (function debugLog(){
    const rows = collectRows();
    console.log(`[PDF] Found ${rows.length} data rows. First row:`, rows[0]);
  })();
})();
</script>

<!-- ===== TalkKink Compatibility ‚Äì Test Harness =====
Place this AFTER your existing compatibility script (so it can call handleUpload). -->

<style>
  .tk-testbar { display:flex; flex-wrap:wrap; gap:.5rem; margin:1rem 0; }
  .tk-note { font-size:.9rem; opacity:.8; }
</style>

<div class="tk-testbar" id="tk-tests">
  <button type="button" onclick="TK_loadSample('A','objectMap05')">Load Sample A (Object map 0‚Äì5)</button>
  <button type="button" onclick="TK_loadSample('B','array10')">Load Sample B (Array 1‚Äì10 ‚Üí scaled)</button>
  <button type="button" onclick="TK_loadSample('B','percent')">Load Sample B (Percent strings)</button>
  <button type="button" onclick="TK_loadSample('B','mismatch')">Load Sample B (Fuzzy label mismatch)</button>
  <button type="button" onclick="TK_loadSample('A','malformed')">Load Malformed JSON ‚Üí error</button>
  <div class="tk-note">Use these to verify parsing, fuzzy mapping, scaling, and PDF gating.</div>
</div>

<script>
/* ------- Test Fixtures ------- */
const TK_FIXTURES = {
  /* A: object map like your export (0‚Äì5 scale) */
  objectMap05: {
    "Choosing my partner‚Äôs outfit for the day or a scene": 5,
    "Selecting their underwear, lingerie, or base layers": 5,
    "Styling their hair (braiding, brushing, tying, etc.)": 1,
    "Picking head coverings (bonnets, veils, hoods, hats) for mood or protocol": 1,
    "Offering makeup, polish, or accessories as part of ritual or play": 5
  },

  /* B: array of rows on a 1‚Äì10 scale ‚Üí should normalize to 0‚Äì5 */
  array10: [
    { label: "Choosing my partner‚Äôs outfit for the day or a scene", rating: 8 },
    { label: "Selecting their underwear, lingerie, or base layers", rating: 7 },
    { label: "Styling their hair (braiding, brushing, tying, etc.)", rating: 2 },
    { label: "Picking head coverings (bonnets, veils, hoods, hats) for mood or protocol", rating: 3 },
    { label: "Offering makeup, polish, or accessories as part of ritual or play", rating: 9 }
  ],

  /* B: percent strings ‚Üí should coerce to 0‚Äì5 (80% ‚Üí 4.0) */
  percent: {
    "Choosing my partner‚Äôs outfit for the day or a scene": "80%",
    "Selecting their underwear, lingerie, or base layers": "60%",
    "Styling their hair (braiding, brushing, tying, etc.)": "20%",
    "Picking head coverings (bonnets, veils, hoods, hats) for mood or protocol": "40%",
    "Offering makeup, polish, or accessories as part of ritual or play": "100%"
  },

  /* B: labels with punctuation/spacing differences ‚Üí tests fuzzy match */
  mismatch: {
    "Choosing my partners outfit for the day (or scene)": 4,
    "Selecting underwear / lingerie / base layers": 3,
    "Styling their hair - braiding, brushing, tying etc": 2,
    "Picking head coverings (hoods, hats, veils)": 2,
    "Makeup / polish / accessories as ritual or play": 5
  },

  /* Malformed JSON (string, not parseable on purpose) */
  malformed: "{ this is not valid JSON }"
};

/* ------- Loader: calls your existing handleUpload(file, 'A'|'B') ------- */
async function TK_loadSample(which, key){
  const data = TK_FIXTURES[key];
  let file;

  if (key === "malformed") {
    file = new File([TK_FIXTURES.malformed], `malformed-${which}.json`, { type: "application/json" });
  } else {
    const text = JSON.stringify(data, null, 2);
    file = new File([text], `sample-${key}-${which}.json`, { type: "application/json" });
  }

  // Prefer the real UI pathway if your script uses input change listeners
  const input = document.getElementById(which === 'A' ? 'uploadA' : 'uploadB');
  if (input) {
    // Trigger your existing handler path by dispatching a synthetic change
    const dt = new DataTransfer();
    dt.items.add(file);
    input.files = dt.files;
    input.dispatchEvent(new Event('change', { bubbles: true }));
    return;
  }

  // Fallback: call global handleUpload directly if exposed
  if (typeof handleUpload === "function") {
    await handleUpload(file, which);
  } else {
    console.warn("handleUpload is not in global scope; ensure the main module script is loaded first.");
  }
}

/* ------- Quick ‚ÄúTest Plan‚Äù you can follow step-by-step (visible in console) ------- */
console.log(`TalkKink Test Plan:
1) Click "Load Sample A (Object map 0‚Äì5)" ‚Üí Partner A column should fill with 5,5,1,1,5.
2) Click "Load Partner Survey" (if present) or one of the B buttons:
   a) "Array 1‚Äì10" ‚Üí values normalize; Match% computed.
   b) "Percent strings" ‚Üí 80% becomes 4.0, etc.
   c) "Fuzzy mismatch" ‚Üí labels with different punctuation still map to rows.
3) Try "Malformed JSON" ‚Üí status should turn red with an error message; Download remains disabled.
4) After both A and B are valid, Download button enables. If jsPDF + AutoTable are on the page, a PDF is generated.
`);
</script>
<!-- ‚úÖ 1) Add this *once* near the end of every page that was freezing (before </body>) -->
<script>
/* ---------- TalkKink Safe Bootstrap (drop-in) ---------- */
(function () {
  const LOG = (...a) => console.log("[TK-SAFE]", ...a);

  /* A. QUICK SANITY CHECKS ‚Äî find & warn about merge markers (these often lock pages) */
  try {
    const html = document.documentElement.innerHTML;
    if (html.includes("<<<<<<<") || html.includes("=======") || html.includes(">>>>>>>")) {
      console.warn("[TK-SAFE] Merge conflict markers detected in DOM. Remove them to avoid broken JS/CSS.");
    }
  } catch (_) {}

  /* B. ONE-TIME INIT GUARD (prevents duplicate event bind/render loops) */
  if (window.__TK_INITED__) {
    LOG("Init skipped: already initialized.");
    return;
  }
  window.__TK_INITED__ = true;

  /* C. SAFE-MODE FLAGS (use ?safe=1 or ?nopdf=1 or ?noscore=1 to bypass heavy work) */
  const params = new URLSearchParams(location.search);
  const SAFE_MODE  = params.has("safe");
  const NO_PDF     = SAFE_MODE || params.has("nopdf");
  const NO_SCORE   = SAFE_MODE || params.has("noscore");

  if (SAFE_MODE) LOG("SAFE MODE ON: skipping scoring/render and lazy-loading libraries.");

  /* D. SMALL UTILITIES */
  const byId = (id) => document.getElementById(id);
  function once(el, type, handler, opts) {
    // prevent stacked duplicate listeners after HMR/partials
    el && el.addEventListener(type, function f(e) {
      el.removeEventListener(type, f, opts);
      handler(e);
    }, opts);
  }
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      if (document.querySelector(`script[src="${src}"]`)) return resolve();
      const s = document.createElement("script");
      s.src = src; s.async = true; s.defer = true;
      s.onload = resolve;
      s.onerror = () => reject(new Error("Failed to load " + src));
      document.head.appendChild(s);
    });
  }
  function idle(fn) {
    // yield back to the browser to keep UI responsive
    return (window.requestIdleCallback || ((cb)=>setTimeout(cb,0)))(fn);
  }

  /* E. LAZY LOADERS FOR HEAVY LIBS (loaded only on click) */
  async function ensureJsPDF() {
    if (!(window.jspdf && window.jspdf.jsPDF)) {
      await loadScript("https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js");
    }
  }
  async function ensureAutoTable() {
    // Only after jsPDF UMD maps window.jspdf.jsPDF
    await ensureJsPDF();
    const hasAT = (window.jspdf && window.jspdf.jsPDF && window.jspdf.jsPDF.API && window.jspdf.jsPDF.API.autoTable)
               || (window.jspdf && window.jspdf.autoTable);
    if (!hasAT) {
      await loadScript("https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.3/jspdf.plugin.autotable.min.js");
    }
  }

  /* F. DEFENSIVE BINDINGS (buttons used across pages) */
  idle(() => {
    // PDF buttons (compatibility, IKA, etc.)
    const dl1 = byId("downloadBtn");
    const dl2 = byId("downloadPdfBtn");
    const anyDownload = dl1 || dl2;

    if (anyDownload) {
      const handler = async (e) => {
        e.preventDefault();
        if (NO_PDF) { alert("PDF disabled (safe mode). Add ?safe=0 or remove ?nopdf."); return; }
        try {
          // Lazy load heavy libs only now
          await ensureAutoTable();
          // Yield once more before heavy export:
          await new Promise(r => setTimeout(r, 0));
          // Call your existing exporter (must be defined elsewhere)
          if (typeof window.TKPDF_export === "function") {
            await window.TKPDF_export();
          } else if (typeof window.TKPDF_forceDark === "function") {
            await window.TKPDF_forceDark();
          } else if (typeof window.exportIKAPdf === "function") {
            await window.exportIKAPdf();
          } else {
            alert("Export function not found. Expected TKPDF_export/TKPDF_forceDark/exportIKAPdf.");
          }
        } catch (err) {
          console.error("[TK-SAFE] PDF export failed:", err);
          alert("PDF export failed: " + (err?.message || err));
        }
      };

      // Bind once to whichever exists
      if (dl1) once(dl1, "click", handler);
      if (dl2) once(dl2, "click", handler);
      LOG("Bound PDF button(s).");
    }

    // File upload styled label (IKA)
    const fileInput = byId("ikaFile");
    const fileLabel = document.querySelector('label[for="ikaFile"]');
    if (fileInput && fileLabel) {
      once(fileLabel, "click", () => fileInput.click());
      LOG("Bound Upload Survey label‚Üíinput.");
    }
  });

  /* G. STOP RUNNING EXPENSIVE WORK ON LOAD (scoring/rendering) */
  // Wrap your page‚Äôs auto-render or scoring in this gate:
  window.TK_canRunHeavy = function () {
    if (SAFE_MODE) return false;
    // Avoid running more than once
    if (window.__TK_HEAVY_RAN__) return false;
    window.__TK_HEAVY_RAN__ = true;
    return true;
  };

  // Example usage for your pages (leave here; your code can call it):
  // if (window.TK_canRunHeavy()) {
  //   // run scoring/render here or schedule with idle(...)
  //   idle(() => window.renderResults && window.renderResults());
  // }

  /* H. GLOBAL CATCH FOR ACCIDENTAL LONG TASKS */
  // If something still locks the UI, advise safe mode.
  window.addEventListener("error", (e) => {
    console.warn("[TK-SAFE] Window error:", e.message);
  });
})();
</script>
<!-- ---------- End Safe Bootstrap ---------- -->
</body>
</html>
