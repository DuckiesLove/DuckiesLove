<!-- ================= CODEX: Dark PDF + Consent + Robust Uploads ================= -->
<input id="yourFile"    type="file" accept="application/json" style="display:none" />
<input id="partnerFile" type="file" accept="application/json" style="display:none" />

<button id="yourBtn"    type="button">Upload Your Survey</button>
<button id="partnerBtn" type="button">Upload Partnerâ€™s Survey</button>
<button id="downloadBtn" type="button">Download PDF</button>

<script>
(function () {
  const $ = (s, r=document) => r.querySelector(s);

  // Buttons/inputs
  const yourBtn     = $('#yourBtn');
  const partnerBtn  = $('#partnerBtn');
  const downloadBtn = $('#downloadBtn');
  const yourInput   = $('#yourFile');
  const partnerInput= $('#partnerFile');

  // State
  let yourBlob=null, partnerBlob=null, yourJSON=null, partnerJSON=null;
  let libsReady=false;

  // â€”â€”â€”â€”â€”â€”â€”â€”â€” Load libs on demand with fallback â€”â€”â€”â€”â€”â€”â€”â€”â€”
  async function loadLibs() {
    if (libsReady && window.jspdf && window.jspdf.jsPDF && window.jspdf_autotable) return true;
    const load = (src) => new Promise((res, rej)=>{ const s=document.createElement('script'); s.src=src; s.onload=res; s.onerror=rej; document.head.appendChild(s); });
    try {
      if (!window.jspdf) await load('https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js');
      if (!window.jspdf_autotable) await load('https://unpkg.com/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js');
      libsReady = true;
      return true;
    } catch {
      // fallback CDN
      await load('https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js');
      await load('https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js');
      libsReady = true; 
      return true;
    }
  }

  // â€”â€”â€”â€”â€”â€”â€”â€”â€” Fix: always fire change (clear value BEFORE click) â€”â€”â€”â€”â€”â€”â€”â€”â€”
  function openFilePicker(input){
    if (!input) return;
    input.value = '';        // important: clear BEFORE click so selecting same file fires 'change'
    input.click();
  }

  yourBtn   && yourBtn.addEventListener('click',   () => openFilePicker(yourInput));
  partnerBtn&& partnerBtn.addEventListener('click',() => openFilePicker(partnerInput));

  // â€”â€”â€”â€”â€”â€”â€”â€”â€” Fast change handlers (stash only) â€”â€”â€”â€”â€”â€”â€”â€”â€”
  yourInput && yourInput.addEventListener('change', (ev)=>{
    const f = ev.target?.files?.[0]; if(!f) return;
    yourBlob = f;
    // optional toast/alert you already use:
    (window.tkNotifyYourReady ? tkNotifyYourReady() : alert('Uploaded âœ“'));
  });

  partnerInput && partnerInput.addEventListener('change', (ev)=>{
    const f = ev.target?.files?.[0]; if(!f) return;
    const ok = confirm(
      'Before importing a partnerâ€™s survey, confirm you have their explicit consent to upload and compare their responses here.\n\nClick â€œOKâ€ to continue or â€œCancelâ€ to stop.'
    );
    if(!ok) return;
    partnerBlob = f;
    (window.tkNotifyPartnerReady ? tkNotifyPartnerReady() : alert('Uploaded âœ“\n(You confirmed you have your partnerâ€™s explicit consent.)'));
  });

  // â€”â€”â€”â€”â€”â€”â€”â€”â€” Parse lazily â€”â€”â€”â€”â€”â€”â€”â€”â€”
  async function ensureParsed(){
    await Promise.resolve(); // microtask to keep change fast
    if (yourBlob && !yourJSON)     yourJSON     = JSON.parse(await yourBlob.text());
    if (partnerBlob && !partnerJSON) partnerJSON = JSON.parse(await partnerBlob.text());
  }

  // â€”â€”â€”â€”â€”â€”â€”â€”â€” Download PDF â€”â€”â€”â€”â€”â€”â€”â€”â€”
  downloadBtn && downloadBtn.addEventListener('click', async ()=>{
    try {
      await loadLibs();
      await ensureParsed();

      if (!yourJSON && !partnerJSON) {
        alert('Load at least one survey first (yours or partner).');
        return;
      }
      await generateDarkPDF(yourJSON, partnerJSON);
    } catch (e) {
      console.error(e);
      alert('Could not generate the PDF. Check your connection and try again.');
    }
  });

  // â€”â€”â€”â€”â€”â€”â€”â€”â€” Helpers â€”â€”â€”â€”â€”â€”â€”â€”â€”
  function rowsFromTalkKink(json){
    if(!json) return [];
    const map = json.answersById || {};
    const out = [];
    for (const [id, score] of Object.entries(map)) {
      const parts=id.split('-');
      const role=parts.at(-1);
      const category=(parts[0]+' '+parts[1]).replace(/\b\w/g,m=>m.toUpperCase());
      const item=parts.slice(2,-1).join(' ').replace(/\bTv\b/gi,'TV').replace(/\s+/g,' ').trim();
      out.push({Category:category, Item:item.charAt(0).toUpperCase()+item.slice(1), Role:role.charAt(0).toUpperCase()+role.slice(1), Score:Number(score)});
    }
    out.sort((a,b)=>a.Category.localeCompare(b.Category)||a.Role.localeCompare(b.Role)||a.Item.localeCompare(b.Item));
    return out;
  }

  async function generateDarkPDF(yourJSON, partnerJSON){
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit:'pt', format:'letter' });
    const W = doc.internal.pageSize.getWidth(), H = doc.internal.pageSize.getHeight();

    function paint() {
      doc.setFillColor(10,10,12); doc.rect(0,0,W,H,'F');
      doc.setDrawColor(0,255,255); doc.setLineWidth(1); doc.line(48,68,W-48,68);
      doc.setTextColor(255,255,255); doc.setFont('helvetica','bold'); doc.setFontSize(20);
      doc.text('TalkKink Compatibility â€” Printable Report', 48, 50);
      doc.setFont('helvetica','normal'); doc.setFontSize(10); doc.setTextColor(170,200,255);
      doc.text('Generated: '+new Date().toLocaleString(), 48, 62);
    }
    paint();

    const CYAN = [0,255,255];
    const BODY_BG_1 = [8,8,10];
    const BODY_BG_2 = [13,13,17];
    const GRID = [30,30,38];
    const WHITE = [255,255,255];

    const tableBase = {
      theme:'grid',
      margin:{ left:48, right:48 },
      styles:{ font:'helvetica', fontSize:10, cellPadding:4, textColor:WHITE, fillColor:BODY_BG_1, lineColor:GRID, lineWidth:0.25 },
      alternateRowStyles:{ fillColor:BODY_BG_2 },
      headStyles:{ fillColor:[0,0,0], textColor:CYAN, lineColor:GRID, lineWidth:0.25, fontStyle:'bold' },
      didAddPage:()=>paint()
    };

    const A = rowsFromTalkKink(yourJSON);
    const B = rowsFromTalkKink(partnerJSON);
    const hasA = A.length>0, hasB = B.length>0;

    let y = 90;

    if (hasA && hasB) {
      const cats=[...new Set([...A,...B].map(r=>r.Category))];
      for(const cat of cats){
        doc.setFont('helvetica','bold'); doc.setFontSize(16); doc.setTextColor(WHITE); doc.text(cat,48,y); y+=12;
        const body = buildAB(A.filter(r=>r.Category===cat), B.filter(r=>r.Category===cat));
        doc.autoTable({ ...tableBase, startY:y+8, head:[['Role','Item','Partner A','Match','Flag','Partner B']], body,
          columnStyles:{0:{cellWidth:70},1:{cellWidth:280},2:{cellWidth:60,halign:'center'},3:{cellWidth:60,halign:'center'},4:{cellWidth:40,halign:'center'},5:{cellWidth:60,halign:'center'}} });
        y = doc.lastAutoTable.finalY + 16; if (y > H-72) { doc.addPage(); y = 90; }
      }
    } else {
      const rows = hasA ? A : B; const who = hasA ? 'Partner A' : 'Partner';
      const cats=[...new Set(rows.map(r=>r.Category))];
      for(const cat of cats){
        doc.setFont('helvetica','bold'); doc.setFontSize(16); doc.setTextColor(WHITE); doc.text(`${cat} â€” ${who}`,48,y); y+=12;
        const body = rows.filter(r=>r.Category===cat).map(r=>[r.Role,r.Item,String(r.Score)]);
        doc.autoTable({ ...tableBase, startY:y+8, head:[['Role','Item','Score']], body,
          columnStyles:{0:{cellWidth:90},1:{cellWidth:350},2:{cellWidth:60,halign:'center'}} });
        y = doc.lastAutoTable.finalY + 16; if (y > H-72) { doc.addPage(); y = 90; }
      }
    }

    const name = (hasA && hasB)?'compatibility-pretty-dark.pdf':'partner-survey-pretty-dark.pdf';
    doc.save(name);
  }

  function buildAB(A,B){
    const key = r=>`${r.Role}|${r.Item}`.toLowerCase();
    const mA = Object.fromEntries(A.map(r=>[key(r),r]));
    const mB = Object.fromEntries(B.map(r=>[key(r),r]));
    const keys=[...new Set([...Object.keys(mA),...Object.keys(mB)])].sort();
    const rows=[];
    for(const k of keys){
      const a=mA[k], b=mB[k];
      const role=a?.Role||b?.Role||'';
      const item=a?.Item||b?.Item||'';
      const aS=Number.isFinite(a?.Score)?a.Score:'';
      const bS=Number.isFinite(b?.Score)?b.Score:'';
      let match='', flag='';
      if (a && b) {
        const pct = Math.round((1 - Math.abs(a.Score - b.Score)/5)*100);
        match = pct+'%';
        if (pct>=90) flag='â­'; else if (pct<=30) flag='ğŸš©';
        if ((a.Score===5&&b.Score<5) || (b.Score===5&&a.Score<5)) flag = flag? flag+' ğŸŸ¨' : 'ğŸŸ¨';
      }
      rows.push([role,item,String(aS),match,flag,String(bS)]);
    }
    return rows;
  }
})();
</script>
<!-- ===================================================================== -->
