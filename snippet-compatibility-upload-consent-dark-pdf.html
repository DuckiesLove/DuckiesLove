<!-- ================= CODEX: Dark PDF + Consent + Robust Uploads ================= -->
<input id="yourFile"    type="file" accept="application/json" style="display:none" />
<input id="partnerFile" type="file" accept="application/json" style="display:none" />

<button id="yourBtn"    type="button">Upload Your Survey</button>
<button id="partnerBtn" type="button">Upload Partner’s Survey</button>
<button id="downloadBtn" type="button">Download PDF</button>

<script>
(function () {
  const $ = (s, r=document) => r.querySelector(s);

  // Buttons/inputs
  const yourBtn     = $('#yourBtn');
  const partnerBtn  = $('#partnerBtn');
  const downloadBtn = $('#downloadBtn');
  const yourInput   = $('#yourFile');
  const partnerInput= $('#partnerFile');

  // State
  let yourBlob=null, partnerBlob=null, yourJSON=null, partnerJSON=null;
  let libsReady=false;

  // ————————— Load libs on demand with fallback —————————
  async function loadLibs() {
    if (libsReady && window.jspdf && window.jspdf.jsPDF && window.jspdf_autotable) return true;
    const load = (src) => new Promise((res, rej)=>{ const s=document.createElement('script'); s.src=src; s.onload=res; s.onerror=rej; document.head.appendChild(s); });
    try {
      if (!window.jspdf) await load('https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js');
      if (!window.jspdf_autotable) await load('https://unpkg.com/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js');
      libsReady = true;
      return true;
    } catch {
      // fallback CDN
      await load('https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js');
      await load('https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js');
      libsReady = true; 
      return true;
    }
  }

  // ————————— Fix: always fire change (clear value BEFORE click) —————————
  function openFilePicker(input){
    if (!input) return;
    input.value = '';        // important: clear BEFORE click so selecting same file fires 'change'
    input.click();
  }

  yourBtn   && yourBtn.addEventListener('click',   () => openFilePicker(yourInput));
  partnerBtn&& partnerBtn.addEventListener('click',() => openFilePicker(partnerInput));

  // ————————— Fast change handlers (stash only) —————————
  yourInput && yourInput.addEventListener('change', (ev)=>{
    const f = ev.target?.files?.[0]; if(!f) return;
    yourBlob = f;
    // optional toast/alert you already use:
    (window.tkNotifyYourReady ? tkNotifyYourReady() : alert('Uploaded ✓'));
  });

  partnerInput && partnerInput.addEventListener('change', (ev)=>{
    const f = ev.target?.files?.[0]; if(!f) return;
    const ok = confirm(
      'Before importing a partner’s survey, confirm you have their explicit consent to upload and compare their responses here.\n\nClick “OK” to continue or “Cancel” to stop.'
    );
    if(!ok) return;
    partnerBlob = f;
    (window.tkNotifyPartnerReady ? tkNotifyPartnerReady() : alert('Uploaded ✓\n(You confirmed you have your partner’s explicit consent.)'));
  });

  // ————————— Parse lazily —————————
  async function ensureParsed(){
    await Promise.resolve(); // microtask to keep change fast
    if (yourBlob && !yourJSON)     yourJSON     = JSON.parse(await yourBlob.text());
    if (partnerBlob && !partnerJSON) partnerJSON = JSON.parse(await partnerBlob.text());
  }

  // ————————— Download PDF —————————
  downloadBtn && downloadBtn.addEventListener('click', async ()=>{
    try {
      await loadLibs();
      await ensureParsed();

      if (!yourJSON && !partnerJSON) {
        alert('Load at least one survey first (yours or partner).');
        return;
      }
      await generateDarkPDF(yourJSON, partnerJSON);
    } catch (e) {
      console.error(e);
      alert('Could not generate the PDF. Check your connection and try again.');
    }
  });

  // ————————— Helpers —————————
  function rowsFromTalkKink(json){
    if(!json) return [];
    const map = json.answersById || {};
    const out = [];
    for (const [id, score] of Object.entries(map)) {
      const parts=id.split('-');
      const role=parts.at(-1);
      const category=(parts[0]+' '+parts[1]).replace(/\b\w/g,m=>m.toUpperCase());
      const item=parts.slice(2,-1).join(' ').replace(/\bTv\b/gi,'TV').replace(/\s+/g,' ').trim();
      out.push({Category:category, Item:item.charAt(0).toUpperCase()+item.slice(1), Role:role.charAt(0).toUpperCase()+role.slice(1), Score:Number(score)});
    }
    out.sort((a,b)=>a.Category.localeCompare(b.Category)||a.Role.localeCompare(b.Role)||a.Item.localeCompare(b.Item));
    return out;
  }

  async function generateDarkPDF(yourJSON, partnerJSON){
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit:'pt', format:'letter' });
    const W = doc.internal.pageSize.getWidth();
    const H = doc.internal.pageSize.getHeight();

    const CONTENT_W = Math.min(680, W - 96);
    const ML = (W - CONTENT_W) / 2;
    const MR = ML;
    // Center X of the CONTENT block (use this for title, timestamp, section headings)
    const CX = ML + CONTENT_W / 2;
    const TITLE_Y = 46;
    const HEADER_RULE_Y = TITLE_Y + 28;
    const BODY_START_Y = HEADER_RULE_Y + 24;

    function paint() {
      // page background
      doc.setFillColor(10, 10, 12);
      doc.rect(0, 0, W, H, 'F');

      // Title (centered on CONTENT, not full page)
      doc.setTextColor(255, 255, 255);
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(20);
      doc.text('TalkKink Compatibility', CX, 50, { align: 'center' });

      // Timestamp (smaller, centered on CONTENT)
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(9);
      doc.setTextColor(170, 200, 255);
      doc.text('Generated: ' + new Date().toLocaleString(), CX, 64, { align: 'center' });

      // Cyan rule under header, exactly width of CONTENT block
      doc.setDrawColor(0, 255, 255);
      if (typeof doc.setLineWidth === 'function') doc.setLineWidth(1);
      doc.line(ML, 72, ML + CONTENT_W, 72);
    }
    paint();

    const CYAN=[0,255,255], BODY1=[8,8,10], BODY2=[13,13,17], GRID=[30,30,38], WHITE=[255,255,255];
    const GREEN=[0,200,140], YELLOW=[255,210,70], RED=[255,86,86];

    const base = {
      theme:'grid',
      tableWidth: CONTENT_W,
      margin:{ left:ML, right:MR },
      styles:{ font:'helvetica', fontSize:10, cellPadding:4, textColor:WHITE, fillColor:BODY1, lineColor:GRID, lineWidth:0.25 },
      alternateRowStyles:{ fillColor: BODY2 },
      headStyles:{ fillColor:[0,0,0], textColor:CYAN, lineColor:GRID, lineWidth:0.25, fontStyle:'bold' },
      didAddPage:()=>paint()
    };

    const A = rowsFromTalkKink(yourJSON);
    const B = rowsFromTalkKink(partnerJSON);
    const hasA = A.length>0, hasB = B.length>0;

    let y = BODY_START_Y;
    const cat = t => { doc.setFont('helvetica','bold'); doc.setFontSize(16); doc.setTextColor(255,255,255); doc.text(t, CX, y, {align:'center'}); y+=12; };

    if (hasA && hasB) {
      const cats=[...new Set([...A,...B].map(r=>r.Category))];
      for(const c of cats){
        cat(c);
        const body = buildAB(A.filter(r=>r.Category===c), B.filter(r=>r.Category===c));
        doc.autoTable({
          ...base,
          ...withFlagDotHooks('flag'),
          startY:y+8,
          columns:[
            { header:'Role', dataKey:'role' },
            { header:'Item', dataKey:'item' },
            { header:'Partner A', dataKey:'a' },
            { header:'Match', dataKey:'match' },
            { header:'Flag', dataKey:'flag' },
            { header:'Partner B', dataKey:'b' }
          ],
          body,
          columnStyles:{
            role:{ cellWidth:80 },
            item:{ cellWidth: CONTENT_W - (80+70+60+50+70) },
            a:{ cellWidth:70, halign:'center' },
            match:{ cellWidth:60, halign:'center' },
            flag:{ cellWidth:50, halign:'left' },
            b:{ cellWidth:70, halign:'center' }
          }
        });
        y = doc.lastAutoTable.finalY + 18;
        if (y > H-HEADER_RULE_Y) { doc.addPage(); paint(); y = BODY_START_Y; }
      }
    } else {
      const rows = hasA ? A : B; const who = hasA ? 'Partner A' : 'Partner';
      const cats=[...new Set(rows.map(r=>r.Category))];
      for(const c of cats){
        cat(`${c} — ${who}`);
        const body = rows.filter(r=>r.Category===c).map(r=>({ role:r.Role, item:r.Item, score:String(r.Score) }));
        doc.autoTable({
          ...base,
          startY:y+8,
          columns:[
            { header:'Role', dataKey:'role' },
            { header:'Item', dataKey:'item' },
            { header:'Score', dataKey:'score' }
          ],
          body,
          columnStyles:{
            role:{ cellWidth:100 },
            item:{ cellWidth: CONTENT_W - (100+70) },
            score:{ cellWidth:70, halign:'center' }
          }
        });
        y = doc.lastAutoTable.finalY + 18;
        if (y > H-HEADER_RULE_Y) { doc.addPage(); paint(); y = BODY_START_Y; }
      }
    }

    const name = (hasA && hasB)?'compatibility-pretty-dark.pdf':'partner-survey-pretty-dark.pdf';
    doc.save(name);

    function buildAB(Arows, Brows){
      const key = r=>`${r.Role}|${r.Item}`.toLowerCase();
      const mA = Object.fromEntries(Arows.map(r=>[key(r),r]));
      const mB = Object.fromEntries(Brows.map(r=>[key(r),r]));
      const keys=[...new Set([...Object.keys(mA),...Object.keys(mB)])].sort();
      return keys.map(k=>{
        const a=mA[k], b=mB[k];
        const role=a?.Role||b?.Role||'';
        const item=a?.Item||b?.Item||'';
        const aS=Number.isFinite(a?.Score)?a.Score:null;
        const bS=Number.isFinite(b?.Score)?b.Score:null;
        let pct=null, flagColor=null;
        if (aS!=null && bS!=null) {
          pct = Math.round((1 - Math.abs(aS - bS)/5)*100);
          if (pct>85) flagColor = GREEN;
          else if (pct>=50) flagColor = YELLOW;
          else flagColor = RED;
        }
        return {
          role,
          item,
          a: aS==null?'':String(aS),
          match: pct==null?'':pct+'%',
          flag:'',
          flagColor,
          b: bS==null?'':String(bS)
        };
      });
    }

    function withFlagDotHooks(flagColKey){
      return {
        didDrawCell(data){
          if (data.section==='body' && data.column.dataKey===flagColKey) {
            const color = data.row.raw.flagColor;
            if (!color) return;
            const { x, y, height } = data.cell;
            const cx = x + 10;
            const cy = y + height/2;
            const r = 4;
            const [rC,gC,bC] = color;
            doc.setFillColor(rC,gC,bC);
            doc.circle(cx, cy, r, 'F');
            const baseFill = data.row.index % 2 === 0 ? BODY1 : BODY2;
            const [bR,bG,bB] = baseFill;
            doc.setFillColor(bR,bG,bB);
          }
        }
      };
    }
  }
})();
</script>
<!-- ===================================================================== -->
