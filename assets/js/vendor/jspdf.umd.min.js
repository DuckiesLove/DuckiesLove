(function (global) {
  'use strict';

  function clamp255(value) {
    const num = Number(value);
    if (!Number.isFinite(num)) return 0;
    return Math.max(0, Math.min(255, Math.round(num)));
  }

  function formatFloat(value) {
    return Number(value || 0)
      .toFixed(2)
      .replace(/\.00$/, '')
      .replace(/(\.\d)0$/, '$1');
  }

  class LiteJsPDF {
    constructor(options = {}) {
      const { unit = 'pt', format = 'letter' } = options;
      const presets = {
        letter: { width: 612, height: 792 },
        a4: { width: 595.28, height: 841.89 }
      };
      const preset = typeof format === 'string' ? presets[String(format).toLowerCase()] : null;
      const width = Number(options.width || preset?.width || 612);
      const height = Number(options.height || preset?.height || 792);

      if (unit !== 'pt') {
        const factor = unit === 'mm' ? 72 / 25.4 : unit === 'cm' ? 72 / 2.54 : unit === 'in' ? 72 : 1;
        this.width = width * factor;
        this.height = height * factor;
      } else {
        this.width = width;
        this.height = height;
      }

      this.pages = [];
      this.pageIndex = -1;
      this.fontSize = 12;
      this.fontStyle = 'normal';
      this.textColor = [0, 0, 0];
      this.fillColor = [255, 255, 255];
      this.strokeColor = [0, 0, 0];
      this.lineWidth = 1;

      this.internal = {
        pageSize: {
          getWidth: () => this.width,
          getHeight: () => this.height
        },
        getFontSize: () => this.fontSize,
        scaleFactor: 1
      };

      this.addPage();
    }

    addPage() {
      this.pages.push({ commands: [] });
      this.pageIndex = this.pages.length - 1;
      return this;
    }

    _cmd(command) {
      if (!this.pages[this.pageIndex]) {
        this.pages[this.pageIndex] = { commands: [] };
      }
      this.pages[this.pageIndex].commands.push(String(command));
    }

    _formatColor(color) {
      const [r, g, b] = Array.isArray(color) ? color : [0, 0, 0];
      return [clamp255(r) / 255, clamp255(g) / 255, clamp255(b) / 255]
        .map((part) => part.toFixed(3).replace(/\.0+$/, '').replace(/0+$/, '').replace(/\.$/, '') || '0')
        .join(' ');
    }

    _formatLineWidth() {
      return formatFloat(this.lineWidth) || '1';
    }

    _toPdfY(y) {
      return this.height - Number(y || 0);
    }

    setFillColor(r = 0, g = 0, b = 0) {
      this.fillColor = [clamp255(r), clamp255(g), clamp255(b)];
      return this;
    }

    getFillColor() {
      return [...this.fillColor];
    }

    setDrawColor(r = 0, g = 0, b = 0) {
      this.strokeColor = [clamp255(r), clamp255(g), clamp255(b)];
      return this;
    }

    getDrawColor() {
      return [...this.strokeColor];
    }

    setTextColor(r = 0, g = 0, b = 0) {
      this.textColor = [clamp255(r), clamp255(g), clamp255(b)];
      return this;
    }

    getTextColor() {
      return [...this.textColor];
    }

    setLineWidth(width = 1) {
      const num = Number(width);
      if (Number.isFinite(num) && num > 0) {
        this.lineWidth = num;
      }
      return this;
    }

    setFont(_font = 'helvetica', style = 'normal') {
      this.fontStyle = String(style || 'normal');
      return this;
    }

    setFontSize(size = 12) {
      const num = Number(size);
      if (Number.isFinite(num) && num > 0) {
        this.fontSize = num;
      }
      return this;
    }

    getFontSize() {
      return this.fontSize;
    }

    splitTextToSize(text, maxWidth) {
      const raw = String(text ?? '');
      const width = Number(maxWidth);
      if (!Number.isFinite(width) || width <= 0) {
        return raw.split(/\r?\n/);
      }
      const approxCharWidth = Math.max(this.fontSize * 0.55, 1);
      const maxChars = Math.max(Math.floor(width / approxCharWidth), 1);
      const lines = [];

      raw.replace(/\r\n?/g, '\n')
        .split('\n')
        .forEach((line) => {
          if (!line) {
            lines.push('');
            return;
          }
          const words = line.split(/\s+/);
          let current = '';
          const push = () => {
            if (current) {
              lines.push(current);
              current = '';
            }
          };
          words.forEach((word) => {
            if (!word) return;
            if (!current) {
              if (word.length <= maxChars) {
                current = word;
              } else {
                for (let i = 0; i < word.length; i += maxChars) {
                  const chunk = word.slice(i, i + maxChars);
                  if (chunk.length === maxChars) lines.push(chunk);
                  else current = chunk;
                }
              }
              return;
            }
            const candidate = `${current} ${word}`;
            if (candidate.length <= maxChars) {
              current = candidate;
            } else {
              push();
              if (word.length <= maxChars) {
                current = word;
              } else {
                for (let i = 0; i < word.length; i += maxChars) {
                  const chunk = word.slice(i, i + maxChars);
                  if (chunk.length === maxChars) lines.push(chunk);
                  else current = chunk;
                }
              }
            }
          });
          push();
        });

      return lines.length ? lines : [''];
    }

    measureText(text, fontSize = this.fontSize) {
      return String(text ?? '').length * (fontSize * 0.55);
    }

    _escape(text) {
      return String(text ?? '')
        .replace(/\\/g, '\\\\')
        .replace(/\(/g, '\\(')
        .replace(/\)/g, '\\)')
        .replace(/\r?\n/g, '\\n');
    }

    text(text, x, y, options = {}) {
      const lines = String(text ?? '').split(/\r?\n/);
      const align = String(options.align || 'left').toLowerCase();
      const lineHeight = options.lineHeight || this.fontSize * 1.2;
      const fontResource = /bold/i.test(this.fontStyle) ? 'F2' : 'F1';

      lines.forEach((line, index) => {
        let drawX = Number(x || 0);
        if (align === 'center') {
          drawX = Number(x || 0);
        } else if (align === 'right') {
          drawX = Number(x || 0);
        } else {
          drawX = Number(x || 0);
        }
        const drawY = Number(y || 0) + index * lineHeight;
        const pdfY = this._toPdfY(drawY);
        const color = this._formatColor(this.textColor);
        const escaped = this._escape(line);

        const cmds = [`${color} rg`, `BT /${fontResource} ${this.fontSize.toFixed(2)} Tf`];
        if (align === 'center') cmds.push(`${formatFloat(drawX)} ${formatFloat(pdfY)} Td (${escaped}) Tj`);
        else if (align === 'right') cmds.push(`${formatFloat(drawX)} ${formatFloat(pdfY)} Td (${escaped}) Tj`);
        else cmds.push(`${formatFloat(drawX)} ${formatFloat(pdfY)} Td (${escaped}) Tj`);
        cmds.push('ET');
        this._cmd(cmds.join('\n'));
      });

      return this;
    }

    rect(x, y, width, height, style = 'S') {
      const pdfY = this._toPdfY(Number(y || 0) + Number(height || 0));
      const cmds = [];
      const fill = this._formatColor(this.fillColor);
      const stroke = this._formatColor(this.strokeColor);
      const lw = this._formatLineWidth();

      if (style === 'F' || style === 'FD' || style === 'DF') cmds.push(`${fill} rg`);
      if (style === 'S' || style === 'FD' || style === 'DF') {
        cmds.push(`${stroke} RG`);
        cmds.push(`${lw} w`);
      }
      cmds.push(
        `${formatFloat(x)} ${formatFloat(pdfY)} ${formatFloat(width)} ${formatFloat(height)} re`
      );
      if (style === 'F') cmds.push('f');
      else if (style === 'S') cmds.push('S');
      else cmds.push('B');
      this._cmd(cmds.join('\n'));
      return this;
    }

    line(x1, y1, x2, y2) {
      const pdfY1 = this._toPdfY(y1);
      const pdfY2 = this._toPdfY(y2);
      const stroke = this._formatColor(this.strokeColor);
      const lw = this._formatLineWidth();
      const cmds = [
        `${stroke} RG`,
        `${lw} w`,
        `${formatFloat(x1)} ${formatFloat(pdfY1)} m`,
        `${formatFloat(x2)} ${formatFloat(pdfY2)} l`,
        'S'
      ];
      this._cmd(cmds.join('\n'));
      return this;
    }

    circle(cx, cy, radius, style = 'S') {
      const r = Number(radius);
      if (!Number.isFinite(r) || r <= 0) return this;
      const fmt = (val) => formatFloat(val);
      const toPdfY = (val) => this._toPdfY(val);
      const c = r * 0.5522847498;
      const path = [`${fmt(cx)} ${fmt(toPdfY(cy - r))} m`];
      const segments = [
        [cx + c, cy - r, cx + r, cy - c, cx + r, cy],
        [cx + r, cy + c, cx + c, cy + r, cx, cy + r],
        [cx - c, cy + r, cx - r, cy + c, cx - r, cy],
        [cx - r, cy - c, cx - c, cy - r, cx, cy - r]
      ];
      segments.forEach(([cp1x, cp1y, cp2x, cp2y, x, y]) => {
        path.push(
          `${fmt(cp1x)} ${fmt(toPdfY(cp1y))} ${fmt(cp2x)} ${fmt(toPdfY(cp2y))} ${fmt(x)} ${fmt(toPdfY(y))} c`
        );
      });
      if (style === 'F' || style === 'FD' || style === 'DF') path.push('f');
      else if (style === 'S') path.push('S');
      else path.push('B');
      const cmds = [];
      if (style === 'F' || style === 'FD' || style === 'DF') cmds.push(`${this._formatColor(this.fillColor)} rg`);
      if (style === 'S' || style === 'FD' || style === 'DF') {
        cmds.push(`${this._formatColor(this.strokeColor)} RG`);
        cmds.push(`${this._formatLineWidth()} w`);
      }
      cmds.push(path.join('\n'));
      this._cmd(cmds.join('\n'));
      return this;
    }

    lines(segments, startX, startY, scale = 1, style = 'S', closed = false) {
      if (!Array.isArray(segments) || !segments.length) return this;
      const fmt = (val) => formatFloat(val);
      const toPdfY = (val) => this._toPdfY(val);
      const path = [];
      let currentX = Number(startX) || 0;
      let currentY = Number(startY) || 0;
      const factor = Number(scale) || 1;
      path.push(`${fmt(currentX)} ${fmt(toPdfY(currentY))} m`);
      segments.forEach((segment) => {
        if (!Array.isArray(segment) || segment.length < 2) return;
        currentX += Number(segment[0] || 0) * factor;
        currentY += Number(segment[1] || 0) * factor;
        path.push(`${fmt(currentX)} ${fmt(toPdfY(currentY))} l`);
      });
      if (closed) path.push('h');
      const cmds = [];
      if (style === 'F' || style === 'FD' || style === 'DF') cmds.push(`${this._formatColor(this.fillColor)} rg`);
      if (style === 'S' || style === 'FD' || style === 'DF') {
        cmds.push(`${this._formatColor(this.strokeColor)} RG`);
        cmds.push(`${this._formatLineWidth()} w`);
      }
      cmds.push(path.join('\n'));
      if (style === 'F') cmds.push('f');
      else if (style === 'S') cmds.push('S');
      else cmds.push('B');
      this._cmd(cmds.join('\n'));
      return this;
    }

    save(filename = 'document.pdf') {
      const objects = [];
      const pageRefs = [];

      objects.push({ name: 'font_regular', body: '<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>' });
      objects.push({ name: 'font_bold', body: '<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica-Bold >>' });

      this.pages.forEach((page, index) => {
        const stream = page.commands.join('\n');
        const contentName = `content_${index}`;
        const pageName = `page_${index}`;
        objects.push({
          name: contentName,
          body: `<< /Length ${stream.length} >>\nstream\n${stream}\nendstream`
        });
        objects.push({
          name: pageName,
          body: `<< /Type /Page /Parent {{pages}} 0 R /MediaBox [0 0 ${this.width} ${this.height}] /Resources << /Font << /F1 {{font_regular}} 0 R /F2 {{font_bold}} 0 R >> >> /Contents {{${contentName}}} 0 R >>`
        });
        pageRefs.push(`{{${pageName}}} 0 R`);
      });

      objects.push({
        name: 'pages',
        body: `<< /Type /Pages /Kids [ ${pageRefs.join(' ')} ] /Count ${this.pages.length} >>`
      });
      objects.push({ name: 'catalog', body: '<< /Type /Catalog /Pages {{pages}} 0 R >>' });

      const refMap = new Map();
      objects.forEach((object, idx) => {
        refMap.set(object.name, idx + 1);
      });

      const resolveRefs = (body) =>
        String(body).replace(/\{\{([^}]+)\}\}/g, (_, name) => {
          const ref = refMap.get(name);
          if (!ref) throw new Error(`Unknown PDF reference: ${name}`);
          return String(ref);
        });

      let pdf = '%PDF-1.4\n';
      const offsets = [0];
      objects.forEach((object, idx) => {
        offsets.push(pdf.length);
        pdf += `${idx + 1} 0 obj\n${resolveRefs(object.body)}\nendobj\n`;
      });

      const xref = pdf.length;
      pdf += `xref\n0 ${objects.length + 1}\n`;
      pdf += '0000000000 65535 f \n';
      for (let i = 1; i <= objects.length; i += 1) {
        pdf += offsets[i].toString().padStart(10, '0') + ' 00000 n \n';
      }
      const rootRef = refMap.get('catalog');
      pdf += `trailer\n<< /Size ${objects.length + 1} /Root ${rootRef} 0 R >>\nstartxref\n${xref}\n%%EOF`;

      if (typeof document !== 'undefined') {
        const blob = new Blob([pdf], { type: 'application/pdf' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        setTimeout(() => {
          URL.revokeObjectURL(link.href);
          link.remove();
        }, 0);
      } else {
        const fs = require('fs');
        fs.writeFileSync(filename, pdf);
      }

      return this;
    }
  }

  LiteJsPDF.prototype.API = LiteJsPDF.prototype;

  const globalObj = global || {};
  globalObj.jspdf = globalObj.jspdf || {};
  globalObj.jspdf.jsPDF = LiteJsPDF;
  globalObj.jspdf.version = '2.5.1-lite';
  if (typeof globalObj.jsPDF === 'undefined') {
    globalObj.jsPDF = LiteJsPDF;
  }
  LiteJsPDF.API = LiteJsPDF.prototype;

  if (typeof module !== 'undefined' && module.exports) {
    module.exports = { jsPDF: LiteJsPDF };
  }
})(typeof window !== 'undefined' ? window : globalThis);
