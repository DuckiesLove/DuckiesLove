(function (global) {
  'use strict';

  const win = global || {};

  function asNumber(value) {
    const num = Number(value);
    return Number.isFinite(num) ? num : null;
  }

  function toColor(value, fallback) {
    if (Array.isArray(value) && value.length >= 3) {
      return value.slice(0, 3).map((part) => {
        const num = Number(part);
        if (!Number.isFinite(num)) return 0;
        return Math.max(0, Math.min(255, Math.round(num)));
      });
    }
    if (typeof value === 'number') {
      const num = Math.max(0, Math.min(255, Math.round(value)));
      return [num, num, num];
    }
    return Array.isArray(fallback) ? fallback.slice(0, 3) : [0, 0, 0];
  }

  function mergeStyles(base, extra) {
    const out = Object.assign({}, base);
    if (!extra) return out;
    Object.keys(extra).forEach((key) => {
      const val = extra[key];
      if (val === undefined || val === null) return;
      if (key === 'textColor' || key === 'fillColor' || key === 'lineColor') {
        out[key] = toColor(val, out[key]);
      } else {
        out[key] = val;
      }
    });
    return out;
  }

  function parseMargin(margin) {
    if (typeof margin === 'number') {
      return { top: margin, right: margin, bottom: margin, left: margin };
    }
    const base = { top: 40, right: 40, bottom: 40, left: 40 };
    if (!margin || typeof margin !== 'object') return base;
    return {
      top: margin.top ?? base.top,
      right: margin.right ?? base.right,
      bottom: margin.bottom ?? base.bottom,
      left: margin.left ?? base.left
    };
  }

  function simpleWrap(text, width, fontSize) {
    const raw = String(text ?? '');
    if (!raw) return [''];
    const approx = Math.max((fontSize || 10) * 0.55, 1);
    const maxChars = Math.max(Math.floor(width / approx), 1);
    const words = raw.split(/\s+/);
    const lines = [];
    let current = '';
    const push = () => {
      if (current) {
        lines.push(current);
        current = '';
      }
    };
    words.forEach((word) => {
      if (!word) return;
      if (!current) {
        if (word.length <= maxChars) {
          current = word;
        } else {
          for (let i = 0; i < word.length; i += maxChars) {
            const chunk = word.slice(i, i + maxChars);
            if (chunk.length === maxChars) lines.push(chunk);
            else current = chunk;
          }
        }
        return;
      }
      const candidate = `${current} ${word}`;
      if (candidate.length <= maxChars) {
        current = candidate;
      } else {
        push();
        if (word.length <= maxChars) {
          current = word;
        } else {
          for (let i = 0; i < word.length; i += maxChars) {
            const chunk = word.slice(i, i + maxChars);
            if (chunk.length === maxChars) lines.push(chunk);
            else current = chunk;
          }
        }
      }
    });
    push();
    return lines.length ? lines : [''];
  }

  function deriveColumns(options) {
    if (Array.isArray(options.columns) && options.columns.length) {
      return options.columns.map((col, index) => ({
        header: col.header ?? col.title ?? String(col.dataKey ?? index),
        dataKey: col.dataKey ?? index,
        index
      }));
    }
    if (Array.isArray(options.head) && options.head.length) {
      const headers = options.head[0] || [];
      return headers.map((header, index) => ({ header, dataKey: index, index }));
    }
    if (Array.isArray(options.body) && options.body.length && Array.isArray(options.body[0])) {
      const len = options.body[0].length;
      return Array.from({ length: len }, (_, index) => ({ header: '', dataKey: index, index }));
    }
    return [];
  }

  function deriveHeadRows(options, columns) {
    if (Array.isArray(options.head) && options.head.length) {
      return options.head.map((row) =>
        row.map((cell, index) => ({ text: cell, column: columns[index] || { dataKey: index, index } }))
      );
    }
    if (!columns.length) return [];
    return [columns.map((col) => ({ text: col.header ?? '', column: col }))];
  }

  function deriveBodyRows(options, columns) {
    const rows = [];
    (options.body || []).forEach((raw, idx) => {
      if (Array.isArray(raw)) {
        rows.push({
          raw,
          index: idx,
          cells: raw.map((value, index) => ({ text: value, column: columns[index] || { dataKey: index, index } }))
        });
        return;
      }
      if (raw && typeof raw === 'object') {
        rows.push({
          raw,
          index: idx,
          cells: columns.map((col) => ({ text: raw[col.dataKey], column: col }))
        });
        return;
      }
      rows.push({ raw, index: idx, cells: columns.map((col) => ({ text: '', column: col })) });
    });
    return rows;
  }

  function computeColumnWidths(columns, columnStyles, tableWidth) {
    const widths = new Array(columns.length).fill(null);
    let fixed = 0;
    let flexCount = 0;

    columns.forEach((col, index) => {
      const style = columnStyles?.[col.dataKey] ?? columnStyles?.[col.index] ?? columnStyles?.[String(col.dataKey)];
      const width = asNumber(style?.cellWidth);
      if (width && width > 0) {
        widths[index] = width;
        fixed += width;
      } else {
        flexCount += 1;
      }
    });

    const remaining = Math.max(tableWidth - fixed, 0);
    const flexWidth = flexCount ? remaining / flexCount : 0;
    return widths.map((width) => (width == null ? flexWidth : width));
  }

  function wrapCellText(doc, text, width, fontSize) {
    if (width <= 4) return [String(text ?? '')];
    const available = width - 6;
    if (doc.splitTextToSize) {
      const result = doc.splitTextToSize(String(text ?? ''), available);
      if (Array.isArray(result) && result.length) return result.map((line) => String(line ?? ''));
    }
    return simpleWrap(text, available, fontSize);
  }

  function drawRow(doc, cells, rowInfo, config) {
    const {
      margin,
      columnWidths,
      section,
      styles,
      rowStyles,
      columnStyles,
      pageWidth,
      pageHeight,
      didDrawCell,
      didAddPage,
      cursor
    } = config;

    const baseFontSize = rowStyles.fontSize ?? styles.fontSize;
    const prepared = cells.map((cell, columnIndex) => {
      const columnKey = cell.column?.dataKey ?? columnIndex;
      const columnStyle = columnStyles?.[columnKey] ?? columnStyles?.[columnIndex];
      const merged = mergeStyles(rowStyles, columnStyle);
      const fontSize = merged.fontSize ?? baseFontSize;
      const lines = wrapCellText(doc, cell.text, columnWidths[columnIndex], fontSize);
      const lineHeight = (merged.lineHeight ?? fontSize * 1.2);
      const height = Math.max(lineHeight * lines.length + 6, fontSize + 6);
      return { cell, lines, fontSize, lineHeight, height, style: merged, columnIndex };
    });

    const rowHeight = prepared.reduce((max, cell) => Math.max(max, cell.height), 0);

    const maxY = pageHeight - margin.bottom;
    if (cursor.y + rowHeight > maxY) {
      doc.addPage();
      cursor.y = margin.top;
      if (typeof didAddPage === 'function') {
        try {
          didAddPage({ doc, pageNumber: doc.pages?.length || 0 });
        } catch (err) {
          console.warn('[autotable] didAddPage error', err);
        }
      }
    }

    let currentX = margin.left;
    prepared.forEach((item) => {
      const width = columnWidths[item.columnIndex];
      const style = item.style;
      const x = currentX;
      const y = cursor.y;

      if (style.fillColor) {
        doc.setFillColor(...style.fillColor);
        doc.rect(x, y, width, rowHeight, 'F');
      }

      doc.setDrawColor(...(style.lineColor ?? styles.lineColor));
      doc.setLineWidth(style.lineWidth ?? styles.lineWidth ?? 0.5);
      doc.rect(x, y, width, rowHeight, 'S');

      doc.setTextColor(...(style.textColor ?? styles.textColor));
      doc.setFont('helvetica', style.fontStyle ?? rowStyles.fontStyle ?? styles.fontStyle ?? 'normal');
      doc.setFontSize(style.fontSize ?? rowStyles.fontSize ?? styles.fontSize);

      const totalHeight = item.lines.length * item.lineHeight;
      let textY = y + Math.max((rowHeight - totalHeight) / 2, 0) + item.lineHeight - 2;
      const align = (style.halign || rowStyles.halign || styles.halign || 'left').toLowerCase();

      item.lines.forEach((line, lineIndex) => {
        let drawX = x + 4;
        if (align === 'center') drawX = x + width / 2;
        else if (align === 'right') drawX = x + width - 4;
        doc.text(String(line ?? ''), drawX, textY + lineIndex * item.lineHeight, { align });
      });

      if (typeof didDrawCell === 'function') {
        try {
          didDrawCell({
            section,
            column: { dataKey: item.cell.column?.dataKey ?? item.columnIndex, index: item.columnIndex },
            row: rowInfo,
            cell: {
              x,
              y,
              width,
              height: rowHeight,
              text: item.lines,
              raw: item.cell.text
            },
            doc,
            table: {
              width: pageWidth - margin.left - margin.right,
              height: rowHeight,
              cursor: { x, y }
            }
          });
        } catch (err) {
          console.warn('[autotable] didDrawCell error', err);
        }
      }

      currentX += width;
    });

    cursor.y += rowHeight;
  }

  function renderTable(doc, options) {
    const margin = parseMargin(options.margin);
    const pageWidth = doc.internal?.pageSize?.getWidth?.() || 612;
    const pageHeight = doc.internal?.pageSize?.getHeight?.() || 792;
    const availableWidth = pageWidth - margin.left - margin.right;
    const tableWidth = Math.min(options.tableWidth || availableWidth, availableWidth);

    const baseStyles = mergeStyles(
      {
        fontSize: 10,
        fontStyle: 'normal',
        textColor: [255, 255, 255],
        fillColor: null,
        lineColor: [30, 30, 38],
        lineWidth: 0.5,
        halign: 'left'
      },
      options.styles
    );
    const headStyles = mergeStyles(Object.assign({}, baseStyles, { fontStyle: 'bold' }), options.headStyles);
    const bodyStyles = mergeStyles(baseStyles, options.bodyStyles);
    const alternateStyles = mergeStyles(bodyStyles, options.alternateRowStyles);

    const columns = deriveColumns(options);
    const columnWidths = computeColumnWidths(columns, options.columnStyles || {}, tableWidth);
    const headRows = deriveHeadRows(options, columns);
    const bodyRows = deriveBodyRows(options, columns);

    const cursor = { y: options.startY ?? margin.top };

    headRows.forEach((cells, index) => {
      const rowInfo = { index, raw: cells.map((cell) => cell.text) };
      drawRow(doc, cells, rowInfo, {
        margin,
        columnWidths,
        section: 'head',
        styles: baseStyles,
        rowStyles: headStyles,
        columnStyles: options.columnStyles || {},
        pageWidth,
        pageHeight,
        didDrawCell: options.didDrawCell,
        didAddPage: options.didAddPage,
        cursor
      });
    });

    bodyRows.forEach((row, index) => {
      const rowStyles = index % 2 === 1 ? alternateStyles : bodyStyles;
      drawRow(doc, row.cells, { index: row.index, raw: row.raw }, {
        margin,
        columnWidths,
        section: 'body',
        styles: baseStyles,
        rowStyles,
        columnStyles: options.columnStyles || {},
        pageWidth,
        pageHeight,
        didDrawCell: options.didDrawCell,
        didAddPage: options.didAddPage,
        cursor
      });
    });

    doc.lastAutoTable = { finalY: cursor.y };
    return doc;
  }

  function install(doc) {
    if (!doc || typeof doc !== 'object') return;
    if (typeof doc.autoTable === 'function') return doc.autoTable;
    doc.autoTable = function autoTable(options = {}) {
      return renderTable(this, options);
    };
    return doc.autoTable;
  }

  function attachToAPI(jsPDF) {
    if (!jsPDF) return;
    const API = jsPDF.API || jsPDF.prototype;
    if (!API) return;
    if (typeof API.autoTable !== 'function') {
      API.autoTable = function autoTablePlugin(options = {}) {
        install(this);
        return this.autoTable(options);
      };
    }
  }

  function autoTablePlugin(doc) {
    if (doc) install(doc);
  }

  autoTablePlugin.version = '3.8.2-lite';

  win.jspdf_autotable = autoTablePlugin;

  if (win.jspdf && win.jspdf.jsPDF) {
    attachToAPI(win.jspdf.jsPDF);
  }

  if (typeof module !== 'undefined' && module.exports) {
    module.exports = autoTablePlugin;
  }
})(typeof window !== 'undefined' ? window : globalThis);
