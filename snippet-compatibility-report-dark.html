<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Compatibility Report Export (Dark)</title>
</head>
<body>
<!--
ONE-BOX DROP-IN — fixes your two problems:
1) Wrong columns (Partner B values ending up under “Flag”) → we IGNORE the DOM and build rows ONLY from window.partnerAData / window.partnerBData. That guarantees the order is: Category | A | Match | Flag | B.
2) White border on later pages → we paint a pure-black background on EVERY page via didDrawPage.

What you do
1) Make sure BOTH client-side objects exist after uploads:
   - window.partnerAData  (either {items:[{id|label, score|value|rating}…]} OR just an array of those items)
   - window.partnerBData  (same shape)
2) Paste this whole <script> block right before </body>.
3) Your existing button with id="downloadBtn" (or id="downloadPdfBtn" or [data-download-pdf]) will start working.
   You can also call window.exportCompatibilityPDF() from the console.

Notes
• Category is clamped to TWO lines with an ellipsis.
• Columns are locked to exact widths so numbers do not drift.
• Background and cells are black; text is white on ALL pages (no white border).
-->

<script>
(function () {
  /* ---------------- deps ---------------- */
  function load(src){return new Promise((res,rej)=>{if(document.querySelector(`script[src="${src}"]`))return res();const s=document.createElement("script");s.src=src;s.async=true;s.onload=res;s.onerror=()=>rej(new Error("Failed to load "+src));document.head.appendChild(s);});}
  async function ensureLibs(){
    if(!(window.jspdf && window.jspdf.jsPDF)){
      await load("https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js");
    }
    if(!((window.jspdf&&window.jspdf.autoTable)||(window.jsPDF&&window.jsPDF.API&&window.jsPDF.API.autoTable))){
      await load("https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.3/jspdf.plugin.autotable.min.js");
    }
  }
  function runAutoTable(doc, opts){
    if(typeof doc.autoTable==="function") return doc.autoTable(opts);
    return window.jspdf.autoTable(doc, opts);
  }

  /* ---------------- utils ---------------- */
  const tidy = s => String(s||"").replace(/\s+/g," ").trim();
  const toNum = v => { const n = Number(String(v??"").trim()); return Number.isFinite(n) ? n : null; };
  const pct   = (a,b)=> (a==null||b==null) ? null : Math.round(100 - (Math.abs(a-b)/5)*100);
  const flagI = p => p==null ? "" : (p>=90 ? "★" : (p>=60 ? "⚑" : "🚩"));

  // clamp Category to exactly max 2 lines with ellipsis
  function clamp2(doc, text, width, fontSize){
    doc.setFontSize(fontSize);
    const lines = doc.splitTextToSize(text, width);
    if(lines.length<=2) return lines;
    const merged = [lines[1], ...lines.slice(2)].join(" ");
    let second = doc.splitTextToSize(merged, width)[0] || lines[1];
    while(doc.getTextWidth(second + "…") > width && second.length>0){ second = second.slice(0,-1); }
    return [lines[0], second + "…"];
  }

  // STRICT data builder (never reads table) → prevents column mixups
  function rowsFromDataStrict(){
    const A=(window.partnerAData?.items) || (Array.isArray(window.partnerAData)?window.partnerAData:null);
    const B=(window.partnerBData?.items) || (Array.isArray(window.partnerBData)?window.partnerBData:null);
    if(!A || !B) return null; // require both to avoid DOM fallback/misalignment

    const map=new Map(); // key -> {label,A,B}
    const ingest=(arr,isA)=> (arr||[]).forEach(it=>{
      const key   = it.id || it.label || "";
      const label = tidy(it.label || it.id || "");
      const score = toNum(it.score ?? it.value ?? it.rating);
      if(!map.has(key)) map.set(key,{label,A:null,B:null});
      if(isA) map.get(key).A = score; else map.get(key).B = score;
    });
    ingest(A,true); ingest(B,false);

    return [...map.values()]
      .sort((x,y)=>x.label.localeCompare(y.label,undefined,{sensitivity:"base"}))
      .map(r=>{
        const p = pct(r.A, r.B);
        return [r.label || "—", r.A ?? "—", p==null?"—":`${p}%`, flagI(p), r.B ?? "—"]; // ORDER LOCKED
      });
  }

  /* ---------------- exporter ---------------- */
  async function exportCompatibilityPDF(){
    await ensureLibs();
    const { jsPDF } = window.jspdf;

    const rows = rowsFromDataStrict();
    if(!rows || !rows.length){
      alert("Load BOTH surveys first (Partner A and Partner B).");
      return;
    }

    // page & layout
    const doc = new jsPDF({ orientation:"landscape", unit:"pt", format:"a4" });
    const W = doc.internal.pageSize.getWidth();
    const H = doc.internal.pageSize.getHeight();

    // margins chosen to avoid any right-edge clipping
    const M = { top: 70, left: 54, right: 54, bottom: 54 };
    const INNER_W = W - M.left - M.right;

    // fixed column widths (sum = INNER_W)
    const wCat   = Math.floor(INNER_W * 0.58); // wide Category → 2 lines max
    const wA     = 72;
    const wMatch = 88;
    const wFlag  = 66;
    const wB     = INNER_W - (wCat + wA + wMatch + wFlag); // fill remainder

    const BODY_FS = 12;
    const CAT_FS  = 16;

    // draw black background on EVERY page
    function paintBlackPage(doc){
      doc.setFillColor(0,0,0);
      doc.rect(0,0,W,H,"F");
      doc.setTextColor(255,255,255);
    }
    paintBlackPage(doc);

    // title
    doc.setFontSize(32);
    doc.text("Talk Kink • Compatibility Report", W/2, 48, {align:"center"});

    runAutoTable(doc, {
      head: [["Category","Partner A","Match","Flag","Partner B"]],
      body: rows,
      startY: M.top,
      margin: { left: M.left, right: M.right, top: M.top, bottom: M.bottom },
      theme: "plain",
      tableWidth: INNER_W,
      styles: {
        fontSize: BODY_FS,
        cellPadding: 8,
        overflow: "linebreak",
        halign: "center",
        valign: "middle",
        textColor: [255,255,255],
        fillColor: [0,0,0],
      },
      headStyles: {
        fontSize: 14,
        fontStyle: "bold",
        textColor: [255,255,255],
        fillColor: [0,0,0],
        halign: "center",
      },
      columnStyles: {
        0: { cellWidth: wCat,   halign: "left"  },
        1: { cellWidth: wA,     halign: "center"},
        2: { cellWidth: wMatch, halign: "center"},
        3: { cellWidth: wFlag,  halign: "center"},
        4: { cellWidth: wB,     halign: "center"},
      },
      didParseCell: data => {
        // enforce black/white EVERYWHERE
        data.cell.styles.fillColor = [0,0,0];
        data.cell.styles.textColor = [255,255,255];

        // clamp Category (col 0) to TWO lines
        if(data.section==="body" && data.column.index===0){
          const text = tidy(Array.isArray(data.cell.text)?data.cell.text.join(" "):data.cell.text);
          const usable = wCat - (data.cell.styles.cellPadding*2);
          data.cell.text = clamp2(data.doc, text, usable, CAT_FS);
          data.cell.styles.fontSize = CAT_FS;
          data.cell.styles.lineHeight = 1.18;
          data.cell.styles.halign = "left";
        }
      },
      willDrawCell: (data) => {
        // paint each cell black (prevents any gray/white boxes)
        const c = data.cell;
        data.doc.setFillColor(0,0,0);
        data.doc.rect(c.x, c.y, c.width, c.height, "F");
      },
      didDrawPage: (data) => {
        // repaint page background (for pages after the first)
        paintBlackPage(data.doc);
        // re-draw the title
        data.doc.setFontSize(32);
        data.doc.text("Talk Kink • Compatibility Report", W/2, 48, {align:"center"});
      }
    });

    doc.save("compatibility-report.pdf");
  }

  // bind or create a button
  function bind(){
    let btn = document.querySelector("#downloadBtn,#downloadPdfBtn,[data-download-pdf]");
    if(!btn){
      btn = document.createElement("button");
      btn.id = "downloadBtn";
      btn.textContent = "Download Compatibility PDF";
      btn.style.cssText="margin:12px 0;padding:10px 14px;border-radius:10px;border:1px solid #0ff;background:#001014;color:#0ff;cursor:pointer;";
      document.body.appendChild(btn);
    }
    btn.addEventListener("click", exportCompatibilityPDF);
    window.exportCompatibilityPDF = exportCompatibilityPDF; // optional manual trigger
  }

  if(document.readyState==="loading") document.addEventListener("DOMContentLoaded", bind);
  else bind();
})();
</script>
<!-- ✅ 1) Add this *once* near the end of every page that was freezing (before </body>) -->
<script src="js/tk-safe-bootstrap.js"></script>
<!-- ---------- End Safe Bootstrap ---------- -->
</body>
</html>

