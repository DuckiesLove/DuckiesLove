<!-- Talk Kink — Categories-Only Pre-Start Portal (single file for Codex) -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Talk Kink Survey</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Optional (harmless if your site already loads them) -->
  <link rel="stylesheet" href="/css/style.css" />
  <link rel="stylesheet" href="/css/theme.css" />
  <link rel="stylesheet" href="/css/kinksurvey_overrides.css" />

  <style>
    /* ===== Layout: left categories + right main ===== */
    #tkPortal.tk-portal.grid-2col {
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 20px;
      align-items: start;
    }

    /* Categories panel (left) */
    .category-panel{
      position: sticky;
      top: 16px;
      align-self: start;
      max-height: calc(100vh - 32px);
      overflow: auto;
      padding: 16px;
      border-radius: 12px;
    }
    .panel-header{ display:flex; justify-content:space-between; align-items:baseline; gap:12px; margin-bottom:10px; }
    .panel-header h2{ margin:0; font-size:1.1rem; }
    .category-counter{ opacity:.85; font-size:.95rem; white-space:nowrap; }

    .category-checklist{ list-style:none; margin:12px 0 16px; padding:0; }
    .category-checklist li{ display:flex; align-items:center; gap:10px; padding:8px 6px; border-radius:8px; cursor:pointer; }
    .category-checklist input[type="checkbox"]{ flex:0 0 auto; }

    .themed-button.start-button{ width:100%; padding:10px 12px; border-radius:10px; font-weight:600; }
    .themed-button.start-button:disabled{ opacity:.5; cursor:not-allowed; }

    /* Keep app/scorecard hidden until the engine decides */
    #surveyApp[hidden], #surveyScoreCard[hidden]{ display:none !important; }

    /* Ensure the category panel stays visible while prestart hides siblings */
    body.tk-prestart #categoryPanel{ display:block !important; }
    body.tk-prestart #categoryPanel ~ *{ display:none !important; }

    /* Categories-only prestart guard also honors the host marker */
    body.tk-prestart .tk-cat-host{ display:block !important; }
    body.tk-prestart .tk-cat-host ~ *{ display:none !important; }

    body.tk-prestart #tkPortal.tk-portal.grid-2col{ grid-template-columns:1fr; }
    body.tk-prestart #tkPortal > :not(#categoryPanel){ display:none !important; }

    body.tk-prestart main,
    body.tk-prestart #surveyMain,
    body.tk-prestart .portal-main,
    body.tk-prestart #surveyIntro,
    body.tk-prestart .rubric,
    body.tk-prestart .score-rubric,
    body.tk-prestart #rubric,
    body.tk-prestart #surveyApp,
    body.tk-prestart #surveyScoreCard,
    body.tk-prestart #surveyMain ~ * { display:none !important; }

    /* ===== Categories-only pre-start mode ===== */
    body.tk-prestart #surveyMain { display: none !important; }  /* hide entire right column pre-start */

    /* Responsive collapse */
    @media (max-width:980px){
      #tkPortal.tk-portal.grid-2col{ grid-template-columns:1fr; }
      .category-panel{ position:relative; top:0; max-height:none; }
    }
  </style>
</head>

<!-- Add tk-prestart here to prevent any flash of the right column -->
<body class="theme-dark tk-prestart">
  <!-- TK: categories-only prestart guard (ensures siblings stay hidden until Start) -->
  <script>
    (() => {
      const enterPrestart = () => document.body.classList.add('tk-prestart');
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', enterPrestart, { once: true });
      } else {
        enterPrestart();
      }

      const log = (...a) => console.info('[TK:prestart]', ...a);
      const selectors = [
        '#categoryPanel',
        '#tk-cat-list',
        '#categoryChecklist'
      ];

      const waitForAny = (sels, { timeout = 12000 } = {}) => new Promise((resolve, reject) => {
        const hit = sels.map(s => document.querySelector(s)).find(Boolean);
        if (hit) return resolve({ el: hit, selector: sels.find(s => hit.matches(s)) });

        let timer;

        const obs = new MutationObserver(() => {
          const found = sels.map(s => document.querySelector(s)).find(Boolean);
          if (found) {
            obs.disconnect();
            clearTimeout(timer);
            resolve({ el: found, selector: sels.find(s => found.matches(s)) });
          }
        });
        obs.observe(document.documentElement, { childList: true, subtree: true });
        timer = setTimeout(() => {
          obs.disconnect();
          reject(new Error('timeout waiting for category panel'));
        }, timeout);
      });

      const markCatHost = (node) => {
        const host = node.closest('.panel, section, aside, .sidebar, .category-panel') || node;
        host.classList.add('tk-cat-host');
        log('category host =', host);
        return host;
      };

      const exitPrestart = () => {
        if (document.body.classList.contains('tk-prestart')) {
          document.body.classList.remove('tk-prestart');
          const app = document.getElementById('surveyApp');
          if (app) app.hidden = false;
          log('exited prestart');
        }
      };

      const wireStartDetectors = (host) => {
        host.addEventListener('tk:survey:start', exitPrestart);
        const candidates = [
          '#startSurveyBtn',
          '#tk-start',
          '[data-tk-start]',
          '.start-button'
        ];
        const btn = candidates.map(s => document.querySelector(s)).find(Boolean);
        if (btn) {
          btn.addEventListener('click', () => {
            if (!btn.disabled) exitPrestart();
          });
        }
      };

      (async () => {
        try {
          const { el, selector } = await waitForAny(selectors);
          const host = markCatHost(el);
          wireStartDetectors(host);
          log(`ready (via ${selector}) — categories-only is active until Start`);
        } catch (err) {
          console.warn('[TK:prestart] panel never appeared:', err.message);
          setTimeout(exitPrestart, 1500);
        }
      })();
    })();
  </script>
  <div id="tkPortal" class="tk-portal grid-2col">
    <!-- LEFT: Category Panel (always visible on load) -->
    <section id="categoryPanel" class="panel category-panel">
      <header class="panel-header">
        <h2>Categories</h2>
        <div class="category-counter">
          <span id="categorySelectedCount">0</span><span>/</span><span id="categoryTotalCount">0</span><span> selected</span>
        </div>
      </header>

      <ul id="categoryChecklist" class="category-checklist"><!-- populated at runtime --></ul>

      <button id="startSurveyBtn" class="themed-button start-button" disabled>
        Start Survey
      </button>
    </section>

    <!-- RIGHT: Main area (hidden until Start because of tk-prestart) -->
    <main id="surveyMain" class="portal-main">
      <!-- Your intro/rubric/engine mount points can live here; they won’t show pre-start -->
      <section id="surveyIntro" class="intro">
        <h1 class="themed-header">Talk Kink Survey</h1>
        <p>Select one or more categories on the left, then press <em>Start Survey</em>.</p>
      </section>

      <section id="surveyApp" class="survey-app" hidden></section>
      <aside id="surveyScoreCard" class="scorecard" hidden></aside>
    </main>
  </div>

  <script>
    /* ===== Helpers ===== */
    const TK = window.TK || (window.TK = {});
    TK.log = (...a)=>console.info("[TK]", ...a);

    function onReady(cb){
      if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", cb, {once:true});
      else cb();
    }
    function waitForEl(selector, {timeout=8000, root=document} = {}){
      return new Promise((resolve, reject)=>{
        const first = root.querySelector(selector);
        if (first) return resolve(first);
        const obs = new MutationObserver(()=>{
          const el = root.querySelector(selector);
          if (el){ obs.disconnect(); resolve(el); }
        });
        obs.observe(root, {childList:true, subtree:true});
        if (timeout){
          setTimeout(()=>{ obs.disconnect(); reject(new Error(`timeout waiting for ${selector}`)); }, timeout);
        }
      });
    }

    /* ===== Category helpers ===== */
    const DEFAULT_CATEGORIES = [
      { id: "appearance", name: "Appearance Play" },
      { id: "sensation",  name: "Sensation / Impact" },
      { id: "service",    name: "Service & Protocol" },
      { id: "psych",      name: "Psychological / Primal" },
      { id: "bondage",    name: "Bondage / Restraint" },
      { id: "aftercare",  name: "Care & Aftercare" }
    ];

    const slug = (value) => String(value ?? "")
      .toLowerCase()
      .replace(/&/g, "and")
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "");

    async function fetchJSON(url){
      try {
        const res = await fetch(url, { credentials: "same-origin" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return await res.json();
      } catch (error) {
        console.warn(`[TK] Failed to fetch ${url}:`, error.message);
        throw error;
      }
    }

    async function getCategoryNames(){
      try {
        const data = await fetchJSON("/data/categories.json");
        const arr = Array.isArray(data) ? data : (data?.categories || []);
        if (arr.length) return arr.map((entry) => entry?.name || entry?.title || entry).filter(Boolean);
      } catch {}

      try {
        const data = await fetchJSON("/data/kinks.json");
        const items = Array.isArray(data)
          ? data
          : (data?.items || data?.kinks || []);
        const names = Array.from(new Set(items.map((item) => item?.category || item?.cat || item?.Category).filter(Boolean)));
        if (names.length) return names;
      } catch {}

      return [];
    }

    function normalizeCategoryList(list = []){
      const used = new Set();
      const collator = new Intl.Collator("en", { sensitivity: "base" });
      const mapped = list.map((raw, index) => {
        const name = String(raw?.name || raw?.title || raw?.label || raw?.category || raw || "")
          .trim()
          || `Category ${index + 1}`;
        const idBase = String(raw?.id || slug(name) || slug(raw?.category)).trim() || `cat-${index}`;
        let id = idBase;
        let counter = 2;
        while (used.has(id)) {
          id = `${idBase}-${counter++}`;
        }
        used.add(id);
        return { id, name };
      });
      mapped.sort((a, b) => collator.compare(a.name, b.name));
      return mapped;
    }

    async function resolveCategories(){
      const seeded = Array.isArray(window.TK_CATEGORIES) ? window.TK_CATEGORIES : [];
      if (seeded.length) return normalizeCategoryList(seeded);

      const names = await getCategoryNames();
      if (names.length) return normalizeCategoryList(names);

      return normalizeCategoryList(DEFAULT_CATEGORIES);
    }

    /* ===== Optional stub engine (safe to remove once your real engine mounts) ===== */
    window.TKSurvey = window.TKSurvey || {
      start: ({ categories })=>{
        const mount = document.getElementById("surveyApp");
        if (!mount) return;
        mount.innerHTML = `
          <div class="panel">
            <h2>Survey</h2>
            <p>Initialized with categories:</p>
            <ul>${categories.map(c=>`<li>${c}</li>`).join("")}</ul>
            <p>(Replace this stub with your real survey renderer.)</p>
          </div>`;
      }
    };

    /* ===== Bootstrap: wire categories-only view + Start gate ===== */
    onReady(async ()=>{
      if (window.__TK_CATEGORIES_WIRED__) return;
      window.__TK_CATEGORIES_WIRED__ = true;

      try{
        const panel       = await waitForEl("#categoryPanel");
        const checklist   = await waitForEl("#categoryChecklist");
        const startBtn    = await waitForEl("#startSurveyBtn");
        const countSel    = await waitForEl("#categorySelectedCount");
        const countTot    = await waitForEl("#categoryTotalCount");
        const surveyApp   = document.getElementById("surveyApp");
        const scoreCard   = document.getElementById("surveyScoreCard");
        const surveyIntro = document.getElementById("surveyIntro");

        const categories = await resolveCategories();
        window.__TK_CATEGORIES_RESOLVED__ = categories;
        window.TK_CATEGORIES = categories;
        const catById = new Map(categories.map(cat => [String(cat.id), cat]));

        // Populate the checklist with categories
        checklist.innerHTML = "";
        if (categories.length) {
          const frag = document.createDocumentFragment();
          categories.forEach((cat) => {
            const li = document.createElement("li");
            li.dataset.cat = cat.id;
            const input = document.createElement("input");
            input.type = "checkbox";
            input.id = `cat_${cat.id}`;
            input.value = cat.id;
            const label = document.createElement("label");
            label.htmlFor = input.id;
            label.textContent = cat.name;
            li.append(input, label);
            frag.appendChild(li);
          });
          checklist.appendChild(frag);
        } else {
          const empty = document.createElement("li");
          empty.className = "empty";
          empty.textContent = "No categories available.";
          checklist.appendChild(empty);
        }

        // Counts & gating
        countTot.textContent = String(categories.length);
        const getSelected = () =>
          Array.from(checklist.querySelectorAll('input[type="checkbox"]:checked')).map(i=>i.value);

        function updateState(){
          const selected = getSelected();
          countSel.textContent = String(selected.length);
          startBtn.disabled = selected.length === 0;

          panel.dispatchEvent(new CustomEvent("tk:categories:change", {
            bubbles:true,
            detail:{
              selected,
              categories: selected.map(id => catById.get(id)).filter(Boolean),
              total: categories.length,
              countSelected: selected.length,
              timestamp: Date.now()
            }
          }));
        }

        checklist.addEventListener("change", e=>{
          if (e.target && e.target.matches('input[type="checkbox"]')) updateState();
        });

        // Ensure engine & scorecard stay hidden until Start
        if (surveyApp) surveyApp.hidden = true;
        if (scoreCard) scoreCard.hidden = true;

        function startSurveyFlow(){
          const selected = getSelected();
          if (!selected.length) return;

          const detail = {
            selected,
            categories: selected.map(id => catById.get(id)).filter(Boolean),
            total: categories.length,
            countSelected: selected.length,
            timestamp: Date.now()
          };

          // Reveal the right column by leaving pre-start mode
          document.body.classList.remove("tk-prestart");
          if (surveyIntro) surveyIntro.remove?.();
          if (surveyApp)   surveyApp.hidden = false; // mount now visible

          // Let engine decide when to reveal scorecard
          // scoreCard.hidden = false;

          panel.dispatchEvent(new CustomEvent("tk:survey:start", {
            bubbles:true,
            detail
          }));

          if (window.TKSurvey && typeof window.TKSurvey.start === "function"){
            window.TKSurvey.start({
              categories: selected,
              detail,
              labels: detail.categories.map(cat => cat?.name).filter(Boolean)
            });
          } else {
            TK.log("No TKSurvey.start found — only wiring ran.");
          }
        }

        startBtn.addEventListener("click", (e)=>{ e.preventDefault(); startSurveyFlow(); });

        // Initial state (pre-start: only categories visible)
        updateState();
        TK.log("Categories-only pre-start ready.");

      } catch (err){
        console.warn("[TK] bootstrap failed:", err.message);
      }
    });
  </script>
</body>
</html>
