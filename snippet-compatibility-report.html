<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Compatibility Report Export</title>
</head>
<body>
<!-- (Optional) Example button & table skeleton (keep your own if you already have them)
<button id="downloadPdfBtn">Download Compatibility Report</button>
<table id="compatibilityTable">
  <thead>
    <tr>
      <th>Category</th><th>Partner A</th><th>Match</th><th>Flag</th><th>Partner B</th>
    </tr>
  </thead>
  <tbody><!-- your rows here --></tbody>
</table>
-->

<!--
TALK KINK • COMPATIBILITY REPORT — FINAL “ONE BOX” FIX

WHAT THIS DOES
• Attaches to your EXISTING download button: #downloadBtn OR #downloadPdfBtn OR [data-download-pdf]
• Reads your on-page table (prefer #compatibilityTable), but:
    – Cleans duplicated Category text (e.g., “…scene…scene” → “…scene”)
    – RECOMPUTES Match% and Flag (★ >=90, ⚑ >=60, 🚩 <=30) so you never see a raw “&”
    – Ensures there are exactly 5 columns in the PDF: Category | Partner A | Match | Flag | Partner B
• If the DOM table is empty, falls back to window.partnerAData / window.partnerBData
• Loads jsPDF + AutoTable if they’re not already on the page
• Always downloads a PDF when you click the button

HOW TO USE (copy/paste)
1) Make sure your page renders a table with a THEAD containing these headings (case-insensitive):
      Category | Partner A | [Match] | [Flag] | Partner B
   (Match/Flag may be missing in DOM; the script will compute them).
   Recommended table id:  <table id="compatibilityTable">…</table>

2) Your existing download button must be one of:
      <button id="downloadBtn">…</button>
      <button id="downloadPdfBtn">…</button>
      <button data-download-pdf>…</button>

3) Paste THIS ENTIRE BLOCK at the very end of the HTML file, after the table has been rendered.

That’s it. Click your existing button to export the PDF.
-->

<script>
(function () {
  /* ========== Load libs if missing ========== */
  function loadScript(src){return new Promise((res,rej)=>{const s=document.createElement('script');s.src=src;s.onload=res;s.onerror=()=>rej(new Error('Failed to load '+src));document.head.appendChild(s);});}
  async function ensureLibs(){
    if(!(window.jspdf && window.jspdf.jsPDF)){
      await loadScript("https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js");
    }
    const hasAuto = (window.jspdf && window.jspdf.autoTable) || (window.jsPDF && window.jsPDF.API && window.jsPDF.API.autoTable);
    if(!hasAuto){
      await loadScript("https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.3/jspdf.plugin.autotable.min.js");
    }
  }
  function runAutoTable(doc, opts){
    if (typeof doc.autoTable === "function") return doc.autoTable(opts);
    if (window.jspdf && typeof window.jspdf.autoTable === "function") return window.jspdf.autoTable(doc, opts);
    throw new Error("jsPDF-AutoTable not available.");
  }

  /* ========== Utilities: numbers, % match, flags, text cleanup ========== */
  const THRESH={star:90, flag:60, low:30};
  const ICON={star:"★", flag:"⚑", low:"🚩", blank:""};
  const toNum=v=>{const n=Number(String(v??"").trim());return Number.isFinite(n)?n:null;};
  const pct=(a,b)=>{const A=toNum(a),B=toNum(b); if(A==null||B==null) return null; return Math.round(100-(Math.abs(A-B)/5)*100);};
  const flagFor=p=>p==null?ICON.blank:(p>=THRESH.star?ICON.star:(p>=THRESH.flag?ICON.flag:(p<=THRESH.low?ICON.low:ICON.blank)));
  const tidy=s=>(s||"").replace(/\s+/g," ").trim();
  // If a cell accidentally contains the same text twice concatenated (“foofoo”), cut it in half.
  const dedupeTwice=s=>{const t=tidy(s); const L=t.length; if(L && L%2===0){const h=L/2; if(t.slice(0,h)===t.slice(h)) return t.slice(0,h);} return t;};

  /* ========== Read rows from the on-page table ========== */
  function getTable(){
    return document.getElementById("compatibilityTable")
        || document.querySelector('table[aria-label*="compatibility" i]')
        || document.querySelector("table");
  }
  function headerIndex(table){
    let ths=[...table.querySelectorAll("thead th")];
    if(!ths.length) ths=[...table.querySelectorAll("tr th")];
    const labels=ths.map(th=>tidy(th.textContent).toLowerCase());
    const idx={cat:0, A:1, B:4}; // safe defaults
    const find = key => labels.findIndex(t => t.includes(key));
    const c=find("category"); if(c>-1) idx.cat=c;
    const a=find("partner a"); if(a>-1) idx.A=a;
    const b=find("partner b"); if(b>-1) idx.B=b;
    return idx;
  }
  function rowsFromTable(){
    const table=getTable(); if(!table) return [];
    const idx=headerIndex(table);

    // Prefer TBODY rows; otherwise any TR with TDs inside this table
    let trs=[...table.querySelectorAll("tbody tr")];
    if(!trs.length) trs=[...table.querySelectorAll("tr")].filter(tr=>tr.closest("table")===table && tr.querySelectorAll("td").length);

    const out=[];
    for(const tr of trs){
      const tds=[...tr.querySelectorAll("td")]; if(!tds.length) continue;

      // Resolve cells (support data attributes if present)
      const catCell = tds[idx.cat] || tds[0];
      const aCell   = tr.querySelector('td[data-cell="A"]') || tds[idx.A] || tds[1];
      const bCell   = tr.querySelector('td[data-cell="B"]') || tds[idx.B] || tds[tds.length-1];

      // Clean & compute
      const category = dedupeTwice(catCell?.textContent || tr.getAttribute("data-kink-id") || "");
      const A = toNum(aCell?.textContent);
      const B = toNum(bCell?.textContent);
      const P = pct(A,B);

      // Build the exact 5-column row
      out.push([ category || "—", (A==null?"—":A), (P==null?"—":`${P}%`), flagFor(P), (B==null?"—":B) ]);
    }
    return out;
  }

  /* ========== Memory fallback (window.partnerAData / window.partnerBData) ========== */
  function rowsFromMemory(){
    const A=(window.partnerAData?.items)||(Array.isArray(window.partnerAData)?window.partnerAData:null);
    const B=(window.partnerBData?.items)||(Array.isArray(window.partnerBData)?window.partnerBData:null);
    if(!A && !B) return [];
    const mA=new Map((A||[]).map(i=>[(i.id||i.label),i]));
    const mB=new Map((B||[]).map(i=>[(i.id||i.label),i]));
    const keys=new Map(); (A||[]).forEach(i=>keys.set(i.id||i.label,i.label||i.id)); (B||[]).forEach(i=>keys.set(i.id||i.label,i.label||i.id));
    const out=[];
    for(const [id,label] of keys){
      const a=mA.get(id), b=mB.get(id);
      const Ar=toNum(a?.score), Br=toNum(b?.score), P=pct(Ar,Br);
      out.push([ label||id||"—", (Ar??"—"), (P==null?"—":`${P}%`), flagFor(P), (Br??"—") ]);
    }
    return out;
  }

  /* ========== Exporter ========== */
  async function exportPDF(ev){
    ev?.preventDefault?.();
    try{
      await ensureLibs();
      const { jsPDF } = window.jspdf;

      let rows = rowsFromTable();
      if(!rows.length) rows = rowsFromMemory();

      if(!rows.length){
        alert("No data rows found to export. Ensure the table is visible or partnerA/B data is loaded.");
        return;
      }

      const doc = new jsPDF({orientation:"landscape", unit:"pt", format:"a4"});
      doc.setFontSize(20);
      doc.text("Talk Kink • Compatibility Report", doc.internal.pageSize.width/2, 48, {align:"center"});

      runAutoTable(doc, {
        head: [["Category","Partner A","Match","Flag","Partner B"]],
        body: rows,
        startY: 70,
        styles:     { fontSize: 11, cellPadding: 6, overflow: "linebreak" },
        headStyles: { fillColor: [0,0,0], textColor: [255,255,255], fontStyle: "bold" },
        columnStyles: {
          0:{ halign:"left",   cellWidth: 560 },
          1:{ halign:"center", cellWidth: 80  },
          2:{ halign:"center", cellWidth: 90  },
          3:{ halign:"center", cellWidth: 60  },
          4:{ halign:"center", cellWidth: 80  }
        }
      });

      doc.save("compatibility-report.pdf");
    }catch(err){
      console.error("[PDF] Export failed:", err);
      alert("PDF export failed: " + err.message);
    }
  }

  /* ========== Bind to your existing button ========== */
  function bind(){
    const btn = document.querySelector("#downloadBtn")
            || document.querySelector("#downloadPdfBtn")
            || document.querySelector("[data-download-pdf]");
    if (btn){
      btn.removeEventListener("click", exportPDF);
      btn.addEventListener("click", exportPDF);
      console.log("[PDF] Export bound to button:", btn);
    } else {
      console.warn("[PDF] Download button not found (expected #downloadBtn, #downloadPdfBtn, or [data-download-pdf]).");
    }
  }
  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", bind);
  else bind();
  // Re-bind if your app re-renders
  new MutationObserver(bind).observe(document.documentElement, {childList:true, subtree:true});
})();
</script>

</body>
</html>

